var store = [{
        "title": "Object-Oriented Programming(OOP)",
        "excerpt":"Object-Oriented Programming(OOP)     컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 객체들의 모임으로 파악하고자 하는 컴퓨터 프로그래밍의 패러다임이다.1   강한 응집도(Cohesion)과 약한 결합도(Coupling)을 지향한다.   응집도(Cohesion)  한 모듈 내부의 기능적인 연관도를 나타낸다.2   응집도의 종류  순서대로 응집도는 감소한다.  기능적 응집도(Functional Cohension)  모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우.  순차적 응집도(Sequential Cohension)  동일합 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여있을 경우.  절차적 응집도(Procedural Cohension)  모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우.  시간적 응집도(Temporal Cohension)  연관된 기능이라기 보단 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우.  논리적 응집도(Logical Cohension)  유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우.  우연적 응집도(Coincidentail Cohesion)  모듈 내부의 각 구성요소들이 연관이 없을 경우.   결합도(Coupling)  어떤 모듈이 다른 모듈에 의존하는 정도를 나타내는 것이다.3   결합도의 종류  순서대로 결합도는 감소한다.  내용 결합도(Content Coupling)  다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용 하는 경우. 한 모듈에서 수정이 일어날 경우 다른 모듈 또한 수정이 필요하다.  공통 결합도(Common Coupling)  파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역변수를 갱신하는 식으로 상호작용하는 경우. 전역 변수를 변경하면, 그 자원을 사용하는 모든 모듈의 변경이 필요하다.  외부 결합도(External Coupling)  어떤 모듈에서 반환한 값을 다른 모듈에서 참조해서 사용하는 경우.  제어 결합도(Control Coupling)  단순히 처리를 해야할 대상인 값만 전달되는게 아니라 어떻게 처리를 해야 한다는 제어 요소(DCD, Flag등)이 전달되는 경우.  스탬프 결합도(Stamp Coupling)  모듈간의 인터페이스로 배열이나 오브젝트, 스트럭쳐등이 전달되는 경우.  자료 결합도(Data Coupling)  모듈간의 인터페이스 전달되는 파라미터를 통해서만 모듈간의 상호 작용이 일어나는 경우.   추상화(Abstraction)     복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려 내는 것을 말한다.   자료 표현에 불필요한 정보는 숨기고, 필요한 정보만 표현함으로써 프로그램을 간단히 만드는 것이다.   객체의 구조인 클래스의 속성과 기능을 정의하는 것이다.   public class Class {    // It can only be used inside.   private String variable;    // It can also be used outside.   public String getVariable() {     return this.variable;   }    // It can only be used inside the package.   protected void setVariable(String variable) {     this.variable = variable;   }  }   캡슐화(Encapsulation)     객체가 맡은 역할을 수행하기 위해 관련성 있는 속성과 기능을 하나로 묶는 것이다.   객체 외부에서는 함수를 통해서만 객체 내부에 있는 데이터에 접근이 가능하게 한다.   은닉화(Hiding)     객체 내부의 속성과 기능을 외부에서 접근하지 못하도록 숨기는 것이다.   접근제어자를 이용하여 정보 제공에 대한 범위를 정의한다.   상속(Inheritance)     상위의 개념의 속성과 기능을 하위 개념이 물려 받는 것이다.   public class Media {    public String name;    public Media(String name) {     this.name = name;   }    public void play() {     System.out.printf(\"The media(%s) is played.%n\", this.name);   }  } public class Music extends Media {    public Music(String name) {     super(name);   }    @Override   public void play() {     System.out.printf(\"The music(%s) is played.%n\", this.name);   }  }   다형성(Polymorphism)     프로그램 언어의 각 요소들이 다양한 자료형에 속하는 것이 허가되는 성질을 가리킨다.   코드의 재사용성이 높아지고, 유지보수가 용이해진다.   오버 라이딩(Overriding)     상위의 개념의 기능을 하위 개념이 물려 받아 새로운 기능으로 정의하는 것을 말한다.   같은 이름의 기능이 여러 클래스에서 다른 기능을 한다.   public class Main {    public static void main(String[] args) {     Media media = new Music(\"Graceful Ghost\");     media.play();   }  }  The music(Graceful Ghost) is played.   오버 로딩(Overloading)     같은 이름의 기능이 매개변수의 개수나 자료형에 따라서 다른 기능을 하는 것을 말한다.   public class Media {   ...   public void play(String place) { // Overloaded the play method.     System.out.printf(\"The media(%s) is played in %s.%n\", this.name, place);   }  } public class Music extends Media {   ...   @Override   public void play(String place) {     System.out.printf(\"The music(%s) is played in %s.%n\", this.name, place);   }  }  public class Main {    public static void main(String[] args) {     Media media = new Music(\"Graceful Ghost\");     media.play(\"the Seoul Arts Center\");   }  }   The music(Graceful Ghost) is played in the Seoul Arts Center.   Reference                 Wiki-객체지향프로그래밍 &#8617;                  ITWiki-응집도 &#8617;                  ITWiki-결합도 &#8617;           ","categories": ["Paradigm"],
        "tags": ["Programming","Paradigm","Object"],
        "url": "/paradigm/oop/",
        "teaser": null
      },{
        "title": "Functional Programming(FP)",
        "excerpt":"Functional Programming(OOP)     자료 처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임의 하나이다.1   특징   Immutability     함수형 프로그램의 핵심 개념으로, 객체를 생성한 후 수정할 수 없는 객체이다.   Java에서는 Final keyword를 사용하고 Setter method를 사용하지 않음으로써 불변 Object 생성2할 수 있으나, Reflection을 통해 깨버릴 수 있다.   public class Musician {    private final String name;    public Musician(String name) {     this.name = name;   }    public String getName() {     return this.name;   }  } public class Main {    public static void main(String[] args) throws Exception {     Musician musician = new Musician(\"George Winston\");     System.out.println(musician.getName());      // Using reflection.     Field name = musician.getClass().getDeclaredField(\"name\");     name.setAccessible(true);     name.set(musician, \"Steve Barakatt\");      // Change name.     System.out.println(musician.getName());   }  }  George Winston Steve Barakatt   First-class     함수를 매개변수로 전달할 수 있다.   public class PassingAFunctionToAnotherFunction {    public static void main(String[] args) {     IntStream.range(1, 6).boxed().collect(Collectors.toList()).sort((x, y) -&gt; y - x);   }  }     함수를 결과로 반환할 수 있다.   public class ReturningFunctionsFromFunctions {    public static void main(String[] args) {     IntStream.range(1, 6).boxed().collect(Collectors.toList()).sort(getSort());   }    // Returns the function as a result.   private static Comparator&lt;Integer&gt; getSort() {     return (x, y) -&gt; y - x;   }  }     변수에 함수를 할당할 수 있다.   public class StoringFunctionsInVariables {    public static void main(String[] args) {     Comparator&lt;Integer&gt; comparator = (x, y) -&gt; y - x;     IntStream.range(1, 6).boxed().collect(Collectors.toList()).sort(comparator);   }  }   Lazy evaluation  불필요한 연산을 피하기 위해서 값이 실제로 쓰이기 전까지 그 값의 계산을 최대한 미루는 것이다.   public class LazyEvaluation {    public static void main(String[] args) {     List&lt;Integer&gt; numbers = IntStream.range(1, 31)         .filter(num -&gt; {           System.out.println(num + \" % 2 : \" + num % 2);           return num % 2 == 0;           })         .filter(num -&gt; {           System.out.println(num + \" % 3 : \" + num % 3);           return num % 3 == 0;         })         .map(num -&gt; {           System.out.println(num + \" / 6 : \" + num / 6);           return num / 6;         })         .boxed()         .collect(Collectors.toList());      System.out.println(numbers);   }  }  1 % 2 : 1 2 % 2 : 0 2 % 3 : 2 3 % 2 : 1 4 % 2 : 0 4 % 3 : 1 5 % 2 : 1 6 % 2 : 0 6 % 3 : 0 6 / 6 : 1 7 % 2 : 1 ...   종류   Anonymous Function     이름이 없는 함수이다.   Java에서는 Lambda가 이에 해당한다.   Pure Function     부작용(Side Effect)과 외부에 영향이 없는 함수이다.   내부에 상태를 갖지 않아, 같은 입력에 대해서는 항상 같은 출력이 보장된다.   public class PureFunction {    public static void main(String[] args) throws InterruptedException {     for (int count = 0; count &lt; 5; count++) {       System.out.println(nonPureFunction());       System.out.println(pureFunction(1000, 5));       Thread.sleep(1000L);     }    }    private static LocalDateTime nonPureFunction() {     return LocalDateTime.now();   }    private static int pureFunction(int price, int num) {     return price * num;   }  }   High-Order Function     매개변수로 전달된 함수를 이용하여 만든 새로운 함수이다.   public class HighOrderFunction {    public static void main(String[] args) {     IntStream.range(1, 6).boxed().collect(Collectors.toList()).sort(reverse((x, y) -&gt; x - y));   }    private static Comparator&lt;Integer&gt; reverse(Comparator&lt;Integer&gt; comparator) {     return (x, y) -&gt; comparator.compare(y, x);   }  }   Reference                 Wiki-함수형프로그래밍 &#8617;                  Oracle-A_Strategy_for_Defining_Immutable_Objects &#8617;           ","categories": ["Paradigm"],
        "tags": ["Programming","Paradigm","Function"],
        "url": "/paradigm/fp/",
        "teaser": null
      },{
        "title": "Codility Java BinaryGap",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int N) {     char[] binary = Integer.toBinaryString(N).toCharArray();     int max = 0;     int counter = 0;     // Loop and check max length.     for (int idx = 1; idx &lt; binary.length; idx++) {       if(binary[idx] == '0') {         counter++;       } else {         if (counter &gt; max) {           max = counter;         }         // Initializing counter.         counter = 0;       }     }     return max;   } }   결과  Link   설명     주어진 숫자를 Binary로 변환한다.   Binary를 순차 확인하며, 1사이의 0의 개수를 센다.            Binary의 시작은 항상 1부터로, Index 1부터 탐색한다.       1이 나타날 경우 max에 임시 저장하고, counter를 초기화하여 다시 개수를 센다.           문제의 결과를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Iterations","Java"],
        "url": "/codility/BinaryGap/",
        "teaser": null
      },{
        "title": "Codility Java CyclicRotation",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int[] solution(int[] A, int K) {     int length = A.length;     int[] result = new int[length];     // Repeat the size of array A.     for (int idx = 0; idx &lt; length; idx++) {       result[(idx + K) % length] = A[idx];     }     return result;   } }   설명     결과를 반환할 새로운 int array를 생성한다.            순서만 변경되므로, 배열의 사이즈는 매개변수 A와 같다.           배열을 반복하면서 배열 result에 배열 A의 값을 넣어준다.            기존 index의 값에 반복횟수인 K를 더해서 이동시키고, 배열의 크기를 벗어나면 0번째 index로 이동하여 계산하여야 한다.       위의 조건을 계산식으로 변환하면 A의 idx번째 들어있는 값은 result의 (idx + K) % length번째 index에 들어가야 한다.           주어진 문제의 결과를 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Arrays","Java"],
        "url": "/codility/CyclicRotation/",
        "teaser": null
      },{
        "title": "Codility Java OddOccurrencesInArray",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int[] A) {     int result = 0;     for (int num : A) {       // Using bit operation.       result ^= num;     }     return result;   } }   설명     배열 A를 반복하여 반복이 없는 숫자를 확인한다.            비트 연산의 배타적 논리합을 사용할 경우 같은 값을 더하면 0이 되므로, 남는 값은 반복이 없는 숫자가 된다.           결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Arrays","Java"],
        "url": "/codility/OddOccurrencesInArray/",
        "teaser": null
      },{
        "title": "Codility Java FrogJmp",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int X, int Y, int D) {     return (int) Math.ceil((double)(Y - X) / D);   } }   설명     간단히 현재 거리인 X와 가야할 위치인 Y의 거리 차에 점프 거리인 D만큼 나누고 올림 하면 된다.            단, X &amp; Y &amp; D가 정수 자료형이므로 정확한 나눗셈을 위해 실수 자료형으로 전환해야 한다.           결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Time Complexity","Java"],
        "url": "/codility/FrogJmp/",
        "teaser": null
      },{
        "title": "Codility Java PermMissingElem",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int[] A) {     int difference = A.length + 1;     for (int idx = 0; idx &lt; A.length; idx++) {       difference += (idx + 1) - A[idx];     }     return difference;   } }   설명     배열 A 내 값이 최소 값은 1이고 최대 값은 배열 N의 크기 + 1이므로, Index + 1의 합과 배열 A의 값의 합을 빼면 빠진 값이 도출된다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Time Complexity","Java"],
        "url": "/codility/PermMissingElem/",
        "teaser": null
      },{
        "title": "Codility Java TapeEquilibrium",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int[] A) {     int min = Integer.MAX_VALUE;     int sum = sum(A);     int subSum = 0;     for (int idx = 0; idx &lt; A.length - 1; idx++) {       subSum += A[idx];       sum -= A[idx];       int difference = Math.abs(subSum - sum);       if (difference &lt; min) {         min = difference;       }     }     return min;   }   private int sum(int[] A) {     int sum = 0;     for (int num : A) {       sum += num;     }     return sum;   } }   설명     특정 index 기준으로 우측 합을 더하는 sum과 좌측 합을 더하는 subSum을 정의한다.   반복을 하면서 좌측 합과 우측 합의 차이를 구한다.            최소 값이 위의 차이보다 클 경우에, 차이 값을 최소 값으로 넣어준다.           주어진 문제의 결과를 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Time Complexity","Java"],
        "url": "/codility/TapeEquilibrium/",
        "teaser": null
      },{
        "title": "Codility Java FrogRiverOne",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  import java.util.Set; import java.util.HashSet;  class Solution {   public int solution(int X, int[] A) {     Set&lt;Integer&gt; leafs = new HashSet&lt;&gt;();     for (int idx = 0; idx &lt; A.length; idx++) {       leafs.add(A[idx]);       // Get to the goal.       if (X == leafs.size()) {         return idx;       }     }     return -1;   } }   설명     목표 지점에 도달하기 까지 잎의 위치를 저장할 Collection을 사용한다.            중복된 잎의 위치는 의미가 없으므로 유일 값을 저장할 수 있는 Set을 사용한다.           잎의 위치를 가지고 있는 배열 A를 반복하여 leafs에 넣는다.   만약 목표 지점과 leafs의 크기가 동일하면 현재 index를 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Counting Elements","Java"],
        "url": "/codility/FrogRiverOne/",
        "teaser": null
      },{
        "title": "Codility Java MaxCounters",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int[] solution(int N, int[] A) {     int[] result = new int[N];     int max = 0;     int init = 0;     for (int num : A) {       if (num == N + 1) { // Over than array size and maximum number is N + 1.         // Set init value using max value.         init = max;       } else {         if (init &gt; result[num - 1]) {           result[num - 1] = init + 1;         } else {           result[num - 1]++;         }         // Save maximum value.         if (result[num - 1] &gt; max) {           max = result[num - 1];         }       }     }     // If lower than init value, change each values.     for (int idx = 0; idx &lt; N; idx++) {       if (result[idx] &lt; init) {         result[idx] = init;       }     }     return result;   } }   설명     주어진 크기 N의 배열 result를 생성한다.   주어진 배열인 A를 반복하여 해당 값에 위치한 배열 result의 값을 더한다.            만일 주어진 배열의 크기보다 큰 index가 나오는지를 확인해서 init 변수에 max 값를 넣는다.       주어진 배열의 크기보다 낮은 경우 result의 해당 index 값이 init 보다 작은지를 확인하여, 작으면 init + 1로 값을 초기화 한다.           더해진 값의 크기가 max보다 크다면 배열보다 큰 값인 N + 1이 나올 때 초기값을 설정하기 위해 max에 최대 값을 저장한다.   마지막으로 결과로 반환할 배열 result의 값이 init보다 작다면, init 값으로 초기화 하고 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Counting Elements","Java"],
        "url": "/codility/MaxCounters/",
        "teaser": null
      },{
        "title": "Codility Java MissingInteger",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  import java.util.Set; import java.util.HashSet;  class Solution {   public int solution(int[] A) {     Set&lt;Integer&gt; numSet = new HashSet&lt;&gt;();     for (int num : A) {       if (num &gt; 0) { // Greater than 0.         numSet.add(num);       }     }     for (int idx = 1; idx &lt;= Integer.MAX_VALUE; idx++) {       if (!numSet.contains(idx)) {         return idx;       }     }     return 1;   } }   설명     누락된 숫자를 파악하기 위해 중복을 제거한 Set을 사용하여 numSet을 정의한다.   배열 A를 반복하여 양수만 numSet에 추가한다.   1부터 1씩 증가하며 numSet에 포함되어있는지 확인하고, 없을 경우 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Counting Elements","Java"],
        "url": "/codility/MissingInteger/",
        "teaser": null
      },{
        "title": "Codility Java PermCheck",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  import java.util.Arrays;  class Solution {   public int solution(int[] A) {     Arrays.sort(A);     for (int idx = 0; idx &lt; A.length; idx++) {       if (A[idx] != idx + 1) {         return 0;       }     }     return 1;   } }   설명     순서대로 숫자가 들어있는지 확인하기 위해서 배열을 정렬한다.   배열 A를 반복하여 A의 idx번째 있는 값이 idx + 1이 아니면 0을 주어진 문제의 결과로 반환한다.   for문이 정상적으로 실행 되었을 경우, 배열의 크기만큼의 연속된 숫자가 들어있으므로 1을 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Counting Elements","Java"],
        "url": "/codility/PermCheck/",
        "teaser": null
      },{
        "title": "Codility Java CountDiv",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {     public int solution(int A, int B, int K) {         if (A == 0) {             return (B / K) + 1;         } else {             return (B / K) - ((A - 1) / K);         }     } }   설명     A이상 B이하의 수에서 K로 나누어 나머지가 0인 숫자의 개수를 반환한다.            A가 0일 경우, 0을 포함해야 하기 때문에 B / K에 1을 더해서 주어진 문제의 결과로 반환한다.       A가 0이 아닐 경우, B / K개에서 A미만의 경우를 제외하기 위해 (A - 1) / K개를 빼고 주어진 문제의 결과로 반환한다.           결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Prefix Sums","Java"],
        "url": "/codility/CountDiv/",
        "teaser": null
      },{
        "title": "Codility Java GenomicRangeQuery",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int[] solution(String S, int[] P, int[] Q) {     int[] result = new int[P.length];     // All array is start 0. (Check for changing character is exists.)     int[] A = new int[S.length() + 1];     int[] C = new int[S.length() + 1];     int[] G = new int[S.length() + 1];     // Initializing each array.     for (int idx = 0; idx &lt; S.length(); idx++) {       A[idx + 1] = A[idx];       C[idx + 1] = C[idx];       G[idx + 1] = G[idx];       switch(S.charAt(idx)) {         case 'A': A[idx + 1]++; break;         case 'C': C[idx + 1]++; break;         case 'G': G[idx + 1]++; break;         default: break;       }     }     // Check for contains word in P and Q.     for (int idx = 0; idx &lt; P.length; idx++) {       if (A[P[idx]] != A[Q[idx] + 1]) {         result[idx] = 1;       } else if (C[P[idx]] != C[Q[idx] + 1]) {         result[idx] = 2;       } else if (G[P[idx]] != G[Q[idx] + 1]) {         result[idx] = 3;       } else {         result[idx] = 4;       }     }     return result;   } }   설명     주어진 DNA 문자열 S를 분석하기 위해 A, C, G 배열을 생성한다.            DNA 문자열이 A, C, G에 해당하지 않으면 T로 간주한다.           A, C, G 배열은 각 index + 1 위치에 해당 문자열이 존재하면 문자열의 변화 감지를 위해 점층적으로 증가하도록 한다.   주어진 배열 P와 Q의 값을 이용하여 최소 결과 값인 A부터 G 순으로 문자열의 변화를 분석한다.            P[index] ~ Q[index]까지 A, C, G 배열에 변화가 존재한다면 DNA 영향 계수를 주어진 문제의 결과로 반환한다.       만일 위의 변화가 없으면 T로 간주하여 해당 DNA 영향 계수를 주어진 문제의 결과로 반환한다.           결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Prefix Sums","Java"],
        "url": "/codility/GenomicRangeQuery/",
        "teaser": null
      },{
        "title": "Codility Java MinAvgTwoSlice",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int[] A) {     int result = 0;     double minimumAverage = (A[0] + A[1]) / 2.0d;     for (int idx = 2; idx &lt; A.length; idx++) {       double average = (A[idx - 2] + A[idx - 1] + A[idx]) / 3.0d;       if (minimumAverage &gt; average) {         minimumAverage = average;         result = idx - 2;       }       average = (A[idx - 1] + A[idx]) / 2.0d;       if (minimumAverage &gt; average) {         minimumAverage = average;         result = idx - 1;       }     }     return result;   } }   설명     초기 평균 최소값은 주어진 배열 A의 0번째와 1번째 값의 평균으로 저장한다.            단, 배열 A의 값들은 정수형이므로 실수형으로 변환하여야 한다.           index는 2부터 시작하여 반복문을 통해 평균이 최소가 되는 지점을 탐색한다.            index가 2부터 시작하는 이유는 평균이 최소가 되는 부분의 탐색의 범위를 3까지 하기 때문이다.       탐색의 범위가 3까지인 이유는 범위가 4 이후의 평균은 범위가 2, 3의 평균에 비해 같거나 높아지기 때문에 제외한다.           범위가 2, 3인 경우의 평균이 초기 평균 최소값보다 작다면 해당 값과 시작 index를 저장한다.   반복이 완료되면 최소 평균이 나오는 시작점을 저장한 result를 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Prefix Sums","Java"],
        "url": "/codility/MinAvgTwoSlice/",
        "teaser": null
      },{
        "title": "Codility Java PassingCars",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int[] A) {     int count = 0;     int result = 0;     for (int num : A) {       if (num == 0) {         count++;       } else {         result += count;       }       // If passing cars exeeds 1,000,000,000, return -1.       if (result &gt; 1000000000) {         return -1;       }     }     return result;   } }   설명     동쪽으로 이동하는 차량 기준으로 차량의 숫자를 세면 된다. (기준을 서쪽으로 잡는 경우)            동쪽으로 이동하는 차량의 경우 count를 증가시킨다.       서쪽으로 이동하는 차량의 경우 동쪽으로 이동하는 차량의 수인 count를 결과인 result에 더해준다.           만일 추월하는 차량의 수를 저장한 result가 1,000,000,000이 넘을 경우 -1을 주어진 문제의 결과로 반환한다.   반복이 완료되면 추월된 차량의 수를 저장한 result를 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Prefix Sums","Java"],
        "url": "/codility/PassingCars/",
        "teaser": null
      },{
        "title": "Codility Java Distinct",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int[] A) {     return (int) Arrays.stream(A).distinct().count();   } }   설명     주어진 배열 A의 중복을 제거한 숫자를 반환하면 된다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Sorting","Java"],
        "url": "/codility/Dinstinct/",
        "teaser": null
      },{
        "title": "Codility Java MaxProductOfThree",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int[] A) {     Arrays.sort(A);     // The initial value is set to a value greater than 3.     int result = A[A.length - 3] * A[A.length - 2] * A[A.length - 1];     // Check if the two smallest values are negative and the largest value is positive.     if (A[0] &lt; 0 &amp;&amp; A[1] &lt; 0 &amp;&amp; A[A.length - 1] &gt; 0) {       int temp = A[0] * A[1] * A[A.length - 1];       if (result &lt; temp) {         result = temp;       }     }     return result;   } }   설명     주어진 배열 A를 Arrays 클래스를 활용하여 오름차순 정렬한다.   기본 최대값은 정렬된 배열 A의 최대 3개의 값으로 한다.   만일, 가장 낮은 두 값이 음수이고 가장 큰 값이 양수인 경우에는 최대값을 저장한 result와 비교하여 최대값을 다시 설정한다.   최대값을 저장한 result를 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Sorting","Java"],
        "url": "/codility/MaxProductOfThree/",
        "teaser": null
      },{
        "title": "Codility Java NumberOfDiscIntersections",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int[] A) {     int result = 0;     long[] left = new long[A.length];     long[] right = new long[A.length];     // Save left and right point each array.     for (int idx = 0; idx &lt; A.length; idx++) {       left[idx] = idx - (long) A[idx];       right[idx] = idx + (long) A[idx];     }     Arrays.sort(left);     Arrays.sort(right);     int num = 0;     // Calculate intersects with left and right point.     for (int idx = 0; idx &lt; A.length; idx++) {       while (num &lt; A.length &amp;&amp; right[idx] &gt;= left[num]) {         result += num - idx;         num++;       }     }     // If the number of intersecting pairs excceds 10,000,000.     if (result &gt; 10000000) {       return -1;     }     return result;   } }   설명     주어진 배열 A를 이용하여 x축과 디스크의 접점을 배열 left, right에 담는다.   배열 left와 right를 Arrays 클래스를 활용하여 오름차순 정렬한다.   배열 left와 right를 아래의 내용을 참고하여 디스크들의 접점이 존재하는지를 계산한다.            한 디스크의 우측 x축 접점 기준으로 다른 디스크의 좌측 x축 접점 위치가 작은 경우 두 디스크의 접점이 존재하지 않는다.       한 디스크의 우측 x축 접점 기준으로 다른 디스크의 좌측 x축 접점이 동일한 경우 두 디스크의 접점이 한 개이다. (result + 1)       한 디스크의 우측 x축 접점 기준으로 다른 디스크의 좌측 x축 접점 위치가 큰 경우 두 디스크의 접점이 두 개이다. (result + 1)           디스크들의 교차 수를 저장한 result가 10,000,000보다 큰 경우, -1을 주어진 문제의 결과로 반환한다.   디스크들의 교차 수를 저장한 result를 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Sorting","Java"],
        "url": "/codility/NumberOfDiscIntersections/",
        "teaser": null
      },{
        "title": "Codility Java Triangle",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int[] A) {     if (A.length &lt; 3) {       return 0;     }     Arrays.sort(A);     for (int idx = 0; idx &lt; A.length - 2; idx++) {       if ((long)A[idx] + (long)A[idx + 1] &gt; A[idx + 2]) {         return 1;       }     }     return 0;   } }   설명     주어진 배열 A가 삼각형을 만들 수 없는 최소 개수인 3개 미만인 경우, 0을 주어진 문제의 결과로 반환한다.   주어진 배열 A를 Arrays 클래스를 활용하여 오름차순 정렬한다.   배열을 반복하여 주어진 아래의 조건에 부합하는지를 확인하여 부합하지 않은 경우, 0을 주어진 문제의 결과로 반환한다.            A[P] + A[Q] &gt; A[R]       A[Q] + A[R] &gt; A[P]       A[R] + A[P] &gt; A[Q]           반복이 완료되면 주어진 조건을 만족하므로 1을 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Sorting","Java"],
        "url": "/codility/Triangle/",
        "teaser": null
      },{
        "title": "Codility Java Brackets",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  import java.util.Stack;  class Solution {   public int solution(String S) {     Stack&lt;Character&gt; stack = new Stack&lt;&gt;();     for (char c : S.toCharArray()) {       switch (c) {         case '(': case '{': case '[':           stack.push(c);           break;         case ')':           if (stack.size() == 0 || stack.pop() != '(') {             return 0;           }           break;         case '}':           if (stack.size() == 0 || stack.pop() != '{') {             return 0;           }           break;         case ']':           if (stack.size() == 0 || stack.pop() != '[') {             return 0;           }           break;       }     }     return stack.isEmpty() ? 1 : 0;   } }   설명     괄호 문자열을 임시 저장하기 위한 저장소로 Stack을 사용한다.   괄호 문자열의 시작 문자열(‘(‘, ‘{‘, ‘[‘)이 나올 경우 변수 stack에 저장한다.   괄호 문자열의 종료 문자열(‘)’, ‘}’, ‘]’)은 반드시 시작 문자열 이후에 나와야 하므로, 변수 stack의 크기가 0이거나 시작 문자열이 아닌 경우는 0을 주어진 문제의 결과로 반환한다.   반복이 완료되면 변수 stack이 비어있는지를 확인하여 비어있으면 1을, 비어있지 않으면 0을 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Stack And Queues","Java"],
        "url": "/codility/Brackets/",
        "teaser": null
      },{
        "title": "Codility Java Fish",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  import java.util.Stack;  class Solution {   public int solution(int[] A, int[] B) {     Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();     int lastSize = 0;     int aliveCount = 0;     for (int idx = 0; idx &lt; A.length; idx++) {       if (B[idx] == 1) {         stack.add(A[idx]);       } else {         // Check to fish size.         while (!stack.isEmpty()) {           lastSize = stack.peek();           if (lastSize &lt; A[idx]) {             stack.pop();           } else {             break;           }         }         if (stack.isEmpty()) {           aliveCount++;         }       }     }     return aliveCount + stack.size();   } }   설명     물고기의 크기를 임시 저장하기 위한 저장소로 Stack을 사용한다.   주어진 배열 A를 반복하고 B를 참조하여 살아있는 물고기의 수를 계산한다.            하류로 흘러가는 물고기일 경우 변수 stack에 물고기의 크기를 저장한다.       상류로 흘러가는 물고기일 경우 변수 stack에 있는 물고기의 크기 중 해당 물고기의 크기보다 작을 경우 변수 stack에서 제외하고, 살아있는 물고기 수를 저장하는 aliveCount에 추가한다.           반복이 완료되면 살아있는 물고기 수를 저장하는 aliveCount와 물고기의 크기를 임시 저장하는 stack의 크기를 합쳐서 주어진 문제의 결과로 반환한다.            변수 aliveCount는 상류로 흐르는 물고기의 수이다.       물고기의 크기를 임시 저장하는 stack은 반복 이후에는 생존한 하류로 흐르는 물고기의 크기이므로, stack의 크기는 생존한 하류로 흐르는 물고기의 수이다.           결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Stack And Queues","Java"],
        "url": "/codility/Fish/",
        "teaser": null
      },{
        "title": "Codility Java Nesting",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  import java.util.Stack;  class Solution {   public int solution(String S) {     Stack&lt;Character&gt; stack = new Stack&lt;&gt;();     for (char c : S.toCharArray()) {       switch (c) {         case '(':           stack.push(c);           break;         case ')':           if (stack.isEmpty() || stack.pop() != '(') {               return 0;           }         default:           break;       }     }     return stack.isEmpty() ? 1 : 0;   } }   설명     GitHub-Brackets와 동일한 문제이다.   괄호 문자열을 임시 저장하기 위한 저장소로 Stack을 사용한다.   괄호 문자열의 시작 문자열(‘(‘)이 나올 경우 변수 stack에 저장한다.   괄호 문자열의 종료 문자열(‘)’)은 반드시 시작 문자열 이후에 나와야 하므로, 변수 stack의 크기가 0이거나 시작 문자열이 아닌 경우는 0을 주어진 문제의 결과로 반환한다.   반복이 완료되면 변수 stack이 비어있는지를 확인하여 비어있으면 1을, 비어있지 않으면 0을 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Stack And Queues","Java"],
        "url": "/codility/Nesting/",
        "teaser": null
      },{
        "title": "Codility Java StoneWall",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  import java.util.Stack;  class Solution {   public int solution(int[] H) {     int result = 0;     Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();     for (int height : H) {       while (!stack.isEmpty() &amp;&amp; stack.peek() &gt; height) {         stack.pop(); // Remove higher than new stone wall.       }       if (stack.isEmpty() || stack.peek() &lt; height) {         stack.push(height); // Add new stone wall.         result++;       }     }     return result;   } }   설명     돌담의 높이를 임시 저장하기 위한 저장소로 Stack을 사용한다.   주어진 배열 H를 반복하여 블록의 수를 계산한다.            돌담의 높이를 임시 저장한 stack이 비어있지 않을 떄, stack에서 꺼낸 돌담의 높이가 주어진 돌담의 높이보다 큰 값들을 제거한다.                 주어진 돌담의 높이가 stack에서 꺼낸 돌담의 높이보다 높은 경우는 기존 블록에 새로운 블록을 추가하여 사용하므로 패스한다.       주어진 돌담의 높이가 stack에서 꺼낸 돌담의 높이와 같은 경우는 같은 블록을 사용하므로 무시한다.       주어진 돌담의 높이가 stack에서 꺼낸 돌담의 높이보다 낮은 경우는 새로운 블록을 사용해야 하므로 기존 값을 지운다.     - stack이 비어있거나 stack에서 꺼낸 돌담의 높이가 주어진 돌담의 높이보다 작으면 새로운 블록을 추가해야 하므로 stack에 추가하고, 블록의 수를 저장하는 result를 증가시킨다.           반복이 완료되면 블록의 수를 저장하는 result를 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Stack And Queues","Java"],
        "url": "/codility/StoneWall/",
        "teaser": null
      },{
        "title": "Codility Java Dominator",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  import java.util.Map; import java.util.HashMap;  class Solution {   public int solution(int[] A) {     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();     // Calculate how many numbers are in the array(A).     for (int num : A) {       map.put(num, map.getOrDefault(num, 0) + 1);     }     int num = 0;     int max = 0;     for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {       if (entry.getValue() &gt; max) {         num = entry.getKey();         max = entry.getValue();       }     }     // If not half of array(A)'s size, return -1.     if (max &lt;= A.length / 2) {       return -1;     }     // Find index of num.     for (int idx = 0; idx &lt; A.length; idx++) {       if (A[idx] == num) {         return idx;       }     }     return -1;   } }   설명     주어진 배열 A에 들어간 숫자가 몇 번 반복되었는지를 계산하기 위해 Map을 사용한다.   주어진 배열 A를 반복하여 변수 map에 숫자를 key로 반복 횟수를 value로 증가시켜준다.   변수 map에서 가장 많이 반복된 숫자와 개수를 가져온다.   만일 주어진 배열 A 크기의 절반보다 작은 경우 -1을 주어진 문제의 결과로 반환한다.   주어진 배열 A에서 가장 많이 반복된 숫자의 index를 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Leader","Java"],
        "url": "/codility/Dominator/",
        "teaser": null
      },{
        "title": "Codility Java EquiLeader",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  import java.util.Map; import java.util.HashMap; import java.util.Vector;  class Solution {   public int solution(int[] A) {     Vector&lt;Integer&gt; record = getRecord(A);     int result = 0;     for (int idx = 0; idx &lt; A.length; idx++) {       int left = record.elementAt(idx);       int right = record.lastElement() - left;       int equiOne = ((idx + 1) / 2) + 1;       int equiTwo = ((A.length - (idx + 1)) / 2) + 1;       if ((left &gt;= equiOne) &amp;&amp; (right &gt;= equiTwo)) {         result++;       }     }     return result;   }   private Vector&lt;Integer&gt; getRecord(int[] A) {     Vector&lt;Integer&gt; record = new Vector&lt;&gt;();     int leader = getLeader(A);     int count = 0;     for (int num : A) {       if (num == leader) {         count++;       }       record.add(count);     }     return record;   }   private int getLeader(int[] A) {     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();     for (int num : A) {       map.put(num, map.getOrDefault(num, 0) + 1);     }     int leader = 0;     int max = 0;     for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {       if (entry.getValue() &gt; max) {         leader = entry.getKey();         max = entry.getValue();       }     }     return leader;   } }   설명     주어진 배열 A에 들어간 숫자가 몇 번 반복되었는지를 계산하기 위해 Map을 사용한다.   주어진 배열 A를 반복하여 변수 map에 숫자를 key로 반복 횟수를 value로 증가시켜준다.   변수 map에서 가장 많이 반복된 숫자를 가져온다.   리더의 변화를 탐색하기 위해 Vector를 정의하고, 주어진 배열 A를 반복하여 index 별 리더의 수를 계산한다.   계산된 record 기반으로 이분법을 적용하여 동등한 리더의 수를 계산하여 주어진 문제의 결과로 반환한다.            좌측의 리더의 수인 변수 left와 우측의 리더의 수인 right를 계산한다.       동등한 리더가 되기 위해서는 위치 기반으로 절반 이상의 리더가 존재해야 한다.       절반 이사의 리더가 존재하는 경우만 동등한 리더의 수를 계산하는 변수 result를 증가시킨다.           결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Leader","Java"],
        "url": "/codility/EquiLeader/",
        "teaser": null
      },{
        "title": "Java Generic",
        "excerpt":"Generic     클래스, 인터페이스 및 메서드를 정의할 때 유형이 매개변수가 되도록 한다.   코드 내부에서 사용할 자료형을 외부에서 지정하는 기법이다.   사용의 이점     컴파일 시, 강력한 타입 검사를 통해 런타임 오류를 방지한다.   캐스팅을 제거하여 불필요한 코드를 줄인다.     // The following code snippet without generics requires casting. List list = new ArrayList(); list.add(\"hello\"); String s = (String) list.get(0); // When re-written to use generics, the code does not require casting. List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"hello\"); String s = list.get(0);   // no cast           다양한 유형의 컬렉션에서 작업할 수 있고, 커스터마이징 가능하며, 안전한 타입, 가독성 좋은 제네릭 알고리즘을 구현할 수 있다.   종류  Parameterized Type     타입 매개 변수(K, V)를 매개 변수화 타입(List)으로 대체할 수 있다.     OrderedPair&lt;String, Box&lt;Integer&gt;&gt; p = new OrderedPair&lt;&gt;(\"primes\", new Box&lt;Integer&gt;(...));           Generic Method     제네릭 메서드는 자체 타입 매개 변수를 도입하는 메서드이다.   제네릭 타입을 선언하는 것 과 비슷하지만 타입 매개 변수의 범위는 메서드로 제한된다.     public class Pair&lt;K, V&gt; { private K key; private V value; public Pair(K key, V value) {   this.key = key;   this.value = value; } public void setKey(K key) { this.key = key; } public void setValue(V value) { this.value = value; } public K getKey()   { return key; } public V getValue() { return value; } } public class Util { public static &lt;K, V&gt; boolean compare(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2) {   return p1.getKey().equals(p2.getKey()) &amp;&amp; p1.getValue().equals(p2.getValue()); }     }          public class Main { public static void main(String[] args) {   // The complete syntax for invoking this method would be.   Pair&lt;Integer, String&gt; p1 = new Pair&lt;&gt;(1, \"apple\");   Pair&lt;Integer, String&gt; p2 = new Pair&lt;&gt;(2, \"pear\");   boolean same = Util.&lt;Integer, String&gt;compare(p1, p2);   // The type has been explicitly provided, as shown in bold. Generally, this can be left out and the compiler will infer the type that is needed.   same = Util.compare(p1, p2); } }           Bounded Type Parameter     매개 변수화 타입의 타입 인수로 사용할 수 있는 타입을 제한할 수 있다.     public class Box&lt;T&gt; { ... public &lt;U extends Number&gt; void inspect(U u) { // The parameter u is only allowed in classes that inherit Number.   System.out.println(\"T: \" + t.getClass().getName());   System.out.println(\"U: \" + u.getClass().getName()); } } public class Main { public static void main(String[] args) {   Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();   integerBox.set(new Integer(10));   integerBox.inspect(\"some text\"); // error: this is still String! } }           바인딩된 타입 매개 변수는 제네릭 알고리즘 구현의 핵심이다.     public class Main { // The greater than operator (&gt;) applies only to primitive types such as short, int, double, long, float, byte, and char. public static &lt;T&gt; int countGreaterThan(T[] anArray, T elem) {   int count = 0;   for (T e : anArray) {     if (e &gt; elem) { // compiler error.        ++count;     }   }   return count; } // To fix the problem, use a type parameter bounded by the Comparable&lt;T&gt; interface. This is recursive type bound. public static &lt;T extends Comparable&lt;T&gt;&gt; int countGreaterThan(T[] anArray, T elem) {   int count = 0;   for (T e : anArray) {     if (e.compareTo(elem) &gt; 0) {       ++count;     }   }   return count; } }           Generics, Inheritance, and Subtypes     타입이 호환되는 경우 한 타입의 객체를 다른 타입의 객체에 할당 할 수 있다.     public class Main { public static void main(String[] args) {   // Can assign an Integer to an Object, since Object is one of Integer's supertypes.   Object someObject = new Object();   Integer someInteger = new Integer(10);   someObject = someInteger; // OK   // Integer is also a kind of Number.   someMethod(new Integer(10)); // OK   someMethod(new Double(10.1)); // OK   // any subsequent invocation of add will be allowed if the argument is compatible with Number.   Box&lt;Number&gt; box = new Box&lt;Number&gt;();   box.set(new Integer(10)); // OK   box.set(new Double(10.1)); // OK } public static void someMethod(Number n) { /* ... */ } }           두 개의 구체적인 유형 A와 B가 주어지면 MyClass&lt;A&gt;는 A와 B가 관련되어 있는지 여부에 관계없이 MyClass&lt;B&gt;와 관련이 없다. MyClass&lt;A&gt;와 MyClass&lt;B&gt;의 부모는 Object이다.     클래스 또는 인터페이스를 확장하거나 구현하여 하위 유형을 지정할 수 있다.       // That associates an optional value of generic type P with each element. public interface PayloadList&lt;E, P&gt; extends List&lt;E&gt; { void setPayload(int index, P val); }           PayloadList는 List&lt;String&gt;의 서브타입으로 아래의 형태를 가질 수 있다.             PayloadList&lt;String, String&gt;       PayloadList&lt;String, Integer&gt;       PayloadList&lt;String, Exception&gt;           Upper Bounded Wildcards     변수에 대한 제한을 완화할 수 있다.     public class Main { public static void main(String[] args) {   // Using a list of Integer objects, prints sum = 6.0.   List&lt;Integer&gt; li = Arrays.asList(1, 2, 3);   System.out.println(\"sum = \" + sumOfList(li));   // A list of Double values can use the same sumOfList method. The following code prints sum = 7.0.   List&lt;Double&gt; ld = Arrays.asList(1.2, 2.3, 3.5);   System.out.println(\"sum = \" + sumOfList(ld)); } public static void process(List&lt;? extends Foo&gt; list) {   for (Foo elem : list) {     // ...   } } public static double sumOfList(List&lt;? extends Number&gt; list) {   double s = 0.0;   for (Number n : list) {     s += n.doubleValue();   }   return s; } }           Unbounded Wildcard Type     와일드카드 문자열 '?'를 사용하여 변수에 대한 제한을 하지 않을 수 있다.     public class Main { public static void main(String[] args) {   // Because for any concrete type A, List&lt;A&gt; is a subtype of List&lt;?&gt;, you can use printList to print a list of any type.   List&lt;Integer&gt; li = Arrays.asList(1, 2, 3);   List&lt;String&gt;  ls = Arrays.asList(\"one\", \"two\", \"three\");   printList(li);   printList(ls); } public static void printList(List&lt;?&gt; list) {   for (Object elem: list) {     System.out.print(elem + \" \");   }   System.out.println(); } }           Lower Bounded Wildcards     super 키워드 다음에 와일드카드 문자열 '?'와 lower bound를 표기하는 &lt;? super A&gt;를 사용하여 해당 타입과 상위 타입으로 제한 할 수 있다.     public class Main { public static void main(String[] args) {   addNumbers(new ArrayList&lt;Number&gt;()); } public static void addNumbers(List&lt;? super Integer&gt; list) {   for (int i = 1; i &lt;= 10; i++) {     list.add(i);   } } }           Wildcard And Subtyping     와일드 카드를 사용하여 제네릭 클래스 또는 인터페이스 간의 관계를 만들 수 있다.     public class Main { public static void main(String[] args) {   // It would be reasonable to write the following code.   B b = new B();   A a = b;   // Class B is a subtype of class A if B extends A. This rule does not apply to generic types.   List&lt;B&gt; lb = new ArrayList&lt;&gt;();   List&lt;A&gt; la = lb; // compile-time error } }           Integer가 Number의 하위 타입이지만 List&lt;Number&gt;와 List&lt;Integer&gt;.의 공통 부모는 List&lt;?&gt;이다.     List의 제네릭 타입을 상위 타입인 Number와 하위 타입인 Integer를 사용 한 예제이다.     public class Main { public static void main(String[] args) {   ...   // In order to create a relationship between these classes so that the code can access Number's methods through List&lt;Integer&gt;'s elements, use an upper bounded wildcard:.   List&lt;? extends Integer&gt; intList = new ArrayList&lt;&gt;();   List&lt;? extends Number&gt;  numList = intList; // OK. List&lt;? extends Integer&gt; is a subtype of List&lt;? extends Number&gt; } }                 Wildcard Capture and Helper Methods     경우에 따라서 컴파일러는 코드(List&lt;?&gt;)에서 와일드카드 타입을 유추한다.   대부분 “capture of”라는 문구가 포함된 오류 메시지가 포함되어 표시가 된다.   해당 컴파일러 오류를 해결하기 Helper Method를 정의하여 해결할 수 있다.     public class WildcardError { void foo(List&lt;?&gt; i) {   i.set(0, i.get(0)); // The method set(int, capture#1-of ?) in the type List&lt;capture#1-of ?&gt; is not applicable for the arguments (int, capture#2-of ?) } } public class WildcardFixed { void foo(List&lt;?&gt; i) {   fooHelper(i); } // Helper method created so that the wildcard can be captured // through type inference. private &lt;T&gt; void fooHelper(List&lt;T&gt; l) {   l.set(0, l.get(0)); } }           더 복잡한 예제이다.     public class WildcardErrorBad { public static void main(String[] args) {   List &lt;Integer&gt; li = Arrays.asList (1, 2, 3);   List &lt;Double&gt; ld = Arrays.asList (10.10, 20.20, 30.30);   swapFirst(li, ld);  } private static void swapFirst(List&lt;? extends Number&gt; l1, List&lt;? extends Number&gt; l2) {   Number temp = l1.get(0);   l1.set(0, l2.get(0)); // Expected a CAP#1 extends Number, got a CAP#2 extends Number. same bound, but different types.   l2.set(0, temp); // Expected a CAP#1 extends Number, got a Number. } }          Exception in thread \"main\" java.lang.Error: Unresolved compilation problems:  The method set(int, capture#2-of ? extends Number) in the type List&lt;capture#2-of ? extends Number&gt; is not applicable for the arguments (int, capture#3-of ? extends Number) The method set(int, capture#4-of ? extends Number) in the type List&lt;capture#4-of ? extends Number&gt; is not applicable for the arguments (int, Number)  at gracefulsoul.blog.generic.wildcard.capture.WildcardErrorBad.swapFirst(WildcardErrorBad.java:17) at gracefulsoul.blog.generic.wildcard.capture.WildcardErrorBad.main(WildcardErrorBad.java:11)           Erasure of Generic Types     Java 컴파일러는 모든 타입 매개 변수를 지우고 타입 매개 변수가 바운드 된 경우 첫 번쨰 바운드로 대체하고, 바운드 되지 않은 경우 Object로 바운드한다.     public class Node&lt;T&gt; { private T data; private Node&lt;T&gt; next; public Node(T data, Node&lt;T&gt; next) {   this.data = data;   this.next = next; } public T getData() { return data; } // ... } // Because the type parameter T is unbounded, the Java compiler replaces it with Object public class Node { private Object data; private Node next; public Node(Object data, Node next) {   this.data = data;   this.next = next; } public Object getData() { return data; } // ... }          public class ComparableNode&lt;T extends Comparable&lt;T&gt;&gt; { private T data; private ComparableNode&lt;T&gt; next; public ComparableNode(T data, ComparableNode&lt;T&gt; next) {   this.data = data;   this.next = next; } public T getData() { return data; } // ... } // The Java compiler replaces the bounded type parameter T with the first bound class, Comparable. public class ComparableNode { private Comparable data; private ComparableNode next; public ComparableNode(Comparable data, ComparableNode next) {   this.data = data;   this.next = next; } public Comparable getData() { return data; } // ... }           Erasure of Generic Methods     Java 컴파일러는 제네릭 메소드 인수의 타입 매개 변수도 지운다.     // Counts the number of occurrences of elem in anArray. public static &lt;T&gt; int count(T[] anArray, T elem) {     int cnt = 0;     for (T e : anArray) {         if (e.equals(elem)) {             ++cnt;         }         return cnt;     } } // Because T is unbounded, the Java compiler replaces it with Object. public static int count(Object[] anArray, Object elem) {     int cnt = 0;     for (Object e : anArray) {         if (e.equals(elem)) {             ++cnt;         }         return cnt;     } }          class Shape { public static &lt;T extends Shape&gt; void draw(T shape) { /* ... */ } } //The Java compiler replaces T with Shape. class Shape { public static void draw(Shape shape) { /* ... */ } }           Bridge Methods     매개 변수화 된 클래스와 인터페이스를 확장 및 구현하는 클래스 또는 인터페이스를 컴파일 할 때, 컴파일러는 Bridge Method라는 합성 메서드를 만들수도 있다.     public class Node { public Object data; public Node(Object data) { this.data = data; } public void setData(Object data) {   System.out.println(\"Node.setData\");   this.data = data; } } public class MyNode extends Node { public MyNode(Integer data) {   super(data); } public void setData(Integer data) {   System.out.println(\"MyNode.setData\");   super.setData(data); } } public class MyNode extends Node { ... // Bridge method generated by the compiler. public void setData(Object data) {   setData((Integer) data); } }          Non-Reifiable Types       수정 가능한 타입은 타입의 정보를 런타임시에 이용할 수 있는 타입이다.   수정 불가능한 타입은 Type Erasure로 컴파일 시 정보가 삭제된 타입으로, 런타임에 모든 정보를 사용 할 수 없다.   Heap Pollution     매개 변수화 된 타입이 매개 변수화 된 타입이 아닌 객체를 참조 할 떄 발생한다.   예를 들어, 원시 타입과 매개 변수화 된 타입을 혼합하거나 확인되지 않은 캐스트를 수행할 때 발생한다.   Potential Vulnerabilities of Varargs Methods with Non-Reifiable Formal Parameters     Varargs 입력 매개 변수를 사용하는 제네릭 메서드는 힙 오염을 일으킬 수 있다.     public class ArrayBuilder { public static &lt;T&gt; void addToList(List&lt;T&gt; listArg, T... elements) {   for (T x : elements) {     listArg.add(x);   } } public static void faultyMethod(List&lt;String&gt;... l) {   Object[] objectArray = l; // Valid   objectArray[0] = Arrays.asList(42);   String s = l[0].get(0); // ClassCastException thrown here } } public class HeapPollutionExample { public static void main(String[] args) {   List&lt;String&gt; stringListA = new ArrayList&lt;String&gt;();   List&lt;String&gt; stringListB = new ArrayList&lt;String&gt;();   ArrayBuilder.addToList(stringListA, \"Seven\", \"Eight\", \"Nine\");   ArrayBuilder.addToList(stringListB, \"Ten\", \"Eleven\", \"Twelve\");   List&lt;List&lt;String&gt;&gt; listOfStringLists = new ArrayList&lt;List&lt;String&gt;&gt;();   // Type safety: A generic array of List&lt;String&gt; is created for a varargs parameter.   ArrayBuilder.addToList(listOfStringLists, stringListA, stringListB);   ArrayBuilder.faultyMethod(Arrays.asList(\"Hello!\"), Arrays.asList(\"World!\")); } }           Prevent Warnings from Varargs Methods with Non-Reifiable Formal Parameters     매개 변수화 타입의 매개 변수를 가지는 varargs 메서드에 아래의 어노테이션을 사용함으로써, 컴파일러가 생성하는 ClassCastException 혹은 이와 유사한 다른 Exception들을 방지할 수 있다.            @SafeVarargs1                    메서드의 구현이 varargs 공식 매개변수를 부적절하게 처리 하지 않을 것을 주장한다.                       @SuppressWarnings({“unchecked”, “varargs”})2                    이 어노테이션은 메서드의 호출 사이트에서 생성된 경고를 억제하지 않는다.                           Reference   ※ 본 글은 Oracle-Java_Tutorial_Generic을 기반으로 작성하였습니다.  ※ Sample Code는 여기에서 확인 가능합니다.                 Oracle-Java_Docs_SafeVarargs &#8617;                  Oracle-Java_Docs_SuppressWarnings &#8617;           ","categories": ["Java"],
        "tags": ["Programming","Java","Generic"],
        "url": "/java/generic/",
        "teaser": null
      },{
        "title": "Java",
        "excerpt":"Java     제임스 고슬링(James Gosling)과 다른 연구원들이 개발한 객체 지향적인 프로그래밍 언어이다.   Java의 특징     객체 지향 프로그래밍(Object-Oriented Programming) 언어1이다.            JDK8 이후의 Lambda Expression은 함수형 프로그래밍2을 지원한다.           컴파일 언어인 동시에 인터프리터3 언어이다.              Javac(Java Compiler)를 이용하여 JVM이 이해할 수 있는 16진수의 Java bytecode로 변환한다.       컴파일된 Java bytecode를 JVM(Java Virtual Machine)4에서 Row 단위 수행의 경우 인터프리터를, 전체 수행의 경우 JIT(Just-In Time) Compiler5를 이용하여 기계어로 변환하여 실행한다.           JVM에서 실행되므로 운영체제에 독립적이다.   JVM을 사용하여 자동 메모리 관리(Garbage Collection)6가 된다.   동적 로딩을 지원한다.            Load-Time dynamic loading : 클래스를 로딩하는 과정에서 클래스를 로딩한다.         public class RuntimeLoading {   public static void main(String[] args) {     System.out.println(\"Hello!\");   } }                       Run-Time dynamic loading : 코드를 실행하는 순간에 클래스를 로딩한다.         public enum Language {   DEFAULT, KOREAN, ENGLISH; } public class KoreanGreeting implements Runnable {   public void run() {     System.out.println(\"안녕!\");   } } public class EnglishGreeting implements Runnable {   public void run() {     System.out.println(\"Hello!\");   }   } public class Greeting {   public void greeting(Language language) {     try {       Class&lt;?&gt; _class = this.getClass(language);       Runnable runnable = (Runnable)_class.newInstance();       runnable.run();     } catch (InstantiationException  |  IllegalAccessException e) {       e.printStackTrace();     }   }   private Class&lt;?&gt; getClass(Language language) {     switch(language) {       case KOREAN:         return KoreanGreeting.class;       default:         return EnglishGreeting.class;     }   } } public class LoadTimeLoading {   public static void main(String[] args) {     Greeting greeting = new Greeting();     greeting.greeting(Language.DEFAULT);     greeting.greeting(Language.KOREAN);   } }                           네트워크와 분산처리를 지원한다.            인터넷과 대규모 분산환경을 염두하여 다양한 네트워크 프로그래밍 라이브러리(Java API)를 통해 비교적 짧은 시간에 네트워킹 프로그래밍을 쉽게 개발할 수 있도록 지원한다.           Support  JAVA 제품군의 지원은 아래의 도표7를 보면 알 수 있다.                  Release       GA Date       Premier Support Until       Extended Support Until       Sustaining Support                       7       July 2011       July 2019       July 2022*****       Indefinite                 8**       March 2014       March 2022       December 2030       Indefinite                 9 (non‑LTS)       September 2017       March 2018       Not Available       Indefinite                 10 (non‑LTS)       March 2018       September 2018       Not Available       Indefinite                 11 (LTS)       September 2018       September 2023       September 2026       Indefinite                 12 (non‑LTS)       March 2019       September 2019       Not Available       Indefinite                 13 (non‑LTS)       September 2019       March 2020       Not Available       Indefinite                 14 (non‑LTS)       March 2020***       September 2020       Not Available       Indefinite                 15 (non‑LTS)       September 2020***       March 2021       Not Available       Indefinite           Reference   ※ Sample Code는 여기에서 확인 가능합니다.                 Blog-객체지향프로그래밍 &#8617;                  Blog-함수형프로그래밍 &#8617;                  Wiki-Interpreter &#8617;                  Wiki-JVM &#8617;                  Wiki-JIT_Compiler &#8617;                  NaverD2-Java_Garbage_Collection &#8617;                  Oracle-OracleJava_SE_Product_Releases &#8617;           ","categories": ["Java"],
        "tags": ["Programming","Java"],
        "url": "/java/java/",
        "teaser": null
      },{
        "title": "Java10",
        "excerpt":"주요 변경사항  JAVA 10     자세한 내용은 오라클 공식 변경사항1을 참조하기 바란다.   Local-variable type inference  명시적으로 언급하던 타입을 추론을 통해 가능하게 개선되었다.  public class TypeInference {   public static void main(String[] args) {     // Java6     Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();     // Java7     Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();     // Java10     var map = new HashMap&lt;Integer, String&gt;();   } }   Optional.orElseThrow() Method  Optional 클래스에 get 메서드를 활용하는 orElseThrow 메서드가 추가되었다.   APIs for Creating Unmodifiable Collections  Collectors 클래스에 추가 메서드(toUnmodifiableList, toUnmodifiableSet, toUnmodifiableMap)를 활용하여 수정할 수 없는 컬랙션에서 데이터를 수집할 수 있다.   Parallel Full GC for G1  G1은 단일 스레드로 Mark-Sweep-Compact알고리즘을 사용하였지만, 전체 GC를 병렬로 만들어 G1 최악의 지연 시간을 개선하였다.   Root Certificates  JDK에서 기본 Certification Authority(CA)인증서를 제공합니다.   Time-Based Release Versioning  OpenJDK 커뮤니티는 Java 플랫폼의 주요 릴리스가 6개월마다 발생 하는 새로운 시간 기반 릴리스 모델2을 채택했습니다. JEP2233에서 도입 한 버전 번호 체계를 다시 캐스팅하여 새로운 기능을 포함 할 수있는 기능 릴리스를 정의하는 시간 기반 릴리스 모델과 버그만 수정하는 업데이트 릴리스에 더 적합하도록합니다.4   $FEATURE.$INTERIM.$UPDATE.$PATCH     $FEATURE : 릴리스 내용에 관계없이 모든 기능 릴리스에 대해 증가하는 기능 릴리스 카운터dlek.   $INTERIM : 호환되는 버그 수정 및 개선 사항을 포함하지만 호환되지 않는 변경 사항, 기능 제거 사항 및 표준 API 변경 사항이없는 비 기능 릴리스에 대해 증가하는 임시 릴리스 카운터이다.   $UPDATE : 보안 문제, 회귀 및 최신 기능의 버그를 수정하는 호환 가능한 업데이트 릴리스에 대해 증가하는 카운터이다.   $PATCH : 중요한 문제를 해결하기 위해 카운터이다.   Reference   ※ Sample Code는 여기에서 확인 가능합니다.                 Oracle-Java_10_New_Features_And_Enhancements &#8617;                  Mark_Reinhold-Moving_Java_Forward_Faster &#8617;                  OpenJDK-New_Version-String_Scheme &#8617;                  OpenJDK-Time-Based_Release_Versioning &#8617;           ","categories": ["Java"],
        "tags": ["Programming","Releases","Java 10"],
        "url": "/java/java10/",
        "teaser": null
      },{
        "title": "Java11",
        "excerpt":"주요 변경사항  JAVA 11     자세한 내용은 오라클 공식 변경사항1을 참조하기 바란다.   Unicode 10  유니 코드 표준버전 10.0을 지원하도록 기존 플랫폼 API를 업그레이드 하였다.   HTTP Client (Standard)  JAVA9에 도입되고 JAVA10에서 업데이트 된 jdk.incubator.http패키지는 제거되었고 java.net.http이 생성되었다.     CompletableFutures을 통해 Non-Blocking Request, Response를 지원한다.   java.util.concurrent.Flow API를 이용한 BackPressure와 FlowControl을 지원한다.   이전 HTTP/1.1 구현은 차단되었고, RXFlow 개념의 사용이 구현에 적용되어 HTTP/2을 지원한다.   Factory method로 BodyPublisher, BodyHandler, BodySubscriber를 생성한다.   Updated Locale Data to Unicode CLDR v33  Unicode Consortium의 CLDR(Common Locale Data Registry)을 기반으로하는 Locale Data가 Java11용으로 업데이트되었다.   ZGC A Scalable Low-Latency Garbage Collector (Experimental)  확장 가능한 낮은 지연 가비지 수집기인 Z Garbage Collector가 실험적 기능으로 추가되었다.     일시 중지 시간은 10ms를 초과하지 않는다.   일시 중지 시간은 힙 또는 라이브 세트 크기에 따라 증가하지 않는다.   수백 메가 바이트에서 수 테라 바이트 크기의 힙을 처리한다.   Linux/x64에서만 JVM 옵션(-XX:+UnlockExperimentalVMOptions, -XX:+UseZGC)을 추가하여 사용할 수 있다.   압축 된 oops, 압축 된 클래스 포인트 사용, 클래스 언로드는 지원하지 않으며, JVM 옵션을 추가하여도 효과가 없다.   Nest-Based Access Control  Java 프로그래밍 언어의 기존 중첩 유형 개념과 일치하는 액세스 제어 컨텍스트인 nest가 추가되었다.2   Transport Layer Security (TLS) 1.3  TLS(Transport Layer Security) 1.3 사양(RFC 8446)의 구현이 포함되어 있다.     TLS 프로토콜 버전 이름 : TLSv1.3   SSLContext 알고리즘 이름 : TLSv1.3   TLS1.3 용 TLS 암호 그룹 이름 : TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384   X509KeyManager의 keyType : RSASSA-PSS   X509TrustManager의 authType : RSASSA-PSS   Local-Variable Syntax for Lambda Parameters  변수 선언에 사용되는 var은 람다 식의 형식 매개 변수를 선언 할 때 사용할 수 있다.   Deprecate the Nashorn JavaScript Engine  API와 함께 ECMAScript 언어 구조가 조정되고 수정되는 빠른 속도로 인해 유지 관리가 어려워 Nashorn JavaScript 스크립트 엔진과 API 및 jjs 도구를 제거하였다.   Migrating From JDK 8 to Later JDK Releases  JDK 8 이후 JDK 릴리스 간에 많은 변경이 있었다. JDK 내부 API를 사용하는 코드는 계속 실행해야하지만 지원되는 API를 사용하려면 마이그레이션을 해야한다.     Oracle-Oracle_JDK_Migration_Guide   Microsoft-Java8에서_Java11로_전환   Reference                 Oracle-Java_11_Release_Notes &#8617;                  OpenJDK-Nest-Based_Access_Control &#8617;           ","categories": ["Java"],
        "tags": ["Programming","Releases","Java 11"],
        "url": "/java/java11/",
        "teaser": null
      },{
        "title": "Java8",
        "excerpt":"주요 변경사항  JAVA 8     자세한 내용은 오라클 공식 변경사항1을 참조하기 바란다.   Lambda Expression     Stream : Iterater와 비슷하게 Collection의 저장요소를 하나씩 참조해서 Lambda Expression으로 처리할 수 있도록 해주는 반복자이다.   Functional Inteface : 구현해야 할 메서드가 하나만 정의된 인터페이스이다.   Method Reference : 람다 표현식이 단 하나의 메서드만 호출 하는 경우, 간결하게 표시하는 방법이다.   Default Method  기존 인터페이스에 메서드를 추가할 때, 구현을 강제하지 않도록 하위 호환성을 보장하기 위해 기본 기능을 제공하는 것이다.   Change JavaScript Engine  1998년에 출시되었던 구형 JavaScript Engine인 Rhino에서 ECMAScript-262 Edition 5.1 언어 사양을 기반으로 된 Nashorn2으로 변경되었다.   Change Memory Space  JAVA 7까지 Heap Space에 존재하였던 PermGen이 제거되고, Native Space에 존재하는 Metaspace로 변경되면서 Memory 영역 확보에 크게 의식할 필요를 없앴다.   Improving Concurrent API     ConcurrentHashMap : JAVA 5까지 사용하던 HashTable은 각 메서드에 syncronized 키워드를 사용하여 동시성을 개선하였지만, 성능적인 문제로 인해 개선된 ConcurrentHashMap을 제공한다.   LongAdder, LongAccumulator : AtomicLong의 CAS(compareAndSwap)연산에 의한 Race Condition을 최소화 하기 위한 LongAdder를 제공한다.   StampedLock : 읽기와 쓰기 접근에 대한 대해 락을 운영하는 ReadWriteLock의 성능이 느려 속도와 Optimistic Lock을 제공하는 StampedLock3을 제공한다.   Expansion IO/NIO  Base64 인코딩/디코딩을 지원하는 Base64를 제공하며, Files 클래스 내 read/write 등 개선된 기능을 제공한다.   New Time API  Date와 Calendar 클래스는 불편성과 버그들4로 인해 새로운 날짜 API인 JodaTime API를 도입하였다.   Reference                 Oracle-Java_8_What’s_New &#8617;                  Oracle-Nashron &#8617;                  HeinzKabutz-PhaserAndStampedLock &#8617;                  NaverD2-Java’s_Date_And_Time_API &#8617;           ","categories": ["Java"],
        "tags": ["Programming","Releases","Java 8"],
        "url": "/java/java8/",
        "teaser": null
      },{
        "title": "Java9",
        "excerpt":"주요 변경사항  JAVA 9     자세한 내용은 오라클 공식 변경사항1을 참조하기 바란다.   Add Java Platform Module System(Jigsaw)  유연한 런타임 이미지를 만들기 위해 Java 플랫폼을 모듈화하여 필요한 모듈만 경량화된 이미지를 만들 수 있게 되었다.   Updates Process API  ProcessHandle API를 활용하여 운영체제의 프로세스 제어 및 관리를 위한 API의 기능이 향상되었다.   Add JShell  JavasSript(Node JS), Python 같은 인터프리터 언어처럼 바로 코드를 작성하고 결과를 확인할 수 있는 REPL(Read-Eval-Print-Loop) 도구를 제공한다.   Add Compact String  자바의 char 자료형은 UTF-16기반의 2Byte를 차지하는데 개선된 String은 문자열에 따라 Latin-1(1Byte)와 UTF-16(2Byte)으로 나누어졌다.   SHA-3 Hash Algorithms  SHA-1, SHA-2 표준 해시 함수를 대체하는 SHA-3 해시 함수를 제공한다.   Improve try-with-resource  try~with~resourec 구문 외부에서 정의된 객체도 final 혹은 effectively final이 적용된다.  public class TryWithResource {   public static void main(String[] args) {     // Java7     BufferedReader outerReader = new BufferedReader(new FileReader(\"test.txt\"));     try (BufferedReader innerReader = outerReader) {       /* ... */     }     // Java9     // Final or effectively final applied so that the reader can be used.     BufferedReader reader = new BufferedReader(new FileReader(\"test.txt\"));     try (reader) {       /* ... */     }   } }   Implement Selected ECMAScript 6 Features in Nashorn  Nashorn이 ECMAScript 6 버전의 많은 새로운 기능 중 일부를 구현하여 제공한다.   Private Interface Method  Interface 외부에서 사용 및 참조(Overriding)이 불가능한 private &amp; private static method라는 새로운 기능을 제공한다.   Updates More Concurrency  개선된 CompletableFuture과 Reactive stream이 도입 등 프로그램의 동시성 및 병렬 처리 지원을 위한 라이브러리의 지원이 늘어났다.   Improve Diamond Operator  익명 클래스에 Diamond Operator를 사용할 수 있다.   Stream Improvements  Stream에 추가 메서드(iterate, takeWhile, dropWhile, ofNullable)를 제공하여 비동기 프로그래밍에 대한 편의성을 제공한다.   Optional Class Stream  Optional에 추가 메서드(or, ifPresentOrElse, stream)로 활용도가 높아졌다.   Convenience Factory Methods for Collections  불변 Collection을 보다 가독성 좋게 생성하기 위한 Factory Method를 제공한다.  public class Collection {   public static void main(String[] args) {     // Java8     List&lt;String&gt; list = Collections.unmodifiableList(Stream.of(\"foo\", \"bar\", \"baz\").collect(Collectors.toList()));     Set&lt;String&gt; set = Collections.unmodifiableSet(Stream.of(\"foo\", \"bar\", \"baz\").collect(Collectors.toSet()));     // Java9     List&lt;String&gt; list = List.of(\"foo\", \"bar\", \"baz\");     Set&lt;String&gt; set = Set.of(\"foo\", \"bar\", \"baz\");   } }   Reference   ※ Sample Code는 여기에서 확인 가능합니다.                 Oracle-Java_9_Release_Notes &#8617;           ","categories": ["Java"],
        "tags": ["Programming","Releases","Java 9"],
        "url": "/java/java9/",
        "teaser": null
      },{
        "title": "Java12",
        "excerpt":"주요 변경사항  JAVA 12     자세한 내용은 OpenJDK 공식 변경사항1을 참조하기 바란다.   Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)  Shenandoah[^shenandoah]는 실행중인 Java 프로그램과 동시에 더 많은 Garbage Collection을 수행하여 Garbage Collector의 일시 중지 시간을 줄이는 Garbage Collector이다.    실행 단계는 Root Set을 스캔 후 Concurrent mark을 수행한다. 이후 두번째 정지로 대기열을 비우고 다시 루트 세트를 검색하여 Concurrent mark를 완료하여 라이브 개체가 없는 영역의 회수와 다른 지역으로 복사를 한다. 그 이후 업데이트 참조 단계를 초기화하고 이동이 된 개체에 대한 참조와 기존 Root Set를 업데이트하여 업데이트 참조 단계를 완료한다. 마지막으로 참조가 없는 컬렉션 영역을 회수한다.   Microbenchmark Suite  JDK 소스 코드에 기본 마이크로 벤치 마크 제품군을 추가하였다. 이를 통해 개발자가 기존 마이크로 벤치 마크를 쉽게 실행하고 새 마이크로 벤치 마크를 만들 수 있게 되었다. Microbenchmark 제품군의 벤치 마크 세트는 JMH JDK Microbenchmarks 프로젝트2에서 가져오면된다.   Switch Expressions (Preview)  명령문 또는 표현식으로 사용할 수 있도록 Switch 표현식을 개선시켰다. 단지 이 기능은 미리보기 기능3이다.  public class Switch {   public static void main(String[] args) {     System.out.println(getMessageInJava11(args.length));     System.out.println(getMessageInJava12(args.length));   }   // Java11   private static String getMessageInJava11(int count) {     switch(count) {       case 1:         return \"have one args.\";       case 2:         return \"have two args.\";       default:         return \"have more than two args.\";     }   }   // Java12   private static String getMessageInJava12(int count) {     return switch(count) {       case 1 -&gt; \"have one args.\";       case 2 -&gt; \"have two args.\";       default -&gt; \"have more than two args.\";     }   } }   JVM Constants API  모든 Java 클래스는 내부의 메서드와 클래스, String과 Integer 같은 값을 바이트 코드 형태로 저장하는 아래와 같은 상수 풀 테이블이 존재한다.  cp_info {   u1 tag;   u1 info[]; }  JVM 명령 (Ex: ldc, invokedynamic)은 이 테이블의 정보에 의존한다. 이러한 명령어가 실행되면로드 가능한 상수는 Class, String, int 등과 같은 라이브 값이된다. 새 패키지 java.lang.invoke.constant는 클래스 파일 및 런타임 아티팩트, 특히 상수 풀에서 로드 할 수 있는 상수의 명목상 설명을 모델링하는 API를 도입한다.   One AArch64 Port, Not Two  모든 기여자가 단일 64-bit ARM 구현에 대한 집중과 두 개의 포트를 유지하는 데 필요한 중복 작업을 하지 않도록, 32-bit ARM 포트와 64-bit aarch64 포트를 유지하면서 arm64 포트와 관련된 모든 소스를 제거한다.   Default CDS Archives  64-bit 플랫폼에서 기본 클래스 목록을 사용하여 클래스 데이터-공유(CDS) 아카이브를 생성하도록 JDK 빌드 프로세스를 개선하였다. JDK 11 Early-Access Build 14를 사용하여 Linux/x64에서 측정 한 결과 실행 중인 시작 시간이 32%나 단축된 것을 확인 하였고, 다른 64-bit 플랫폼에서는 비슷하거나 더 높은 시작 성능 향상이 관찰되었다.   Abortable Mixed Collections for G1  G1 Garbage Collection이 휴리스틱 수가 너무 큰 Collection Set을 선택 할 경우, 목표된 일시 중지 시간을 초과할 수 있으므로 효율적으로 동작하도록 하기 위해서 중단 가능한 Collection을 가지도록 변경하였다.   G1 May Uncommit Memory During Marking Cycle  G1은 이제 활성화 상태일 때 운영 체제에 Java의 힙 메모리를 돌려 줄 수 있다. G1은 Full GC가 일어나거나 Concurrent cycle이라는 상황에만 Java의 힙 메모리를 운영체제에 반환하고 있다. 하지만 Full GC는 Java에서 지양하므로 Concurrent Cycle만 해당 반환 작업이 가능한데, 외부에서 강제하지 않는 한 대부분 힙 메모리를 반환하지 않는다. 애플리케이션에 모든 메모리가 필요하지 않은 경우 Java 프로세스의 메모리 사용을 향상시킨다.   Reference   ※ Sample Code는 여기에서 확인 가능합니다.                 OpenJDK-JDK_12 &#8617;                  OpenJDK-JMH_JDK_Microbenchmarks &#8617;                  OpenJDK-Preview_Features &#8617;           ","categories": ["Java"],
        "tags": ["Programming","Releases","Java 12"],
        "url": "/java/java12/",
        "teaser": null
      },{
        "title": "Spring Aspect Orientated Programming(AOP)",
        "excerpt":"Aspect Orientated Programming(AOP)1  횡단 관심사(공통된 코드)의 분리를 허용함으로써 모듈성을 증가시키는 것이 목적인 프로그래밍 패러다임이다.   특징     Spring은 프록시 패턴을 사용한다.   Proxy는 외부 메서드 호출만 인터셉트하여 동일 클래스 내 메소드 호출 시, 동작하지 않는다.   Bean으로 정의된 Method를 대상으로만 적용이 가능하다.   용어  Aspect  횡단 관심사를 모듈화 한 것이다.   Target  Aspect를 적용하는 곳이다.   Advice  부가 기능(코드)을 담은 모듈이다.   Before Advice     메서드가 실행되기 전에 수행하는 모듈이다.   @Before 어노테이션을 사용하여 정의한다.   Around Advice     메서드가 실행되기 전과 실행된 후에 각각 수행하는 모듈이다.   @Around 어노테이션을 사용하여 정의한다.   After Advice     메서드가 실행된 후에 수행하는 모듈이다.   @After 어노테이션을 사용하여 정의한다.   After Returning Advice     메서드가 정상적으로 실행되어 결과를 반환한 후에 실행하는 모듈이다.   결과를 반환한 후에 실행되므로, 메서드의 결과를 활용할 수 있다.   @AfterReturning 어노테이션을 사용하여 정의한다.   After Throwing Advice     메서드가 실행 중 오류가 발생하였을 경우 실행하는 모듈이다.   @AfterThrowing 어노테이션을 사용하여 정의한다.   JoinPoint  Advice가 적용 될 수 있는 위치이다.   PointCut  JoinPoint를 선정하는 방법이다.   execution     JoinPoint를 선정할 메서드를 명시할 때 사용한다.   표현식 : execution([접근 제어자-생략 가능] [리턴 타입] [클래스 이름] [메서드 이름]([인자])   예제                  Expression       Description                       excution(public * *())       접근제어자가 public이고, 인자가 0개인 모든 메서드를 JoinPoint로 선정한다.                 excution(* com.gracefulsoul.spring.aop..(..))       com.gracefulsoul.spring.aop 패키지에 있는 모든 클래스의 메서드 중 인자가 1개 이상인 메서드를 JoinPoint로 선정한다.                 excution(* com.gracefulsoul.spring.aop...(..))       com.gracefulsoul.spring.aop 패키지와 하위에 있는 모든 클래스의 메서드 중 인자가 1개 이상인 메서드를 JoinPoint로 선정한다.                 excution(* insert())       메서드 명이 insert로 시작하는 인자가 1개인 메서드를 JoinPoint로 선정한다.                 excution(* insert(, *))       메서드 명이 insert로 시작하는 인자가 2개인 메서드를 JoinPoint로 선정한다.           within     특정 타입에 속하는 메서드를 JoinPoint로 선정하도록 명시할 때 사용한다.   예제                  Expression       Description                       within(com.gracefulsoul.spring.aop.*)       com.gracefulsoul.spring.aop 패키지에 있는 모든 클래스의 메서드를 JoinPoint로 선정한다.                 within(com.gracefulsoul.spring.aop..)       com.gracefulsoul.spring.aop 패키지와 하위에 있는 모든 클래스의 메서드를 JoinPoint로 선정한다.           bean     Spring 2.5 이상부터 지원하며, Bean을 통해서 JoinPoint를 명시할 때 사용한다.   예제                  Expression       Description                       bean(blackBean)       Bean 이름이 blackBean인 클래스의 메서드를 JoinPoint로 선정한다.                 bean(!blackBean)       Bean 이름이 blackBean이 아닌 클래스의 메서드를 JoinPoint로 선정한다.           Advisor  Advice와 PointCut을 합쳐서 부르는 용어이다.   Weaving  PointCut으로 결정된 JoinPoint에 Advice를 삽입하는 과정이다.   Reference                 SpringDocs-AOP &#8617;           ","categories": ["Spring"],
        "tags": ["Programming","Framework","Spring"],
        "url": "/spring/aop/",
        "teaser": null
      },{
        "title": "Spring Bean",
        "excerpt":"Bean     Spring IOC Container가 관리하는 자바 객체이다.   Bean 등록 방식  Component Scan  특정 클래스들을 Bean으로 등록하기 위해 사용되는 방법이다.   basePackage  지정된 패키지를 포함한 그 이하 패키지의 클래스들을 대상으로 @Component Annotation 혹은 연관 Annotation(@Controller, @Service, …)이 선언되어 있으면 해당 Component를 Scan한다.   basePackageClasses  주어진 클래스의 위치에 해당하는 패키지를 포함한 그 이하 패키지의 클래스들을 대상으로 @Component Annotation 혹은 연관 Annotation(@Controller, @Service, …)이 선언되어 있으면 해당 Component를 Scan한다.   useDefaultFilters  @Component Annotation 혹은 연관 Annotation(@Controller, @Service, …)이 선언되어 있는 클래스를 포함하는지를 결정하기 위해서 사용된다. (Default : true)   FilterType.ANNOTATION  classes에 추가한 Annotation이 선언되어 있는 클래스를 Scan한다.   FilterType.ASPECTJ  AspectJ의 pattern을 사용하여 Scan한다.   FilterType.ASSIGNABLE_TYPE  classes에 추가한 클래스와 해당 클래스의 상속 및 구현체에 해당하는 Scan한다.   FilterType.REGEX  pattern으로 정의한 정규표현식을 이용하여 Scan한다.   FilterType.CUSTOM  사용자 정의된 Filter를 이용하여 Scan한다.   public class CustomFilter implements TypeFilter {   @Override   public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory){     ...   } }   includeFilters  위에 설명된 Filter를 사용하여 Component Scan에 포함한다.   excludeFilters  위에 설명된 Filter를 사용하여 Component Scan에 제외한다. 단, includeFilters와 중복될 경우 exculudeFilters가 우선순위가 높아서 제외가 된다.   lazyInit  ComponentScan된 Class들이 실제 사용할 때, 초기화 된다.   Scope1  Singleton (Default)  하나의 Bean 정의에 대해서 Spring IOC Container 내에 단 하나의 객체만 존재한다.   Prototype  하나의 Bean 정의에 대해서 다수의 객체가 존재할 수 있다.   Request  하나의 Bean 정의에 대해서 하나의 HTTP request의 생명주기 안에 단 하나의 객체만 존재한다.   Session  하나의 Bean 정의에 대해서 하나의 HTTP Session의 생명주기 안에 단 하나의 객체만 존재한다.   Global session  하나의 Bean 정의에 대해서 하나의 global HTTP Session의 생명주기 안에 단 하나의 객체만 존재한다. 일반적으로 portlet context 안에서 유효하다.   Life Cycle  Bean은 객체 생성 &gt; 초기화 &gt; 사용 &gt; 소멸의 Life Cycle을 가진다.   초기화 및 소멸의 3가지 방법     @PostConstruct, @PreConstruct 어노테이션을 활용한다.   InitializingBean, DisposableBean 인터페이스를 구현하여 사용한다.   빈 등록 시, init-method 혹은 destroy-method를 등록한다.   Reference                 SpringDocs-Bean_Scopes &#8617;           ","categories": ["Spring"],
        "tags": ["Programming","Framework","Spring"],
        "url": "/spring/bean/",
        "teaser": null
      },{
        "title": "Spring Dependency Injection(DI)",
        "excerpt":"Dependency Injection(DI) 1     구체적인 의존 오브젝트와 그것을 사용할 주체, 클라이언트를 런타임 시에 연결해주는 작업이다.   Constuctor Injection을 기반으로 Optional한 경우 Setter Injection을 활용 하는 것을 지향한다.   Field Injection은 final keyword를 사용 할 수 없어 가변적이고, 해당 클래스를 바로 Instance화 시킬 수 없는 등의 문제로 인해서 안티패턴으로 사용을 지양해야 한다.   public class BeanObject {   private String name;   public String getName() {     return name;   }   public void setName(String name) {     this.name = name;   } } public class OtherBeanObject {   private BeanObject beanObject;   public BeanObject getBeanObject() {     return beanObject;   }   public void setBeanObject(BeanObject beanObject) {     this.beanObject = beanObject;   } }    Field Injection  @Component public class FieldInjection {   @Autowired   private BeanObject beanObject; }  Setter-based Injection  @Component public class SetterInjection {   private BeanObject beanObject;   // Inject to field variable using Setter Injection.   @Autowired   private void setBeanObject(BeanObject beanObject) {     this.beanObject = beanObject;   }   // Inject into the parameter of the method using Setter Injection.   @Bean   private OtherBeanObject otherBeanObject(@Qualifier(\"beanObject\") BeanObject beanObject) {     OtherBeanObject otherBeanObject = new OtherBeanObject();     otherBeanObject.setBeanObject(beanObject);     return otherBeanObject;   } }  Constuctor-based Injection  @Component public class ConstructorInjection {   private BeanObject beanObject;   // @Autowired   // Constructor dependency injection can omit @Autowired from Spring 4.3.   public ConstructorInjection(BeanObject beanObject) {     this.beanObject = beanObject;   } }   Reference                 SpringDOcs-DI &#8617;           ","categories": ["Spring"],
        "tags": ["Programming","Framework","Spring"],
        "url": "/spring/di/",
        "teaser": null
      },{
        "title": "Framework",
        "excerpt":"Framework     소프트웨어의 구체적인 부분에 해당하는 설계와 구현을 재사용이 가능하게끔 일련의 협업화된 형태로 클래스들을 제공하는 것이다. - 랄프 존슨(Ralph Johnson)   개발자들이 작성하는 코드 품질 및 개발 속도를 상향 평준화시키기 위해 제공되는 개발 환경을 제공해준다.   vs Library  라이브러리는 자주 사용되는 로직을 재사용하기 편리하도록 잘 정리한 일련의 코드들의 집합으로, 개발자의 주도 하에 흐름을 만들어서 사용하는(필요시 가져다 쓰는) 것이다. 하지만 프레임워크는 제공되는 환경(틀) 안에서 개발을 진행하기 때문에 흐름은 내포하고 있어 라이브러리와는 명확한 차이가 존재한다.   프레임워크의 특징1  Modularity     프레임워크는 구현을 인터페이스 뒤에 감추는 캡슐화를 통해서 모듈화를 강화한다.   프레임워크 모듈화는 설계와 구현의 변경에 따르는 영향을 최소화시킴으로써 쉽게 소프트웨어의 품질을 향상시킬 수 있다.   Reusability     프레임워크가 제공하는 인터페이스는 여러 애플리케이션에서 반복적으로 사용할 수 있는 일반적인 컴포넌트를 정의할 수 있게 함으로써 재사용성을 높여준다.   재사용성은 도메인 지식과 경험이 있는 개발자들의 노력을 활용하여, 애플리케이션의 요구사항과 소프트웨어 설계에 대한 공통의 솔루션을 반복적으로 재개발하고, 그에 대한 유효성을 다시 확인하는데 소요되는 시간을 줄여준다.   소프트웨어의 품질, 성능, 신뢰성, 상호 운용성을 향상시킬뿐만 아니라, 프로그래머의 생산성을 상당히 높여준다.   Extensibility     프레임워크는 다형성(polymorphism)을 통해 애플리케이션의 프레임워크의 인터페이스를 확장할 수 있게 한다.   새로운 애플리케이션 서비스와 특성을 커스터마이징하는 것을 보장하는데 필수적인 사항이며, 애플리케이션의 가변성으로부터 분리함으로써 재사용의 이점을 얻게 된다.   Inversion Of Control     일반적으로 어떤 모듈을 호출함으로써 해당 모듈을 재사용하게 되는데 프레임워크에서는 이와는 반대되는 제어 흐름으로 재사용성을 지원한다.   프레임워크 코드가 전체 애플리케이션의 처리흐름을 제어하며, 특정한 이벤트가 발생할 때 다형성(Polymorphism)을 통해 애플리케이션이 확장한 메서드를 호출함으로써 제어가 프레임워크로부터 애플리케이션으로 거꾸로 흐르게 된다.   이러한 제어의 역흐름을 통해 프레임워크가 외부의 이벤트에 대해 애플리케이션이 어떠한 메소드들을 수행해야 하는지 결정할 수 있다.   Reference                 HashNet-프레임워크 &#8617;           ","categories": ["Framework"],
        "tags": ["Programming","Framework"],
        "url": "/framework/framework/",
        "teaser": null
      },{
        "title": "Spring Inversion Of Control(IOC)",
        "excerpt":"Inversion Of Control(IOC)  객체의 의존관계에 대한 책임을 제 3자에게 위임하는 것이다.   BeanFactory     Spring Bean1 Container에 접근하기 위한 최상위 인터페이스이다.   Bean 생성, 의존성 주입, 생명주기(Life Cycle) 관리 등의 기능을 제공한다.   ApplicationContext     응용 프로그램에 대한 구성을 제공하는 중앙 인터페이스이다.   ListableBeanFactory 인터페이스를 상속받아 애플리케이션 Component에 접근하기위한 Bean Factory Method를 제공한다.   ResourceLoader 인터페이스를 상속받아 일반적인 방식으로 파일 리소스를 로드하는 기능을 제공한다.   ApplicationEventPublisher 인터페이스를 상속받아 등록 된 리스너에 이벤트를 게시하는 기능을 제공한다.   MessageSource 인터페이스를 상속받아 국제화를 지원하는 메시지 해결 기능을 제공한다.   StaticApplicationContext     코드를 통해 빈 메타정보를 등록하기 위해 사용한다.   거의 사용하지 않는 구현체이다.   GenericApplicationContext     실전에서 사용될 수 있는 모든 기능을 갖추고 있는 ApplicationContext이다.   일반적으로 ApplicationContext를 의존성 주입(DI)받는 객체이다.   GenericXmlApplicationContext     GenericApplicationContext와 Reader를 통해 설정 파일을 읽을 수 있는 XmlBeanDefinitionReader를 합친 ApplicationContext이다.   WebApplicationContext     웹 환경에서 사용할 때 필요한 기능이 추가된 ApplicationContext이다.   XmlWebApplicationContext (Default)     XML 설정 파일을 사용하는 WebApplicationContext이다.   AnnotationConfigWebApplicationContext     어노테이션 기반으로 설정하는 WebApplicationContext이다.   Reference                 Blog-Bean &#8617;           ","categories": ["Spring"],
        "tags": ["Programming","Framework","Spring"],
        "url": "/spring/ioc/",
        "teaser": null
      },{
        "title": "Spring Framework",
        "excerpt":"Spring Framework     자바 플랫폼을 위한 오픈소스 애플리케이션 프레임워크로서 엔터프라이즈급 애플리케이션을 개발하기 위한 모든 기능을 종합적으로 제공하는 경량화된 솔루션이다.   Spring Framework의 특징     경량 컨테이너로 자바 객체1를 직접 관리한다.   Inversion Of Control(IOC).   Dependency Injection(DI).   Aspect Orientated Programming(AOP).   Reference                 Blog-Bean &#8617;           ","categories": ["Spring"],
        "tags": ["Programming","Framework","Spring"],
        "url": "/spring/spring/",
        "teaser": null
      },{
        "title": "Database Transaction",
        "excerpt":"Transaction     은행 ATM이나 데이터베이스 등의 시스템에서 사용되는 더 이상 쪼갤 수 없는 업무 처리의 최소 단위이다.   ACID  원자성(Atomicity)  트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.  일관성(Consistency)  시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료의 상태가 같아야 한다.  독립성(Isolation)  수행 중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.  지속성(Durability)  성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.   트랜잭션 상태(Status)    활성(Active)  트랜잭션이 실행 중인 상태이다.  실패(Failed)  트랜잭션 실행에 오류가 발생하여 중단된 상태이다.  철회(Aborted)  트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태이다.  부분 완료(Partially Committed)  트랜잭션의 마지막 연산까지 실행하고, Commit 연산이 실행되기 직전의 상태이다.  완료(Committed)  트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태이다.   트랜잭션 연산(Operation)  Commit  모든 작업들을 정상적으로 처리하겠다고 확정하는 명령어로서, 처리과정을 데이터베이스에 영구적으로 저장하는 것이다.   Rollback  작업 중 문제가 발생하여 트랜잭션의 처리과정에서 발생한 변경사항을 취소하는 명령어이다.   Save Point  롤백을 명시하면 삽입, 삭제, 업데이트 등의 작업 전체가 취소되는데, 세이브포인트는 전체가 아닌 특정 부분에서 트랜잭션을 취소하기 위해 사용한다.   트랜잭션 병행 제어(Concurrency Control)  여러 트랜잭션들이 동시에 실행되면서도 데이터베이스의 일관성을 유지할 수 있게 하는 기법이다.   목적     데이터베이스의 일관성을 유지한다.   데이터베이스의 공유를 최대화한다.   시스템의 활용도를 최대화한다.   사용자의 응답시간을 최소화한다.   병행 제어 실패 현상  자원에 대한 경쟁 상태(Race Condition)에서 발생하는 문제이다.   Dirty Write  두 개 이상의 트랜잭션이 같은 데이터를 동시에 바꾸고자하는 문제이다.   Dirty Read  커밋 전 데이터 조회와 롤백 후 데이터 조회의 데이터가 불일치되는 문제이다.   Non-repeatable Read  한 트랜잭션에서 데이터 변경 전과 후 같은 조회 쿼리를 수행 시, 조회된 값이 변경되면서 결과가 달라지는 문제이다.   Phantom Read  한 트랜잭션에서 데이터 추가 전과 후 일정 범위의 레코드를 조회 시, 값이 추가(Phantom Tuple)되면서 결과가 달라지는 문제이다.   Cascade Rollback  두 개 이상의 Transaction이 수행되던 중 한 개의 Transaction이 취소될 때 나머지 다른 Transaction도 연쇄적으로 취소되는 현상.   병행 제어 기법  Locking     트랜잭션이 어떤 데이터에 접근하고자 할 때, 다른 트랜잭션이 접근할 수 없게 하는 기법이다.   필드, 레코드, 파일, 데이터베이스 모두 Locking 단위가 될 수 있다.   Locking 단위가 크면, 관리하기 용이(오버헤드 감소)하지만 병행성(동시성) 수준이 낮아진다.   Locking 단위가 작으면, 병행성(동시성) 수준이 높아지지만 관리가 난해(오버헤드 증가)하다.   2단계 로킹 규약(Two-Phase Locking Protocol)     Lock과 Unlock이 동시에 이루어지면 일관성이 보장되지 않으므로, Lock만 가능한 단계와 Unlock만 가능한 단계를 구분하는 기법이다.   직렬가능성을 보장하며, 교착상태가 발생할 수 있다.   확장 단계 : 새로운 Lock은 가능하고 Unlock은 불가능하다.   축소 단계 : Unlock 은 가능하고 새로운 Lock은 불가능하다.   Time Stamp     데이터에 접근하는 시간을 미리 정해서 정해진 시간(Time Stamp)의 순서대로 데이터에 접근하여 수행하는 기법이다.   직렬가능성을 보장하며, 교착상태가 발생하지 않는다.   연쇄복귀(Cascading Rollback)를 초래할 수 있다.   낙관적 병행제어(Optimistic Concurrency Control)     트랜잭션 수행 동안은 어떠한 검사도 하지 않고, 트랜잭션 종료 시에 일괄적으로 검사하는 기법이다.   트랜잭션 수행 동안 그 트랜잭션을 위해 유지되는 데이터 항목들의 지역 사본에 대해서만 갱신한다.   트랜잭션 종료 시에 동시성을 위한 트랜잭션 직렬화가 검증되면 일시에 DB로 반영한다.   다중 버전 병행제어(Multi-Version Concurrency Control)     여러 버전의 타임스탬프를 비교하여 스케줄상 직렬가능성이 보장되는 타임스탬프를 선택하는 기법이다.   동시 접근을 허용하는 데이터베이스에서 동시성을 제어하기 위해 사용하는 방법 중 하나이다.            Locking을 필요하지 않아서 일반적인 RDBMS보다 빠르게 작동한다.       미사용 데이터가 계속 쌓이게 되므로 주기적으로 삭제하는 시스템이 필요하다.       여러 버전의 데이터를 허용하기 때문에 버전이 충돌날 수 있으며, 이는 애플리케이션 영역에서 해결해야 한다.           Undo &amp; Redo  Undo  트랜잭션 로그를 이용하여 오류와 관련된 모든 변경을 취소하여 복구를 수행한다.  Redo  트랜잭션 로그를 이용하여 오류가 발생한 트랜잭션을 재실행하여 복구를 수행한다.   트랜잭션 회복 기법(Recovery)  로그 기반(Log-based) Recovery  지연 갱신(Deferred Update)     트랜잭션의 Partially Committed 상태에서는 변경 내용을 로그 파일에만 저장한다.   Commit 연산을 실행하기 전까진 데이터베이스에 기록하지 않는다.   중간에 장애가 생기더라도 데이터베이스에 기록되지 않았으므로 UNDO가 필요 없다.(미실행 된 로그 폐기)   즉시 갱신(Immediate Update)     트랜잭션 수행 도중에도 변경 내용을 즉시 데이터베이스에 기록한다.   Commit 연산을 실행하기 이전의 갱신은 원자성이 보장되지 않는 미완료 갱신이므로 장애 발생 시 UNDO가 필요하다.   검사점(Checkpoint) Recovery     장애 발생 시 Checkpoint 이전에 처리된 트랜잭션은 회복에서 제외하고, Checkpoint 이후에 처리된 트랜잭션은 회복 작업 수행한다.            Commit 연산이 완료된 이후 Checkpoint를 지나서 장애가 발생이 되면 Redo를 수행한다.       장애 발생 시점까지 Commit 연산이 수행되지 못한 경우 Undo를 수행한다.           미디어(Media) Recovery     디스크와 같은 비휘발성 저장 장치가 손상되는 장애가 발생할 상황을 대비한 회복 기법이다.   데이터베이스 내용을 백업, 미러링, RAID등을 통해 별도의 물리적 저장장치에 덤프를 수행한다.   미디어 장애 시 가장 최근 덤프로 복구하고 로그 파일을 참조해 덤프 이후의 작업까지 Redo를 수행한다.   Undo는 사용하지 않는다.   ARIES Recovery  REDO 중 Repeating history     붕괴가 발생했을 때의 데이터베이스 상태를 복구하기 위하여 붕괴 발생 이전에 수행했던 모든 연산을 다시 한번 수행한다.   붕괴가 발생했을 때 완료되지 않은 상태인 진행 트랜잭션은 UNDO를 수행한다.     UNDO 중 Logging       UNDO를 할 때에도 로깅을 함으로써 회복을 수행하는 도중에 실패하여 회복을 다시 시작할 때에 이미 완료된 UNDO 연산은 반복하지 않는다.  ","categories": ["Database"],
        "tags": ["Programming","Database","Transaction"],
        "url": "/database/transaction/",
        "teaser": null
      },{
        "title": "Codility Java MaxDoubleSliceSum",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int[] A) {     int result = 0;     // Init subsum arrays.     int[] firstSubSum = new int[A.length];     for (int idx = 1; idx &lt; A.length - 1; idx++) {       firstSubSum[idx] = Math.max(0, firstSubSum[idx - 1] + A[idx]);     }     int[] secondSubSum = new int[A.length];     for (int idx = A.length - 2; idx &gt;= 1; idx--) {       secondSubSum[idx] = Math.max(0, secondSubSum[idx + 1] + A[idx]);     }     // Calculate max(result) value.     for (int idx = 1; idx &lt; A.length - 1; idx++) {       int temp = firstSubSum[idx - 1] + secondSubSum[idx + 1];       if (temp &gt; result) {         result = temp;       }     }     return result;   } }   설명     세 인덱스 사잇 값들을 더한 값을 보관하기 2개의 배열 firstSubSum, secondSubSum을 생성하여 반복문을 통해 계산한다.            반복의 초기 값은 배열의 처음과 마지막 값을 빼고 계산해야 하기 때문에 0과 A.length - 1의 값은 제외한다.       firstSubSum 계산은 정방향으로, secondSubSum 계산은 역방향으로 누적합계를 구한다.           특정 인덱스가 주어지면, 해당 인덱스 기준으로 사잇 값의 누계를 합하여 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Maximum Slice Problem","Java"],
        "url": "/codility/MaxDoubleSliceSum/",
        "teaser": null
      },{
        "title": "Codility Java MaxProfit",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int[] A) {     int result = 0;     // The function should return 0 if it was impossible to gain any profit.     if (A.length &lt; 2) {       return 0;     }     int min = A[0];     for (int idx = 1; idx &lt; A.length; idx++) {       if (A[idx] &lt; min) {         min = A[idx];       } else {         int temp = A[idx] - min;         if (result &lt; temp) {           result = temp;         }       }     }     return result;   } }   설명     주어진 배열 A의 크기가 2보다 작으면 이익을 계산할 수 없으므로, 0을 주어진 문제의 결과로 반환한다.   초기 최소값을 주어진 배열 A의 0번째 인덱스로 초기화 하고, 최대 이익을 계산한다.            최대 이익은 현재 값과 최소 값의 차이가 가장 큰 지점을 찾아야 하므로, 만일 최소값을 저장한 변수 min보다 작은 값이 주어진 경우 min에 현재 값을 저장한다.       위의 경우가 아니면 현재 값을 최소값을 저장한 변수 min의 차이를 결과로 임시 저장을 한다.           반복이 끝나면 최대 이익을 계산한 result를 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Maximum Slice Problem","Java"],
        "url": "/codility/MaxProfit/",
        "teaser": null
      },{
        "title": "Codility Java MaxSliceSum",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int[] A) {     int result = A[0];     int sum = A[0];     for (int idx = 1; idx &lt; A.length; idx++) {       sum = Math.max(A[idx], sum + A[idx]);       if (result &lt; sum) {         result = sum;       }     }     return result;   } }   설명     최소 배열의 크기가 1개이므로, 결과를 저장하는 result는 주어진 배열 A의 0번째 인덱스의 값으로 초기화 한다.   1번의 이유로 반복은 1번째 인덱스부터 반복을 돌려 최대 값을 탐색한다.            해당 값이 이전의 최대 합보다 크다면, 해당 값부터 합계가 시작하도록 최대 합계를 저장하는 변수 sum에 저장한다.       만일 최대 합계를 저장하는 변수 sum이 결과를 저장하는 변수 result보다 크다면 result에 최대 합계로 저장한다.           반복이 끝나면 최대 합계를 저장한 result를 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Maximum Slice Problem","Java"],
        "url": "/codility/MaxSliceSum/",
        "teaser": null
      },{
        "title": "Codility Java CountFactors",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int N) {     if (N == 1) {       return N;     }     int result = 1;     for (int idx = 2; idx &lt; Math.sqrt(N); idx++) {       if (N % idx == 0) {         result++;       }     }     result = result * 2;     if (Math.sqrt(N) % 1 == 0) {       result++;     }     return result;   } }   설명     주어진 변수 N이 1일 경우 1개이므로, 그대로 주어진 문제의 결과로 반환한다.   결과값을 담는 변수 result는 1인 경우를 포함하여 1로 초기화 한다.   2번의 이유로 2부터 주어진 변수 N의 제곱근의 값만큼 반복한다.            주어진 변수 N이 만일 정수라면, N의 제곱근의 인수는 해당 값을 전후로 개수가 동일하게 된다.           3번의 이유로 반복이 끝나면 인수의 개수를 담은 result에 2를 곱하고, 만일 제곱근의 값이 정수라면 1을 더해서 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Prime And Composite Numbers","Java"],
        "url": "/codility/CountFactors/",
        "teaser": null
      },{
        "title": "Codility Java Flags",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int[] A) {     int result = 0;     boolean[] peaks = getPeaks(A);     int[] nextPeaks = getNextPeaks(peaks);     for (int idx = 1; idx &lt; A.length; idx++) {       if (isPossibleToSetOnPeak(nextPeaks, idx)) {         result = Math.max(result, idx);       }     }     return result;   }   private boolean[] getPeaks(int[] A) {     boolean[] peaks = new boolean[A.length];     for (int idx = 1; idx &lt; A.length - 1; idx++) {       if (A[idx] &gt; A[idx - 1] &amp;&amp; A[idx] &gt; A[idx + 1]) {         peaks[idx] = true;       }     }     return peaks;   }   private int[] getNextPeaks(boolean[] peaks) {     int[] nextPeaks = new int[peaks.length];     int nextPeak = -1;     for (int idx = nextPeaks.length - 1; idx &gt;= 0; idx--) {       if (peaks[idx]) {         nextPeak = idx;       }       nextPeaks[idx] = nextPeak;     }     return nextPeaks;   }   private boolean isPossibleToSetOnPeak(int[] nextPeaks, int point) {     int index = 0;     for (int idx = 0; idx &lt; point; idx++) {       if (index &gt;= nextPeaks.length || nextPeaks[index] &lt; 0) {         return false;       }       index = nextPeaks[index] + point;     }     return true;   } }   설명     우선 봉우리가 될 수 있는 위치를 먼저 계산하여 배열 peaks에 저장한다.            봉우리가 될 수 있는 기본 조건은 해당 높이가 전후 높이보다 커야 한다.           봉우리가 될 수 있는 위치를 기반으로 다음 봉우리의 위치를 계산하여 배열 nextPeaks에 저장한다.            봉우리가 될 수 있는 위치를 역순으로 반복을 수행하여 다음 봉우리의 위치를 임시 저장하고, 직전 봉우리에서 해당 위치를 사용하면 된다.           저장한 다음 봉우리의 위치를 기반으로 최종 봉우리의 개수를 계산하여 주어진 문제의 결과로 반환한다.            반복을 통해서 다음 봉우리가 존재하지 않거나, 다음 봉우리가 현재 위치보다 더 멀 경우 깃발을 꽃을 수 없다.           결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Prime And Composite Numbers","Java"],
        "url": "/codility/Flags/",
        "teaser": null
      },{
        "title": "Codility Java MinPerimeterRectangle",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int N) {     int result = Integer.MAX_VALUE;     for (int idx = 1; idx &lt;= Math.sqrt(N); idx++) {       if (N % idx == 0) {         int temp = 2 * (idx + (N / idx));         if (result &gt; temp) {           result = temp;         }       }     }     return result;   } }   설명     최소 사각형의 둘레를 구하기 위해 결과 값을 저장하는 변수 result를 최대 정수형으로 저장한다.   주어진 정수 N의 제곱근만큼 반복하여 사각형의 최소 둘레를 구한다.            정수의 제곱근 이하의 정수 중에서 나머지가 0이 되는 숫자가 해당 정수 이하의 인수이다.       정수를 정수 이하의 인수 중 하나로 나누면 해당 정수 이상의 인수가 된다.       위에서 구한 두 인수의 합의 2배가 정수의 둘레가 된다.           반복이 끝나면 최소 둘레를 저장하는 변수 result를 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Prime And Composite Numbers","Java"],
        "url": "/codility/MinPerimeterRectangle/",
        "teaser": null
      },{
        "title": "Codility Java Peaks",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  import java.util.List; import java.util.ArrayList;  class Solution {   public int solution(int[] A) {     List&lt;Integer&gt; peaks = getPeaks(A);     for (int idx = A.length; idx &gt;= 1; idx--) {       if (A.length % idx == 0) {         int blockSize = A.length / idx;         int blockCount = 0;         for (int peakIndex : peaks) {           if (peakIndex / blockSize == blockCount) {             blockCount++;           }         }         if (blockCount == idx) {           return blockCount;         }       }     }     // If A cannot be divided into some number of blocks, the function should return 0.     return 0;   }   private List&lt;Integer&gt; getPeaks(int[] A) {     List&lt;Integer&gt; peaks = new ArrayList&lt;&gt;();     for (int idx = 1; idx &lt; A.length - 1; idx++) {       if (A[idx - 1] &lt; A[idx] &amp;&amp; A[idx] &gt; A[idx + 1]) {         peaks.add(idx);       }     }     return peaks;   } }   설명     우선 봉우리가 될 수 있는 위치를 먼저 계산하여 변수 peaks에 저장한다.            봉우리가 될 수 있는 기본 조건은 해당 높이가 전후 높이보다 커야 한다.       특정 위치에 봉우리가 될 수 있는지가 중요하므로, 배열이 아니라 컬렉션으로 인덱스만 저장한다.           반복문을 통해서 봉우리를 포함하여 나눌 수 있는 최대 블록의 수를 구한다.            동일한 숫자의 블록으로 나눠야 하므로, 주어진 배열 A의 크기와 블록의 수를 표현하는 idx를 나눈 값이 정수인 경우에만 확인한다.       봉우리의 위치를 저장한 변수 peaks를 반복하여 동일한 숫자의 블록이 가능한지 계산을 하고, 가능한 블록의 숫자가 확인되면 해당 값을 주어진 문제의 결과로 반환한다.           반복이 끝나면 동일한 숫자의 블록으로 나눌 수 없다는 의미이므로, 0을 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Prime And Composite Numbers","Java"],
        "url": "/codility/Peaks/",
        "teaser": null
      },{
        "title": "Spring Transaction",
        "excerpt":"Spring Transaction1     Spring Transaction은 어노테이션 기반으로 수행이 된다.   Spring Bean2으로 정의 된 Method를 트랜잭션 관리를 하고자 할 때, @Transactional 어노테이션을 활용하면 프록시 패턴의 AOP3를 사용하여 원하는 수준의 트랜잭션 관리를 할 수 있다.    Isolation Level     트랜잭션에서 일관성이 없는 데이터를 다른 트랜잭션이 읽는 것을 허용하도록 하는 수준이다.   트랜잭션 경쟁(Race Conditiaon)에 대한 문제점  Dirty Read  커밋 전 데이터 조회와 롤백 후 데이터 조회의 데이터 불일치 문제이다.  Non-Repeatable Read  한 트랜잭션에서 데이터 변경 전과 후에 같은 조회 쿼리를 수행 시, 값이 변경되면서 결과가 달라지는 문제이다.  Phantom Read  한 트랜잭션에서 데이터 추가 전과 후에 같은 조회 쿼리를 수행 시, 값이 추가되면서 결과가 달라지는 문제이다.   종류  기본적으로 Isolation Level이 높아질수록 데이터를 점유하는 권한이 강화되고, 이로 인해서 수행 속도는 느려진다.  DEFAULT     사용하는 Database의 Isolation Level을 따라 적용 한다.     READ_UNCOMMITED(Level 0)       트랜잭션에서 처리 중인 혹은 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.   Dirty Read 문제가 발생한다.     READ_COMMITED(Level 1)       트랜잭션이 커밋되어 확정된 데이터만을 읽는 것을 허용한다.   Oracle, MSSQL 등의 일반적인 RDBMS에서 Default Isolation Level로 사용한다.   Dirty Read 문제를 방지하나, Non-Repeatable Read 문제가 발생한다.     REPREATABLE_READ(Level 2)       트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock을 걸어 다른 사용자들은 그 영역의 데이터에 대한 수정이 불가능하다.   MySQL와 같은 특정 RDBMS에서 Default Isolation Level로 사용한다.   Dirty Read, Non-Repeatable Read의 문제들을 방지하나, Phantom Read 문제가 발생한다.     SERIALIZABLE(Level 3)       트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock을 걸어 다른 사용자들은 그 영역의 데이터에 대한 수정 및 입력이 불가능하다.   Dirty Read, Non-Repeatable Read, Phantom Read의 문제들을 방지한다.   Propagation  트랜잭션을 시작하거나 기존 트랜잭션에 참여하는 방법을 결정하는 속성이다.   종류  REQUIRED  부모 트랜잭션 내에서 실행하며 부모 트랜잭션이 없을 경우 새로운 트랜잭션을 생성한다.  REQUIRES_NEW  부모 트랜잭션을 무시하고 무조건 새로운 트랜잭션을 생성한다.  SUPPPORT  부모 트랜잭션 내에서 실행하며 부모 트랜잭션이 없을 경우 Non-Transactionally로 실행한다.  MANDATORY  부모 트랜잭션 내에서 실행되며 부모 트랜잭션이 없을 경우 Exception이 발생한다.  NOT_SUPPORT  Non-Transactionally로 실행하며 부모 트랜잭션 내에서 실행될 경우 일시 정지한다,  NEVER  Non-Transactionally로 실행하며 부모 트랜잭션이 존재하면 Exception이 발생한다.  NESTED     부모 트랜잭션이 존재하면 부모 트랜잭션 내에서 실행되며, 별개로 커밋되거나 롤백될 수 있다.   부모 트랜잭션이 존재하지 않으면 RQUIRED와 동일하게 실행된다.   Readonly     해당 Transaction 내에서 데이터를 읽기만 할지를 결정한다.   Default : false   RollbackFor/NoRollbackFor  RollbackFor  특정 Exception을 추가 할 수 있으며, 해당 Exception이 발생하면 Rollback을 수행한다.  NoRollbackFor  특정 Exception을 추가 할 수 있으며, 해당 Exception이 발생하면 Rollback을 수행하지 않는다.   Timeout     지정한 시간 내에 해당 메서드 수행이 완료되지 않은 경우, Rollback을 수행한다.   Default : -1(No-Timeout)   Reference                 SpringDocs-Transaction &#8617;                  Blog-Bean &#8617;                  Blog-AOP &#8617;           ","categories": ["Spring"],
        "tags": ["Programming","Spring","Transactional"],
        "url": "/spring/transaction/",
        "teaser": null
      },{
        "title": "SOLID - Object-Oriented Design",
        "excerpt":"객체지향 설계(SOLID)     로버트 마틴이 2000년대 초반에 명명한 객체 지향 프로그래밍1 및 설계의 다섯 가지 기본 원칙을 마이클 페더스가 두문자어 기억술로 소개한 것이다.   프로그래머가 시간이 지나도 유지 보수와 확장이 쉬운 시스템을 만들고자 할 때 이 원칙들을 함께 적용할 수 있다.   SOLID 원칙들은 소프트웨어 작업에서 프로그래머가 소스 코드가 읽기 쉽고 확장하기 쉽게 될 때까지 소프트웨어 소스 코드를 리팩터링하여 코드 냄새를 제거하기 위해 적용할 수 있는 지침이다.   이 원칙들은 애자일 소프트웨어 개발과 적응적 소프트웨어 개발의 전반적 전략의 일부다.   단일 책임의 원칙(Single Responsibility Principle - SRP)     한 클래스는 하나의 책임만 가져야 한다.   public class Music {    private String name;   private String artist;   private LocalDateTime releaseDate;    public String getName() {     return name;   }    public void setName(String name) {     this.name = name;   }    public String getArtist() {     return artist;   }    public void setArtist(String artist) {     this.artist = artist;   }    public LocalDateTime getReleaseDate() {     return releaseDate;   }    public void setReleaseDate(LocalDateTime releaseDate) {     this.releaseDate = releaseDate;   }    // This code is violate the single responsibility principle.   public void playMusic() {     System.out.printf(\"The song(%s) is playing now.\", this.name);   }  }      Music 클래스에는 재생에 대한 책임이 같이 있으므로, 단일 책임의 원칙에 위배된다.   그래서 아래와 같이 음악 재생에 대한 클래스를 분리해야 하였다.   public class MusicPlayer {    public void playMusic(Music music) {     System.out.printf(\"The song(%s) is playing now.\", music.getName());   }  }   개방-폐쇄 원칙(Open-Closed Principle - OCP)     소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.   아래의 DataSource는 각 데이터베이스 종류에 따라 확장이 가능하다.   public class DataSource {    private String userName;   private String password;    public String getUserName() {     return userName;   }    public void setUserName(String userName) {     this.userName = userName;   }    public String getPassword() {     return password;   }    public void setPassword(String password) {     this.password = password;   }  } public class OracleDataSource extends DataSource {    private String jdbcUrl;    public String getJdbcUrl() {     return jdbcUrl;   }    public void setJdbcUrl(String jdbcUrl) {     this.jdbcUrl = jdbcUrl;   }  } public class MongodbDataSource extends DataSource {    private String host;   private int port;    public String getHost() {     return host;   }    public void setHost(String host) {     this.host = host;   }    public int getPort() {     return port;   }    public void setPort(int port) {     this.port = port;   }  }   리스코프 치환 원칙(Liskov Substitution Principle - LSP)     프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.   public class Item {    private int price;    public int getPrice() {     return price;   }    public void setPrice(int price) {     this.price = price;   }  } public class DiscountItem extends Item {    private double discountRate;    public double getDiscountRate() {     return discountRate;   }    public void setDiscountRate(double discountRate) {     this.discountRate = discountRate;     this.applyDiscountedPrice();   }    private void applyDiscountedPrice() {     super.setPrice((int)(super.getPrice() * (1 - this.discountRate)));   }  } public class WrongDiscountItem extends Item {    private double discountRate;    public double getDiscountRate() {     return discountRate;   }    public void setDiscountRate(double discountRate) {     this.discountRate = discountRate;   }    @Override   public void setPrice(int price) {     super.setPrice((int)(super.getPrice() * (1 - this.discountRate)));   }  }      위의 코드에서 Item과 WrongDiscountItem은 setPrice 메서드를 수행 시 결과 값이 달라지므로 LSP를 위반하며, Item과 DiscountItem은 LSP를 준수한다.   인터페이스 분리 원칙(Interface Segregation Principle - ISP)     클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다.   public interface WrongMultifunctionPrinter {    public void print();    public void copy();    public void scan();    public void fax();  }      WrongMultifunctionPrinter은 여러 기능들을 복합적으로 사용하고 있어 SRP와 ISP를 위반한다.   아래는 각 기능을 수행하는 책임 단위로 인터페이스를 분리하였다.   public interface MultifunctionPrinter extends Printer, CopyMachine, Scanner, Fax { } public interface Printer {    public void print();  } public interface CopyMachine {    public void copy();  } public interface Scanner {    public void scan();  } public interface Fax {    public void fax();  }   의존관계 역전 원칙(Dependency Inversion Principle - DIP)     고수준의 모듈(추상화)은 저수준의 모듈(구체화)에 의존해서는 안된다.   public class WrongComputer {    private final LCDMonitor monitor;   private final MechanicalKeyBoard keyboard;   private final GamingMouse mouse;    public WrongComputer() {     this.monitor = new LCDMonitor();     this.keyboard = new MechanicalKeyBoard();     this.mouse = new GamingMouse();   }  } public class Computer {    private final Monitor monitor;   private final KeyBoard keyboard;   private final Mouse mouse;    public Computer(Monitor monitor, KeyBoard keyboard, Mouse mouse) {     this.monitor = monitor;     this.keyboard = keyboard;     this.mouse = mouse;   }  } public interface Monitor { } public class LCDMonitor implements Monitor { } public interface KeyBoard { } public class MechanicalKeyBoard implements KeyBoard { } public interface Mouse { } public class GamingMouse implements Mouse { }      WrongComputer는 각 장비 간 결합으로 인해 종속되어있고, 테스트와 장비의 전환도 쉽지 않다.   각 장비 별 인터페이스를 구현하여 종속성을 분리하였으며 추상화를 통해 전환이 자유로워진다.   Reference                 Wiki-객체지향프로그래밍 &#8617;           ","categories": ["CS"],
        "tags": ["Programming","CS","Object"],
        "url": "/cs/solid/",
        "teaser": null
      },{
        "title": "Java Exception",
        "excerpt":"Error     런타임 시, 시스템 혹은 가상머신에서 비정상적인 상황으로 인해서 발생하는 심각한 수준의 오류이다.   개발자가 사전에 예측하여 처리할 수 없기 때문에, 오류에 대한 처리를 신경쓰지 않아도 된다.   대표적으로 StackOverflowError, OutOfMemoryError 등이 존재한다.   Exception     런타임 시, 개발자가 잘못 구현한 로직(코드) 혹은 사용자의 잘못된 조작에서 발생하는 오류이다.   개발자가 사전에 예측하여 처리할 수 있기 때문에, 예외를 구분하여 그에 맞는 대처를 할 수 있다.   대표적으로 IOException, NullPointerException 등이 존재한다.   Checked Exception &amp; Unchecked Exception                          Checked Exception       Unchecked Exception                       예외 처리       명시적 예외 처리       생략 가능                 확인 시점       컴파일 단계       런타임 단계                 예외 발생 시, 트랜잭션 처리       Rollback 수행       Rollback 미수행                 대표 예외       Exception 클래스의 자식(서브) 클래스       RuntimeException 클래스의 자식(서브) 클래스                         IOException       RuntimeException                         SQLException       NullPointerException                         InterruptedException       ClassCastException           예외 처리  방법  예외 복구     예외 상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 방법이다.   재시도를 통해 복구하는 방법이 있다.   예외처리 회피     예외 처리를 직접 담당하지 않고, 호출한 쪽으로 던져 회피하는 방법이다.   throws 키워드를 이용하여 예외를 전달하는 방법이 있다.   예외 전환     예외 회피와 비슷하게 메서드 밖으로 예외를 던지지만, 그냥 던지지 않고 적절한 예외로 전환해서 넘기는 방법이다.   사용자 정의 Exception을 생성하여 해당 클래스로 throws 키워드를 이용하여 전달하는 방법이 있다.   핸들링  try ~ catch block     try ~ catch 블록을 이용하여 예외가 발생하는 부분을 감싸고 예외가 발생하면, 적절한 방법으로 처리한다.   public class FileService {   public List&lt;String&gt; usingTryCatch() {     List&lt;String&gt; rows = new ArrayList&lt;&gt;();     // You must declare the InputStreamReader, BufferedReader class outside the try~catch syntax so it can be used and closed.     InputStreamReader inputStreamReader = new InputStreamReader(FileService.class.getClassLoader().getResourceAsStream(\"music.txt\"));     BufferedReader bufferedReader = null;     try {       bufferedReader = new BufferedReader(inputStreamReader);       String line;       while ((line = bufferedReader.readLine()) != null) {         rows.add(line);       }       return rows;     } catch (IOException e) {       e.printStackTrace();     } finally { // Must close the InputStreamReader, BufferedReader class.       try {         inputStreamReader.close();         bufferedReader.close();       } catch (IOException e) {         e.printStackTrace();       }     }     return null;   }   public List&lt;String&gt; usingTryWithResources() {     List&lt;String&gt; rows = new ArrayList&lt;&gt;();     try (InputStreamReader inputStreamReader = new InputStreamReader(FileService.class.getClassLoader().getResourceAsStream(\"music.txt\"));        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);) {       String line;       while ((line = bufferedReader.readLine()) != null) {         rows.add(line);       }       return rows;     } catch (IOException e) {       e.printStackTrace();     } // Even if you don't use the Finally keyword, the BufferedReader closes automatically.     return null;   } }     usingTryCatch 메서드의 경우 InputStreamReader와 BufferedReader를 종료하는 close() 메서드를 호출하기 위해서 finally 구문을 사용해야 하는데 scope의 문제로 try~catch 구문 밖에 변수를 선언하여야 사용하는 불편함이 존재한다.   usingTryWithResources 메서드의 경우 JDK 1.7부터 지원하는 try-with-resources 구문을 사용하여 소괄호 안에 정의한 변수들은 AutoCloseable 인터페이스를 상속받아 구현되어 있어, 구문 종료 이후 자동으로 리소스 관리를 해준다.   throws     메서드 내부에서 발생하는 Exception을 호출한 메서드로 전달한다.   예외처리 회피에 사용되는 방법이다.   public class FileService {   ...   public List&lt;String&gt; usingThrows() throws IOException { // Pass the IOException to the caller.     List&lt;String&gt; rows = new ArrayList&lt;&gt;();     try (InputStreamReader inputStreamReader = new InputStreamReader(FileService.class.getClassLoader().getResourceAsStream(\"music.txt\"));        BufferedReader bufferedReader = new BufferedReader(inputStreamReader)) {       String line;       while ((line = bufferedReader.readLine()) != null) {         rows.add(line);       }       return rows;     }   } }   throw     메서드 내부에서 발생하는 Exception을 적절한 Exception으로 전환하여 호출한 메서드로 전달한다.   예외 전환에 사용되는 방법이다.   public class FileException extends RuntimeException {   private static final long serialVersionUID = -7903712172617310856L;   public FileException(String message) {     super(message);   }   public FileException(Throwable cause) {     super(cause);   }   public FileException(String message, Throwable cause) {     super(message, cause);   } } public class FileService {   ...   public List&lt;String&gt; usingThrow() { // Pass the IOException to the caller.     List&lt;String&gt; rows = new ArrayList&lt;&gt;();     try (InputStreamReader inputStreamReader = new InputStreamReader(FileService.class.getClassLoader().getResourceAsStream(\"music.txt\"));        BufferedReader bufferedReader = new BufferedReader(inputStreamReader)) {       String line;       while ((line = bufferedReader.readLine()) != null) {         rows.add(line);       }       return rows;     } catch (IOException e) {       throw new FileException(\"An error occurred while loading the file.\", e);     }   } }   ※ Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Java"],
        "tags": ["Programming","Java","Exception"],
        "url": "/java/Exception/",
        "teaser": null
      },{
        "title": "Git",
        "excerpt":"Git     버전 관리 시스템(VCS - Version Control System) 중 하나이다.   GNU GPL(General Public License)v2 하에 배포되는 무료 소프트웨어이다.   서로 완전히 독립적 일 수있는 여러 개의 로컬 브랜치를 허용하고 권장한다.   CSV, Sebversion, Perforce 같은 시스템은 중앙 집중식 버전 관리(CVCS - Centralized VCS)이며, Git은 분산 버전 관리 시스템(DVCS - Distributed VCS)이다.            CVCS : Client-Sever Model로 하나의 중앙 서버가 존재하며, 중앙 서버에서 각자 맡은 부분의 작업을 수행 후 중앙 서버로 통합을 수행한다.       DVCS : Distributed Model로 하나의 중앙 서버와 각자의 컴퓨터 저장소에 사본을 관리하여 장애와 복원에 유리한 이점을 가지고 있으며, 각자 독립적으로 작업한 이후 변경사항의 통합을 수행한다.           SVN과 차이점     Git은 분산 버전 관리 시스템으로 로컬에서 사본을 관리하기 때문에 서버와 지속적으로 통신이 필요한 중앙 집중식 시스템(SVN)보다 속도가 빠르다.   Git은 각자의 컴퓨터 저장소에 사본을 관리하여 중앙 서버에만 저장되는 중앙 집중식 버전 관리 시스템인 SVN보다 장애와 복원에 유리하다.   Git은 저장소에 사본을 관리하며 버전을 관리하므로 인터넷이 연결되지 않아도 작업이 가능하고, 속도 또한 빠르다. 하지만 SVN은 중앙 서버에 지속적으로 접속해야 하므로 인터넷이 필요하며, 속도 또한 느리다.   특징1  비선형 개발을 위한 강력한 지원     신속한 분기 및 병합을 지원하며 비선형 개발 기록을 시각화 및 탐색하기 위한 특정 도구를 포함한다.   변경사항이 다양한 검토자에게 전달되기 때문에 작성된 것보다 더 자주 병합된다.   분기는 매우 가볍고 하나의 커밋에 대한 참조이며, 부모의 커밋으로 전체 분기 구조를 구성할 수 있습니다.   분산 개발     각 개발자에게 전체 개발 기록의 로컬 사본을 제공하고 변경 사항은 이러한 저장소에서 다른 저장소로 복사된다.   기존 시스템 및 프로토콜과의 호환성     저장소는 Hypertext Transfer Protocol(HTTP), File Transfer Protocol(FTP) 또는 일반 소켓이나 Secure Shell(SSH)를 통해 공유할 수 있다.   CVS 클라이언트와 연결 할 수 있는 CVS 서버 에뮬레이션을 제공하며, Subversion 저장소는 git-svn으로 연결 가능하다.   대규모 프로젝트의 효율적인 처리     로컬에 저장된 저장소에서 버전의 기록을 가져오는 것은 원격 서버에서 가져오는 것보다 100배 더 빠를 수 있다.2   이력의 암호화 인증     Git 이력는 특정 버전의 Commit ID가 해당 Commit에 이르는 전체 개발 이력에 따라 달라지는 방식으로 저장된다.   한 번 공유되면 알림없이 이전 버전을 변경할 수 없습니다.   플러그 형 병합 전략     툴킷 설계의 일부로, Git은 불완전한 병합의 잘 정의된 모델을 가지고 있으며, 병합을 완료하기 위한 다중 알고리즘을 가지고 있어 사용자에게 병합을 자동으로 완료할 수 없으며 수동 편집이 필요하다는 것을 알려준다.   쓰레기는 수거될 때까지 축적된다.     작업을 중단하거나 변경 내용을 백업하면 데이터베이스에 쓸모없는 매달려 있는 개체가 남게 된다.   Git은 리포지토리에 느슨한 개체가 충분히 생성되면 가비지 수집을 자동으로 수행한다.   가비지 컬렉션은 Git gc를 사용하여 명시적으로 호출할 수 있다.   GitHub  버전 관리 도구의 웹호스팅 서비스이다.   용어  Repository  저장소를 의미하며, 저장소는 히스토리, 태그, 브랜치에 따라 버전을 저장한다. 저장소를 통해 작업자가 변경한 모든 이력를 확인 할 수 있다.   Working Tree  Repository의 어느 한 시점을 바라보는 작업자의 시점이다.   Staging Area  Repository에 저장하기 전에 커밋을 준비하는 위치이다.   Commit  현재 변경 된 작업 상태를 점검을 마치면 확정하고, Repository에 저장하는 작업이다.   Head  현재 작업 중인 Branch이다.   Branch  가지 또는 분기점을 의미하며, 작업을 할 때 현재 상태를 복사하여 Branch에서 작업을 한 후에 Merge를 한다.   Merge  다른 Branch의 내용을 현재 Branch로 가져와 합치는 작업을 의미한다. 이력을 볼 때 뿌리가 여러개로 나눠져 있어서 보기가 어렵다.   Rebase  Merge와 합치는 작업은 비슷하지만, 베이스를 다시 정의함으로써 커밋 라인을 새롭게 정리하여 이력을 깔끔하게 볼 수 있게 해준다.   Index  변경 내역이 포함된 파일들의 모음이다.   Fetch  Remote Repository에서 Head의 정보를 가져와서 확인만 수행하는 것을 말한다.   명령어  git init  버전 관리를 수행하고자 하는 폴더에서 Git 로컬 저장소를 초기화한다.   git help  Git 관련 명령어의 도움말을 출력한다.   git status  Git 저장소의 상태(변경사항, 작업상태 등)를 출력한다.   git clone  Remote Repository를 Local Repository로 복사한다.   git add  파일을 추가하면, Git의 Repository Snapshot에 포함된다.   git commit  Git의 의미있는 수정 작업이 끝났을 때 완료를 알리는 작업이다.   git push  Commit된 작업에 대해서 Remote Repository에 반영하는 작업이다.   git pull  Remote Repository에 반영된 내용을 Local Repository에 반영하는 작업이다.   git log  Commit 내역을 확인할 때 사용하는 명령어이다.   git branch  새로운 Branch를 생성하여 독립적인 공간을 생성한다.   git checkout  독립된 작업 공간인 Branch를 자유롭게 이동할 수 있다.   git merge  Branch에서 작업을 끝내고, 모든 협업 개발자가 볼 수 있는 Master와 병합을 수행한다.   Reference                 Wiki-Git &#8617;                  Wiki-Order_Of_Magnitude &#8617;           ","categories": ["Devops"],
        "tags": ["Programming","Devops","Git"],
        "url": "/devops/git/",
        "teaser": null
      },{
        "title": "Git Workflow",
        "excerpt":"Git Flow    특징     브랜치 전략에 있어서 다른 워크플로우보다 엄격하다.   계획적인 릴리즈를 스케줄링 하는 대규모 프로젝트에 적합하다.   대다수의 소프트웨어 개발 프로젝트에는 불필요한 절차를 준수하게 하여, 생산성을 떨어뜨린다는 비판이 있다.     Branch      Master       릴리즈 할 때 사용하는 최종 단계의 메인 브랜치이다.   릴리즈 기록을 담고 있다.   태그를 통해 Versioning을 하게 된다.     Develop       다음 릴리즈 버전 개발을 진행하는 브랜치이다.   기능의 구현이 필요하면 Develop 브랜치에서 다시 브랜치를 내어 개발을 진행한다.   개발이 완료된 기능은 다시 Develop 브랜치로 병합된다.     Feature       기능 구현을 이유로 브랜치를 낼 때 사용하는 브랜치이다.   브랜치를 내는 기준은 한 기능 단위가 된다.     Release       현재 코드가 Master 브랜치로 병합될 수 있는지 테스트를 하고 테스트 과정에서 발생한 버그를 고치는 역할을 담당하는 브랜치이다.     Hotfix       검수를 진행했음에도 릴리즈된 Master 브랜치에서 버그가 발생한 경우 사용하는 브랜치이다.   버그를 수정한 이후 Master 브랜치와 Develop 브랜치에 병합해주고 브랜치를 닫는다.   GitHub Flow    특징     Master 브랜치가 릴리즈에 있어서 절대적인 역할을 한다.   Master 브랜치는 항상 최신 버전을 유지하며 Stable 한 상태를 담보한다.   Develop 브랜치가 존재하지 않고 Feature 브랜치는 Master 브랜치에서 생성되며, 병합된다.   병합을 할 때는 무조건 Pull Request를 하여 코드에 대한 검토를 받도록 한다.   Github flow는 CI가 필수적이다.   GitLab Flow    특징     너무 단순해진 Github flow에 보완하는 내용을 가미하여 제안된 방식이다.   Production 브랜치는 Git flow의 Master 브랜치 역할과 같다.   Gitlab flow의 Master 브랜치는 Production 브랜치로 병합한다.   Production 브랜치에서 릴리즈된 코드가 항상 프로젝트 최신버전 상태를 유지해야 할 필요가 없다는 이점이 있다.  ","categories": ["Devops"],
        "tags": ["Programming","Devops","Git","Workflow"],
        "url": "/devops/workflow/",
        "teaser": null
      },{
        "title": "Codility Java CountNonDivisible",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int[] solution(int[] A) {     int[] result = new int[A.length];     // Initializing array, element's range is [1, 2 * N]     int[] divisors = new int[(A.length * 2) + 1];     for (int idx = 0; idx &lt; A.length; idx++) {       divisors[A[idx]]++;     }     for (int idx1 = 0; idx1 &lt; A.length; idx1++) {       int count = 0;       for (int idx2 = 1; idx2 * idx2 &lt;= A[idx1]; idx2++) {         // Common factor         if (A[idx1] % idx2 == 0) {           count += divisors[idx2];           // Not square root           if (A[idx1] / idx2 != idx2) {             count += divisors[A[idx1] / idx2];           }         }       }       result[idx1] = A.length - count;     }     return result;   } }   설명     주어진 배열 A에 존재하는 정수의 숫자 별 개수를 변수 divisors 배열에 저장한다.            숫자는 1부터 2 * N까지 주어지므로, 0을 제외하면 배열의 크기는 (2 * N) + 1이어야 한다.           주어진 배열 A를 변수 divisors를 이용하여 인수가 아닌 숫자의 수를 구한다.            divisors 배열은 숫자 기준으로 저장되었으므로 0번째 인덱스는 무시한다.       최대 반복은 제곱근이 될 수 있는 idx2^2가 A[idx1] 이하가 될 때까지 한다.       반복 중 나머지가 0이 되면 인수가 되는 숫자이다.       만일 A[idx1] / idx2가 idx2가 되는 경우는 제곱근이 되는 경우이므로, 한 번을 더 더해준다.       마지막으로 A의 크기에서 인수가 되는 숫자의 개수를 빼면, 인수가 아닌 숫자의 개수가 나오므로 해당 결과를 변수 result에 저장한다.           반복이 끝나면 주어진 배열 A의 각 숫자의 인수가 아닌 숫자의 개수를 저장한 변수 result를 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Sieve Of Eratosthenes","Java"],
        "url": "/codility/CountNonDivisible/",
        "teaser": null
      },{
        "title": "Codility Java CountSemiprimes",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int[] solution(int N, int[] P, int[] Q) {     int[] result = new int[P.length];     int[] preSum = getPreSum(N);     for (int idx = 0; idx &lt; P.length; idx++) {       result[idx] = preSum[Q[idx]] - preSum[P[idx] - 1];     }     return result;   }    private int[] getPreSum(int N) {     int[] preSum = new int[N + 1];     int[] flags = getCheckNumbers(N);     int semiPrimeCount = 0;     for (int idx = 2; idx &lt;= N; idx++) {       if (flags[idx] == 2) {         semiPrimeCount++;       }       preSum[idx] = semiPrimeCount;     }     return preSum;   }    // 1: No prime, 2: SemiPrime   private int[] getCheckNumbers(int N) {     int[] flags = new int[N + 1];     flags[0] = 1;     flags[1] = 1;     for (int idx = 2; idx * idx &lt;= N; idx++) {       if (flags[idx] == 1) {         continue;       }       int multiple = idx * idx;       while (multiple &lt;= N) {         if (flags[idx] == 0 &amp;&amp; flags[multiple / idx] == 0) {           flags[multiple] = 2;         } else {           flags[multiple] = 1;         }         multiple = multiple + idx; // Next multiple number.       }     }     return flags;   } }   설명     0부터 주어진 숫자 N까지 SemiPrime인지 확인해서 배열로 저장한다.            초기값 0을 제외하고 1을 SemiPrime이 아닌 경우, 2를 SemiPrime인 경우로 설정한다.       0과 1의 경우는 SemiPrime이 아니니까 1로 초기화 시키고, 2부터 idx^2이 최대 정수 값인 주어진 정수 N 이하만큼 반복한다.       만일 해당 정수가 SemiPrime이 아닌 경우는 제외하고 계속 반복한다.       해당 정수와 제곱을 해당 값을 나눈 수가 SemiPrime이 아니라고 판단되지 않은 경우에 SemiPrime으로 설정하고, 그렇지 않은 경우 SemiPrime이 아닌 경우로 설정한다.                    제곱의 값을 나눈 특정 정수가 특정 배수인 경우는 특정 정수는 SemiPrime이 될 수 없다.           위에서 SemiPrime이 되는 경우가 아닌 경우는 모두 SemiPrime이 아닌 정수이다.                       idx^2 값에 idx값을 더하여 N이하까지 반복하여 사전 합계를 계산하여 변수 preSum 배열로 저장한다.                    idx 값을 더하면 idx 값의 배수로 계산이 반복 수행된다.                       반복문을 통해 변수 preSum 배열을 활용하여 주어진 배열 P와 Q의 값 사이의 SemiPrime 개수를 결과를 저장하는 result 배열로 저장한다.       반복이 끝나면 주어진 배열 P와 Q의 값 사이의 SemiPrime 개수를 저장한 변수 result를 주어진 문제의 결과로 반환한다.           결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Sieve Of Eratosthenes","Java"],
        "url": "/codility/CountSemiprimes/",
        "teaser": null
      },{
        "title": "Codility Java ChocolatesByNumbers",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int N, int M) {     return N / getGcd(M, N);   }   // Euclidean algorithm.   private int getGcd(int num1, int num2) {     if (num1 % num2 == 0) {       return num2;     } else {       return getGcd(num2, num1 % num2);     }   } }   설명     유클리드 호제법1을 사용하여 1에서 부터 주어진 정수 N까지 M을 이용해서 최대 공약수를 먼저 구한다.   주어진 정수 N을 유클리드 호제법을 통해 구한 최대 공약수로 나누어서 나온 먹을 초콜릿의 개수를 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.   Reference                 Wiki-Euclidean_Algorithm &#8617;           ","categories": ["Codility"],
        "tags": ["Programming","Codility","Euclidean Algorithm","Java"],
        "url": "/codility/ChocolatesByNumbers/",
        "teaser": null
      },{
        "title": "Codility Java CommonPrimeDivisors",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int[] A, int[] B) {     int result = 0;     for (int idx = 0; idx &lt; A.length; idx++) {       if (isSameDivisors(A[idx], B[idx])) {         result++;       }     }     return result;   }   // Check whether the sets of prime divisors of integers N and M are exactly the same.   private boolean isSameDivisors(int num1, int num2) {     int gcd = getGcd(num1, num2);     return getDivisor(gcd, num1) == 1 &amp;&amp; getDivisor(gcd, num2) == 1;   }   private int getDivisor(int gcd, int num) {     int quotient = 0;     while (quotient != 1) {       quotient = getGcd(num, gcd);       num /= quotient;     }     return num;   }   // Euclidean algorithm.   private int getGcd(int num1, int num2) {     if (num1 % num2 == 0) {       return num2;     } else {       return getGcd(num2, num1 % num2);     }   } }   설명     유클리드 호제법1을 사용하여 주어진 배열 A와 B 특정 idx에 속한 값의 최대 공약수를 구하여 변수 gcd로 임시 보관을 한다.   구한 최대 공약수를 이용하여 배열 A와 B 특정 idx에 속한 값의 소인수가 각각 1인지를 확인하여 true면 소수 집합이 동일한 값의 개수를 저장하는 변수 result를 증가 시키고, 그렇지 않으면 다음 idx에 속한 값으로 넘어간다.   반복이 끝나면 소수 집합이 동일한 값의 개수를 저장하는 변수 result를 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.   Reference                 Wiki-Euclidean_Algorithm &#8617;           ","categories": ["Codility"],
        "tags": ["Programming","Codility","Euclidean Algorithm","Java"],
        "url": "/codility/CommonPrimeDivisors/",
        "teaser": null
      },{
        "title": "Codility Java FibFrog",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  import java.util.Map; import java.util.HashMap; import java.util.List; import java.util.ArrayList; import java.util.Collections; import java.util.Queue; import java.util.LinkedList;  class Solution {   private final Map&lt;Integer, Integer&gt; fibonacciMap = new HashMap&lt;&gt;();   public int solution(int[] A) {     for (int idx = 0; getFibonacciData(idx) &lt;= A.length + 1; idx++) {       getFibonacciData(idx);     }     List&lt;Integer&gt; fibonacciList = new ArrayList&lt;&gt;(fibonacciMap.values());     Collections.reverse(fibonacciList);      Queue&lt;Point&gt; queue = new LinkedList&lt;&gt;();     boolean[] check = new boolean[A.length + 1];      queue.add(new Point(-1, 0)); // Starting point.      while (!queue.isEmpty()) {       Point currentPoint = queue.poll();       for (int fibonacci : fibonacciList) {         int next = currentPoint.getPosition() + fibonacci;         if (next == A.length) {           return currentPoint.getJump() + 1;         } else if (next &lt; A.length &amp;&amp; next &gt;= 0) {           if (A[next] == 1 &amp;&amp; !check[next]) {             check[next] = true;             queue.add(new Point(next, currentPoint.getJump() + 1));           }         }       }     }     return -1;   }   private int getFibonacciData(int num) {     if (num &lt;= 1) {       return num;     }     if (fibonacciMap.containsKey(num)) {       return fibonacciMap.get(num);     } else {       int temp = getFibonacciData(num - 2) + getFibonacciData(num - 1);       fibonacciMap.put(num, temp);       return temp;     }   } } class Point {   private int position;   private int jump;   public Point(int position, int jump) {     this.position = position;     this.jump = jump;   }   public int getPosition() {     return this.position;   }   public int getJump() {     return this.jump;   } }   설명     주어진 배열 A의 크기 + 1만큼 피보나치1 수열을 생성한다.            피보나치 수열은 0, 1, 1, 2, …로 시작하지만, 불필요한 0과 첫 1은 제외하고 구성한다.(개구리가 점프하는 거리가 중복되는 것은 의미가 없다.)           구한 피보나치 수열을 역순으로 변수 fibonacciList에 저장한다.            개구리가 점프하여 이동하는 거리를 정방향이 아니라 역방향으로 계산하기 위함이다.           개구리의 점프 횟수와 현재 위치를 저장하는 Point를 선입선출로 저장하는 변수 queue를 지정하여 초기 값을 넣어준다.            초기값은 위치가 -1이고, 점프 횟수는 0으로 설정한다.           개구리가 점프하여 닿을 수 있는 위치를 확인하는 변수 check 배열을 추가하여 점프를 통해 닿을 수 있는 위치를 저장해둔다.   변수 queue의 값이 없을 때 까지 반복하여 개구리가 점프하여 이동할 수 있는지를 검증한다.            역순으로 정렬한 피보나치 수열을 기반으로 반복하여, 개구리가 점프하여 이동할 수 있는지를 확인한다.                    만일 개구리의 현재 위치와 피보나치 수열 값의 합이 주어진 배열 A의 크기와 같으면 해당 거리만큼 개구리가 점프하면 강을 건널 수 있으므로, 기존 점프 횟수에 1을 증가하여 주어진 문제의 결과로 반환한다.           혹은 개구리의 현재 위치와 피보나치 수열 값의 합이 주어진 배열 A의 크기보다 작고 0보다 클 경우 아래의 세부적인 검증을 하고, 그렇지 않은 경우 다음 피보나치 값으로 위의 반복을 계속 수행한다.           해당 위치가 점프를 통해 밟을 수 있는 잎이 있으며 아직 밟지 않았다면, 해당 위치를 변수 check 배열에 true로, 새로운 Point를 생성하여 변수 queue에 추가한 후 해당 위치부터 맨 위의 반복을 다시 수행한다.                           만일 반복문이 정상적으로 종료되면, 개구리가 강 반대편에 도달 할 수 없다는 의미이므로 -1을 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.   Reference                 Wiki-Fibonacci_Numbers &#8617;           ","categories": ["Codility"],
        "tags": ["Programming","Codility","Fibonacci Numbers","Java"],
        "url": "/codility/FibFrog/",
        "teaser": null
      },{
        "title": "Codility Java Ladder",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {     public int[] solution(int[] A, int[] B) {         int[] result = new int[A.length];         int[] fibonacci = getFibonacci(A.length);         for (int idx = 0; idx &lt; A.length; idx++) {             result[idx] = fibonacci[A[idx]] % (1 &lt;&lt; B[idx]);         }         return result;     }     private int[] getFibonacci(int length) {         int[] fibonacci = new int[length + 2];         fibonacci[1] = 1;         fibonacci[2] = 2;         for (int idx = 3; idx &lt;= length; idx++) {             fibonacci[idx] = (fibonacci[idx - 2] + fibonacci[idx - 1]) % (1 &lt;&lt; 30);         }         return fibonacci;     } }   설명     주어진 배열 A의 크기 + 2만큼 피보나치1 수열을 생성한다.            피보나치 수열의 초기화와       피보나치 수열은 0, 1, 1, 2, …로 시작하지만, 불필요한 중복되는 1은 제외하고 구성한다.       단, 1 « 30(= 2 ^ 30)을 사용하여 오버플로를 방지하면서 결과 값이 동일해지는 역할을 수행한다.           주어진 배열 A의 크기만큼 반복하여 구한 피보나치 수열의 결과를 활용해 A[idx] 길이의 사다리를 B[idx] 횟수로 올라갈 수 있는 방법의 수를 구하여 결과를 저장하는 변수 result[idx]에 넣는다.            피보나치 값의 A[idx]번째 있는 값은 진행 가능한 횟수를 의미하며, 해당 값을 1 « Bidx로 나눈 나머지 값이 실제 사다리 꼭대기에 오르는 방법의 수이다.           반복이 끝나면 주어진 배열 A와 B의 각 요소 별 사다리 꼭대기에 오르는 방법의 수를 저장한 변수 result를 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.   Reference                 Wiki-Fibonacci_Numbers &#8617;           ","categories": ["Codility"],
        "tags": ["Programming","Codility","Fibonacci Numbers","Java"],
        "url": "/codility/Ladder/",
        "teaser": null
      },{
        "title": "Behavior-Driven Development(BDD)",
        "excerpt":"Behavior-Driven Development(BDD)1           TDD에서 한 발 더 나아가 테스트 케이스 자체가 요구사양이 되도록 하는 개발 방식이다.   소프트웨어 개발은 ​​사용자의 요구를 충족한다.   업무상 중요한 기능이 먼저 제공된다.   모든 당사자는 프로젝트에 대한 공통의 이해를 가지고 있으며, 의사 소통에 참여할 수 있다.   공통 언어는 개발자와 비개발자를 포함한 모든 사람이 프로젝트의 진행 상황을 완벽히 파악할 수 있도록한다.   소프트웨어 설계는 기존 요구 사항을 충족하고 향후 비즈니스 요구 사항을 지원할 수 있도록 설계한다.   코드의 품질 개선으로 유지보수 비용을 절감하고 프로젝트 리스크를 최소화 한다.   시나리오 패턴     Feature : 테스트에 대상의 기능/책임을 명시한다.   Scenario : 테스트 목적에 대한 상황을 설명한다.   Given : 시나리오 진행에 필요한 값을 설정한다.   When : 시나리오를 진행하는데 필요한 조건을 명시한다.   Then : 시나리오를 완료했을 때 보장해야 하는 결과를 명시한다.   테스트의 자동화     테스트를 자동화 함으로써, (Continuous integration)CI 단계에서 발생이 가능한 오류와 버그를 먼저 진단하여 안정적인 서비스 운영에 기여한다.   자동화 도구     Cucumber2 : Behavior-Driven Development(BDD) 기반의 테스트 프레임워크이며 Gherkin이라는 문법을 사용한다.   JBehave3 : Behavior-Driven Development(BDD)를 위한 테스트 프레임워크이다.   BeanSpec4 : Behavior-Driven Development(BDD)를 위한 Java 솔루션으로, 선언적 &amp; 서술적 스타일로 구성 요소의 동작을 지정, 확인 및 요약한다.   Reference                 Wiki-Behavior-Driven_Development &#8617;                  Cucumber-Home &#8617;                  JBehave-Home &#8617;                  BeanSpec-SourceForce &#8617;           ","categories": ["CS"],
        "tags": ["Programming","CS","Methodologies"],
        "url": "/cs/bdd/",
        "teaser": null
      },{
        "title": "Domain-Driven Development(DDD)",
        "excerpt":"Domain-Driven Development(DDD)1     보편적인(유비쿼터스) 언어를 사용한다.   분석 작업과 설계 그리고 구현까지 통일된 방식으로 커뮤니케이션이 가능하다.   개념  Context     의미를 결정하는 단어나 문장이 나타나는 설정이다.   Domain     지식, 영향력 또는 활동의 영역이다.   사용자가 프로그램을 적용하는 주제 영역은 소프트웨어의 도메인이다.   Model     도메인의 선택된 측면을 설명하고 해당 도메인과 관련된 문제를 해결하는 데 사용할 수 있는 추상화 시스템이다.   Ubiquitous Language     도메인 모델을 중심으로 구성되고 모든 팀 구성원이 팀의 모든 활동을 소프트웨어와 연결하는 데 사용하는 언어이다.   단점     모델을 순수하고 유용한 언어 구조로 유지하기 위해, 팀은 일반적으로 도메인 모델 내에서 많은 양의 격리 및 캡슐화를 구현해야한다.            도메인 중심 설계에 기초한 시스템은 상대적으로 높은 비용을 들일 수 있다.       도메인 중심 설계는 유지 보수성과 같은 많은 기술적 이점을 제공하지만, 마이크로소프트는 모델과 언어 프로세스가 복잡한 정보의 통신과 도메인에 대한 공통된 이해를 형성하는 데 분명한 이점을 제공하는 복잡한 도메인에만 적용할 것을 권고한다.           Strategic Domain-Driven Development(DDD)     모델 무결성을 유지하고 도메인 모델을 추출하며 여러 모델로 작업하기 위한 일련의 원칙이다.   Bounded Context     모델이 적용되는 컨텍스트를 명시적으로 정의한다.   팀 구성, 애플리케이션의 특정 부분에서의 사용 및 코드베이스, 데이터베이스 스키마와 같은 물리적 표시 측면에서 경계를 명시적으로 설정한다.   Continuous Integration     자동화된 테스트로 모든 코드와 기타 구현 아티팩트를 자주 병합하여 조각화에 신속하게 플래그를 지정하는 프로세스를 구축한다.   개념이 다른 사람들의 머릿속에서 진화함에 따라 모델의 공유된 관점을 강조하기 위해 유비쿼터스 언어를 끊임없이 연습한다.   Context Map     프로젝트에서 실행 중인 각 모델을 식별하고 제한 컨텍스트를 정의한다.   여기에는 비객체 지향 서브시스템의 암시적 모델이 포함된다.   각 경계 컨텍스트의 이름을 지정하고, 이름을 유비쿼터스 언어의 일부로 지정한다.   모델 간의 접촉 지점을 설명하고, 모든 커뮤니케이션을 위한 명시적 번역의 개요를 설명하고, 공유를 강조한다.   Artifacts  Entity     객체는 속성으로 정의되지 않고 스레드의 연속성과 정체성에 의해 정의된다.   Value object     속성을 포함하지만 개념적 정체성이 없는 객체이다. 불변으로 취급되어야 한다.   Aggregate     Aggregate Root라고도하는 Root Entity로 함께 바인딩 된 객체의 Collection이다.   Aggregate Root는 외부 객체가 해당 멤버에 대한 참조를 보유하지 못하도록 차단하여 집계 내에서 수행되는 변경의 일관성을 보장한다.   Domain Event     이벤트를 정의하는 Domain 객체이다.   Domain 이벤트는 Domain 전문가가 관심을 갖는 이벤트이다.   Service     작업이 개념적으로 어떤 객체에도 속하지 않는 경우, 서비스에서 이러한 작업을 구현할 수 있다.   Repository     Domain 객체를 검색하는 방법은 대체 저장소 구현을 쉽게 교환할 수 있도록 특수 저장소 객체에 위임해야 한다.   Factory     도메인 개체를 만드는 방법은 대체 구현이 쉽게 교환 될 수 있도록 특수한 Factory 객체에 위임해야한다.   Reference                 Wiki_Domain-Driven_Design &#8617;           ","categories": ["CS"],
        "tags": ["Programming","CS","Methodologies"],
        "url": "/cs/ddd/",
        "teaser": null
      },{
        "title": "Test-Driven Development(TDD)",
        "excerpt":"Test-Driven Development(TDD)1     매우 짧은 개발 서클의 반복을 갖는 소프트웨어 개발 프로세스이다.   먼저 테스트를 먼저 작성하고 실제 코드를 작성하기 때문에 테스트 되지 않는 코드가 없어진다. 즉, 모든 코드가 테스트되기 때문에 버그의 발생 가능성이 줄어든다.   테스트가 요구사항을 분명하게 드러나게 해주는 효과가 있고, 테스트에 적합하게 구현하다보면 프로그램의 디자인이 단순화되는 경향이 있다.   테스트가 잘 작성되어 있으면 프로그램의 변경 작업을 할 때 사이드 이펙트가 발생하는 것을 쉽게 확인 가능하므로 변경 작업을 쉽게 할 수 있게 된다. 즉, 개발 과정의 유연성이 높아지고 생산성이 향상된다.   과정           개발자는 먼저 요구사항을 검증하는 자동화된 테스트 케이스를 작성한다.   그런 후에, 그 테스트 케이스를 통과하기 위한 최소한의 코드를 생성한다.   마지막으로 작성한 코드를 표준에 맞도록 리팩토링한다.   테스트의 자동화     테스트를 자동화 함으로써, (Continuous integration)CI 단계에서 발생이 가능한 오류와 버그를 먼저 진단하여 안정적인 서비스 운영에 기여한다.   자동화 도구     JUnit2 : Java 및 JVM을 위한 테스트 프레임워크이다.   Selenium3 : 브라우저 기반의 웹 어플리케이션 테스트 자동화 도구이다.   Mockito4 : Java UnitTest를 위한 테스트 프레임워크이다.   Spock5 : Java 및 Groovy 애플리케이션을 위한 테스트 프레임워크이다.   Reference                 Wiki-테스트_주도_개발 &#8617;                  JUnit-Home &#8617;                  Selenium-Home &#8617;                  Mokito-Home &#8617;                  Spock-Home &#8617;           ","categories": ["CS"],
        "tags": ["Programming","CS","Methodologies"],
        "url": "/cs/tdd/",
        "teaser": null
      },{
        "title": "Design Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   필수 요소   Context     문제가 발생하는 여러 상황 기술한다.   Problem     패턴이 적용되어 해결될 필요가 있는 디자인 이슈들을 기술한다.   Solution     요소들 사이의 관계, 책임, 협력등을 기술(템플릿)한다.   GoF(Gang of Fours) 디자인 패턴 종류     GoF(Gang of Fout)라 불리는 인에리히 감마(Erich Gamma), 리차드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시디스(John Vissides) 네 명의 컴퓨터 과학 연구자들이 정의하고 분류한 디자인 패턴이다.   Creational Patterns, 생성 패턴     객체가 생성되는 방식을 중시하는 패턴이다.   객체의 생성과 조합을 캡슐화하여 객체가 생성 혹은 수정되어도 전체 프로그램 구조에 영향을 받지 않도록 유연성을 제공한다.   Singleton     전역 변수를 사용하지 않고 객체를 하나만 생성도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴이다.   Factory Method     객체 생성을 서브 클래스로 분리해 처리하도록 캡슐화하는 패턴이다.   Abstract Factory     구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만들 수 있는 인터페이스를 제공하는 패턴이다.   Builder     복잡한 객체를 생성하는 방법을 정의하는 클래스와 표현하는 방법을 정의하는 클래스를 별도로 분리하여, 서로 다른 표현이라도 이를 생성할 수 있는 동일한 절차를 제공하는 패턴이다.   Prototype     Original 객체를 새로운 객체에 복사하여 우리의 필요에 따라 수정하는 메커니즘을 제공하는 패턴이다.   Java Cloneable 클래스의 clone() 메서드가 대표적인 예이다.   Structural Patterns     클래스와 객체를 더 큰 결과물로 합칠 수 있는 구조로 설계하는 패턴이다.   서로 다른 인터페이스를 지닌 여러 개의 객체를 조합하여 단일 인터페이스를 제공하거나, 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.   Composite     여러 개의 객체들로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 해주는 패턴이다.   Decorator     객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주는 패턴이다.   Adaptor     클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 변환시키는 패턴이다.   Proxy     어떤 다른 객체로 접근하는 것을 통제하기 위해서 그 객체의 대리자나 자리표시자의 역할을 하는 패턴이다.   Flyweight     공유를 통하여 대량의 객체들을 효과적으로 지원하는 패턴이다.   Facade     서브시스템을 더 쉽게 사용할 수 있도록 높은 수준의 인터페이스를 정의하고 제공하는 패턴이다.   Bridge     추상화를 구현으로부터 분리하여 각각 독립적으로 변화할 수 있도록 하는 패턴이다.   Filter     다양한 기준을 사용하여 객체 집합을 필터링하고 논리적 작업을 통해 분리된 방식으로 연결할 수 있도록하는 패턴이다.   Behavioral Patterns     객체간의 상호작용과 책임을 중시하는 패턴이다.   한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하면서 객체 사이의 결합도를 최소화하는 것에 중점을 두는 패턴이다.   Observer     한 객체의 상태 변화에 따라 다른 객체의 상태도 연동되도록 일대다 객체 의존 관계를 구성하는 패턴이다.   State     객체의 상태에 따라 객체의 행위 내용을 변경하게 해주는 패턴이다.   Strategy     행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴이다.   Command     실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴이다.   Template Method     어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화하여 전체를 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 작업을 바꾸는 패턴이다.   Interpreter     언어 문법이나 표현을 평가할 수 있는 방법을 제공하는 패턴이다.   Mediator     서로 관련된 객체 사이의 복잡한 통신과 제어를 한 곳으로 집중시키는 패턴이다.   Memento     객체를 이전의 상태로 복구시켜야 하는 경우 사용하는 패턴이다.   Chain of Responsibility     한 요청을 두 개 이상의 객체에서 처리하고 싶을 때 사용하는 패턴이다.   Iterator     컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있는 방법을 제공하는 패턴이다.   Visitor     알고리즘을 객체 구조에서 분리시키는 패턴이다.   Other     GoF 디자인 패턴 외 Java EE 등에서 사용되거나, MVC 등의 범용적인 패턴들이다.   Business Delegate     Java EE 디자인 패턴이다.   프레젠테이션 계층과 비즈니스 계층을 분리하여 결합을 줄이고 서비스의 세부 구현 정보를 캡슐화 하는데 사용된다.   기본적으로 프레젠테이션 계층 코드에서 비즈니스 계층 코드에 대한 통신 또는 원격 조회 기능을 줄이는 데 사용된다.   Composite Entity     EJB Persistence Mechanism에서 사용되는 디자인 패턴이다.   Composite Entity는 객체의 그래프를 나타내는 EJB Entity Bean이다.   Composite Entity가 업데이트되면 내부적으로 종속된 Bean이 EJB Entity에 의해 관리되어 자동으로 업데이트된다.   Data Access Object     DAO 패턴이라고도 불린다.   API 또는 작업에 액세스하는 하위 수준의 데이터를 상위 수준의 비즈니스 서비스에서 분리하는 데 사용된다.   Front Controller     모든 요청이 단일 핸들러로 처리되도록 중앙 집중식 요청 처리 메커니즘을 제공하는 데 사용된다.   이 핸들러는 요청의 인증/권한/로깅 또는 추적을 수행한 다음 요청을 해당 핸들러로 전달할 수 있다.   Intercepting Filter     응용 프로그램의 Request나 Response의 전/후 처리를 하고자 할 때 사용된다.   실제 대상 응용 프로그램에 요청을 전달하기 전에 필터가 정의되고 요청에 적용된다.   필터는 인증/승인/로그인 또는 요청의 추적 작업을 수행한 다음 해당 처리기에 요청을 전달할 수 있다.   Model-View-Controller(MVC)     사용자 인터페이스로부터 비즈니스 로직을 분리하여 애플리케이션의 시각적 요소나 그 이면에서 실행되는 비즈니스 로직을 서로 영향 없이 쉽게 고칠 수 있는 애플리케이션을 만들 기 위해 사용한다.   Null Object     NULL Object 인스턴스의 검사를 대체하여 사용 및 동작을 설명한다.   Service Locator     JNDI 조회를 사용하여 다양한 서비스를 찾고자 할 때 사용된다.   서비스에 대한 JNDI를 찾는 데 드는 높은 비용을 고려하여 캐싱 기술을 사용한다.   Service Locator를 통한 추가 조회 또는 동일한 서비스가 캐쉬에서 수행되므로 애플리케이션 성능이 크게 향상된다.   Transfer Object(../transferObject){:target=”_blank”}     여러 속성을 가진 데이터를 Client에서 Server로 한 번에 전달할 때 사용된다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","DesignPattern"],
        "url": "/designpattern/designpattern/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Singleton Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Creational Patterns, 생성 패턴     객체가 생성되는 방식을 중시하는 패턴이다.   객체의 생성과 조합을 캡슐화하여 객체가 생성 혹은 수정되어도 전체 프로그램 구조에 영향을 받지 않도록 유연성을 제공한다.   Singleton Pattern     전역 변수를 사용하지 않고 객체를 하나만 생성도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴이다.   Example  public class SingleObject {    // Create an object of SingleObject.   private static SingleObject instance = new SingleObject();    // Make the constructor private so that this class cannot be instantiated.   private SingleObject() {   }    // Get the only object available.   public static SingleObject getInstance() {     return instance;   }    public void showMessage() {     System.out.println(\"Hello World!\");   }  }      private 생성자만 구현함으로써, 외부에서 해당 객체를 생성하지 못하도록 하였다.   하나의 객체를 생성하여 getter method를 제공함으로써, 해당 객체를 다른 객체에서 참조 가능하도록 하였다.   public class SingletonPatternMain {    public static void main(String[] args) {     // Illegal construct.     // Compile Time Error: The constructor SingleObject() is not visible.     // SingleObject object = new SingleObject();     // Get the only object available.     SingleObject object = SingleObject.getInstance();     // Show the message.     object.showMessage();   }  }      Singleton 객체를 생성자를 통해 생성하고자 하면, Compile 단계에서 오류가 발생한다.   Singleton 객체의 getter 메서드를 이용하여 내부 메서드(기능)를 사용하면 정상적으로 수행이 된다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Creational Patterns"],
        "url": "/designpattern/singleton/",
        "teaser": null
      },{
        "title": "Java Garbage Collection",
        "excerpt":"Garbage Collection       Java 프로그램이 자동 메모리 관리를 수행하는 프로세스이다.   Java 프로그램은 Java Virtual Machine 또는 간단히 JVM에서 실행할 수있는 바이트 코드로 컴파일된다.   Java 프로그램이 JVM에서 실행될 때 프로그램 전용 메모리의 일부인 힙에 개체가 생성된다.   결국 일부 개체는 더 이상 필요하지 않는다. 가비지 수집기는 이러한 사용하지 않는 개체를 찾아 삭제하여 메모리를 확보한다.   용어  Stop-The-World(STW)     GC을 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것이다.   Stop-The-World가 발생하면 GC를 실행하는 스레드를 제외한 나머지 스레드들은 모두 작업을 멈추게된다.     Metaspace       JAVA 7에서 Heap Memory 영역 중 하나로 클래스 메타데이터를 저장하는 영역이었던 Permanent Generation이 JAVA 8에서 Metaspace로 대체되었다.     Young Generation       새롭게 생성한 객체가 Heap Memory에서 위치하는 공간이다.   Minor GC가 발생하면 Unreachable Object는 삭제되고, 지속적으로 참조되고 있는 객체들인 Surviving Object들은 Old Generation으로 이동한다.     Old Generation       지속적으로 참조되고 있는 객체들이 Young 영역에서 살아남아 이동되는 공간이다.   Old Generation이 가득차게되면 Major GC가 발생한다.     Minor GC       Young Generation에서 발생하는 GC이다.     Major GC       Old Generation에서 발생하는 GC이다.   Process1     새로운 객체가 생성되면 Eden 영역에 할당이 된다.   Eden 영역이 가득차면 Minor GC가 발생하여, Reachable 오브젝트들은 Survival 0 영역으로 이동하고 Eden 영역은 정리된다.   다음 Minor GC가 발생하면 2번 과정이 반복하고, Survival 0에 있는 Reachable 오브젝트들은 Survival 1으로 age 값이 증가하여 옮겨지고 Eden 영역과 Survival 0 영역이 정리된다.   다음 Minor GC가 발생하면 3번 과정이 반복되고, Survival 1에서 살아남은 오브젝트들은 Survival 0로 이동하면서 Eden 영역과 Survival 1 영역이 정리된다.   2 ~ 4번 과정이 지속적으로 반복되면서 Young Generation에서 계속 살아남아 age값이 특정 값 이상이 되면 Old Generation으로 이동한다. Promotion이라고 불리는 단계이다.   Minor GC가 계속 반복되면 Promotion이 꾸준히 발생하고, Old Generation이 가득차면 Major GC가 발생하게 된다. 이 때 Stop-The-World(STW)가 발생한다.   종류      Serial GC     Old 영역에서 Mark-Sweep-Compact라는 알고리즘을 사용한다.            Mark : Old 영역에 살아 있는 객체를 식별한다.       Sweep : 힙(heap)의 앞 부분부터 확인하여 살아 있는 것만 남긴다.       Compaction : 힙의 가장 앞 부분부터 채워서 객체가 존재하는 부분과 객체가 없는 부분으로 나눈다           적은 메모리와 CPU 코어 개수가 적을 경우 적합한 방식이다.   -XX:+UseSerialGC JVM 옵션을 통해서 사용 가능하다.   Parallel(Throughput) GC     Serial GC와 동작 방식은 같지만, GC를 처리하는 쓰레드가 여러 개여서 Serial GC보다 빠르게 수행된다.   메모리가 충분하고 코어의 개수가 많을 때 유리하다.   -XX:+UseParallelGC JVM 옵션을 통해서 사용 가능하다.   Parallel Old GC     Old 영역에서 Mark-Summary-Compaction이라는 알고리즘을 사용하여 Parallel GC와는 다르게 수행된다.            Summary : 앞서 GC를 수행한 영역에 대해서 별도로 살아있는 객체를 식별한다.           -XX:+UseParallelOldGC JVM 옵션을 통해서 사용 가능하다.   CMS(Low Latency) GC       Serial, Parallel, Parallel Old GC와는 다른 방식으로 수행된다.            Initial Mark : 클래스 로더에서 가장 가까운 객체 중 살아 있는 객체만 찾아 멈추는 시간이 짧다.       Concurrent Mark : 다른 스레드가 실행 중인 상태에서 동시에 살아있다고 확인한 객체에서 참조하고 있는 객체들을 순차적으로 확인한다.       Remark : Concurrent Mark 단계에서 새로 추가되거나 참조가 끊긴 객체를 확인한다.       Concurrent Sweep : 다른 스레드가 실행되고 있는 상태에서 동시에 Garbage를 정리하는 작업을 실행한다.           Stop-The-World 시간이 짧고, 다른 스레드가 실행되고 있는 상황에서 진행된다.   메모리와 CPU 사용이 더 많고, Compaction 단계가 제공되지 않는다.   -XX:+UseConcMarkSweepGC JVM 옵션을 통해서 사용 가능하다.   G1(Garbage First) GC2       전체 힙 메모리를 Region이라는 특정한 영역으로 나누어 역할(Eden, Survivor, Old)이 동적으로 부여되는 상태이다.            Initial Mark : 애플리케이션을 멈추고, Old Region에 존재하는 객체들이 참조하는 Survivor Region을 찾는다.       Root Region Scan : Initial Mark에서 찾은 Survivor 객체들에 대한 스캔을 한다.       Concurrent Mark : 전체 Heap Memory의 스캔을 하고, GC 대상 객체가 발견되지 않은 Region은 이후 단계에서 제외한다.       Remark : 애플리케이션을 멈추고, 최종적으로 GC 대상에서 제외할 객체를 식별한다       Cleanup : 애플리케이션을 멈추고, 살아있는 객체가 가장 적은 Region에 대한 미사용 객체를 제거한다       Copy : GC 대상의 Region이었지만, Cleanup 과정에서 완전히 비워지지 않은 Region의 살아남은 객체들을 새로운 Region(Available/Unused) Region에복사하여 Compaction을 수행한다. 살아있는 객체가 아주 적은 Old 영역에 대해 [GC pause(mixed)] 를 로그로 표시하고, Young GC가 이루어질 때 수집되도록 한다.           큰 힙 메모리에서 짧은 GC 시간을 보장한다.   JAVA 9부터는 Default로 적용되며, -XX:+UseG1GC JVM 옵션을 통해서 사용 가능하다.   ZGC       JAVA 11에서 실험적 기능으로 추가된 확장 가능한 낮은 지연 가비지 수집기3이다.   일시 중지 시간은 10ms를 초과하지 않는다.   일시 중지 시간은 힙 또는 라이브 세트 크기에 따라 증가하지 않는다.   수백 메가 바이트에서 수 테라 바이트 크기의 힙을 처리한다.   Linux/x64에서만 JVM 옵션(-XX:+UnlockExperimentalVMOptions, -XX:+UseZGC)을 추가하여 사용할 수 있다.   압축 된 oops, 압축 된 클래스 포인트 사용, 클래스 언로드는 지원하지 않으며, JVM 옵션을 추가하여도 효과가 없다.   Shenandoah GC       JAVA 12에서 추가된 Shenandoah4는 실행중인 Java 프로그램과 동시에 더 많은 Garbage Collection을 수행하여 Garbage Collector의 일시 중지 시간을 줄이는 Garbage Collector이다.            Init Mark : 동시 표시를 위해 Heap Memory 및 애플리케이션 스레드를 준비한 다음 첫 번째 일시 중지를 하여 Root Set를 스캔한다.       Concurrent Marking : Heap Memory 위에서 도달 가능한 객체를 추적한다.       Final Mark : 보류중인 모든 표시/업데이트 대기열을 비우고 두 번째 일시 중지를 하여 Root Set을 다시 검색하여 동시 표시를 완료한다.       Concurrent Cleanup : 즉시 Garbage 영역, 즉 동시 표시 이후에 감지 된 살아있는 객체가 없는 영역을 회수한다.       Concurrent Evacuation : 컬렉션 집합에서 다른 지역으로 개체를 복사하는 역할을 수행한다. 이는 다른 GC와는 차별적인 단계이다.       Init Update Refs : 세 번째 일시 중지를 하여 업데이트 참조 단계를 초기화한다.       Concurrent Update References : 응용 프로그램과 동시에 실행되며, Heap Memory를 살펴보고 Concurrent Evacuation 중에 이동 된 객체에 대한 참조를 업데이트한다.       Final Update Refs :마지막 일시 중지를 통해 기존 Root Set를 다시 업데이트하여 업데이트 참조 단계를 완료한다.       Concurrent Cleanup : 참조가없는 컬렉션 집합 영역을 회수한다.           동시 압축을 포함하여 대량의 GC 작업을 동시에 수행하여 일시 중지 시간이 더 이상 힙 크기에 직접 비례하지 않는다.   도구  VisualVM     VisualVM5은 애플리케이션 CPU 사용량, GC 활동, Heap 및 Metaspace / Permanent Generation Memory,로드된 클래스의 개수 및 실행 중인 스레드들을 모니터링한다.   Java 프로세스에서 실행중인 모든 스레드는 집계 된 Running, Sleeping, Wait, Park 및 Monitor 시간과 함께 타임 라인에 표시된다.   애플리케이션 성능 및 메모리 관리를 분석하기위한 기본 프로파일링 기능을 제공한다.   대상 프로세스에서 진행되는 작업을 즉시 파악하기 위해 스레드 덤프를 가져와 표시하며, 여러 프로세스의 동시 스레드 덤프는 분산 된 교착 상태를 발견하는 데 도움이 된다.   JConsole     JConsole6은 그래픽 사용자 인터페이스는 JMX(Java Management Extensions) 사양을 준수하는 모니터링 도구이다.   JConsole은 Java VM(Java Virtual Machine)의 광범위한 계측을 사용하여 Java 플랫폼에서 실행되는 응용 프로그램의 성능 및 리소스 소비에 대한 정보를 제공한다.   Prometheus     Prometheus7의 Persistence Layer에는 key-value 형태의 NoSQL제품인 LevelDB를 사용하여 데이터를 저장된다.   Grafana 대시보드를 지원하여 PromQL로 데이터를 시각화 하여 표현한다.   Go/Java/Ruby/Python 등 10개 이상의 언어로 작성된 클라이언트 라이브러리를 사용 가능하다.   주로 Docker 모니터링 용도로 사용된다.   Scouter     Scouter8는 새로운 replicate 및 App dynamics와 같은 오픈 소스 APM이다.   Agent, Sever(Collector), Client(Viewer), Web API(Since @1.8.0)의 4가지 모듈로 구성되어 실행이 된다.   Scouter Client는 Eclipse RCP Platform으로 만들어진 독립 클라이언트이기 때문에, 웹형 뷰어보다 많은 성능 데이터를 제어할 수 있다.   Scouter가 압축된 파일 서비스 성능 및 프로파일 데이터를 저장하여 빅데이터를 수집하고 각 서비스의 트랜잭션(요청)을 분석한다.   Pinpoint     Pinpoint9는 Java/PHP로 작성된 대규모 분산 시스템용 APM(Application Performance Management) 도구이다.   애플리케이션 토폴로지를 한눈에 이해할 수 있다.   실시간으로 애플리케이션 모니터링이 가능하다.   모든 트랜잭션에 대한 코드 수준의 가시성이 확보된다.   한 줄의 코드를 변경하지 않고 APM 에이전트를 설치할 수 있다.   성능에 미치는 영향 최소화(리소스 사용량 약 3% 증가)시키며 설치 및 실행이 가능하다.   Reference                 Oracle-Garbage_Collection &#8617;                  Oracle-G1_GC &#8617;                  OpenJDKWiki-ZGC &#8617;                  OpenJDKWiki-Shenandoah &#8617;                  VisualVM-Home &#8617;                  OpenJDK-JConsole &#8617;                  Prometheus-Home &#8617;                  Github-Scouter &#8617;                  Pinpoint-Home &#8617;           ","categories": ["Java"],
        "tags": ["Programming","Java","Garbage Collection"],
        "url": "/java/gc/",
        "teaser": null
      },{
        "title": "Codility Java MinMaxDivision",
        "excerpt":"문제  Link   코드  // you can also use imports, for example: // import java.util.*;  // you can write to stdout for debugging purposes, e.g. // System.out.println(\"this is a debug message\");  class Solution {   public int solution(int K, int M, int[] A) {     int sum = 0;     int max = 0;     for (int idx = 0; idx &lt; A.length; idx++) {       sum += A[idx];       if (A[idx] &gt; max) {         max = A[idx];       }     }     int result = sum;     while (max &lt;= sum) {       int mid = (max + sum) / 2;       if (isDivisable(mid, K, A)) {         result = mid;         sum = mid - 1;       } else {         max = mid + 1;       }     }     return result;   }   private boolean isDivisable(int mid, int K, int[] A) {     int size = K;     int sum = 0;     for (int idx = 0; idx &lt; A.length; idx++) {       sum = sum + A[idx];       if (sum &gt; mid) {         size--;         sum = A[idx];       }       if (size == 0) {         return false;       }     }     return true;   } }    설명     주어진 배열 A의 합계와 배열 내 최대 값을 확인한다.   블록을 나누어 한 블록의 최대 합계가 다른 경우보다 최소가 되는 수를 구하기 위해 이진 검색을 활용하여 탐색한다.            이진 검색은 주어진 배열 A의 합계를 초기 값으로 저장한(이하 상한) 정수 sum보다 주어진 배열 A내 최대 값을 저장한 정수 max(이하 하한)가 작거나 같을 경우 계속 수행한다.       한 블록에 모든 값이 포함된 경우가 최대값이기 때문에 초기 결과 값으로 지정한다.       상한 값과 하한 값을 2로 나누어 변수 mid를 선언하고, 이진 검색을 수행한다.                    이진 검색에 활용하는 mid 변수를 이용하여 주어진 배열 A를 K 블록으로 분할 가능한지 확인한다.                       만일 K 블록으로 분할이 불가능하면(반복 도중 size가 0이 될 경우) 하한을 mid + 1 값으로 변경하여 이진 검색을 계속 수행한다.       만일 K 블록으로 분할이 가능하면 결과 값을 저장하는 result 변수에 mid 값을 넣고, 상한을 mid - 1 값으로 변경하여 이진 검색을 계속 수행한다.           반복이 종료되면 결과 값을 저장한 변수 result를 주어진 문제의 결과로 반환한다.   결과  Link   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Codility"],
        "tags": ["Programming","Codility","Binary Search Algorithm","Java"],
        "url": "/codility/MinMaxDivision/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Abstract Factory Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Creational Patterns, 생성 패턴     객체가 생성되는 방식을 중시하는 패턴이다.   객체의 생성과 조합을 캡슐화하여 객체가 생성 혹은 수정되어도 전체 프로그램 구조에 영향을 받지 않도록 유연성을 제공한다.   Abstract Factory Pattern     구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만들 수 있는 인터페이스를 제공하는 패턴이다.   Example  public interface Shape {    void draw();  } public class Circle implements Shape {    @Override   public void draw() {     System.out.println(\"Inside Circle::draw() method.\");   }  }  public class Rectangle implements Shape {    @Override   public void draw() {     System.out.println(\"Inside Rectangle::draw() method.\");   }  } public class Square implements Shape {    @Override   public void draw() {     System.out.println(\"Inside Square::draw() method.\");   }  } public enum ShapeType {    CIRCLE, RECTANGLE, SQUARE;  } public interface Color {    void fill();  } public class Blue implements Color {    @Override   public void fill() {     System.out.println(\"Inside Blue::fill() method.\");   }  } public class Green implements Color {    @Override   public void fill() {     System.out.println(\"Inside Green::fill() method.\");   }  } public class Red implements Color {    @Override   public void fill() {     System.out.println(\"Inside Red::fill() method.\");   }  } public enum ColorType {    BLUE, GREEN, RED;  }      Color와 Shape의 조합을 만들 수 있는 각각의 객체를 생성한다.   public abstract class AbstractFactory {    abstract Color getColor(ColorType colorType);    abstract Shape getShape(ShapeType shapeType);  } public class ShapeFactory extends AbstractFactory {    @Override   public Shape getShape(ShapeType shapeType) {     switch (shapeType) {       case CIRCLE:         return new Circle();       case RECTANGLE:         return new Rectangle();       case SQUARE:         return new Square();       default:         return null;     }   }    @Override   public Color getColor(ColorType colorType) {     return null;   }  } public class ColorFactory extends AbstractFactory {    @Override   public Shape getShape(ShapeType shapeType) {     return null;   }    @Override   public Color getColor(ColorType colorType) {     switch (colorType) {       case RED:         return new Red();       case GREEN:         return new Green();       case BLUE:         return new Blue();       default:         return null;     }   }  }      AbstractFactory는 주어진 Color와 Shape의 조합을 만들 수 있는 인터페이스이다.   하위로 Color와 Shape의 세부 설정을 위한 Factory Method 객체들이 존재한다.   public class FactoryProducer {    public static AbstractFactory getFactory(FactroyType factroyType) {     switch (factroyType) {       case SHAPE:         return new ShapeFactory();       case COLOR:         return new ColorFactory();       default:         return null;     }   }  } public class AbstractFactoryPatternMain {    public static void main(String[] args) {      // Get shape factory     AbstractFactory shapeFactory = FactoryProducer.getFactory(FactroyType.SHAPE);      // Get an object of Shape Circle     Shape shape1 = shapeFactory.getShape(ShapeType.CIRCLE);      // Call draw method of Shape Circle     shape1.draw();      // Get an object of Shape Rectangle     Shape shape2 = shapeFactory.getShape(ShapeType.RECTANGLE);      // Call draw method of Shape Rectangle     shape2.draw();      // Get an object of Shape Square     Shape shape3 = shapeFactory.getShape(ShapeType.SQUARE);      // Call draw method of Shape Square     shape3.draw();      // Get color factory     AbstractFactory colorFactory = FactoryProducer.getFactory(FactroyType.COLOR);      // Get an object of Color Red     Color color1 = colorFactory.getColor(ColorType.RED);      // Call fill method of Red     color1.fill();      // Get an object of Color Green     Color color2 = colorFactory.getColor(ColorType.GREEN);      // Call fill method of Green     color2.fill();      // Get an object of Color Blue     Color color3 = colorFactory.getColor(ColorType.BLUE);      // Call fill method of Color Blue     color3.fill();   }  }      FactoryProducer를 통해서 AbstractFactory 인터페이스를 가져와서 Color와 Shape의 조합을 만들 수 있다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Creational Patterns"],
        "url": "/designpattern/abstarctfactory/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Builder Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Creational Patterns, 생성 패턴     객체가 생성되는 방식을 중시하는 패턴이다.   객체의 생성과 조합을 캡슐화하여 객체가 생성 혹은 수정되어도 전체 프로그램 구조에 영향을 받지 않도록 유연성을 제공한다.   Builder Pattern     복잡한 객체를 생성하는 방법을 정의하는 클래스와 표현하는 방법을 정의하는 클래스를 별도로 분리하여, 서로 다른 표현이라도 이를 생성할 수 있는 동일한 절차를 제공하는 패턴이다.   Example  public interface Item {    public String name();    public Packing packing();    public float price();  } public abstract class Burger implements Item {    @Override   public Packing packing() {     return new Wrapper();   }    @Override   public abstract float price();  } public class ChickenBurger extends Burger {    @Override   public float price() {     return 50.5f;   }    @Override   public String name() {     return \"Chicken Burger\";   }  } public class VegBurger extends Burger {    @Override   public float price() {     return 25.0f;   }    @Override   public String name() {     return \"Veg Burger\";   }  } public abstract class ColdDrink implements Item {    @Override   public Packing packing() {     return new Bottle();   }    @Override   public abstract float price();  } public class Coke extends ColdDrink {    @Override   public float price() {     return 30.0f;   }    @Override   public String name() {     return \"Coke\";   }  } public class Pepsi extends ColdDrink {    @Override   public float price() {     return 35.0f;   }    @Override   public String name() {     return \"Pepsi\";   }  } public interface Packing {    public String pack();  } public class Bottle implements Packing {    @Override   public String pack() {     return \"Bottle\";   }  } public class Wrapper implements Packing {    @Override   public String pack() {     return \"Wrapper\";   }  }      Paking, Burger, ColdDring를 상속받은 각각의 객체를 생성한다.   public class Meal {    private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;();    public void addItem(Item item) {     items.add(item);   }    public float getCost() {     float cost = 0.0f;     for (Item item : items) {       cost += item.price();     }     return cost;   }    public void showItems() {     for (Item item : items) {       System.out.print(\"Item : \" + item.name());       System.out.print(\", Packing : \" + item.packing().pack());       System.out.println(\", Price : \" + item.price());     }   }  } public class MealBuilder {    public Meal prepareVegMeal() {     Meal meal = new Meal();     meal.addItem(new VegBurger());     meal.addItem(new Coke());     return meal;   }    public Meal prepareNonVegMeal() {     Meal meal = new Meal();     meal.addItem(new ChickenBurger());     meal.addItem(new Pepsi());     return meal;   }  }      햄버거와 음료의 세트 메뉴를 정의하는 Meal 객체를 선언하고, Builder 패턴의 MealBuilder 객체를 생성하여 원하는 조합으로 객체를 생성한다.   public class CustomMealBuilder {    private Meal meal = new Meal();    public void addBurger(Burger burger) {     this.meal.addItem(burger);   }    public void addColdDring(ColdDrink coldDring) {     this.meal.addItem(coldDring);   }    public Meal build() {     return meal;   }  }      MealBuilder를 동적으로 생성하도록 CustomMealBuilder와 같은 구조로 Builder 객체를 생성 할 수 있다.   public class BuilderPatternMain {    public static void main(String[] args) {     MealBuilder mealBuilder = new MealBuilder();      Meal vegMeal = mealBuilder.prepareVegMeal();     System.out.println(\"Veg Meal\");     vegMeal.showItems();     System.out.println(\"Total Cost: \" + vegMeal.getCost());      Meal nonVegMeal = mealBuilder.prepareNonVegMeal();     System.out.println(\"Non-Veg Meal\");     nonVegMeal.showItems();     System.out.println(\"Total Cost: \" + nonVegMeal.getCost());   }  }      MealBuilder 객체를 이용하여 원하는 햄버거와 음료 세트를 생성자 파라미터 구조와 상관 없이 생성이 가능하다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Creational Patterns"],
        "url": "/designpattern/builder/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Factory Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Creational Patterns, 생성 패턴     객체가 생성되는 방식을 중시하는 패턴이다.   객체의 생성과 조합을 캡슐화하여 객체가 생성 혹은 수정되어도 전체 프로그램 구조에 영향을 받지 않도록 유연성을 제공한다.   Factory Method Pattern     객체 생성을 서브 클래스로 분리해 처리하도록 캡슐화하는 패턴이다.   Example  public interface Shape {    void draw();  } public class Circle implements Shape {    @Override   public void draw() {     System.out.println(\"Inside Circle::draw() method.\");   }  } public class Rectangle implements Shape {    @Override   public void draw() {     System.out.println(\"Inside Rectangle::draw() method.\");   }  } public class Square implements Shape {    @Override   public void draw() {     System.out.println(\"Inside Square::draw() method.\");   }  } public enum ShapeType {    CIRCLE, RECTANGLE, SQUARE;  } public class ShapeFactory {    public Shape getShape(ShapeType shapeType) {     switch (shapeType) {       case CIRCLE:         return new Circle();       case RECTANGLE:         return new Rectangle();       case SQUARE:         return new Square();       default:         return null;     }   }  }      Shape를 상속받은 각 형태의 객체를 선언하고, 실제 그 객체를 생성하여 전달하는 역할을 ShapeFactory에서 진행하게 한다.   public class FactoryPatternMain {    public static void main(String[] args) {     ShapeFactory shapeFactory = new ShapeFactory();      // Get an object of Circle and call its draw method.     Shape shape1 = shapeFactory.getShape(ShapeType.CIRCLE);      // Call draw method of Circle     shape1.draw();      // Get an object of Rectangle and call its draw method.     Shape shape2 = shapeFactory.getShape(ShapeType.RECTANGLE);      // Call draw method of Rectangle     shape2.draw();      // Get an object of Square and call its draw method.     Shape shape3 = shapeFactory.getShape(ShapeType.SQUARE);      // Call draw method of circle     shape3.draw();   }  }      주어진 ShapeType에 맞추어 요청한 객체를 생성하여 제공한다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Creational Patterns"],
        "url": "/designpattern/factory/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Prototype Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Creational Patterns, 생성 패턴     객체가 생성되는 방식을 중시하는 패턴이다.   객체의 생성과 조합을 캡슐화하여 객체가 생성 혹은 수정되어도 전체 프로그램 구조에 영향을 받지 않도록 유연성을 제공한다.   Factory Method Pattern     Original 객체를 새로운 객체에 복사하여 우리의 필요에 따라 수정하는 메커니즘을 제공하는 패턴이다.   Java Cloneable 클래스의 clone() 메서드가 대표적인 예이다.   Example  public abstract class Shape implements Cloneable {    private int id;   protected String type;    abstract void draw();    public String getType() {     return type;   }    public int getId() {     return id;   }    public void setId(int id) {     this.id = id;   }    public Object clone() {     Object clone = null;     try {       clone = super.clone();     } catch (CloneNotSupportedException e) {       e.printStackTrace();     }     return clone;   }  } public class Circle extends Shape {    public Circle() {     type = \"Circle\";   }    @Override   public void draw() {     System.out.println(\"Inside Circle::draw() method.\");   }  } public class Rectangle extends Shape {    public Rectangle() {     type = \"Rectangle\";   }    @Override   public void draw() {     System.out.println(\"Inside Rectangle::draw() method.\");   }  } public class Square extends Shape {    public Square() {     type = \"Square\";   }    @Override   public void draw() {     System.out.println(\"Inside Square::draw() method.\");   }  } public class Square extends Shape {    public Square() {     type = \"Square\";   }    @Override   public void draw() {     System.out.println(\"Inside Square::draw() method.\");   }  }      Clonable을 상속받은 Shape Abstarct 객체를 선언하고, 하위 형태의 객체를 생성한다.   public class ShapeCache {    private static Map&lt;Integer, Shape&gt; shapeMap = new ConcurrentHashMap&lt;Integer, Shape&gt;();    public static Shape getShape(int shapeId) {     Shape cachedShape = shapeMap.get(shapeId);     return (Shape) cachedShape.clone();   }    // For each shape run database query and create shape shapeMap.put(shapeKey, shape);   // For example, we are adding three shapes   public static void loadCache() {     Circle circle = new Circle();     circle.setId(1);     shapeMap.put(circle.getId(), circle);      Square square = new Square();     square.setId(2);     shapeMap.put(square.getId(), square);      Rectangle rectangle = new Rectangle();     rectangle.setId(3);     shapeMap.put(rectangle.getId(), rectangle);   }  }      ShapeCache 객체는 Persistence Layer 대용으로 사용 할 객체이다.   public class PrototypePatternMain {    public static void main(String[] args) {     ShapeCache.loadCache();      Shape clonedShape = (Shape) ShapeCache.getShape(1);     System.out.println(\"Shape : \" + clonedShape.getType());      Shape clonedShape2 = (Shape) ShapeCache.getShape(2);     System.out.println(\"Shape : \" + clonedShape2.getType());      Shape clonedShape3 = (Shape) ShapeCache.getShape(3);     System.out.println(\"Shape : \" + clonedShape3.getType());   }  }      ShapeCache 객체의 getShape 메서드를 이용하여 clone된 객체를 반환함으로써, Prototype Pattern을 구현한다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Creational Patterns"],
        "url": "/designpattern/prototype/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Composite Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Structural Patterns, 구조 패턴     클래스와 객체를 더 큰 결과물로 합칠 수 있는 구조로 설계하는 패턴이다.   서로 다른 인터페이스를 지닌 여러 개의 객체를 조합하여 단일 인터페이스를 제공하거나, 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.   Composite Pattern     여러 개의 객체들로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 해주는 패턴이다.   Example  public class Employee {    private String name;   private String dept;   private int salary;   private List&lt;Employee&gt; subordinates;    // Constructor   public Employee(String name, String dept, int sal) {     this.name = name;     this.dept = dept;     this.salary = sal;     this.subordinates = new ArrayList&lt;Employee&gt;();   }    public void add(Employee e) {     this.subordinates.add(e);   }    public void remove(Employee e) {     this.subordinates.remove(e);   }    public List&lt;Employee&gt; getSubordinates() {     return this.subordinates;   }    public String toString() {     return (\"Employee :[ Name : \" + this.name + \", dept : \" + this.dept + \", salary :\" + this.salary + \" ]\");   }  }      다양한 직급의 임직원 정보를 저장할 Employee 객체를 생성한다.   public class CompositePatternMain {    public static void main(String[] args) {     Employee CEO = new Employee(\"John\", \"CEO\", 30000);      Employee headSales = new Employee(\"Robert\", \"Head Sales\", 20000);     Employee headMarketing = new Employee(\"Michel\", \"Head Marketing\", 20000);      Employee clerk1 = new Employee(\"Laura\", \"Marketing\", 10000);     Employee clerk2 = new Employee(\"Bob\", \"Marketing\", 10000);      Employee salesExecutive1 = new Employee(\"Richard\", \"Sales\", 10000);     Employee salesExecutive2 = new Employee(\"Rob\", \"Sales\", 10000);      CEO.add(headSales);     CEO.add(headMarketing);      headSales.add(salesExecutive1);     headSales.add(salesExecutive2);      headMarketing.add(clerk1);     headMarketing.add(clerk2);      // Print all employees of the organization.     System.out.println(CEO);      for (Employee headEmployee : CEO.getSubordinates()) {       System.out.println(headEmployee);       for (Employee employee : headEmployee.getSubordinates()) {         System.out.println(employee);       }     }    } }      CEO부터 영업직군까지 Employee를 추가하여 CEO와 subordinates에 포함된 모든 임직원들을 출력한다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Structural Patterns"],
        "url": "/designpattern/composite/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Decorator Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Structural Patterns, 구조 패턴     클래스와 객체를 더 큰 결과물로 합칠 수 있는 구조로 설계하는 패턴이다.   서로 다른 인터페이스를 지닌 여러 개의 객체를 조합하여 단일 인터페이스를 제공하거나, 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.   Decorator Pattern     객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주는 패턴이다.   Example  public interface Shape {    void draw();  } public class Circle implements Shape {    @Override   public void draw() {     System.out.println(\"Shape: Circle\");   }  } public class Rectangle implements Shape {    @Override   public void draw() {     System.out.println(\"Shape: Rectangle\");   }  }      각 도형을 그리기 위해 Shape 인터페이스를 정의하고, Circle, Rectangle 클래스를 구현하여 draw() 메서드를 작성한다.   public abstract class ShapeDecorator implements Shape {    protected Shape decoratedShape;    public ShapeDecorator(Shape decoratedShape) {     this.decoratedShape = decoratedShape;   }    public void draw() {     decoratedShape.draw();   }  } public class RedShapeDecorator extends ShapeDecorator {    public RedShapeDecorator(Shape decoratedShape) {     super(decoratedShape);   }    @Override   public void draw() {     decoratedShape.draw();     setRedBorder(decoratedShape);   }    private void setRedBorder(Shape decoratedShape) {     System.out.println(\"Border Color: Red\");   }  }      Shape 인터페이스를 단순 상속받은 Circle, Rectangle 객체는 단순 형태를 그릴 수 있지만, Decorator Pattern을 활용하여 색상을 추가하였다.   public class DecoratorPatternMain {    public static void main(String[] args) {     Shape circle = new Circle();     Shape redCircle = new RedShapeDecorator(new Circle());     Shape redRectangle = new RedShapeDecorator(new Rectangle());      System.out.println(\"Circle with normal border\");     circle.draw();      System.out.println(\"Circle of red border\");     redCircle.draw();      System.out.println(\"Rectangle of red border\");     redRectangle.draw();   }  }      Shape의 형태 별 객체와 Decorator 객체를 이용하여 확인한다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Structural Patterns"],
        "url": "/designpattern/decorator/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Adaptor Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Structural Patterns, 구조 패턴     클래스와 객체를 더 큰 결과물로 합칠 수 있는 구조로 설계하는 패턴이다.   서로 다른 인터페이스를 지닌 여러 개의 객체를 조합하여 단일 인터페이스를 제공하거나, 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.   Adaptor Pattern     클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 변환시키는 패턴이다.   Example  public enum AudioType {    MP3, MP4, VLC, AVI;  } public interface MediaPlayer {    public void play(AudioType audioType, String fileName);  } public class AudioPlayer implements MediaPlayer {    MediaAdaptor mediaAdapter;    @Override   public void play(AudioType audioType, String fileName) {     // Inbuilt support to play mp3 music files.     switch (audioType) {       case MP3:         System.out.println(\"Playing mp3 file. Name : \" + fileName);         break;       case VLC:       case MP4:         mediaAdapter = new MediaAdaptor(audioType);         mediaAdapter.play(audioType, fileName);         break;       default:         System.out.println(\"Invaild media. \" + audioType + \" format not supported.\");         break;     }   }  }      MediaPlayer 인터페이스를 상속받은 AudioPlayer 클래스를 구현하여 특정 파일 형식 별 처리가 가능하도록 한다.   public interface AdvancedMediaPlayer {    public void playVlc(String fileName);    public void playMp4(String fileName);  } public class Mp4Player implements AdvancedMediaPlayer {    @Override   public void playVlc(String fileName) {     // Do nothing.   }    @Override   public void playMp4(String fileName) {     System.out.println(\"Playing mp4 file. Name : \" + fileName);   }  } public class VlcPlayer implements AdvancedMediaPlayer {    @Override   public void playVlc(String fileName) {     System.out.println(\"Playing vlc file. Name : \" + fileName);   }    @Override   public void playMp4(String fileName) {     // Do nothing.   }  }      테스트를 위해 VlcPlayer와 Mp4Player를 구현한다.   public class MediaAdaptor implements MediaPlayer {    private AdvancedMediaPlayer advancedMediaPlayer;    public MediaAdaptor(AudioType audioType) {     switch (audioType) {       case VLC:         advancedMediaPlayer = new VlcPlayer();         break;       case MP4:         advancedMediaPlayer = new Mp4Player();         break;       default:         break;     }   }    @Override   public void play(AudioType audioType, String fileName) {     switch (audioType) {       case VLC:         advancedMediaPlayer.playVlc(fileName);         break;       case MP4:         advancedMediaPlayer.playMp4(fileName);         break;       default:         break;     }   }  }      MediaAdaptor 클래스로 주어진 AudioType 별 구현체를 사용하도록 처리한다.   public class AdaptorPatternMain {    public static void main(String[] args) {     AudioPlayer audioPlayer = new AudioPlayer();      audioPlayer.play(AudioType.MP3, \"Beyond the horizen.mp3\");     audioPlayer.play(AudioType.MP4, \"Alone.mp4\");     audioPlayer.play(AudioType.VLC, \"Far far away.vlc\");     audioPlayer.play(AudioType.AVI, \"Mind me.avi\");   }  }      AudioType 별로 AudioPlayer의 play method를 호출하여 지원 가능한 확장자를 확인해본다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Structural Patterns"],
        "url": "/designpattern/adaptor/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Proxy Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Structural Patterns, 구조 패턴     클래스와 객체를 더 큰 결과물로 합칠 수 있는 구조로 설계하는 패턴이다.   서로 다른 인터페이스를 지닌 여러 개의 객체를 조합하여 단일 인터페이스를 제공하거나, 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.   Proxy Pattern     어떤 다른 객체로 접근하는 것을 통제하기 위해서 그 객체의 대리자나 자리표시자의 역할을 하는 패턴이다.   Example  public interface Image {    void display();  } public class RealImage implements Image {    private String fileName;    public RealImage(String fileName) {     this.fileName = fileName;     loadFromDisk(fileName);   }    @Override   public void display() {     System.out.println(\"Displaying \" + fileName);   }    private void loadFromDisk(String fileName) {     System.out.println(\"Loading \" + fileName);   }  } public class ProxyImage implements Image {    private RealImage realImage;   private String fileName;    public ProxyImage(String fileName) {     this.fileName = fileName;   }    @Override   public void display() {     if (realImage == null) {       realImage = new RealImage(fileName);     }     realImage.display();   }  }      실제 Image 정보를 저장할 RealImage 클래스와 RealImage 정보를 저장하여 관리하는 ProxyImage 객체를 생성한다.   public class ProxyPatternMain {    public static void main(String[] args) {     Image image = new ProxyImage(\"test_10mb.jpg\");      // Image will be loaded from disk     image.display();      // Image will not be loaded from disk     image.display();   }  }      ProxyImage 클래스로 Image를 생성하고 display() Method를 반복 호출하면 처음의 경우 RealImage를 통해 정보를 가져오지만, 그 이후부터는 ProxyImage에 저장된 정보를 반환한다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Structural Patterns"],
        "url": "/designpattern/proxy/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Bridge Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Structural Patterns, 구조 패턴     클래스와 객체를 더 큰 결과물로 합칠 수 있는 구조로 설계하는 패턴이다.   서로 다른 인터페이스를 지닌 여러 개의 객체를 조합하여 단일 인터페이스를 제공하거나, 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.   Bridge Pattern     추상화를 구현으로부터 분리하여 각각 독립적으로 변화할 수 있도록 하는 패턴이다.   Example  public interface DrawAPI {    public void drawCircle(int radius, int x, int y);  }      도형을 그리기위한 DrawAPI 인터페이스를 정의한다.   public abstract class Shape {    protected DrawAPI drawAPI;    protected Shape(DrawAPI drawAPI) {     this.drawAPI = drawAPI;   }    public abstract void draw();  } public class Circle extends Shape {    private int x, y, radius;    public Circle(int x, int y, int radius, DrawAPI drawAPI) {     super(drawAPI);     this.x = x;     this.y = y;     this.radius = radius;   }    public void draw() {     drawAPI.drawCircle(radius, x, y);   }  }      DrawAPI를 활용하는 Shape 추상 클래스를 정의하고, 원을 그리기 위해 Circle 객체를 구현한다.   public class GreenCircle implements DrawAPI {    @Override   public void drawCircle(int radius, int x, int y) {     System.out.println(\"Drawing Circle[ color: green, radius: \" + radius + \", x: \" + x + \", \" + y + \"]\");   }  } public class RedCircle implements DrawAPI {    @Override   public void drawCircle(int radius, int x, int y) {     System.out.println(\"Drawing Circle[ color: red, radius: \" + radius + \", x: \" + x + \", \" + y + \"]\");   }  }      DrawAPI를 상속받아 색상을 부여한 GreenCircle, RedCircle를 구현한다.   public class BridgePatternMain {    public static void main(String[] args) {     Shape redCircle = new Circle(100, 100, 10, new RedCircle());     Shape greenCircle = new Circle(100, 100, 10, new GreenCircle());      redCircle.draw();     greenCircle.draw();   }  }      GreenCircle, RedCircle 구현체를 이용하여 원을 생성 할 때, 색상을 독립적으로 적용할 수 있다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Structural Patterns"],
        "url": "/designpattern/bridge/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Facade Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Structural Patterns, 구조 패턴     클래스와 객체를 더 큰 결과물로 합칠 수 있는 구조로 설계하는 패턴이다.   서로 다른 인터페이스를 지닌 여러 개의 객체를 조합하여 단일 인터페이스를 제공하거나, 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.   Facade Pattern     서브시스템을 더 쉽게 사용할 수 있도록 높은 수준의 인터페이스를 정의하고 제공하는 패턴이다.   Example  public interface Shape {    void draw();  } public class Circle implements Shape {    @Override   public void draw() {     System.out.println(\"Circle::draw()\");   }  } public class Rectangle implements Shape {    @Override   public void draw() {     System.out.println(\"Rectangle::draw()\");   }  } public class Square implements Shape {    @Override   public void draw() {     System.out.println(\"Square::draw()\");   }  }      Shape 인터페이스를 상속받은 Circle, Rectangle, Square 객체를 구현한다.   public class ShapeMaker {    private Shape circle;   private Shape rectangle;   private Shape square;    public ShapeMaker() {     circle = new Circle();     rectangle = new Rectangle();     square = new Square();   }    public void drawCircle() {     circle.draw();   }    public void drawRectangle() {     rectangle.draw();   }    public void drawSquare() {     square.draw();   }  }      ShapeMaker 객체를 구현하여 특정 형태에 대한 요청을 내부적으로 구현하여 결과를 쉽게 제공한다.   public class FacadepatternMain {    public static void main(String[] args) {     ShapeMaker shapeMaker = new ShapeMaker();      shapeMaker.drawCircle();     shapeMaker.drawRectangle();     shapeMaker.drawSquare();   }  }      ShapeMaker 객체를 이용하여 각 형태를 그려본다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Structural Patterns"],
        "url": "/designpattern/facade/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Flyweight Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Structural Patterns, 구조 패턴     클래스와 객체를 더 큰 결과물로 합칠 수 있는 구조로 설계하는 패턴이다.   서로 다른 인터페이스를 지닌 여러 개의 객체를 조합하여 단일 인터페이스를 제공하거나, 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.   Flyweight Pattern     공유를 통하여 대량의 객체들을 효과적으로 지원하는 패턴이다.   Example  public interface Shape {    void draw();  } public class Circle implements Shape {    private String color;   private int x;   private int y;   private int radius;    public Circle(String color) {     this.color = color;   }    public void setX(int x) {     this.x = x;   }    public void setY(int y) {     this.y = y;   }    public void setRadius(int radius) {     this.radius = radius;   }    @Override   public void draw() {     System.out.println(\"Circle: Draw() [Color : \" + color + \", x : \" + x + \", y :\" + y + \", radius :\" + radius);   }  }      공유 객체로 사용할 Shape 인터페이스를 정의하고, Circle 클래스를 구현한다.   public class ShapeFactory {    // Uncomment the compiler directive line and javac *.java will compile properly.   // @SuppressWarnings(\"unchecked\")   private static final Map&lt;String, Circle&gt; circleMap = new HashMap&lt;&gt;();    public static Shape getCircle(String color) {     Circle circle = (Circle) circleMap.get(color);     if (circle == null) {       circle = new Circle(color);       circleMap.put(color, circle);       System.out.println(\"Creating circle of color : \" + color);     }     return circle;   }  }      공유 객체를 관리하는 ShapeFactory 객체를 생성하여 color 별 첫 Circle 객체는 생성하고, 이후 요청은 circleMap에 저장된 color 별 Circle 객체를 공유하게된다.   Javac를 활용한 Compile 시, 주석처리된 @SuppressWarnings(“unchecked”)을 해제하고 사용해야 정상 컴파일이 가능하다.   public class FlyweightPatternMain {    private static final String colors[] = { \"Red\", \"Green\", \"Blue\", \"White\", \"Black\" };    public static void main(String[] args) {     for (int i = 0; i &lt; 20; ++i) {       Circle circle = (Circle) ShapeFactory.getCircle(getRandomColor());       circle.setX(getRandomX());       circle.setY(getRandomY());       circle.setRadius(100);       circle.draw();     }   }    private static String getRandomColor() {     return colors[(int) (Math.random() * colors.length)];   }    private static int getRandomX() {     return (int) (Math.random() * 100);   }    private static int getRandomY() {     return (int) (Math.random() * 100);   }  }      임의의 X축과 Y축에 반지름이 100인 원을 20개 그리도록하여 color 별 circle이 제공되는 방식을 확인한다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Structural Patterns"],
        "url": "/designpattern/flyweight/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Observer Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Behavioral Patterns, 행위 패턴     객체간의 상호작용과 책임을 중시하는 패턴이다.   한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하면서 객체 사이의 결합도를 최소화하는 것에 중점을 두는 패턴이다.   Flyweight Pattern     한 객체의 상태 변화에 따라 다른 객체의 상태도 연동되도록 일대다 객체 의존 관계를 구성하는 패턴이다.   Example  public class Subject {    private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;();   private int state;    public int getState() {     return state;   }    public void setState(int state) {     this.state = state;     notifyAllObservers();   }    public void attach(Observer observer) {     observers.add(observer);   }    public void notifyAllObservers() {     for (Observer observer : observers) {       observer.update();     }   }  }      각 String 별 Observer Pettern을 위한 Subject 객체를 선언한다.   public abstract class Observer {    protected Subject subject;    public abstract void update();  } public class BinaryObserver extends Observer {    public BinaryObserver(Subject subject) {     this.subject = subject;     this.subject.attach(this);   }    @Override   public void update() {     System.out.println(\"Binary String: \" + Integer.toBinaryString(subject.getState()));   }  } public class HexaObserver extends Observer {    public HexaObserver(Subject subject) {     this.subject = subject;     this.subject.attach(this);   }    @Override   public void update() {     System.out.println(\"Hex String: \" + Integer.toHexString(subject.getState()).toUpperCase());   }  } public class OctalObserver extends Observer {    public OctalObserver(Subject subject) {     this.subject = subject;     this.subject.attach(this);   }    @Override   public void update() {     System.out.println(\"Octal String: \" + Integer.toOctalString(subject.getState()));   }  }      Subject 객체를 활용하는 Observer 추상 객체를 선언하고 BinaryObserver, HexaObserver, OctalObserver를 구현한다.   public class ObserverPatternMain {    public static void main(String[] args) {     Subject subject = new Subject();      new HexaObserver(subject);     new OctalObserver(subject);     new BinaryObserver(subject);      System.out.println(\"First state change: 15\");     subject.setState(15);     System.out.println(\"Second state change: 10\");     subject.setState(10);   }  }      각 BinaryObserver, HexaObserver, OctalObserver객체를 생성할 때, 공통의 Subject 객체를 주입하여 Subject 객체를 이용하여 일대 다 의존 관계를 구성하여 State를 관리한다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Behavioral Patterns"],
        "url": "/designpattern/observer/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Command Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Behavioral Patterns, 행위 패턴     객체간의 상호작용과 책임을 중시하는 패턴이다.   한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하면서 객체 사이의 결합도를 최소화하는 것에 중점을 두는 패턴이다.   Command Pattern     실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴이다.   Example  public interface Order {    void execute();  }      주식 주문을 수행하는 Order 인터페이스를 정의한다.   public class Stock {    private String name = \"ABC\";   private int quantity = 10;    public void buy() {     System.out.println(\"Stock [ name: \" + name + \", Quantity: \" + quantity + \" ] bought\");   }    public void sell() {     System.out.println(\"Stock [ name: \" + name + \", Quantity: \" + quantity + \" ] sold\");   }  } public class BuyStock implements Order {    private Stock abcStock;    public BuyStock(Stock abcStock) {     this.abcStock = abcStock;   }    public void execute() {     abcStock.buy();   }  } public class SellStock implements Order {    private Stock abcStock;    public SellStock(Stock abcStock) {     this.abcStock = abcStock;   }    public void execute() {     abcStock.sell();   }  }      ABC라는 임의 주식 정보와 사고 파는 기능을 포함한 Stock 객체를 구현한다.   주식을 파는 BuyStock과 사는 SellStock 객체를 구현하여 Stock 객체의 기능을 활용하도록 처리한다.    public class Broker {   private List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;();   public void takeOrder(Order order) {     orderList.add(order);   }   public void placeOrders() {     for (Order order : orderList) {       order.execute();     }     orderList.clear();   } }      Broker는 주어진 Order를 받고 수행을 하며, 사고 파는 행위에 대한 구분 없이 execute() 메서드만 호출한다.   public class CommandPatternMain {    public static void main(String[] args) {     Stock abcStock = new Stock();      BuyStock buyStockOrder = new BuyStock(abcStock);     SellStock sellStockOrder = new SellStock(abcStock);      Broker broker = new Broker();     broker.takeOrder(buyStockOrder);     broker.takeOrder(sellStockOrder);     broker.placeOrders();   }  }      구매 브로커, 판매 브로커를 ABC 주식에 대한 Stock 객체를 주입하여 구현하고, Broker를 통해 사고 파는 행위를 진행하여 확인한다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Behavioral Patterns"],
        "url": "/designpattern/command/",
        "teaser": null
      },{
        "title": "Java Design Pattern - State Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Behavioral Patterns, 행위 패턴     객체간의 상호작용과 책임을 중시하는 패턴이다.   한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하면서 객체 사이의 결합도를 최소화하는 것에 중점을 두는 패턴이다.   State Pattern     객체의 상태에 따라 객체의 행위 내용을 변경하게 해주는 패턴이다.   Example  public interface State {    public void doAction(Context context);  } public class StartState implements State {    @Override   public void doAction(Context context) {     System.out.println(\"Player is in start state\");     context.setState(this);   }    @Override   public String toString() {     return \"Start State\";   }  } public class StopState implements State {    @Override   public void doAction(Context context) {     System.out.println(\"Player is in stop state\");     context.setState(this);   }    @Override   public String toString() {     return \"Stop State\";   }  }      상태를 관리하기 위한 Status를 정의하고 시작과 정지를 구분하는 StartState, StopState 객체를 구현한다.   public class Context {    private State state;    public Context() {     state = null;   }    public void setState(State state) {     this.state = state;   }    public State getState() {     return state;   }  }       Context 객체는 State를 유동적으로 받아 동작하도록 구현된 객체이다.   public class StatePatternMain {    public static void main(String[] args) {     Context context = new Context();      StartState startState = new StartState();     startState.doAction(context);     System.out.println(context.getState().toString());      StopState stopState = new StopState();     stopState.doAction(context);     System.out.println(context.getState().toString());   }  }      Content 객체에 StartState와 StopState에 따라서 각각 상태가 변경되는 것을 확인 할 수 있다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Behavioral Patterns"],
        "url": "/designpattern/state/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Strategy Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Behavioral Patterns, 행위 패턴     객체간의 상호작용과 책임을 중시하는 패턴이다.   한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하면서 객체 사이의 결합도를 최소화하는 것에 중점을 두는 패턴이다.   Strategy Pattern     행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴이다.   Example  public interface Operation {    public int doOperation(int num1, int num2);  } public class AddOperation implements Operation {    @Override   public int doOperation(int num1, int num2) {     return num1 + num2;   }  } public class MultiplyOperation implements Operation {    @Override   public int doOperation(int num1, int num2) {     return num1 * num2;   }  } public class SubstractOperation implements Operation {    @Override   public int doOperation(int num1, int num2) {     return num1 - num2;   }  }      계산 방식을 동적으로 변경하기 위해서 Operation 인터페이스를 정의하고, Add, Multiply, Substract 행위를 하는 각 Operation 객체를 구현한다.   public class Context {    private Operation operation;    public Context(Operation operation) {     this.operation = operation;   }    public int executeStrategy(int num1, int num2) {     return operation.doOperation(num1, num2);   }  }      Context 객체는 동적으로 Operation의 구현체 중 하나를 받아 행위를 변경하여 수행 가능하도록 구현된 객체이다.   public class StrategyPatternMain {    public static void main(String[] args) {     Context context = new Context(new AddOperation());     System.out.println(\"10 + 5 = \" + context.executeStrategy(10, 5));      context = new Context(new SubstractOperation());     System.out.println(\"10 - 5 = \" + context.executeStrategy(10, 5));      context = new Context(new MultiplyOperation());     System.out.println(\"10 * 5 = \" + context.executeStrategy(10, 5));   }  }      Content 객체에 필요한 Add, Substract, Multiply 행위에 대한 구현체를 주입하여 활용 가능한 것을 확인 할 수 있다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Behavioral Patterns"],
        "url": "/designpattern/strategy/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Command Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Behavioral Patterns, 행위 패턴     객체간의 상호작용과 책임을 중시하는 패턴이다.   한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하면서 객체 사이의 결합도를 최소화하는 것에 중점을 두는 패턴이다.   Template Method Pattern     어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화하여 전체를 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 작업을 바꾸는 패턴이다.   Example  public abstract class Game {    abstract void initialize();    abstract void startPlay();    abstract void endPlay();    // Template method   public final void play() {     // Initialze the game     initialize();     // Start game     startPlay();     // End game     endPlay();   }  } public class Cricket extends Game {    @Override   void endPlay() {     System.out.println(\"Cricket Game Finished!\");   }    @Override   void initialize() {     System.out.println(\"Cricket Game Initialized! Start playing.\");   }    @Override   void startPlay() {     System.out.println(\"Cricket Game Started. Enjoy the game!\");   }  } public class Football extends Game {    @Override   void endPlay() {     System.out.println(\"Football Game Finished!\");   }    @Override   void initialize() {     System.out.println(\"Football Game Initialized! Start playing.\");   }    @Override   void startPlay() {     System.out.println(\"Football Game Started. Enjoy the game!\");   }  }      스포츠 게임에 대한 행위를 추상화 시킨 Game 추상 객체를 정의한다.   각 게임 전, 시작, 종료를 캡슐화 하여 각 스포츠 게임에 따라 Cricket과 Football을 구현시킨다.   public class TemplatePatternMain {    public static void main(String[] args) {     Game game = new Cricket();     game.play();     game = new Football();     game.play();   }  }      Game 추상 객체를 Cricket과 Football 별로 play 시켜 주어진 게임의 단계 별 행위가 다른 것을 확인한다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Behavioral Patterns"],
        "url": "/designpattern/template/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Chain of Responsibility Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Behavioral Patterns, 행위 패턴     객체간의 상호작용과 책임을 중시하는 패턴이다.   한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하면서 객체 사이의 결합도를 최소화하는 것에 중점을 두는 패턴이다.   Chain of Responsibility Pattern     한 요청을 두 개 이상의 객체에서 처리하고 싶을 때 사용하는 패턴이다.   Example  public abstract class AbstractLogger {    public static int INFO = 1;   public static int DEBUG = 2;   public static int ERROR = 3;    protected int level;    // Next element in chain or responsibility.   protected AbstractLogger nextLogger;    public void setNextLogger(AbstractLogger nextLogger) {     this.nextLogger = nextLogger;   }    public void logMessage(int level, String message) {     if (this.level &lt;= level) {       write(message);     }     if (nextLogger != null) {       nextLogger.logMessage(level, message);     }   }    abstract protected void write(String message);  } public class ConsoleLogger extends AbstractLogger {    public ConsoleLogger(int level) {     this.level = level;   }    @Override   protected void write(String message) {     System.out.println(\"Standard Console::Logger: \" + message);   }  } public class ErrorLogger extends AbstractLogger {    public ErrorLogger(int level) {     this.level = level;   }    @Override   protected void write(String message) {     System.out.println(\"Error Console::Logger: \" + message);   }  } public class FileLogger extends AbstractLogger {    public FileLogger(int level) {     this.level = level;   }    @Override   protected void write(String message) {     System.out.println(\"File::Logger: \" + message);   }  }      일정 Level에 해당하는 Logger 클래스를 찾아 Logging을 위한 AbstractLogger 추상 클래스를 정의한다.   Console, Error, File 별 Logging을 위한 각 클래스를 정의하고, 각 Logging 방식에 대한 write 메서드를 구현한다.   public class ChainPatternMain {    private static AbstractLogger getChainOfLoggers() {      AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);     AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);     AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);      errorLogger.setNextLogger(fileLogger);     fileLogger.setNextLogger(consoleLogger);      return errorLogger;   }    public static void main(String[] args) {     AbstractLogger loggerChain = getChainOfLoggers();      loggerChain.logMessage(AbstractLogger.INFO, \"This is an information.\");     loggerChain.logMessage(AbstractLogger.DEBUG, \"This is an debug level information.\");     loggerChain.logMessage(AbstractLogger.ERROR, \"This is an error information.\");   }  }      Error 수준의 경우 ErrorLogger를 호출하고, Debug 수준의 경우 FileLogger, Info 수준은 ConsoleLogger를 호출하도록 선언한다.   ErrorLogger가 호출되면 다음에는 FileLogger를 호출하도록하고, FileLogger가 호출되면 다음에는 ConsoleLogger를 호출하도록 연결한다.   위의 설정이 적용된 Logger를 AbstractLogger로 받아 각 Logging Level 별 Log 메시지를 출력해본다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Behavioral Patterns"],
        "url": "/designpattern/chainOfResponsibility/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Interpreter Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Behavioral Patterns, 행위 패턴     객체간의 상호작용과 책임을 중시하는 패턴이다.   한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하면서 객체 사이의 결합도를 최소화하는 것에 중점을 두는 패턴이다.   Interpreter Pattern     언어 문법이나 표현을 평가할 수 있는 방법을 제공하는 패턴이다.   Example  public interface Expression {    public boolean interpret(String context);  } public class AndExpression implements Expression {    private Expression expr1 = null;   private Expression expr2 = null;    public AndExpression(Expression expr1, Expression expr2) {     this.expr1 = expr1;     this.expr2 = expr2;   }    @Override   public boolean interpret(String context) {     return expr1.interpret(context) &amp;&amp; expr2.interpret(context);   }  } public class OrExpression implements Expression {    private Expression expr1 = null;   private Expression expr2 = null;    public OrExpression(Expression expr1, Expression expr2) {     this.expr1 = expr1;     this.expr2 = expr2;   }    @Override   public boolean interpret(String context) {     return expr1.interpret(context) || expr2.interpret(context);   }  } public class TerminalExpression implements Expression {    private String data;    public TerminalExpression(String data) {     this.data = data;   }    @Override   public boolean interpret(String context) {     if (context.contains(data)) {       return true;     }     return false;   }  }      각 표현식을 위해 Interpreter 인터페이스를 정의한다.   And, Or 표현을 위해 각 Expression 객체를 구현하고, 데이터를 주입받아 각 Expression에 주입할 TerminalExpression 객체를 구현한다.   public class InterpreterPatternMain {    // Rule: Robert and John are male   public static Expression getMaleExpression() {     Expression robert = new TerminalExpression(\"Robert\");     Expression john = new TerminalExpression(\"John\");     return new OrExpression(robert, john);   }    // Rule: Julie is a married women   public static Expression getMarriedWomanExpression() {     Expression julie = new TerminalExpression(\"Julie\");     Expression married = new TerminalExpression(\"Married\");     return new AndExpression(julie, married);   }    public static void main(String[] args) {     Expression isMale = getMaleExpression();     Expression isMarriedWoman = getMarriedWomanExpression();      System.out.println(\"John is male? \" + isMale.interpret(\"John\"));     System.out.println(\"Julie is a married women? \" + isMarriedWoman.interpret(\"Married Julie\"));   }  }      Expression의 조합을 통해서 각 질의를 수행해본다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Behavioral Patterns"],
        "url": "/designpattern/interpreter/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Iterator Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Behavioral Patterns, 행위 패턴     객체간의 상호작용과 책임을 중시하는 패턴이다.   한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하면서 객체 사이의 결합도를 최소화하는 것에 중점을 두는 패턴이다.   Iterator Pattern     컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있는 방법을 제공하는 패턴이다.   Example  public interface Iterator {    public boolean hasNext();    public Object next();  } public class NameIterator implements Iterator {    String[] names;   int index;    public NameIterator(String[] names) {     this.names = names;   }    @Override   public boolean hasNext() {     if (index &lt; names.length) {       return true;     }     return false;   }    @Override   public Object next() {     if (this.hasNext()) {       return names[index++];     }     return null;   }  }      반복 수행을 위한 Iterator 인터페이스를 정의하고, 이름에 대한 배열을 저장할 NameIterator를 구현한다.   public interface Container {    public Iterator getIterator();  } public class NameRepository implements Container {    public String names[] = { \"Robert\", \"John\", \"Julie\", \"Lora\" };    @Override   public Iterator getIterator() {     return new NameIterator(names);   }  }      Iterator를 가져오기 위한 Container 인터페이스를 정의하고, 이름 배열을 저장하여 NameIterator 객체로 반환하기 위한 NameRepository 클래스를 구현한다.   public class IteratorPatternMain {    public static void main(String[] args) {     NameRepository namesRepository = new NameRepository();      for (Iterator iter = namesRepository.getIterator(); iter.hasNext();) {       String name = (String) iter.next();       System.out.println(\"Name : \" + name);     }    }  }      NameRepository를 이용하여 NameIterator를 가져와서 반복 수행해본다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Behavioral Patterns"],
        "url": "/designpattern/iterator/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Mediator Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Behavioral Patterns, 행위 패턴     객체간의 상호작용과 책임을 중시하는 패턴이다.   한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하면서 객체 사이의 결합도를 최소화하는 것에 중점을 두는 패턴이다.   Mediator Pattern     서로 관련된 객체 사이의 복잡한 통신과 제어를 한 곳으로 집중시키는 패턴이다.   Example  public class ChatRoom {    public static void showMessage(User user, String message) {     System.out.println(LocalDateTime.now().toString() + \" [\" + user.getName() + \"] : \" + message);   }  }      대화를 나눌 ChatRoom 클래스를 구현한다.   public class User {    private String name;    public String getName() {     return name;   }    public void setName(String name) {     this.name = name;   }    public User(String name) {     this.name = name;   }    public void sendMessage(String message) {     ChatRoom.showMessage(this, message);   }  }      사용자 정보와 ChatRoom을 이용하여 메시지 전송을 위한 User 클래스를 구현한다.   public class MediatorPatternMain {    public static void main(String[] args) {     User robert = new User(\"Robert\");     User john = new User(\"John\");      robert.sendMessage(\"Hi! John!\");     john.sendMessage(\"Hello! Robert!\");   }  }      각 유저를 생성하여 메시지를 전송하면 ChatRoom을 통해 모든 메시지가 전송되는 것을 확인 할 수 있다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Behavioral Patterns"],
        "url": "/designpattern/mediator/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Memento Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Behavioral Patterns, 행위 패턴     객체간의 상호작용과 책임을 중시하는 패턴이다.   한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하면서 객체 사이의 결합도를 최소화하는 것에 중점을 두는 패턴이다.   Memento Pattern     객체를 이전의 상태로 복구시켜야 하는 경우 사용하는 패턴이다.   Example  public class Memento {    private String state;    public Memento(String state) {     this.state = state;   }    public String getState() {     return this.state;   }  }      객체의 상태를 저장하기 위한 Memento 객체를 구현한다.   public class Originator {    private String state;    public void setState(String state) {     this.state = state;   }    public String getState() {     return state;   }    public Memento saveStateToMemento() {     return new Memento(state);   }    public void getStateFromMemento(Memento memento) {     state = memento.getState();   }  } public class CareTaker {    private List&lt;Memento&gt; mementoList = new ArrayList&lt;Memento&gt;();    public void add(Memento state) {     this.mementoList.add(state);   }    public Memento get(int index) {     return this.mementoList.get(index);   }  }      이전 상태로 복원하기 위해 이력을 저장 및 복원 기능을 포함한 Originator 객체와 이력을 관리하는 CareTaker 객체를 구현한다.   public class MementoPatternMain {    public static void main(String[] args) {     Originator originator = new Originator();     CareTaker careTaker = new CareTaker();      originator.setState(\"State #1\");     originator.setState(\"State #2\");     careTaker.add(originator.saveStateToMemento());      originator.setState(\"State #3\");     careTaker.add(originator.saveStateToMemento());      originator.setState(\"State #4\");     System.out.println(\"Current State: \" + originator.getState());      originator.getStateFromMemento(careTaker.get(0));     System.out.println(\"First saved State: \" + originator.getState());     originator.getStateFromMemento(careTaker.get(1));     System.out.println(\"Second saved State: \" + originator.getState());   }  }      상태를 변경시키며 저장을 원하면 Originator 객체를 사용하여 현재 객체의 상태를 저장하고, CareTaker 객체에 이력을 저장시켜 필요 시 복원 가능하도록 한다.   이력 저장과 상태 변경을 다수 실행하고, CareTaker 객체에서 기존 이력을 Originator 객체로 복원하여 출력해본다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Behavioral Patterns"],
        "url": "/designpattern/memento/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Visitor Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Behavioral Patterns, 행위 패턴     객체간의 상호작용과 책임을 중시하는 패턴이다.   한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하면서 객체 사이의 결합도를 최소화하는 것에 중점을 두는 패턴이다.   Visitor Pattern     알고리즘을 객체 구조에서 분리시키는 패턴이다.   Example  public interface ComputerPartVisitor {    public void visit(Computer computer);    public void visit(Mouse mouse);    public void visit(Keyboard keyboard);    public void visit(Monitor monitor);  } public class ComputerPartDisplayVisitor implements ComputerPartVisitor {    @Override   public void visit(Computer computer) {     System.out.println(\"Displaying Computer.\");   }    @Override   public void visit(Mouse mouse) {     System.out.println(\"Displaying Mouse.\");   }    @Override   public void visit(Keyboard keyboard) {     System.out.println(\"Displaying Keyboard.\");   }    @Override   public void visit(Monitor monitor) {     System.out.println(\"Displaying Monitor.\");   }  }      Computer를 장비 별로 분리하여 연결하기 위해 ComputerPartVisitor 인터페이스를 정의하고, 장비 별 연결 방식(알고리즘)을 정의할 ComputerPartDisplayVisitor 클래스를 구현한다.   public interface ComputerPart {    public void accept(ComputerPartVisitor computerPartVisitor);  } public class Keyboard implements ComputerPart {    @Override   public void accept(ComputerPartVisitor computerPartVisitor) {     computerPartVisitor.visit(this);   }  } public class Monitor implements ComputerPart {    @Override   public void accept(ComputerPartVisitor computerPartVisitor) {     computerPartVisitor.visit(this);   }  } public class Mouse implements ComputerPart {    @Override   public void accept(ComputerPartVisitor computerPartVisitor) {     computerPartVisitor.visit(this);   }  } public class Computer implements ComputerPart {    ComputerPart[] parts;    public Computer() {     parts = new ComputerPart[] { new Mouse(), new Keyboard(), new Monitor() };   }    @Override   public void accept(ComputerPartVisitor computerPartVisitor) {     for (int i = 0; i &lt; parts.length; i++) {       parts[i].accept(computerPartVisitor);     }     computerPartVisitor.visit(this);   }  }      Computer를 각 장비 별로 구현하기 위한 ComputerPart 인터페이스를 정의한다.   각 장비 별 연결하기 위해 ComputerPartVisitor의 visit 메서드를 호출하는 accept 메서드를 정의한다.   각 장비 별 연결과 ComputerPartVisitor 객체에 자신을 연결하는 Computer 클래스를 구현한다.   public class VisitorPatternMain {    public static void main(String[] args) {     ComputerPart computer = new Computer();     computer.accept(new ComputerPartDisplayVisitor());   }  }       Computer 객체를 생성하여 새 ComputerPartDisplayVisitor 객체를 accept 메서드에 주입하여 수행 흐름을 확인한다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Behavioral Patterns"],
        "url": "/designpattern/visitor/",
        "teaser": null
      },{
        "title": "Internet Protocol Suite",
        "excerpt":"Internet Protocol Suite     인터넷에서 컴퓨터들이 서로 정보를 주고받는 데 쓰이는 통신규약(프로토콜)의 모음이다.1   인터넷 프로토콜 스택은 보통 네 계층으로 나눌 수 있다.                  계층       프로토콜                       응용 계층       BGP, DHCP, DNS, FTP, HTTP, HTTPS, IMAP, LDAP, MGCP, MQTT, NNTP, NTP, POP, ONC/RPC, RTP, RTSP, RIP, SIP, SMTP, SNMP, SSH, Telnet, TLS/SSL, XMPP, …                 전송 계층       TCP, QUIC, UDP, DCCP, SCTP, RSVP, …                 인터넷 계층       IP(IPv4, IPv6), ARP, ICMP, ICMPv6, ECN, IGMP, IPsec, …                 링크 계층       NDP, OSPF, 터널(L2TP), PPP, MAC(이더넷, DSL, ISDN, FDDI), …           User Datagram Protocol(UDP)     TCP와 함께 데이터그램으로 알려진 단문 메시지를 교환하기 위해서 사용된다.   UDP의 전송 방식은 너무 단순해서 서비스의 신뢰성이 낮고, 데이터그램 도착 순서가 바뀌거나, 중복되거나, 심지어는 통보 없이 누락시키기도 한다.   주로 DNS, IPTV, VoIP, TFTP 등에서 사용한다.   Transmission Control Protocol(TCP)     UDP에 비해 신뢰성과 순차적인 전달을 제공하며, 송신자와 수신자 모두가 소켓이라는 종단점을 생성함으로써 신뢰성있는 바이트 스트림을 전송하도록 설계되었다.   TCP는 웹 브라우저들이 월드 와이드 웹에서 서버에 연결할 때 사용되며, 이메일 전송이나 파일 전송에도 사용된다.        3-way Handshaking : TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정(Connection Establish)하는 과정이다.   4-way Handshaking : TCP의 연결을 해제(Connection Termination)하는 과정이다.   TCP Control Flag  SYN, Synchronize     TCP 연결을 시작하며 회선을 개설하는 용도이며, 연결을 요청하고 허락할 때 세워진다.   즉, 3-Way Handshake를 시작하는 플래그며 두 호스트의 첫 번째 비트에만 세워진다.   ACK, Acknowledgement     Acknowledgement number 값이 설정되어 유효하다는 것을 의미하며, 전송을 제대로 받았다는 증거가 된다.   SYN 플래그를 받으면 이 플래그를 보내며 이후 모든 세그먼트에는 항상 이 플래그가 세워져 있다. 값은 Sequence number에 1을 더한 값이 된다.   URG, Urgent     이 플래그가 세워지면 수신자에게 다른 패킷보다 해당 패킷을 먼저 처리하도록 요청한다.   PSH, Push     받은 패킷을 버퍼링하지 않고 즉시 처리하도록 요청한다.   예를 들어 패킷을 상위 계층 응용프로그램에 빠르게 전달하도록 하며 URG와 비슷하다고 볼 수 있다.   RST, Reset     연결이 확립(Established)된 회선에 강제로 리셋을 요청한다.   FIN, Finish     이 플래그가 세워진 세그먼트를 받아 ACK 플래그를 세워 응답하면 연결이 종료된다.   Internet Protocol(IP)     송신 호스트와 수신 호스트가 패킷 교환 네트워크에서 정보를 주고받는 데 사용하는 정보 위주의 규약이다.   IP는 흐름에 관여하지 않기 때문에 보낸 정보가 제대로 갔는지 보장하지 않는다는 비신뢰성(Unreliability)과 비연결성(Connectionlessness)이 특징이다.   TCP/IP는 패킷을 수집하는 것만으로도 도청이 가능하여 암호화 하여 전송해야 한다.   IPv4 vs IPv6                  구분       IPv4       IPv6                       주소 길이       32bit       128bit                 주소 개수       $2^{32}$인 4,294,967,296개       $2^{128}$인 약 $3.4\\times10^{38}$개                 품질 제어       베스트 에퍼트 방식으로 품질 보장이 곤란 (타입이나 서비스에 대한 QoS 일부 지원)       등급별, 서비스 별로 패킷을 구분할 수 있어 품질 보장이 용이 (트래픽 클라스, 폴로 라벨에 의한 QoS 지원)                 보안 기능       IPsec 프로토콜 별도 설치       확장 기능에서 기본으로 제공                 Plug &amp; Play       없음       있음(오디오 컨피큐어레이션 가능)                 Mobile IP       곤란(비효율적)       용이(효율적)                 Web Casting       곤란       용이(스코프 필드 증가)           HyperText Transfer Protocol(HTTP)     클라이언트와 서버 사이에 이루어지는 요청/응답(Request/Response) 프로토콜이다.   HTTP는 평문(ASCII) 메시지 통신이기 때문에 도청이 가능하다.   통신 상대를 확인하지 않기 때문에 위장이 가능하다.   Request Method  GET     Request-URI로 식별되는 모든 정보(엔티티 형식)를 검색하는 것을 의미한다.   HEAD     서버가 응답에서 메시지 본문을 반환하지 않아야한다는 점을 제외하고 GET과 동일하다.   POST     요청 라인에서 요청 URI에 의해 식별된 자원의 새로운 종속 항목으로 요청에 포함된 엔티티를 원 서버가 수락하도록 요청하는데 사용된다.   PUT     PUT 메소드는 같이 전달된 엔티티가 제공된 Request-URI 아래에 저장되도록 요청한다.   DELETE     Request-URI로 식별 된 자원을 원 서버가 삭제하도록 요청한다.   CONNECT     목적 리소스로 식별되는 서버로의 터널을 맺는다.   OPTIONS     Request-URI로 식별되는 요청 / 응답 체인에서 사용할 수있는 통신 옵션에 대한 정보 요청을 나타낸다.   TRACE     요청 메시지의 원격 애플리케이션 계층 Loop-Back을 호출하는 데 사용됩니다   PATCH     PATCH 메서드는 리소스의 부분만을 수정하는 데 쓰인다.   Status                  Status code       Description                       100 ~ 199       Informational Responses                 200 ~ 299       Successful Responses                 300 ~ 399       Redirects                 400 ~ 499       Client errors                 500 ~ 599       Server errors           Headers  General Headers     Request와 Response 모두에 사용되며, 최종적으로 전송되는 Body의 데이터와는 관련이 없는 Header이다.   Request Headers     가져올 Resource 또는 Resource를 요청하는 Client에 대한 추가 정보를 제공하는 Header이다.   Response headers     Response의 위치 또는 Response를 제공하는 Server에 대한 추가 정보를 제공하는 Header이다.   Entity headers     컨텐츠 길이나 MIME 타입과 같이 Resource 본문에 대한 정보를 포함하는 Header이다.   HyperText Transfer Protocol over Secure Socket Layer(HTTPS)     HTTP 프로토콜의 보안적인 부분을 해결하기 위해 HTTP 통신하는 소켓부분을 TCP에서 SSL(Secure Socket Layer) or TLS(Transport Layer Security)라는 프로토콜로 대체함으로써 암호화와 증명서, 안정성 보호를 이용할 수 있게 된다.   Reference                 Wiki-인터넷_프로토콜_스위트 &#8617;           ","categories": ["Cs"],
        "tags": ["Programming","Cs","Protocol"],
        "url": "/cs/protocol/",
        "teaser": null
      },{
        "title": "Deployment",
        "excerpt":"Deployment     제품 팀은 릴리스를 더 자주 프로덕션에 배포하며, 순수한 소프트웨어 제품을 구축하는 경우에는 수 개월 또는 수 년에 걸친 릴리스 주기가 드물어지고 있다.   배포 빈도가 높을수록 배포 된 코드가 사이트 안정성이나 고객 경험에 부정적인 영향을 미칠 수 있으므로, 제품과 고객에 대한 위험을 최소화하는 코드 배포 전략을 개발하는 것이 중요하다.   배포 직후 발생하는 문제를 모니터링하는 것은 완벽한 배포를 계획하고 실행하는 것 만큼 중요하다.   Strategy  Rolling Deployment       서버를 한 대씩 구버전에서 새 버전으로 교체해가는 전략이다.   서버의 수에 제약이 있을 경우 유용하다.   배포 중 인스턴스 수가 감소하므로, 서버 처리 용량을 미리 고려해야 한다.   Blue-Green Deployment        구버전에서 새 버전으로 일제히 전환하는 전략이다.   하나의 버전만 프로덕션 되므로 버전 관리 문제를 방지 할 수 있다.   빠른 롤백이 가능하다.   운영 환경에 영향을 주지 않고 실제 서비스 환경에서 새 버전 테스트가 가능하다.   시스템 자원이 두 배로 필요하고, 전체 플랫폼에 대한 테스트가 진행되어야 한다.   Canary Deployment       카나리아 새처럼 위험을 빠르게 감지할 수 있는 배포 기법이다.   구 버전의 서버와 새 버전의 서버를 구성하고 일부 트래픽을 새 버전으로 분산하여 오류 여부를 판단한다.   A/B 테스트도 가능하며, 오류율 및 성능 모니터링에 유용하다.            A/B Testing : 카나리 배포와 유사하지만, A/B Testing은 신규 애플리케이션 기능에 관한 사용자 반응을 측정하는 데 초점을 맞춘다.           트래픽을 분산시킬 때는 라우팅을 랜덤하게 할 수 있고, 사용자로 분류할 수도 있다.  ","categories": ["Devops"],
        "tags": ["Programming","Devops","Deployment"],
        "url": "/devops/deployment/",
        "teaser": null
      },{
        "title": "Object-Relational Mapping(ORM)",
        "excerpt":"Object-Relational Mapping(ORM)     Object-Oriented Programming(OOP)1에서 사용되는 객체라는 개념을 구현한 클래스와 Relational Database(RDBMS)에서 쓰이는 데이터인 테이블을 자동으로 연결해주는 것이다.   Persistence, 영속성     프로그램이 종료되더라도 생성한 데이터가 사라지지 않는 데이터의 특성을 말한다.   Object Persistence     메모리 상의 데이터를 파일 시스템, 데이터베이스 등을 활용하여 영구적으로 저장시켜서 영속성을 부여한다.   Persistence Layer     시스템 아키텍처에서 데이터에 영속성을 부여해주는 계층을 말한다.   Persistence Framework     JDBC 프로그래밍의 복잡함이나 번거로움 없이 간단한 작업으로 데이터베이스와 연동되는 시스템을 균등한 수준의 개발과 안정성을 보장한다.   Hibernate     Java Persistence API(JPA) 사양의 구현으로, 데이터베이스와 상호 작용하는 Java 애플리케이션의 개발을 단순화하는 Java Persistence Framework이다.   거의 모든 주요 RDBMS를 지원하며, 코드를 작성하지 않고 XML 파일을 사용하여 Java 클래스를 데이터베이스 테이블에 매핑하는 작업을 처리한다.   MyBatis     MyBatis는 사용자 지정 SQL, 저장 프로시저 및 고급 매핑을 지원하는 Persistence Framework이다.   데이터베이스 레코드에 기본 자료형, Map, Plain Old Java Objects(POJO)를 설정해서 매핑하기 위해 XML과 어노테이션을 사용할 수 있다.   장점     라이브러리가 SQL 쿼리를보다 간단한 메서드로 캡슐화하므로 SQL Query를 크게 보완하여 객체와 직접 상호 작용할 수 있다.            반복적인 SQL Query의 시간을 절약하기 때문에 매우 유용하다.       SQL을 잘 알 필요는 없지만, RDBMS가 작동하는 방식을 이해하면 ORM 내부에서 일어나는 동작을 이해하는데 도움이 된다.           시간을 크게 절약 할 수있는 낙관적 잠금 및 비관적 잠금 기능을 기본 제공한다.   클래스 및 객체에 명확한 데이터 구조를 제공하여 코드의 유지보수성을 향상하고 데이터 유형을 확인할 수 있다.   DBMS에 대한 종속성이 줄어들어 양 쪽에서 변경사항을 구현하기 쉽다.   단점     ORM에 익숙해지는 데 러닝커브가 존재하여, 익숙하게 설정 및 활용하는데 시간이 약간 걸릴 수 있다.   프로시저가 많은 시스템에서는 ORM의 객체 지향적인 장점을 활용하기 어렵다.   Object-Relational Impedance Mismatch, 객체-관계 패러다임 불일치   Granularity, 세분성     경우에 따라서 데이터베이스에 있는 테이블 수 보다 더 많은 클래스를 가진 모델이 생길 수 있다.   Inheritance, 상속성     상속은 객체 지향 프로그래밍 언어의 자연스러운 패러다임이다.   일부 RDBMS에서는 하위 유형을 지원하지만, 완전히 표준화되지 않았다.   Identity, 일치     RDBMS는 정확히 하나의 동일성의 개념인 기본 키(Primary Key)를 정의한다.   그러나 Java는 객체 식별과 객체 동등성을 모두 정의한다   Associations, 연관성     연관은 객체 지향 언어에서 단방향 참조로 표시되는 반면 RDBMS는 외래 키(Foreign Key) 개념을 사용한다.   Java에서 양 방향 관계가 필요한 경우 참조를 두 번(양 방향으로) 정의해야한다.   마찬가지로 객체 도메인 모델을보 고 관계의 다중성을 확인할 수 없다.   Navigation, 탐색     Java에서 데이터에 액세스하는 방법은 관계형 데이터베이스에서 수행하는 방법과 근본적으로 다르다.   Java에서는 하나의 연결에서 다른 연결로 개체 네트워크를 탐색한다.   일반적으로 데이터베이스에서는 SQL 쿼리 수를 최소화하여 JOIN을 통해 여러 엔터티를 로드하고 원하는 대상 엔터티를 선택하는 방식으로 탐색한다.   Reference                 Blog-OOP &#8617;           ","categories": ["CS"],
        "tags": ["Programming","CS","ORM"],
        "url": "/cs/orm/",
        "teaser": null
      },{
        "title": "Internationalization(i18n) and Localization(l10n)",
        "excerpt":"Internationalization(I18N), 국제화     문화, 지역 또는 언어가 다양한 대상 고객을 위해 쉽게 L10N(현지화) 할 수 있는 디자인 및 개발이다.   소프트웨어의 국제화     번역, 문자 인코딩, 문자열 치환을 지원한다.   디자인의 국제화     소스 코드의 변경 없이도 다양한 언어/지역을 지원 할 수 있도록 처리해야 한다.   리소스의 국제화     언어/지역에 맞춰 가장 적절한 리소스를 준비해야한다.   Localization(L10N), 지역화     특정 목표 시장(국가)의 문화 및 기타 요구 사항을 충족시키는 작업이다.   LTR/RTL(쓰기 방향의 차이)  LTR    RTL     숫자, 화폐, 날짜 및 시간 형식  숫자                  국가       숫자 표기                       캐나다       1,234.00                 덴마크       1.234.567,00                 핀란드       1 234 567,00           화폐                  국가       통화       화폐 표기                       캐나다       $       $1,234.56                 덴마크       kr       Kr 1.234,56                 핀란드       €       €1 234,56           날짜                  국가       형식       날짜 표기                       캐나다       dd/mm/yy       24/03/21                 덴마크       yyyy-mm-dd       2021-03-24                 핀란드       dd.mm.yyyy       24.03.2021           UTC     문자열 정렬 방법     한국어 대한민국 표준어에서 사용되는 정렬 순서는 다음과 같다. 대개 가나다순이라고 한다.            초성: ㄱ ㄲ ㄴ ㄷ ㄸ ㄹ ㅁ ㅂ ㅃ ㅅ ㅆ ㅇ ㅈ ㅉ ㅊ ㅋ ㅌ ㅍ ㅎ       중성: ㅏ ㅐ ㅑ ㅒ ㅓ ㅔ ㅕ ㅖ ㅗ ㅘ ㅙ ㅚ ㅛ ㅜ ㅝ ㅞ ㅟ ㅠ ㅡ ㅢ ㅣ       종성: (없음) ㄱ ㄲ ㄳ ㄴ ㄵ ㄶ ㄷ ㄹ ㄺ ㄻ ㄼ ㄽ ㄾ ㄿ ㅀ ㅁ ㅂ ㅄ ㅅ ㅆ ㅇ ㅈ ㅊ ㅋ ㅌ ㅍ ㅎ           라틴 문자 기본적인 정렬 순서는 아래와 같고 모든 글자 사이에 Primary Difference가 있으나, 언어에 따라서 조금씩 차이가 있다.            A B C D E F G H I J K L M N O P Q R S T U V W X Y Z           키릴 문자 기본적인 정렬 순서는 아래와 같다. 각 글자 사이에 Primary Difference가 있으나, 언어에 따라서 조금씩 차이가 있다. Diacritic이 붙은 문자와 Diacritic이 붙지 않은 문자 사이에는 Secondary Difference가 있다.            А Б В Г Д Е Ж З И Й К Л М Н О П Р С Т У Ф Х Ц Ч Ш Щ Ъ Ы Ь Э Ю Я           개인 이름 및 주소 형식 처리 등  개인 이름     동아시아나 헝가리 등지에서는 이름 앞에 쓰고, 유럽(헝가리 제외)이나 중동, 터키, 인도, 아메리카에서는 뒤에 쓴다.   대부분의 문화권에서 성이 있지만 지금도 아랍인과 말레이인처럼 성이 없는 문화권이 있다.   주소 형식     우편번호  한국     2015년 8월 1일부터 국가기초구역에 부여된 5자리 구역번호인 국가기초구역번호를 우편번호로 사용한다.   일본     3자리의 발송용 번호와 4자리의 숫자를 이용한다. 〒100-0000은 도쿄도 지요다구의 우편번호이다.   미국     Postal code(postcode) 혹은 ZIP code라고 불리는 독자적인 형식의 우편번호 양식을 사용하고 있다.   일반적으로 5자리의 발송용 번호(ZIP)로 대표되는 지역을 세분화하여 4자리의 숫자를 추가할 수 있도록 해놓았다.   지역의 관습     용지 크기   전화 번호 형식   측정 시스템   배터리 크기   전압 및 전류 표준   다양한 법적 요건     개인 정보 보호 법률 준수   웹 사이트에 대한 추가 면책 조항   다양한 소비자 라벨링 요구 사항   수출 제한 준수 및 암호화   인터넷 검열 정권 또는 소환 절차   접근성에 대한 요구사항   세금 징수에 대한 규정(Ex. 판매 세 , 부가가치세 또는 관세)   지리적 명명 분쟁 및 &lt;87과 같은 다양한 정치적 문제에 대한 민감도&gt;분쟁 된 국경 지도에 표시 (Ex. 인도는 카슈미르 및 정부가 의도 한 기타 지역을 범죄로 표시하지 않는 논란이 있는 법안을 제안했다.)   Reference     NamuWiki-성씨   NamuWiki-정렬/순서   NaverBlog-세계의 주소 체계   Wikipedia-국제화 및 현지화  ","categories": ["CS"],
        "tags": ["Programming","CS","Internationalization","Localization"],
        "url": "/cs/internationalization/",
        "teaser": null
      },{
        "title": "REpresentational State Transfer(REST)",
        "excerpt":"REpresentational State Transfer(REST)     World Wide Web(WWW, W3)과 같은 분산 하이퍼미디어 시스템을 위한 Software Architecture의 한 형식이다.   RESTful     RESTful은 일반적으로 REST라는 Architecture를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어이다.   구조  Resource, 자원     Uniform Resource Identifier(URI)를 뜻한다.   모든 자원에 Server에 고유한 ID로 존재한다.   각 자원은 ‘/cs/{subject}’ 형식으로 구성된다.   Verb, 행위     Client는 URI를 이용해 Resource를 제공하기 위해 HTTP Method를 사용한다.   Representation of Resource, 표현     Request에 대한 모든 Response에 해당한다.   Request에 대한 Response 주체의 상태를 HTTP Status로 제공한다.   HTML, XML, JSON 등 Format의 Payload로 Request에 대한 응답을 Response Body를 제공한다.   Response에 대한 상세 정보를 Response Header에 담아 제공한다. (Ex. API Key, …)   규칙     Uniform Resource Identifier(URI)는 정보(Information)의 자원(Resource)을 표현(Representation of Resource)해야 한다.   자원(Resource)에 대한 행위(Verb)는 HTTP Method으로 표현해야 한다.   특징  Uniform Interface, 일관된 인터페이스  Resource identification in requests, 요청에 대한 리소스 식별     개별 Resource는 Request에서 식별된다.   예를 들어 RESTful 웹 서비스에서 URI를 사용한다.   Resource manipulation through representations, 표현을 통한 리소스 식별     Client는 연결된 메타데이터를 포함하여 자원의 표현(Representation of Resource)을 보유하면 Resource 상태를 수정하거나 삭제할 수 있는 충분한 정보를 보유한다.   Self-descriptive messages, 자기 설명 메시지     각 메시지에는 메시지 처리 방법을 설명하는 데 필요한 충분한 정보가 포함되어 있다.   예를 들어 미디어 유형에 따라 호출할 파서를 지정할 수 있다   Hypermedia as the engine of application state[HATEOAS], 애플리케이션 상태의 엔진으로서의 하이퍼미디어     REST Application의 초기 URI에 액세스한 REST Client는 Server에서 제공하는 링크를 동적으로 사용하여 필요한 모든 Resource를 검색할 수 있어야한다.   액세스가 진행되면 Server는 현재 사용 가능한 다른 Resource에 대한 하이퍼링크가 포함된 텍스트로 응답한다.   Stateless, 무상태성     각 Request에 대한 상태 정보를 Server에 저장하지 않는다.   Cacheable, 캐시 가능     World Wide Web에서와 같이 Client는 Response를 캐싱할 수 있어야 한다.   잘 관리되는 캐싱은 Client-Server의 상호작용을 부분적으로 또는 완전하게 제거하여 Scalability와 성능을 향상시킨다.   Layered System, 계층형 구조     Client는 Server에 직접적으로 연결되었는지, Intermediary Servers를 이용하여 간접적으로 연결되었는지 확인이 불가능하다.   Intermediary Servers의 경우, Load Balancing과 Schared Chaches 기능을 제공함으로써 시스템 규모 확장성을 향상시키는데 유용하다.   Client-Server     Architecture를 단순화, 분리함으로써 Client-Server의 의존성이 줄어든다.   User Interface와 Data Storage 문제를 분리하면 여러 플랫폼에서 User Interface의 이식성이 향상된다.   Code on demand(Optional)     Server에서 코드 전송으로 Client에서 실행 가능해야한다.(EX. Java applet, Js, …)   장점     HTTP Protocol의 인프라를 그대로 사용하므로 REST API사용을 위한 별도의 인프라를 구축할 필요가 없다.   HTTP Standard Protocol에 따르는 모든 Platform에서 사용이 가능하다.   REST API 메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악할 수 있다.   Server와 Client의 역할을 명확하게 분리한다.   단점     REST API의 표준이 존재하지 않는다.   HTTP Method가 제한적이다.   Reference  Wiki-REST  ","categories": ["CS"],
        "tags": ["Programming","CS","REST"],
        "url": "/cs/rest/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Business Delegate Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Business Delegate Pattern     Java EE 디자인 패턴이다.   프레젠테이션 계층과 비즈니스 계층을 분리하여 결합을 줄이고 서비스의 세부 구현 정보를 캡슐화 하는데 사용된다.   기본적으로 프레젠테이션 계층 코드에서 비즈니스 계층 코드에 대한 통신 또는 원격 조회 기능을 줄이는 데 사용된다.   Example  public interface BusinessService {    public void doProcessing();  } public class DefaultService implements BusinessService {    @Override   public void doProcessing() {     System.out.println(\"Processing task by invoking Default Service\");   }  } public class EJBService implements BusinessService {    @Override   public void doProcessing() {     System.out.println(\"Processing task by invoking EJB Service\");   }  } public class JMSService implements BusinessService {    @Override   public void doProcessing() {     System.out.println(\"Processing task by invoking JMS Service\");   }  }      BusinessService 인터페이스와 이의 구현체인 DefaultService, EJBService, JMSService를 정의한다.   public enum ServiceType {   EJB, JMS; } public class BusinessDelegate {    private BusinessLookUp lookupService = new BusinessLookUp();   private BusinessService businessService;   private ServiceType serviceType;    public void setServiceType(ServiceType serviceType) {     this.serviceType = serviceType;   }    public void doTask() {     businessService = lookupService.getBusinessService(serviceType);     businessService.doProcessing();   }  } public class BusinessLookUp {    public BusinessService getBusinessService(ServiceType serviceType) {     switch (serviceType) {       case EJB:         return new EJBService();       case JMS:         return new JMSService();       default:         return new DefaultService();     }   }  }      BusinessService를 특정 ServiceType에 맞게 실행 가능하도록 BusinessDelegate를 정의한다.   BusinessLookUp 클래스는 ServiceType 별 BusinessService를 호출하는 역할을 담당한다.   public class Client {    BusinessDelegate businessDelegate;    public Client(BusinessDelegate businessDelegate) {     this.businessDelegate = businessDelegate;   }    public void doTask() {     businessDelegate.doTask();   }  }      Client는 BusinessDelegate를 활용하여 Business를 수행할 수 있도록 구현한다.   public class BusinessDelegatePatternMain {    public static void main(String[] args) {      BusinessDelegate businessDelegate = new BusinessDelegate();     businessDelegate.setServiceType(ServiceType.EJB);      Client client = new Client(businessDelegate);     client.doTask();      businessDelegate.setServiceType(ServiceType.JMS);     client.doTask();   }  }      ServiceType을 변경하면서 Client의 doTask() 메서드를 호출해본다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern"],
        "url": "/designpattern/businessDelegate/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Composite Entity Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Composite Entity Pattern     EJB Persistence Mechanism에서 사용되는 디자인 패턴이다.   Composite Entity는 객체의 그래프를 나타내는 EJB Entity Bean이다.   Composite Entity가 업데이트되면 내부적으로 종속된 Bean이 EJB Entity에 의해 관리되어 자동으로 업데이트된다.   Example  public class DependentObject1 {    private String data;    public void setData(String data) {     this.data = data;   }    public String getData() {     return this.data;   }  } public class DependentObject2 {    private String data;    public void setData(String data) {     this.data = data;   }    public String getData() {     return this.data;   }  }      종속된 Bean을 담당할 두 DependentObject1, DependentObject2를 정의한다.   public class CoarseGrainedObject {    DependentObject1 do1 = new DependentObject1();   DependentObject2 do2 = new DependentObject2();    public void setData(String data1, String data2) {     do1.setData(data1);     do2.setData(data2);   }    public String[] getData() {     return new String[] { do1.getData(), do2.getData() };   }  } public class CompositeEntity {    private CoarseGrainedObject cgo = new CoarseGrainedObject();    public void setData(String data1, String data2) {     cgo.setData(data1, data2);   }    public String[] getData() {     return cgo.getData();   }  }      CoarseGrainedObject를 통해 자체 수명주기가있는 개체로 다른 개체에 대한 자체 관계를 관리한다.   CompositeEntity는 CoarseGrainedObject이거나 CoarseGrainedObject를 참조 할 수 있는 객체이다.   public class Client {    private CompositeEntity compositeEntity = new CompositeEntity();    public void printData() {     for (int i = 0; i &lt; compositeEntity.getData().length; i++) {       System.out.println(\"Data: \" + compositeEntity.getData()[i]);     }   }    public void setData(String data1, String data2) {     compositeEntity.setData(data1, data2);   }  }      CompositeEntity를 사용하는 Client를 정의한다.   public class CompositeEntityPatternMain {    public static void main(String[] args) {     Client client = new Client();     client.setData(\"Test\", \"Data\");     client.printData();      client.setData(\"Second Test\", \"Data1\");     client.printData();   }  }      Client를 이용하여 Composite Entity Pattern을 확인한다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern"],
        "url": "/designpattern/compositeEntity/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Data Access Object Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Data Access Object Pattern     DAO 패턴이라고도 불린다.   API 또는 작업에 액세스하는 하위 수준의 데이터를 상위 수준의 비즈니스 서비스에서 분리하는 데 사용된다.   Example  public class Student {    private String name;   private int rollNo;    Student(String name, int rollNo) {     this.name = name;     this.rollNo = rollNo;   }    public String getName() {     return name;   }    public void setName(String name) {     this.name = name;   }    public int getRollNo() {     return rollNo;   }    public void setRollNo(int rollNo) {     this.rollNo = rollNo;   }  }      Student DTO객체를 정의한다.   public interface StudentDao {    public List&lt;Student&gt; getAllStudents();    public Student getStudent(int rollNo);    public void updateStudent(Student student);    public void deleteStudent(Student student);  } public class StudentDaoImpl implements StudentDao {    // List is working as a database.   List&lt;Student&gt; students;    public StudentDaoImpl() {     students = new ArrayList&lt;Student&gt;();     Student student1 = new Student(\"Robert\", 0);     Student student2 = new Student(\"John\", 1);     students.add(student1);     students.add(student2);   }    @Override   public void deleteStudent(Student student) {     students.remove(student.getRollNo());     System.out.println(\"Student: Roll No \" + student.getRollNo() + \", deleted from database\");   }    // Retrieve list of students from the database.   @Override   public List&lt;Student&gt; getAllStudents() {     return students;   }    @Override   public Student getStudent(int rollNo) {     return students.get(rollNo);   }    @Override   public void updateStudent(Student student) {     students.get(student.getRollNo()).setName(student.getName());     System.out.println(\"Student: Roll No \" + student.getRollNo() + \", updated in the database\");   }  }      Student 관련 기능을 제공할 StudentDao 인터페이스를 정의하고, 세부 기능을 구현한 StudentDaoImpl 클래스를 정의한다.   public class DaoPatternMain {    public static void main(String[] args) {     StudentDao studentDao = new StudentDaoImpl();      // Print all students.     for (Student student : studentDao.getAllStudents()) {       System.out.println(\"Student: [RollNo : \" + student.getRollNo() + \", Name : \" + student.getName() + \" ]\");     }      // Update student.     Student student = studentDao.getAllStudents().get(0);     student.setName(\"Michael\");     studentDao.updateStudent(student);      // Get the student.     studentDao.getStudent(0);     System.out.println(\"Student: [RollNo : \" + student.getRollNo() + \", Name : \" + student.getName() + \" ]\");   }  }      StudentDao를 활용하여 기능을 수행해본다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern"],
        "url": "/designpattern/dataAccessObject/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Front Controller Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Front Controller Pattern     모든 요청이 단일 핸들러로 처리되도록 중앙 집중식 요청 처리 메커니즘을 제공하는 데 사용된다.   이 핸들러는 요청의 인증/권한/로깅 또는 추적을 수행한 다음 요청을 해당 핸들러로 전달할 수 있다.   Example  public class HomeView {    public void show() {     System.out.println(\"Displaying Home Page\");   }  } public class StudentView {    public void show() {     System.out.println(\"Displaying Student Page\");   }  }      View의 역할을 할 HomeView와 StudentView를 구현한다.   public class Dispatcher {    private StudentView studentView;   private HomeView homeView;    public Dispatcher() {     this.studentView = new StudentView();     this.homeView = new HomeView();   }    public void dispatch(Request request) {     if (Request.STUDENT.equals(request)) {       this.studentView.show();     } else {       homeView.show();     }   }  }      Dispatcher를 통해 Request에 대한 View를 제공하도록 처리한다.   public class FrontController {    private Dispatcher dispatcher;    public FrontController() {     this.dispatcher = new Dispatcher();   }    private boolean isAuthenticUser() {     System.out.println(\"User is authenticated successfully.\");     return true;   }    private void trackRequest(Request request) {     System.out.println(\"Page requested: \" + request.name());   }    public void dispatchRequest(Request request) {     // Long each request.     trackRequest(request);     // Authenticate the user.     if (isAuthenticUser()) {       dispatcher.dispatch(request);     }   }  }      FrontController에서는 Request에 대한 권한 관리와 로깅을 수행한다.   public class FrontControllerPatternMain {    public static void main(String[] args) {     FrontController frontController = new FrontController();     frontController.dispatchRequest(Request.HOME);     frontController.dispatchRequest(Request.STUDENT);   }  }      Request를 통해 각 요청을 수행해본다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern"],
        "url": "/designpattern/frontController/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Filter Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Structural Patterns, 구조 패턴     클래스와 객체를 더 큰 결과물로 합칠 수 있는 구조로 설계하는 패턴이다.   서로 다른 인터페이스를 지닌 여러 개의 객체를 조합하여 단일 인터페이스를 제공하거나, 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.   Filter Pattern     다양한 기준을 사용하여 객체 집합을 필터링하고 논리적 작업을 통해 분리된 방식으로 연결할 수 있도록하는 패턴이다.   Example  public enum Gender {   MALE, FEMALE } public enum MaritalStatus {   SINGLE, MARRIED } public class Person {    private String name;   private String gender;   private String maritalStatus;    public Person(String name, String gender, String maritalStatus) {     this.name = name;     this.gender = gender;     this.maritalStatus = maritalStatus;   }    public String getName() {     return name;   }    public String getGender() {     return gender;   }    public String getMaritalStatus() {     return maritalStatus;   }  }      Filter Pattern을 적용할 Person 객체를 선언한다.   public interface Criteria {    public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons);  }      결합 조건과 단일 조건을 위한 Criteria 인터페이스를 구현한다.   public class CriteriaMale implements Criteria {    @Override   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {     List&lt;Person&gt; malePersons = new ArrayList&lt;Person&gt;();      for (Person person : persons) {       if (Gender.MALE.equals(person.getGender())) {         malePersons.add(person);       }     }     return malePersons;   }  } public class CriteriaFemale implements Criteria {    @Override   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {     List&lt;Person&gt; femalePersons = new ArrayList&lt;Person&gt;();     for (Person person : persons) {       if (Gender.FEMALE.equals(person.getGender())) {         femalePersons.add(person);       }     }     return femalePersons;   }  } public class CriteriaSingle implements Criteria {    @Override   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {     List&lt;Person&gt; singlePersons = new ArrayList&lt;Person&gt;();     for (Person person : persons) {       if (MaritalStatus.SINGLE.equals(person.getMaritalStatus())) {         singlePersons.add(person);       }     }     return singlePersons;   }  } public class CriteriaMarried implements Criteria {    @Override   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {     List&lt;Person&gt; singlePersons = new ArrayList&lt;Person&gt;();     for (Person person : persons) {       if (MaritalStatus.MARRIED.equals(person.getMaritalStatus())) {         singlePersons.add(person);       }     }     return singlePersons;   }  }      Gender와 MaritalStatus 별 단일 조건을 수행하기 위한 CriteriaMale, CriteriaFemale, CriteriaSingle, CriteriaMarried 클래스를 구현한다.   public class AndCriteria implements Criteria {    private Criteria criteria;   private Criteria otherCriteria;    public AndCriteria(Criteria criteria, Criteria otherCriteria) {     this.criteria = criteria;     this.otherCriteria = otherCriteria;   }    @Override   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {     List&lt;Person&gt; firstCriteriaPersons = criteria.meetCriteria(persons);     return otherCriteria.meetCriteria(firstCriteriaPersons);   }  } public class OrCriteria implements Criteria {    private Criteria criteria;   private Criteria otherCriteria;    public OrCriteria(Criteria criteria, Criteria otherCriteria) {     this.criteria = criteria;     this.otherCriteria = otherCriteria;   }    @Override   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {     List&lt;Person&gt; firstCriteriaItems = criteria.meetCriteria(persons);     List&lt;Person&gt; otherCriteriaItems = otherCriteria.meetCriteria(persons);      for (Person person : otherCriteriaItems) {       if (!firstCriteriaItems.contains(person)) {         firstCriteriaItems.add(person);       }     }     return firstCriteriaItems;   }  }      두 가지 조건으로 결합하여 조건을 수행하기 위한 AndCriteria와 OrCriteria를 구현한다.   public class CriteriaPatternMain {    public static void main(String[] args) {     List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;();      persons.add(new Person(\"Robert\", Gender.MALE, MaritalStatus.SINGLE));     persons.add(new Person(\"John\", Gender.MALE, MaritalStatus.MARRIED));     persons.add(new Person(\"Laura\", Gender.FEMALE, MaritalStatus.MARRIED));     persons.add(new Person(\"Diana\", Gender.FEMALE, MaritalStatus.SINGLE));     persons.add(new Person(\"Mike\", Gender.MALE, MaritalStatus.SINGLE));     persons.add(new Person(\"Bobby\", Gender.MALE, MaritalStatus.SINGLE));      Criteria male = new CriteriaMale();     Criteria female = new CriteriaFemale();     Criteria single = new CriteriaSingle();     Criteria singleMale = new AndCriteria(single, male);     Criteria singleOrFemale = new OrCriteria(single, female);      System.out.println(\"Males: \");     printPersons(male.meetCriteria(persons));      System.out.println(\"Females: \");     printPersons(female.meetCriteria(persons));      System.out.println(\"Single Males: \");     printPersons(singleMale.meetCriteria(persons));      System.out.println(\"Single Or Females: \");     printPersons(singleOrFemale.meetCriteria(persons));   }    public static void printPersons(List&lt;Person&gt; persons) {     for (Person person : persons) {       System.out.println(\"Person : [ Name : \" + person.getName() + \", Gender : \" + person.getGender()           + \", Marital Status : \" + person.getMaritalStatus() + \" ]\");     }   }  }      각 독립적인 속성을 조건을 활용하여 분류가 가능하며, 조합도 가능하다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern","Structural Patterns"],
        "url": "/designpattern/filter/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Intercepting Filter Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Intercepting Filter Pattern     응용 프로그램의 Request나 Response의 전/후 처리를 하고자 할 때 사용된다.   실제 대상 응용 프로그램에 요청을 전달하기 전에 필터가 정의되고 요청에 적용된다.   필터는 인증/승인/로그인 또는 요청의 추적 작업을 수행한 다음 해당 처리기에 요청을 전달할 수 있다.   Example  public interface Filter {    public void execute(String request);  } public class DebugFilter implements Filter {    public void execute(String request) {     System.out.println(\"Request log: \" + request);   }  } public class AuthenticationFilter implements Filter {    public void execute(String request) {     System.out.println(\"Authenticating request: \" + request);   }  }      Filter 인터페이스를 정의하고 디버깅과 인증을 위한 DebugFilter, AuthenticationFilter 클래스를 정의한다.   public class Target {    public void execute(String request) {     System.out.println(\"Executing request: \" + request);   }  }      Intercepting Filter Pattern의 목표가 되는 Target 클래스를 정의한다.   public class FilterChain {    private List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();   private Target target;    public void addFilter(Filter filter) {     filters.add(filter);   }    public void execute(String request) {     for (Filter filter : filters) {       filter.execute(request);     }     this.target.execute(request);   }    public void setTarget(Target target) {     this.target = target;   }  } public class FilterManager {    FilterChain filterChain;    public FilterManager(Target target) {     this.filterChain = new FilterChain();     this.filterChain.setTarget(target);   }    public void setFilter(Filter filter) {     this.filterChain.addFilter(filter);   }    public void filterRequest(String request) {     this.filterChain.execute(request);   }  }      Filter를 관리하고 전처리를 하기 위한 FilterChain 클래스를 정의한다.   필터 처리를 관리하고 적절한 필터를 사용하여 올바른 순서로 FilterChain을 생성하고 처리를 시작하는 FilterManager 클래스를 정의한다.   public class Client {    FilterManager filterManager;    public void setFilterManager(FilterManager filterManager) {     this.filterManager = filterManager;   }    public void sendRequest(String request) {     this.filterManager.filterRequest(request);   }  }      FilterManager를 관리하고 적용 할 수 있는 Client 클래스를 정의한다.   public class InterceptingFilterMain {    public static void main(String[] args) {     FilterManager filterManager = new FilterManager(new Target());     filterManager.setFilter(new AuthenticationFilter());     filterManager.setFilter(new DebugFilter());      Client client = new Client();     client.setFilterManager(filterManager);     client.sendRequest(\"HOME\");   }  }      FilterManager 객체를 생성하여 Client 객체에 적용하여 요청을 수행해본다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern"],
        "url": "/designpattern/interceptingFilter/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Model-View-Controller(MVC) Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Model-View-Controller(MVC) Pattern     사용자 인터페이스로부터 비즈니스 로직을 분리하여 애플리케이션의 시각적 요소나 그 이면에서 실행되는 비즈니스 로직을 서로 영향 없이 쉽게 고칠 수 있는 애플리케이션을 만들 기 위해 사용한다.   Example  public class Student {    private String rollNo;   private String name;    public String getRollNo() {     return rollNo;   }    public void setRollNo(String rollNo) {     this.rollNo = rollNo;   }    public String getName() {     return name;   }    public void setName(String name) {     this.name = name;   }  }      데이터의 구조인 Student 클래스를 정의한다.   public class StudentView {    public void printStudentDetails(String studentName, String studentRollNo) {     System.out.println(\"Student: \");     System.out.println(\"Name: \" + studentName);     System.out.println(\"Roll No: \" + studentRollNo);   }  }      데이터의 시각화 역할을 수행할 StudentView 클래스를 정의한다.   public class StudentController {    private Student model;   private StudentView view;    public StudentController(Student model, StudentView view) {     this.model = model;     this.view = view;   }    public void setStudentName(String name) {     model.setName(name);   }    public String getStudentName() {     return model.getName();   }    public void setStudentRollNo(String rollNo) {     model.setRollNo(rollNo);   }    public String getStudentRollNo() {     return model.getRollNo();   }    public void updateView() {     view.printStudentDetails(model.getName(), model.getRollNo());   }  }      View와 Model을 이어줄 수 있는 StudentController 클래스를 정의한다.   public class MVCPatternMain {    public static void main(String[] args) {     // Fetch student record based on his roll no from the database.     Student model = retriveStudentFromDatabase();      // Create a view : to write student details on console.     StudentView view = new StudentView();      StudentController controller = new StudentController(model, view);     controller.updateView();      // Update model data.     controller.setStudentName(\"John\");     controller.updateView();   }    private static Student retriveStudentFromDatabase() {     Student student = new Student();     student.setName(\"Robert\");     student.setRollNo(\"10\");     return student;   }  }      Controller 객체에 View와 Model 객체를 주입하여 기능을 수행해본다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern"],
        "url": "/designpattern/mvc/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Null Object Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Null Object Pattern     NULL Object 인스턴스의 검사를 대체하여 사용 및 동작을 설명한다.   Example  public abstract class AbstractCustomer {    protected String name;    public abstract boolean isNil();    public abstract String getName();  } public class NullCustomer extends AbstractCustomer {    @Override   public String getName() {     return \"NotAvailable in Customer Database\";   }    @Override   public boolean isNil() {     return true;   }  } public class RealCustomer extends AbstractCustomer {    public RealCustomer(String name) {     this.name = name;   }    @Override   public String getName() {     return name;   }    @Override   public boolean isNil() {     return false;   }  }      AbstractCustomer 인터페이스를 정의하고, 고객의 정보를 담을 수 있는 RealCustomer 클래스와 고객의 정보가 없을 때 반환할 NullCustomer 클래스를 정의한다.   public class CustomerFactory {    public static final String[] names = { \"Rob\", \"Joe\", \"Julie\" };    public static AbstractCustomer getCustomer(String name) {     for (int i = 0; i &lt; names.length; i++) {       if (names[i].equalsIgnoreCase(name)) {         return new RealCustomer(name);       }     }     return new NullCustomer();   }  }      고객 정보를 보관하고 가져올 수 있는 Persistence Layer 역할을 담당할 CustomerFactory 클래스를 정의한다.   public class NullPatternMain {    public static void main(String[] args) {     AbstractCustomer customer1 = CustomerFactory.getCustomer(\"Rob\");     AbstractCustomer customer2 = CustomerFactory.getCustomer(\"Bob\");     AbstractCustomer customer3 = CustomerFactory.getCustomer(\"Julie\");     AbstractCustomer customer4 = CustomerFactory.getCustomer(\"Laura\");      System.out.println(\"Customers\");     System.out.println(customer1.getName());     System.out.println(customer2.getName());     System.out.println(customer3.getName());     System.out.println(customer4.getName());   }  }      CustomerFactory 클래스에 저장된 이름을 포함하여 다양한 이름으로 고객 정보를 조회해본다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern"],
        "url": "/designpattern/nullObject/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Service Locator Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Service Locator Pattern     JNDI 조회를 사용하여 다양한 서비스를 찾고자 할 때 사용된다.   서비스에 대한 JNDI를 찾는 데 드는 높은 비용을 고려하여 캐싱 기술을 사용한다.   Service Locator를 통한 추가 조회 또는 동일한 서비스가 캐쉬에서 수행되므로 애플리케이션 성능이 크게 향상된다.   Example  public interface Service {    public String getName();    public void execute();  } public class Service1 implements Service {    public void execute() {     System.out.println(\"Executing Service1\");   }    @Override   public String getName() {     return \"Service1\";   }  } public class Service2 implements Service {    public void execute() {     System.out.println(\"Executing Service2\");   }    @Override   public String getName() {     return \"Service2\";   }  }      다양한 서비스를 제공하기 위해 Service 인터페이스를 정의하고, Service1과 Service2 클래스를 정의한다.   public class Cache {    private List&lt;Service&gt; services;    public Cache() {     services = new ArrayList&lt;Service&gt;();   }    public Service getService(String serviceName) {     for (Service service : services) {       if (service.getName().equalsIgnoreCase(serviceName)) {         System.out.println(\"Returning cached  \" + serviceName + \" object\");         return service;       }     }     return null;   }    public void addService(Service newService) {     boolean exists = false;     for (Service service : services) {       if (service.getName().equalsIgnoreCase(newService.getName())) {         exists = true;       }     }     if (!exists) {       services.add(newService);     }   } }      Service들을 캐싱하여 저장 및 제공할 Cache 클래스를 정의한다.   public class InitialContext {    public Object lookup(String jndiName) {     switch (jndiName) {       case \"SERVICE1\":         System.out.println(\"Looking up and creating a new Service1 object\");         return new Service1();       case \"SERVICE2\":         System.out.println(\"Looking up and creating a new Service2 object\");         return new Service2();       default:         return null;     }   }  }      Service를 확인하여 제공할 InitialContext 클래스를 정의한다.   public class ServiceLocator {    private static Cache cache = new Cache();   private static InitialContext context = new InitialContext();    public static Service getService(String jndiName) {     Service service = cache.getService(jndiName);     if (service != null) {       return service;     } else {       Service service1 = (Service) context.lookup(jndiName);       cache.addService(service1);       return service1;     }   }  }      Service를 제공할 때 캐싱 기능을 사용하는 ServiceLocator 클래스를 정의한다.   public class ServiceLocatorpatternMain {    public static void main(String[] args) {     Service service = ServiceLocator.getService(\"Service1\");     service.execute();     service = ServiceLocator.getService(\"Service2\");     service.execute();     service = ServiceLocator.getService(\"Service1\");     service.execute();     service = ServiceLocator.getService(\"Service2\");     service.execute();   }  }      정의된 각 서비스들을 호출해본다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern"],
        "url": "/designpattern/serviceLocator/",
        "teaser": null
      },{
        "title": "Java Design Pattern - Transfer Object Pattern",
        "excerpt":"Design Pattern     과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다.   디자인 패턴은 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론일 뿐이며 모든 상황의 해결책이 아니다.   Transfer Object Pattern     여러 속성을 가진 데이터를 Client에서 Server로 한 번에 전달할 때 사용된다.   Example  public class StudentVO {    private String name;   private int rollNo;    StudentVO(String name, int rollNo) {     this.name = name;     this.rollNo = rollNo;   }    public String getName() {     return name;   }    public void setName(String name) {     this.name = name;   }    public int getRollNo() {     return rollNo;   }    public void setRollNo(int rollNo) {     this.rollNo = rollNo;   }  }      Value Object 역할을 수행할 StudentVO 클래스를 정의한다.   public class StudentBO {    // List is working as a database.   List&lt;StudentVO&gt; students;    public StudentBO() {     students = new ArrayList&lt;StudentVO&gt;();     StudentVO student1 = new StudentVO(\"Robert\", 0);     StudentVO student2 = new StudentVO(\"John\", 1);     students.add(student1);     students.add(student2);   }    public void deleteStudent(StudentVO student) {     students.remove(student.getRollNo());     System.out.println(\"Student: Roll No \" + student.getRollNo() + \", deleted from database\");   }    // Retrieve list of student from the database.   public List&lt;StudentVO&gt; getAllStudents() {     return students;   }    public StudentVO getStudent(int rollNo) {     return students.get(rollNo);   }    public void updateStudent(StudentVO student) {     students.get(student.getRollNo());     System.out.println(\"Student: Roll No \" + student.getRollNo() + \", updated from database\");   }  }      Business Object 역할을 담당하는 StudentBO 클래스를 정의한다.   public class TransferObjectPatternMain {    public static void main(String[] args) {     StudentBO studentBusinessObject = new StudentBO();      // Print all students.     for (StudentVO student : studentBusinessObject.getAllStudents()) {       System.out.println(\"Student: [RollNo : \" + student.getRollNo() + \", Name : \" + student.getName() + \" ]\");     }      // Update student.     StudentVO student = studentBusinessObject.getAllStudents().get(0);     student.setName(\"Michael\");     studentBusinessObject.updateStudent(student);      // Get the student.     student = studentBusinessObject.getStudent(0);     System.out.println(\"Student: [RollNo : \" + student.getRollNo() + \", Name : \" + student.getName() + \" ]\");   }  }      StudentBO 객체를 사용하여 StudentVO를 조회 및 수정을 해본다.   Source  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["DesignPattern"],
        "tags": ["Programming","Java","DesignPattern"],
        "url": "/designpattern/transferObject/",
        "teaser": null
      },{
        "title": "Database Normalization",
        "excerpt":"Normalization     관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스이다.   데이터베이스 정규화의 목표는 이상(Anomaly)이 있는 관계를 재구성하여 작고 잘 조직된 관계를 생성하는 것에 있다.   목적     중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 방지한다.   각 릴레이션에 중복된 종속성을 여러 개의 릴레이션에 분할한다.   어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하게 한다.   데이터 삽입 시 릴레이션을 재구성할 필요성을 감소시킨다.   효과적인 검색 알고리즘을 생성 가능하게 한다.   Anomaly, 이상     충분히 정규화되지 않은 테이블에서 테이블을 수정(갱신, 삽입, 삭제)시, 원치 않던 부작용이 발생하는 것이다.   Update Anomaly, 갱신 이상       튜플 수정 시 중복된 데이터의 일부만 수정되어 일어나는 데이터 불일치 현상이다.   Insertion Anomaly, 삽입 이상       튜플 삽입 시 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 현상이다.   Deletion Anomaly, 삭제 이상       튜플 삭제 시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상이다.   과정       비공식적으로 “관계형 데이터베이스 테이블(컴퓨터 공학적 표현으로는 관계)이 제 3정규(3NF)화가 되었으면 정규화 되었다.”라고 한다.   일반적으로 2002년에 소개된 6NF는 정규화 대상에서 제외된다.   1NF                  Customer ID       First Name       Surname       Telephone Number                       123       Pooja       Singh       555-861-2025, 192-122-1111                 456       San       Zhang       (555) 403-1659 Ext. 53; 182-929-2929                 789       John       Doe       555-808-9633              위의 도표에서 Telephone Number는 한 컬럼에 단일 값(원자값)이 아니다.                  Customer ID       First Name       Surname       Telephone Number1       Telephone Number2                       123       Pooja       Singh       555-861-2025       192-122-1111                 456       San       Zhang       (555) 403-1659 Ext. 53       182-929-2929                 789       John       Doe       555-808-9633                      컬럼을 분리하여 단일 값이 들어가도록 수정하였다.   2NF                  Manufacturer       Model       Model full name       Manufacturer country                       Forte       X-Prime       Forte X-Prime       Italy                 Forte       Ultraclean       Forte Ultraclean       Italy                 Dent-o-Fresh       EZbrush       Dent-o-Fresh EZbrush       USA                 Brushmaster       SuperBrush       Brushmaster SuperBrush       USA                 Kobayashi       ST-60       Kobayashi ST-60       Japan                 Hoch       Toothmaster       Hoch Toothmaster       Germany                 Hoch       X-Prime       Hoch X-Prime       Germany              기본 키를 Model full name으로 지정했더라도 다른 후보 키인 Manufacturer, Model이 있기 때문에 2NF를 위반한다.                  Manufacturer       Manufacturer country                       Forte       Italy                 Dent-o-Fresh       USA                 Brushmaster       USA                 Kobayashi       Japan                 Hoch       Germany                 Electric       toothbrush models                          Manufacturer       Model       Model full name                       Forte       X-Prime       Forte X-Prime                 Forte       Ultraclean       Forte Ultraclean                 Dent-o-Fresh       EZbrush       Dent-o-Fresh EZbrush                 Brushmaster       SuperBrush       Brushmaster SuperBrush                 Kobayashi       ST-60       Kobayashi ST-60                 Hoch       Toothmaster       Hoch Toothmaster                 Hoch       X-Prime       Hoch X-Prime              테이블을 두 개로 분리하여 부분적 함수 종속을 제거한다.   3NF                  Tournament       Year       Winner       Winner’s date of birth                       Indiana Invitational       1998       Al Fredrickson       21 July 1975                 Cleveland Open       1999       Bob Albertson       28 September 1968                 Des Moines Masters       1999       Al Fredrickson       21 July 1975                 Indiana Invitational       1999       Chip Masterson       14 March 1977              복합 키 (Tournament, Year)는 행을 고유하게 식별 할 수 있는 테이블의 후보 키이다.   Winner’s date of birth가 Winner에 의존한다는 사실은 동일한 사람이 다른 기록에 생년월일이 다르게 기입되는 것을 막을 수 없기 때문에 테이블이 논리적 불일치에 취약하게 만들어 3NF를 위반한다.                  Tournament       Year       Winner                       Indiana Invitational       1998       Al Fredrickson                 Cleveland Open       1999       Bob Albertson                 Des Moines Masters       1999       Al Fredrickson                 Indiana Invitational       1999       Chip Masterson                          Winner       Date of birth                       Chip Masterson       14 March 1977                 Al Fredrickson       21 July 1975                 Bob Albertson       28 September 1968              테이블을 두 개로 분리하여 Winner의 Date of birth가 다르게 기입이 불가능하므로, 이행적 함수 종속을 제거한다.   BCNF                  Court       Start time       End time       Rate type                       1       09:30       10:30       SAVER                 1       11:00       12:00       SAVER                 1       14:00       15:30       STANDARD                 2       10:00       11:30       PREMIUM-B                 2       11:30       13:30       PREMIUM-B                 2       15:00       16:30       PREMIUM-A              모든 속성은 어떤 후보 키에 속하므로 2NF와 3NF를 모두 준수한다.                  Rate type       Court Member       flag                       SAVER       1       Yes                 STANDARD       1       No                 PREMIUM-A       2       Yes                 PREMIUM-B       2       No                          Member flag       Court       Start time       End time                       Yes       1       09:30       10:30                 Yes       1       11:00       12:00                 No       1       14:00       15:30                 No       2       10:00       11:30                 No       2       11:30       13:30                 Yes       2       15:00       16:30              첫 테이블의 후보키는 Rate type 혹은 복합키인 (Court Member, flag)이다.   다음 테이블의 후보키는 복합키인 (Court, Start time) 혹은 (Court, End time)이다.   Rate type이 첫 테이블의 키인 경우, 두 개의 다른 Court와 연결할 수 없으므로 결정자이면서 후보키가 아닌 것이 제거된다.   4NF                  Restaurant       Pizza Variety       Delivery Area                       A1 Pizza       Thick Crust       Springfield                 A1 Pizza       Thick Crust       Shelbyville                 A1 Pizza       Thick Crust       Capital City                 A1 Pizza       Stuffed Crust       Springfield                 A1 Pizza       Stuffed Crust       Shelbyville                 A1 Pizza       Stuffed Crust       Capital City                 Elite Pizza       Thin Crust       Capital City                 Elite Pizza       Stuffed Crust       Capital City                 Vincenzo’s Pizza       Thick Crust       Springfield                 Vincenzo’s Pizza       Thick Crust       Shelbyville                 Vincenzo’s Pizza       Thin Crust       Springfield                 Vincenzo’s Pizza       Thin Crust       Shelbyville              테이블의 키가 Restaurant, Pizza Variant, Delivery Area뿐이므로 BCNF까지의 모든 정규 형식을 충족한다.   레스토랑이 제공하는 피자 품종이 배달 지역의 영향을 받지 않는다고 가정한다면 4NF를 충족하지 않는다.                  Restaurant       Pizza Variety                       A1 Pizza       Thick Crust                 A1 Pizza       Stuffed Crust                 Elite Pizza       Thin Crust                 Elite Pizza       Stuffed Crust                 Vincenzo’s Pizza       Thick Crust                 Vincenzo’s Pizza       Thin Crust                          Restaurant       Delivery Area                       A1 Pizza       Springfield                 A1 Pizza       Shelbyville                 A1 Pizza       Capital City                 Elite Pizza       Capital City                 Vincenzo’s Pizza       Springfield                 Vincenzo’s Pizza       Shelbyville              한 음식점에서 제공하는 피자 품종이 배달 지역마다 완전히 다르다면(다치 종속 관계를 제거한다면), 4NF를 만족시킬 것이다.   5NF                  Traveling Salesman       Brand       Product Type                       Jack Schneider       Acme       Vacuum Cleaner                 Jack Schneider       Acme       Breadbox                 Mary Jones       Robusto       Pruning Shears                 Mary Jones       Robusto       Vacuum Cleaner                 Mary Jones       Robusto       Breadbox                 Mary Jones       Robusto       Umbrella Stand                 Louis Ferguson       Robusto       Vacuum Cleaner                 Louis Ferguson       Robusto       Telescope                 Louis Ferguson       Acme       Vacuum Cleaner                 Louis Ferguson       Acme       Lava Lamp                 Louis Ferguson       Nimbus       Tie Rack              기본 키는 복합키인 (Traveling Salesman,  Brand, Product Type)이며, 다치 종속성이 없기 때문에 4NF를 만족한다.                  Traveling Salesman       Product Type                       Jack Schneider       Vacuum Cleaner                 Jack Schneider       Breadbox                 Mary Jones       Pruning Shears                 Mary Jones       Vacuum Cleaner                 Mary Jones       Breadbox                 Mary Jones       Umbrella Stand                 Louis Ferguson       Telescope                 Louis Ferguson       Vacuum Cleaner                 Louis Ferguson       Lava Lamp                 Louis Ferguson       Tie Rack                          Traveling Salesman       Brand                       Jack Schneider       Acme                 Mary Jones       Robusto                 Louis Ferguson       Robusto                 Louis Ferguson       Acme                 Louis Ferguson       Nimbus                          Brand       Product Type                       Acme       Vacuum Cleaner                 Acme       Breadbox                 Acme       Lava Lamp                 Robusto       Pruning Shears                 Robusto       Vacuum Cleaner                 Robusto       Breadbox                 Robusto       Umbrella Stand                 Robusto       Telescope                 Nimbus       Tie Rack              위 세 테이블 기반으로 보면 후보키를 통해서 조인 관계가 성립하므로, Louis Ferguson은 Acme가 만든 Vacuum Cleaner 뿐 아니라 Robusto가 만든 Vacuum Cleaner도 판매할 수 있다.   Reference     Wiki-Database_normalization   Wiki-First_normal_form   Wiki-Second_normal_form   Wiki-Third_normal_form   WIki-Boyce–Codd_normal_form   Wiki-Fourth_normal_form   Wiki-Fifth_normal_form  ","categories": ["Database"],
        "tags": ["Programming","Database","Normalization"],
        "url": "/database/normalization/",
        "teaser": null
      },{
        "title": "JSON Web Token(JWT)",
        "excerpt":"JSON Web Token(JWT)     당사자간에 JSON 객체로 가볍고 자가 수용적인 방식으로 정보를 안전하게 전송하기 위한 개방형 표준(RFC7519)이다.   JWT는 비밀(HMAC 알고리즘 사용) 또는 RSA 또는 ECDSA를 사용하는 공개/개인 키 쌍을 사용하여 서명할 수 있다.   장점  언어의 지원 폭이 넓다.     JAVA, JavaScript, Python, Ruby 등 다양한 언어에서 JWT를 지원하므로, 언어에 제한이 없이 사용이 가능하다.   자가 수용적이다.     자체적으로 필요한 모든 정보를 JSON 형태로 가지고 있다.   쉽게 전달 가능하다.     JSON은 XML보다 간결하며, 인코딩 될 때 크기도 작아지므로 HTML과 HTTP 환경에서 전송하기 좋다.   구조     Header     JWT를 어떻게 검증(Verify)하는가에 대한 내용을 담고있다.   {   \"alg\": \"HS256\",   \"typ\": \"JWT\" }   typ     토큰의 유형을 지정한다.   alg     서명 시 사용하는 해시 알고리즘을 지정한다.   Payload     토큰에 담을 클레임(Claim) 정보를 포함한다.   {   \"sub\": \"1234567890\",   \"name\": \"Grace\",   \"iat\": 1616769012 }   Registered Claim, 등록된 클레임     토큰에 대한 정보들을 담기 위하여 이름이 이미 정해진 클레임들이다.   대표적인 예로 iss(발행자), exp(만료 시간), sub(주제) 등이 있으며, 세부 항목은 여기에 정의되어 있다.   Public Claim, 공개 클레임     충돌이 방지된(Collision-Resistant) 이름을 가지고 있는 클레임들이다.   일반적으로 URI 형식으로 정의한다.   Private Claim, 비공개 클레임     양 측이 협의 하에 사용되는 클레임들이다.   Signature     헤더의 인코딩 값과 정보의 인코딩 값을 합친 후 주어진 비밀키로 해시하여 생성한다.   HMACSHA256(   base64UrlEncode(header) + \".\" +   base64UrlEncode(payload),   secretKey )   Reference     JWT-Home   Wiki-JSON_Web_Token  ","categories": ["CS"],
        "tags": ["Programming","CS","JWT"],
        "url": "/cs/jwt/",
        "teaser": null
      },{
        "title": "OAuth",
        "excerpt":"OAuth     인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수 있는 공통적인 수단으로서 사용된다.   접근 위임을 위한 개방형 표준[OAuth 1.0(RFC5849), OAuth 2.0(RFC6749)]이다.   용어  User, 사용자     서비스 제공자와 소비자를 사용하는 계정을 가지고 있는 개인이다.   Consumer, 소비자     Open API를 이용하여 개발된 OAuth를 사용하여 서비스 제공자에게 접근하는 웹사이트 또는 애플리케이션이다.   Service Provider, 서비스 제공자     OAuth를 통해 접근을 지원하는 웹 애플리케이션(Open API를 제공하는 서비스)이다.   Consumer Secret, 소비자 비밀번호     서비스 제공자에서 소비자가 자신임을 인증하기 위한 키이다.   Request Token, 요청 토큰     소비자가 사용자에게 접근권한을 인증받기 위해 필요한 정보가 담겨있으며 후에 접근 토큰으로 변환된다.   Access Token, 접근 토큰     인증 후에 사용자가 서비스 제공자가 아닌 소비자를 통해서 보호된 자원에 접근하기 위한 키를 포함한 값이다.   인증 방식        소비자가 서비스 제공자에게 요청토큰을 요청한다.   서비스 제공자가 소비자에게 요청토큰을 발급해준다.   소비자가 사용자를 서비스 제공자로 이동시킨다. 여기서 사용자 인증이 수행된다.   서비스 제공자가 사용자를 소비자로 이동시킨다.   소비자가 접근 토큰을 요청한다.   서비스 제공자가 접근 토큰을 발급한다.   발급된 접근 토큰을 이용하여 소비자에서 사용자 정보에 접근한다.   OAuth 2.0에서 개선된 점     웹 애플리케이션이 아닌 애플리케이션의 지원이 강화되었다.   HTTPS를 사용하고 HMAC을 사용하지 않아서 암호화가 필요없다.   Signature 단순화 정렬과 URL 인코딩이 필요없다.   Access Token의 Life-Time을 지정할 수 있다.   Reference     JWT-Home   Wiki-OAuth  ","categories": ["CS"],
        "tags": ["Programming","CS","OAUTH"],
        "url": "/cs/oauth/",
        "teaser": null
      },{
        "title": "JavaScript",
        "excerpt":"JavaScript     가벼운 Interpreter 또는 JIT Compile 프로그래밍 언어이다.   First-Class Functions를 지원한다.   Prototype 기반, 다중 패러다임 스크립트 언어이다.   동적이고 Command, Object-Oriented Programming(OOP), Functional Programming(FP) 스타일을 지원한다.   변수 자료형이 선언되지 않는다.(Dynamic Typing, Loosely Typed)   First-Class Functions, 일급 함수     매개변수로 제공이 가능하다.   function sayHello() {    return \"Hello, \"; } function greeting(helloMessage, name) {   console.log(helloMessage() + name); } // Pass `sayHello` as an argument to `greeting` function. greeting(sayHello, \"JavaScript!\");      함수가 함수를 반환할 수 있다.   // Using a variable. const sayHello = function() {    return function() {       console.log(\"Hello!\");    } } const myFunc = sayHello(); myFunc();   // Using double parentheses. function sayHello() {    return function() {       console.log(\"Hello!\");    } } sayHello()();      변수에 할당이 가능하다.   const foo = function() {    console.log(\"foobar\"); } // Invoke it using the variable. foo();   Library  JQuery     이벤트 처리, CSS 애니메이션 및 Ajax 뿐만 아니라 HTML Document Object Model(DOM)트리 탐색 및 조작을 단순화하도록 설계된 JavaScript Library이다.   React     User Interface 또는 UI Components를 구축하기위한 Open Source, Front-End, JavaScript Library이다.   Framework  Bootstrap     Responsive Mobile-First Front-End Web 개발을 위한 무료 오픈 소스 Framework이다.   Angular.js / Angular     JavaScript에 정적 타입 개념을 추가한 신형 언어인 TypeScript 기반 오픈 소스 Web Application Framework이다.   Angular 1.x 버전은 Angular.js, Angular 2 버전 이상부터 Angular로 불린다.   Vue.js     User Interface 및 Single-Page Application(SPA)을 구축하기위한 오픈 소스 Model-View-ViewModel Front-End JavaScript Framework이다.   선언적 렌더링 및 구성요소의 구성에 초점을 맞추어 점진적으로 적응이 가능한 아키텍처를 제공한다.   ECMAScript     JavaScript를 이루는 코어 스크립트 언어이자 표준(ECMA-262)이다.   Reference     Wiki-JavaScript  ","categories": ["JavaScript"],
        "tags": ["Programming","JavaScript"],
        "url": "/javascript/javascript/",
        "teaser": null
      },{
        "title": "JavaScript Asynchronous",
        "excerpt":"Promise     자바스크립트 비동기 처리에 사용되는 객체이다.   상태  Pending, 대기     비동기 처리 로직이 아직 완료되지 않은 상태이다. new Promise()  함수를 호출하면  대기 상태가 된다.   Fulfilled, 이행     비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태이다. 콜백 함수의 인자 resolve를 실행하면 이행 상태가 된다.   Rejected, 실패     비동기 처리가 실패하거나 오류가 발생한 상태이다. 콜백 함수의 인자 reject를 실행하면 실패 상태가 된다.   Promise Chaining, 프로미스 연결     then() 메서드를 호출하면 새로운 프로미스 객체를 반환하여 다시 then() 메서드를 이어서 사용 가능하다.   new Promise(function(resolve, reject) {   setTimeout(() =&gt; resolve(1), 1000); }).then(function(result) {   alert(result); // 1   return result * 2; }).then(function(result) {   alert(result); // 2   return result * 2; }).then(function(result) {   alert(result); // 4   return result * 2; });   오류 처리     then()을 사용하여 두 번째 인자로 에러를 처리한다.            이 방법으로 호출되면 Uncaught Error가 발생하므로, catch()를 이용하도록 한다.           catch()를 이용하여 에러를 처리한다.   async, await     자바스크립트 비동기 처리 패턴 중 가장 최근에 나온 문법이다.   기존 비동기 처리 방식인 콜백 함수와 프로미스의 단점을 보완하고 개발자가 읽기 좋은 코드를 작성 할 수 있도록 해준다.   async function asyncFunction() {   const data = await asyncMethod();   // Logic. }   async     비동기 처리를 하는 함수 앞에 async라는 키워드를 사용한다.   Ex. async function 함수명() {}   await     비동기 처리를 하는 코드 앞에 await라는 키워드를 사용한다.   Ex. await 함수명()  ","categories": ["JavaScript"],
        "tags": ["Programming","JavaScript","Asynchronous"],
        "url": "/javascript/asynchronous/",
        "teaser": null
      },{
        "title": "Synchronous/Asynchronous, Blocking/NonBlocking",
        "excerpt":"Synchronous/Asynchronous     호출되는 함수의 작업 완료 여부를 누가 신경쓰는지가 관심사이다.   Synchronous     호출한 함수가 호출되는 함수의 작업 완료를 지속적으로 확인한다.   Asynchronous     호출한 함수는 작업 완료 여부를 신경쓰지 않으며 호출되는 함수에게 Callback을 전달한다.   호출되는 함수의 작업이 완료되면 전달받은 Callback을 실행한다.   Blocking/NonBlocking     호출되는 함수가 바로 반환하는지가 관심사이다.   Blocking     호출된 함수가 자신의 작업을 모두 마칠 때까지 호출한 함수에게 제어권을 넘겨주지 않고 대기하게 만든다.   Non-Blocking     호출된 함수가 바로 반환해서 호출한 함수에게 제어권을 넘겨주고, 호출한 함수가 다른일을 할 수 있는 기회를 준다.   Synchronous-Blocking        호출된 함수에서 제어권을 반환하지 않아, 호출한 함수는 호출된 함수가 끝날 때까지 다른 일을 하지 못하고 기다려야 한다.   Synchronous-NonBlocking        호출된 함수에서 제어권을 바로 반환하여, 호출한 함수는 다른 일을 수행할 수 있다.   호출한 함수는 호출된 함수가 완료되었는지를 주기적으로 확인한다.   Asynchronous-Blocking        호출한 함수는 CallBack을 전달하지만 호출된 함수에서 제어권을 반환하지 않아, 호출한 함수는 호출된 함수가 끝날 때까지 다른 일을 하지 못하고 기다려야 한다.   Asynchronous-NonBlocking        호출된 함수에서 제어권을 바로 반환하여, 호출한 함수는 다른 일을 수행할 수 있다.   호출된 함수에서 작업이 완료되면 CallBack을 수행함으로써, 호출한 함수는 완료되었는지 확인 할 필요가 없다.   대표적으로 NodeJS, WebSocket가 이에 해당한다.  ","categories": ["CS"],
        "tags": ["Programming","CS","Synchronous","Asynchronous","Blocking","NonBlocking"],
        "url": "/cs/synchronous-blocking/",
        "teaser": null
      },{
        "title": "Leetcode Java Two Sum",
        "excerpt":"문제  Link   코드  class Solution {    public int[] twoSum(int[] nums, int target) {     for (int idx1 = 0; idx1 &lt; nums.length - 1; idx1++) {       for (int idx2 = idx1 + 1; idx2 &lt; nums.length; idx2++) {         if (target == nums[idx1] + nums[idx2]) {           return new int[]{idx1, idx2};         }       }     }     return new int[2];   }  }   결과  Link   설명     두 수의 합이 원하는 값이 이루어져야 하므로, 첫 값부터 순차 탐색한다.   만일 두 값의 합이 목표의 결과 값이면 배열에 추가하여 결과로 반환한다.            사전 제약 조건 중 정답은 단 하나만 존재한다고 서술되어 있으므로, 결과를 못 찾았을 경우 반환하는 값은 의미가 없다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/two-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Add Two Numbers",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {     ListNode listNode = new ListNode();     ListNode temp = listNode;     int quotient = 0;     while (l1 != null || l2 != null) {       int sum = quotient + getValue(l1) + getValue(l2);       quotient = sum / 10;       temp.next = new ListNode(sum % 10);       temp = temp.next;       l1 = getNext(l1);       l2 = getNext(l2);     }     if (quotient &gt; 0) {       temp.next = new ListNode(quotient);     }     return listNode.next;   }      private int getValue(ListNode listNode) {     return listNode != null ? listNode.val : 0;   }      private ListNode getNext(ListNode listNode) {     return listNode != null ? listNode.next : null;   }  }   결과  Link   설명     ListNode를 먼저 파악해보면 숫자를 val 변수로 저장하고,다음 ListNode를 next 변수로 저장한다.            Java에서 LinkedList를 이해하면 도움이 된다.       하나의 ListNode는 숫자의 역순으로 저장이 되므로 val의 값은 1의 자리, 다음 ListNode의 val의 값은 10의 자리이다.       예를 들어 숫자 123은 ‘3 - 2 - 1’ 순의 ListNode로 구성된다.       위의 경우 첫 ListNode의 val값은 3이고, next ListNode의 val값은 2이고, next ListNode의 val값은 1이며 next는 null이 된다.           두 ListNode 값의 합을 더해야 하므로, 결과로 반환하기 위해 사용될 ListNode와 임시 ListNode를 구성할 listNode와 temp 변수를 선언한다.            listNode 변수는 결과 값을 누적하기 위해 사용된다.       temp 변수는 앞으로 계산할 val값을 지정하고, listNode의 next값을 지속적으로 넣어주기 위해 사용된다.           주어진 두 ListNode의 val값을 차례대로 합산한다.            한 자리는 0 ~ 9 까지 구성되므로 두 합은 최대 18이고, 이전 값을 10으로 나눈 몫을 합쳐도 두 자릿수이므로 현재 값에서 10으로 나눈 몫은 다음 값 계산에만 사용하면 된다.       두 값의 합이 10을 초과할 시, 다음 ListNode의 val값을 계산할 때 사용하기 위해 quotient 변수에 10으로 나눈 몫을 임시 저장한다.       현재 ListNode의 val은 이전에 10으로 나눈 몫인 quotient와 두 ListNode의 val값을 합쳐서 정한다.       현재 ListNode의 next는 다시 temp에 할당하고, 주어진 두 ListNode는 next ListNode 값으로 재 할당한다.                3번의 반복이 끝난 이후 몫이 남아있다면, temp의 next ListNode 값으로 넣어준다.       계산이 끝난 listNode의 next 값을 주어진 문제의 결과로 반환한다.            초기 ListNode를 선언하고 temp가 next값부터 주입되었으므로, 첫 ListNode는 껍데기이다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/add-two-numbers/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Substring Without Repeating Characters",
        "excerpt":"문제  Link   코드  class Solution {    public int lengthOfLongestSubstring(String s) {     int result = 0;     Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();     for (int i = 0, j = 0; i &lt; s.length(); ++i) {       char c = s.charAt(i);       if (map.containsKey(c)) {         j = Math.max(j, map.get(c) + 1);       }       map.put(c, i);       result = Math.max(result, i - j + 1);     }     return result;   }  }   결과  Link   설명     임시로 문자를 저장하기 위해 Collection을 선언한다.            List가 아니라 Map을 사용하는 이유는 문자와 index를 저장하여 길이를 계산하기 위함이다.           주어진 변수 s를 반복문을 통해서 고유 문자열의 길이를 계산한다.            변수 i는 반복문의 index로 사용한다.       변수 j는 반복된 문자의 index를 가져오기 위해 사용한다.           주어진 변수 s의 i번째 문자를 가져와서 Collection에 존재하는지를 확인한다.            만일 존재한다면 반복된 문자이므로, 글자의 길이를 판단하기 위해 index + 1를 변수 j에 주입한다.       index + 1을 사용하는 이유는 결과 값에 대한 보정치이다. (자세한건 5번에서 설명한다.)                Collection에 주어진 변수 s의 i번째 문자와 index를 저장한다.       기존에 계산한 고유 문자열의 길이와 $i - j + 1$ 중 큰 값을 고유 문자열의 길이를 저장하는 result 변수에 주입한다.            $i - j + 1$로 길이를 계산하는 이유는 s가 한 글자인 경우 글자의 길이가 0으로 반환되는 부분을 보정하기 위함이다.           반복이 끝나면 고유 문자열의 길이를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-substring-without-repeating-characters/",
        "teaser": null
      },{
        "title": "Leetcode Java Median of Two Sorted Arrays",
        "excerpt":"문제  Link   코드  class Solution {    public double findMedianSortedArrays(int[] nums1, int[] nums2) {     int[] nums = mergeNums(nums1, nums2);     int mid = nums.length / 2;     return nums.length % 2 == 0 ? (double) (nums[mid - 1] + nums[mid]) / 2 : nums[mid];   }      private int[] mergeNums(int[] nums1, int[] nums2) {     int[] mergeNums = new int[nums1.length + nums2.length];     int idx1 = 0;     int idx2 = 0;     for (int idx = 0; idx &lt; mergeNums.length; idx++) {       if (idx1 &lt; nums1.length &amp;&amp; (idx2 &gt;= nums2.length || nums1[idx1] &lt;= nums2[idx2])) {         mergeNums[idx] = nums1[idx1];         idx1++;       } else if (idx2 &lt; nums2.length &amp;&amp; (idx1 &gt;= nums1.length || nums1[idx1] &gt; nums2[idx2])) {         mergeNums[idx] = nums2[idx2];         idx2++;       }     }     return mergeNums;   }  }   결과  Link   설명     주어진 두 배열의 중앙값을 찾기 위해서 하나의 배열로 합친다.            두 배열은 오름차순 정렬된 배열이므로, 각 배열의 숫자를 비교하여 두 배열의 합쳐진 배열인 변수인 mergeNums에 추가하여야 한다.       각 배열의 마지막 값을 mergeNums에 추가한 경우(배열의 idx값이 length와 동일하거나 클 경우), 해당 배열은 무시하고 다른 배열의 값을 계속 추가하도록 한다.           합친 배열의 중앙값을 문제의 결과로 반환한다.            배열의 크기가 홀수일 경우, 가운데 있는 값이 중앙값이다.       배열의 크가기 짝수일 경우, 가운데 있는 두 값의 평균이 중앙값이다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/median-of-two-sorted-arrays/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Palindromic Substring",
        "excerpt":"문제  Link   코드  class Solution {    public String longestPalindrome(String s) {     int start = 0;     int end = 0;     for (int i = 0; i &lt; s.length(); i++) {       int len = Math.max(expandAroundCenter(s, i, i), expandAroundCenter(s, i, i + 1));       if (len &gt; end - start) {         start = i - (len - 1) / 2;         end = i + len / 2;       }     }     return s.substring(start, end + 1);   }    private int expandAroundCenter(String s, int left, int right) {     while (left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) {       left--;       right++;     }     return right - left - 1;   }  }   결과  Link   설명          주어진 문자열 s에서 가장 긴 반복 문자열을 추출하기 위해서 변수 start와 end를 정의한다.       주어진 문자열 s의 길이만큼 반복문을 통해 가장 긴 반복 문자열의 시작과 끝 index를 탐색한다.            반복은 좌측 index가 0보다 크거나 같고, 우측 index가 주어진 문자열 s의 길이보다 작은 값까지 반복한다.       주어진 문자열의 i번째 index부터 좌측과 우측의 값이 같은지를 차례대로 비교한다.       주어진 문자열의 i번째 index와 i + 1번째 index의 값이 같으면, 좌측과 우측의 값이 같은지를 차례대로 비교한다.       위의 두 경우 중 큰 값을 길이로 결정한다.           만일 2번의 결과로 나온 길이가 end - start보다 크다면 start와 end 값을 수정한다.            변수 start는 index i 기준으로 $\\frac{(len - 1)}{2}$를 뺀 값으로 설정한다.       변수 end는 index i 기준으로 $\\frac{len}{2}$를 더한 값으로 설정한다.           반복이 끝나면 주어진 문자열 s에서 변수 start번째 문자부터 변수 end까지 문자까지 잘라서 주어진 문제의 결과로 제출한다.            end까지 자르는데 substring(start, end + 1)인 이유는 substring 메서드가 start번째 부터 end + 1번째 전까지 자르기 때문이다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-palindromic-substring/",
        "teaser": null
      },{
        "title": "Leetcode Java ZigZag Conversion",
        "excerpt":"문제  Link   코드  class Solution {    public String convert(String s, int numRows) {     if (numRows == 1) {       return s;     }     char[] c = s.toCharArray();     StringBuilder[] sbArr = initStringBuilderArray(numRows);     int sign = 1;     int i = 0;     for (int idx = 0; idx &lt; c.length; idx++) {       sbArr[i].append(c[idx]);       if (idx != 0 &amp;&amp; idx % (numRows - 1) == 0) {         sign *= (-1);       }       i += sign;     }     return getResult(sbArr);   }    private StringBuilder[] initStringBuilderArray(int numRows) {     StringBuilder[] sbArr = new StringBuilder[numRows];     for (int idx = 0; idx &lt; sbArr.length; idx++) {       sbArr[idx] = new StringBuilder();     }     return sbArr;   }    private String getResult(StringBuilder[] sbArr) {     for (int idx = 1; idx &lt; sbArr.length; idx++) {       sbArr[0].append(sbArr[idx]);     }     return sbArr[0].toString();   }  }   결과  Link   설명          주어진 행의 수인 변수 numRows가 1이면 주어진 문자열 그대로이므로, 주어진 문제의 결과로 반환한다.       주어진 문자열 s를 문자 배열 c에 저장하고, 주어진 행의 수인 변수 numRows를 이용하여 StringBuilder 배열인 sbArr을 만든다.            StringBuilder 배열은 행의 숫자인 numRows 크기로 만든다.       동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.           방향을 나탄는 변수 sign과 지그재그로 표현하기 위한 최대 꼭짓점인 변수 i를 선언한다.            변수 sign은 양수/음수에 따라서 아래로 내려갔다가 다시 위로 올라오기 위해 사용한다.       변수 i는 지그재그의 꼭짓점(가장 아랫부분의 길이)까지 반복하기 위해사용한다.           문자 배열 c의 크기만큼 반복을 통해 주어진 결과를 생성한다.            sbArr의 i 번째 index에 c[idx] 값을 주입한다.       만일 idx가 0이 아니거나, idx를 numRows - 1로 나눈 나머지 값이 0인 경우 sign에 -1을 곱하여 방향을 전환한다.       idx가 0인 경우, 무슨 값으로 나누더라도 결과는 0이므로 이 경우는 제외하도록 한다.       idx를 numRows - 1로 나눈 값이 0인 경우, 맨 위에서 c[idx] 값을 주입한 이후 위치가 지그재그의 모서리(시작과 끝) 높이이므로 방향을 바꾸어 준다.           sbArr 값을 하나의 문자열로 합쳐서 주어진 문제의 결과로 반환한다.            sbArr[0]의 값에 0 이후 index 배열의 값을 append 시켜 sbArr[0].toString()을 통해 간단히 하나의 문자열로 생성하였다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/zigzag-conversion/",
        "teaser": null
      },{
        "title": "Leetcode Java Reverse Integer",
        "excerpt":"문제  Link   코드  class Solution {    public int reverse(int x) {     int result = 0;     while (x != 0) {       int temp = result * 10 + x % 10;       if (temp / 10 != result) {         return 0;       } else {         result = temp;         x /= 10;       }     }     return result;   }  }   결과  Link   설명          주어진 정수 x를 반대로 전환한 결과값을 저장할 result 변수를 선언한다.       반복문을 통해 x가 0이 될 때까지 반복을 통해 주어진 정수를 역전시킨다.            임시 정수로 사용되는 temp 변수를 선언하여 $result\\times10 + \\frac{x}{10}$을 통해 정수를 역순으로 생성해준다.       $\\frac{x}{10}$을 통해 주어진 정수의 마지막 자리를 첫 자리로 전환한다. 단 마지막 숫자열이 0인 경우, temp가 0이 되므로 무시된다.       $result\\times10$을 통해 역전시키는 정수의 자릿수를 올려준다.           만일 임시 정수로 사용되는 temp변수에 10으로 나눈 값과 result의 값이 다른 경우, 주어진 문제의 결과로 0을 반환한다.            $result\\times10$을 통해 int형의 최솟값(-2,147,483,648)과 최댓값(2,147,483,647)을 돌파할 경우, 값이 초기화되는 점을 활용한다. ($-2147483648\\times10{=}0$, $2147483648\\times10{=}-10$)       위의 이유로 $\\frac{temp}{10}의 결과값과 result의 값이 같지 않다면, int형의 범위를 넘어섰으므로 문제에서 예외 케이스로 주어진 경우를 만족하여 0을 결과로 반환한다.                3번의 경우가 아닌 경우에는 결과값을 저장하는 result 변수에 임시 정수로 사용되는 temp 변수의 값을 주입하고, x값에 $\\frac{x}{10}$의 몫을 저장하고 반복문을 계속 수행한다.       반복문이 종료되면 주어진 정수 x를 반대로 전환한 결과값을 저장한 result 변수의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reverse-integer/",
        "teaser": null
      },{
        "title": "Leetcode Java String to Integer (atoi)",
        "excerpt":"문제  Link   코드  class Solution {    public int myAtoi(String s) {     int result = 0;     if (s.length() == 0) {       return result;     }     int idx = getBeginning(s);     if (idx == s.length()) {       return result;     }     int sign = 1;     if (s.charAt(idx) == '+' || s.charAt(idx) == '-') {       sign = s.charAt(idx++) == '-' ? -1 : 1;     }     while (idx &lt; s.length() &amp;&amp; s.charAt(idx) &gt;= '0' &amp;&amp; s.charAt(idx) &lt;= '9') {       if (isOverflow(result, s.charAt(idx))) {         return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;       }       result = result * 10 + s.charAt(idx++) - '0';     }     return result * sign;   }    private int getBeginning(String s) {     int idx = 0;     while (idx &lt; s.length() &amp;&amp; s.charAt(idx) == ' ') {       idx++;     }     return idx;   }    private boolean isOverflow(int result, char c) {     return result &gt; Integer.MAX_VALUE / 10         || (result == Integer.MAX_VALUE / 10 &amp;&amp; c - '0' &gt; Integer.MAX_VALUE % 10);   }  }   결과  Link   설명          주어진 문자열 s는 0부터 1000까지 길이이므로 s의 길이가 0일 경우, 0을 그대로 주어진 문제의 결과로 반환한다.       주어진 문자열 s의 공백을 확인하여 숫자열 탐색의 시작 index를 확인하여 idx 변수에 저장한다.            공백 문자열의 길이는 주어진 문자열 s보다 작고, s의 idx번째 문자가 공백 문자열의 경우만 idx를 점층적으로 증가시킨다.       만일 idx가 s의 길이와 같거나 공백이 아닌 문자열이 탐색되었을 경우, 반복을 중지하고 idx를 숫자열 탐색의 시작 index로 반환한다.           숫자열 탐색의 시작 index인 idx가 주어진 문자열 s의 길이와 같을 경우, 0을 그대로 주어진 문제의 결과로 반환한다.            주어진 문자열 s가 공백으로만 이루어진 문자열인 경우이다.                주어진 문자열 s의 idx번째 문자가 +나 -인 경우 idx를 증가시키고, -인 경우만 sign을 -1로 변경하여 음수 결과를 반환할 수 있도록한다.       주어진 문자열 s을 idx번째 index부터 각 문자가 0 ~ 9 사이의 숫자인 경우만 탐색한다.            만일 결과로 반환할 result가 int형의 최댓값의 $\\frac{1}{10}$인 214,748,364를 초과 할 경우이거나, result가 214,748,364이고 주어진 문자열 s의 idx번째 문자가 7보다 클 경우 int형의 최댓값과 최솟값을 초과하므로 Overflow 처리한다.                    Character형인 c를 ‘0’으로 빼면 Ascii 값 기준으로 해당 값의 숫자로 반환된다.                       위의 Overflow 처리된 경우, sign이 1이면 int형의 최댓값인 2,147,483,647를 주어진 문제의 결과로 반환한다.       sign이 -1이면 int형의 최솟값인 -2,147,483,648을 주어진 문제의 결과로 반환한다.       Overflow 처리가 되지 않은 경우, result에 reulst * 10과 주어진 문자열 s의 idx번째 문자열의 ascii 코드값에 ‘0’의 ascii 코드값을 뺀 값을 저장하고 반복을 계속 수행한다.           반복이 끝나면 결과로 반환할 result에 음수/양수를 구분할 sign값을 곱하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/string-to-integer-atoi/",
        "teaser": null
      },{
        "title": "Leetcode Java Palindrome Number",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isPalindrome(int x) {     if (x &lt; 0 || (x != 0 &amp;&amp; x % 10 == 0)) {       return false;     } else {       int reverse = 0;       while (x &gt; reverse) {         reverse = reverse * 10 + x % 10;         x /= 10;       }       return x == reverse || x == reverse / 10;     }   }  }   결과  Link   설명     주어진 정수 x가 만일 0보다 작거나 10의 배수인 경우, 주어진 문제의 결과로 false를 반환한다.            음수의 경우는 false로 반환하는 예외로 문제에 명시되어있다.       10의 배수를 false 처리하는 이유는 결과가 특정 값 기준으로 좌우가 같을 경우를 제외하였다. (Ex. 121, 12321)           주어진 정수를 절반으로 나누어 반대로 저장시킬 reverse 변수를 선언하고 reverse 변수가 x보다 더 크거나 같을 때 까지 반복한다.            주어진 정수 x의 절반을 반대로 전환시키면 해당 정수가 회문 정수형인지 확인 가능하다.       만일 주어진 정수 x가 1221이라면, x가 12이고 reverse가 12일 때 까지 반복한다.       만일 주어진 정수 x가 12321이라면, x가 12이고 reverse가 123일 때 까지 반복한다.       마지막으로 x를 10으로 나눈 몫을 x에 다시 주입한다.           주어진 정수 x의 절반과 반대로 저장시킨 reverse 변수의 값이 동일하거나 $\\frac{reverse}{10}$와 동일하면 true로, 아니면 false로 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/palindrome-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Regular Expression Matching",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isMatch(String s, String p) {     if (isBlank(p)) {       return isBlank(s);     }     boolean[][] dp = initDp(s, p);     for (int i = 0; i &lt; s.length(); i++) {       for (int j = 0; j &lt; p.length(); j++) {         if (p.charAt(j) == '.' || p.charAt(j) == s.charAt(i)) {           dp[i + 1][j + 1] = dp[i][j];         } else if (p.charAt(j) == '*') {           if (p.charAt(j - 1) != s.charAt(i) &amp;&amp; p.charAt(j - 1) != '.') {             dp[i + 1][j + 1] = dp[i + 1][j - 1];           } else {             dp[i + 1][j + 1] = (dp[i + 1][j] || dp[i][j + 1] || dp[i + 1][j - 1]);           }         }       }     }     return dp[s.length()][p.length()];   }    private boolean isBlank(String s) {     return s == null || s.length() == 0;   }    private boolean[][] initDp(String s, String p) {     boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];     dp[0][0] = true;     for (int i = 1; i &lt; p.length(); i+=2) {       dp[0][i + 1] = p.charAt(i) == '*' &amp;&amp; dp[0][i - 1];     }     return dp;   }  }   결과  Link   설명     주어진 패턴 p가 null이거나 길이가 0이라면 주어진 문자열 s가 null이거나 길이가 0인지를 주어진 문제의 결과로 반환한다.            패턴이 없을 경우 문자열도 없어야 정상이기 때문이다.           해당 문제를 주어진 문자열 s와 주어진 패턴 p를 활용하기 위해 2차원 boolean 배열인 dp에 주어진 패턴 p의 ‘*‘이 들어가 있는 위치를 먼저 설정한다.            주어진 패턴 p를 이용하여 초기 값인 dp[0][0]의 값을 true로 설정한다.       주어진 패턴 p의 i번째 문자가 ‘*‘이고 dp[0][i - 1]의 값이 true일 경우, dp[0][i + 1]의 값을 true로 설정한다.       문자가 ‘*‘이 들어가는 위치는 특정 문자열 뒤에 붙으므로, 짝수열만 탐색하면 되어 i는 1부터 2씩 증가시킨다.           주어진 문자열 s와 주어진 패턴 p를 각각 비교하기 위해 s와 p의 길이만큼 각각 반복을 수행한다.            만일 주어진 패턴의 j번째 문자가 ‘.’이거나, 주어진 패턴의 j번째 문자와 주어진 문자열 s의 i번째 자리가 동일한 경우 dp[i + 1][j + 1]의 값에 dp[i][j]의 값을 주입한다.                    위의 경우는 해당 문자열이 임의 문자가 들어가거나, 동일 문자가 들어가는 경우이므로, 해당 위치까지 주어진 문자열이 주어진 패턴에 부합하다고 판단한다.                       만일 주어진 패턴의 j번째 문자가 ‘*‘인 경우, 아래의 조건 확인한다.                    주어진 패턴의 j - 1번째 문자가 주어진 문자열의 i번째 문자와 다르고 주어진 패턴의 j - 1번째 문자가 ‘.’이 아닌 경우, dp[i + 1][j + 1]의 값에 dp[i + 1][j - 1]의 값을 주입한다.           위의 경우가 아닌 경우, dp[i + 1][j + 1]의 값에 아래의 조건에 부합하는 경우 true, 하나도 부합하지 않는 경우 false로 설정한다.                                 dp[i + 1][j]의 값이 true       dp[i][j + 1]의 값이 true       dp[i + 1][j - 1])의 값이 true           반복이 끝난 경우 dp[s.length()][p.length()]의 값을 주어진 문제의 결과로 반환한다.            dp 배열의 s의 길이, p의 길이 위치에 있는 값은 주어진 문자열이 주어진 패턴에 부합한다고 판단되는 경우이기 때문에, 해당 값이 문제의 결과이다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/regular-expression-matching/",
        "teaser": null
      },{
        "title": "Leetcode Java Container With Most Water",
        "excerpt":"문제  Link   코드  class Solution {    public int maxArea(int[] height) {     int start = 0;     int end = height.length - 1;     int max = 0;     while (start &lt; end) {       max = Math.max(max, Math.min(height[start], height[end]) * (end - start));       if (height[start] &lt; height[end]) {         start++;       } else {         end--;       }     }     return max;   }  }   결과  Link   설명          주어진 배열 height의 양 끝단부터 탐색하기 위해 초기 index인 start는 0, end는 height.length - 1로 초기화 한다.            두 index인 start와 end 사이에 최대로 담을 수 있는 물의 양을 저장하기 위해 max 변수를 선언한다.       start 변수의 값이 end 변수의 값보다 같아지기 전까지 반복을 통해 최대로 담을 수 있는 물의 양을 탐색한다.            두 index 사이에서 최대로 담을 수 있는 물의 양은 height[start]와 height[end]의 값 중 작은 값에서 end와 start의 길이만큼을 곱해주면된다.       위의 물의 양과 최대로 담을 수 있는 물의 양을 저장한 변수 max와 비교하여 최대 값만 저장한다.           만일 height[start]의 값이 height[end]을 분석하여 한칸씩 가운데로 이동한다.            두 index 중 한 height[index] 값이 작으면 해당 값 위주로 배수를 곱하므로, 작은 값의 index를 이동하여 최대로 담을 수 있는 물의 양을 다시 탐색하기 위함이다.           반복이 끝나면 최대로 담을 수 있는 물의 양을 저장한 max 변수를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/container-with-most-water/",
        "teaser": null
      },{
        "title": "Leetcode Java Integer to Roman",
        "excerpt":"문제  Link   코드  class Solution {    public String intToRoman(int num) {     String[] romans = new String[] { \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" };     int[] nums = new int[] { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };     StringBuilder sb = new StringBuilder();     int idx = 0;     while (num &gt; 0) {       int multiple = num / nums[idx];       for (int i = 0; i &lt; multiple; i++) {         num -= nums[idx];         sb.append(romans[idx]);       }       idx++;     }     return sb.toString();   }  }   결과  Link   설명     정수 숫자와 로마 숫자를 각 배열 nums와 romans에 정의한다.            같은 index에 해당 값이 존재하므로 1:1 매칭이 되어, 다른 배열로 정의하여도 된다.       높은 순서대로 정의하여, 순차 계산할 경우 오름차순으로 정렬된 로마 숫자 표현식이 되도록 한다.           로마 숫자 표현식을 동적으로 만들기 위해 변수 sb를 선언한다.            동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.           로마 숫자 표현식의 순차 처리를 위해 변수 idx를 0으로 초기화하고, num이 0 이하가 될 때 까지 반복문을 수행하여 로마 숫자 표현식을 완성한다.            주어진 정수 num을 idx번째 nums 배열의 숫자를 나눈 몫만큼 반복하여 변수 sb에 idx번째 roman 배열의 문자열을 반복하고, 주어진 정수 num을 idx번째 숫자를 빼준다.       위의 반복이 완료되면 idx를 증가시켜 다음 로마 숫자를 이용하여 로마 숫자 표현식을 완성한다.           3번의 반복이 완료되면 변수 sb를 String으로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/integer-to-roman/",
        "teaser": null
      },{
        "title": "Java Secure Channel(JSch)",
        "excerpt":"Java Secure Channel(JSch)     순수 SSH2의 Java 구현체로, sshd 서버에 연결하여 포트 포워딩, X11 포워딩, 파일 전송 등을 사용할 수 있다.   Connect     서버에 접속하기 위해 사용되는 사용자 인증 방식은 password, publickey, keyboard-interactive, gssapi-with-mic이 있다.   password     서버에 등록된 계정으로 로그인하는 방식이다.   publickey     SSH Key를 이용하여 로그인하는 방식이다.   DSA, RSA, ECDSA 기반으로 암호화된 Public key를 서버에 등록하여 Local에 보관하고 있는 Private key를 이용하여 로그인한다.   ssh-keygen     OpenSSH에 포함된 ssh key-pair를 만들기 위한 도구이다.   사용  키 생성  키 생성 알고리즘 지정   C:\\Users\\GracefulSoul&gt;ssh-keygen -t rsa Generating public/private rsa key pair.      ssh-keygen 명령어를 통해 키 생성이 가능하다.   -t 키워드를 통해 rsa, dsa, esdsa 등의 암호화 알고리즘을 활용하여 키 생성이 가능하다.   키 생성 위치 지정   Enter file in which to save the key (C:\\Users\\GracefulSoul/.ssh/id_rsa): Created directory 'C:\\Users\\GracefulSoul/.ssh'.      키는 기본 생성 위치를 지정하여 생성이 가능하다.            Linux : /home/{userName}/.ssh/       Window : C:\\Users{userName}/.ssh/           키 passpharse 입력   Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in C:\\Users\\GracefulSoul/.ssh/id_rsa. Your public key has been saved in C:\\Users\\GracefulSoul/.ssh/id_rsa.pub. The key fingerprint is: SHA256:EtIy5fyPVizDk0KYA+3x83b1HPFyNfem2cuGQDb5cn0 gracefulsoul@GracefulSoul-PC The key's randomart image is: +---[RSA 2048]----+ |  ..  .          | |   .oB        ..o| |   .Bo*     .  o=| |    .*o+ o =. o =| |      ooS =.oo.O | |       ooB.o o=.E| |       .o.. + o o| |       .     . + | |              .  | +----[SHA256]-----+      키에 대한 보안성을 위해 Passphrase를 사용 할 수 있으며, 생성된 키에 대한 암복호화에 사용되는 키워드로 생각하면된다.   키 등록  Publickey 확인   C:\\Users\\GracefulSoul&gt;type .\\.ssh\\id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC9lcezehweKlB9WEp6vRmVgqwBVuFK/i3jTbkq3U/GW0VcN0Jgct104usL/hZjBFr9/eizwyePnmmYOWs9O90/Tr6tQN3pJCxHpvwZIED9L+pQNyK5Sa6Mfs63q1WWmndXxznouW17KYEfbPZPAzSVsklqkutecVVDYt8kotkID/HrqakOTa0SeAvUWXyhLW8/hCjMFD4dr+MmYWEf6kZ0xnAYK/DPHa3afp6sb7NBjc+baptw2HYFIUmBfZyToZ6Vy7oRb/2dT8fimP6V6C6vov0UcXlQYkE1oVSMxNYY4f0Ct/2Jw1R7flI4jz054SaL3WJRM7xxrshHFNSDnMw/ gracefulsoul@GracefulSoul-PC      1-2에서 설명한 키 생성 위치에 저장된 Public key 파일을 확인하고, 복사한다.   접속하려는 서버에 Publickey 등록   $ cat /home/gracefulsoul/id_rsa.pub &gt;&gt; /home/gracefulsoul/.ssh/authorized_keys      2-1의 Public key 내용을 서버의 접속하려는 계정의 ssh 설정을 추가한다.   authorized_keys에 등록된 Public key는 서버에 Private Key 기반으로 접속하려는 시도가 있으면 해당 File을 통해서 인증을 수행한다.   위의 설정은 ‘~/.ssh/sshd_config’에 기본 설정이 되어있다.   keyboard-interactive     임의 순서의 요청 및 응답을 사용하는 유연한 인증 방법으로, 올바른 응답을 요청하여 로그인하는 방법이다.   OTP 기반 로그인 등으로 사용한다.   gssapi-with-mic     일반적으로 Kerberos의 인증방식을 이용하여 로그인하는 방법이다.   예제   public class JschConnector {   /* ... */   public void connect(InstanceVo instanceVo) {     JSch jsch = new JSch();     try {       // If you use privateKey. It is safer than using password.       if (StringUtils.isNotBlank(instanceVo.getPrivateKey())) {         this.initJschIdentity(jsch, instanceVo);       }       this.connectSession(jsch, instanceVo);       this.connectChannel();     } catch (JSchException jschException) {       jschException.printStackTrace();       this.disconnect();     }   }    private void initJschIdentity(JSch jsch, InstanceVo instanceVo) throws JSchException {     if (StringUtils.isNotBlank(instanceVo.getPassphrase())) {       // If you used passphrase to create a privateKey.       jsch.addIdentity(instanceVo.getPrivateKey(), instanceVo.getPassphrase());     } else {       // If you did not use passphrase when creating a privateKey.       jsch.addIdentity(instanceVo.getPrivateKey());     }   }   /* ... */      connect() 메서드는 JSch 라이브러리를 이용하여 연결하는 코드이다.   Private key 기반의 로그인 방식을 사용하는 경우, initJschIdentity() 메서드 내용과 같이 Passphrase 유무에 따라 Identity 설정을 같이 해주어야 한다.     /* ... */   private void connectSession(JSch jsch, InstanceVo instanceVo) throws JSchException {     this.session = jsch.getSession(instanceVo.getUserName(), instanceVo.getHost(), instanceVo.getPort());     // If privateKey is not entered, use it as a password-based login.     if (StringUtils.isBlank(instanceVo.getPrivateKey())) {       this.session.setPassword(instanceVo.getPassword());     }     this.session.setConfig(\"StrictHostKeyChecking\", \"no\");     this.session.connect();   }      세션을 연결하는 경우 Private key 기반의 로그인 시도가 아니면, Password 기반의 로그인 시도로 인식하도록 하였다.   세션의 “StrictHostKeyChecking” 설정을 “no”로 한 이유는, 서버 측에 등록된 Host가 아니어도 엄격하게 확인하지 않도록 한 것이다.   만일 Host를 등록하여 엄격하게 확인하여야 한다면 “yes” 혹은 설정을 하지 않으면 된다.   일정 기간 연결하여 반복 사용이 될 경우, connect(int connectTimeout) 메서드를 사용하도록 한다. (단, 보안성에 위배되지 않도록 사용하도록 한다.)     /* ... */   private void connectChannel() throws JSchException {     this.channel = (ChannelSftp) this.session.openChannel(\"sftp\");     this.channel.connect();   }   /* ... */      최종으로 sftp 테스트를 진행 할 예정이므로, sftp 채널로 연결한다.   일정 기간 연결하여 반복 사용이 될 경우, connect(int connectTimeout) 메서드를 사용하도록 한다. (단, 보안성에 위배되지 않도록 사용하도록 한다.)   SFTP(Secure File transfer protocol)     PC와 서버 간의 데이터 전송을 암호화하여 해킹이나 보안상의 문제점을 방지하는 안전한 서비스를 이용할 수 있다.   예제    /* ... */   public boolean check(ActionVo actionVo) {     try {       return null != this.channel.stat(String.join(File.separator, actionVo.getTargetDir(), actionVo.getFileName()));     } catch (SftpException e) {       e.printStackTrace();       return false;     }   }   /* ... */      Sftp의 stat(String path) 메서드를 활용하여 해당 위치에 있는 파일이 존재하는지 확인하는 코드이다.     /* ... */   public void download(ActionVo actionVo) {     try {       this.channel.cd(actionVo.getTargetDir());       FileUtils.mkdirIfNotExists(actionVo.getDestinationDir());       this.copy(actionVo);     } catch (SftpException e) {       e.printStackTrace();     }   }      private void copy(ActionVo actionVo) throws SftpException {     try (InputStream inputStream = this.channel.get(actionVo.getFileName());       OutputStream outputStream = new FileOutputStream(new File(actionVo.getDestinationDir(), actionVo.getFileName()))) {       FileUtils.copy(inputStream, outputStream);     } catch (IOException e) {       e.printStackTrace();     }   }   /* ... */      Sftp의 cd(String path) 메서드와 get(String src) 메서드로 지정된 위치에 있는 파일을 가져와 목표 지점에 복사하는 코드이다.     /* ... */   public void upload(ActionVo actionVo) {     File file = new File(actionVo.getTargetDir(), actionVo.getFileName());     try (InputStream InputStream = new FileInputStream(file)) {       FileUtils.mkdirIfNotExists(actionVo.getDestinationDir());       this.channel.cd(actionVo.getDestinationDir());       this.channel.put(InputStream, actionVo.getFileName());     } catch (IOException e) {       e.printStackTrace();     } catch (SftpException e) {       e.printStackTrace();     }   }   /* ... */      Sftp의 cd(String path) 메서드와 put(InputStream src, String dst) 메서드로 지정된 위치에 파일을 저장하는 코드이다.   Disconnect     사용하지 않는 경우에는 반드시 Session과 Channel을 닫아주어야 한다.   예제  public class JschConnector {   /* ... */   public void disconnect() {     this.disconnectSession();     this.disconnectChannel();   }      private void disconnectSession() {     if (this.session != null &amp;&amp; this.session.isConnected()) {       this.session.disconnect();     }   }      private void disconnectChannel() {     if (this.channel != null &amp;&amp; this.channel.isConnected()) {       this.channel.disconnect();     }   }  }      만일 위에서 일정 기간 연결하여 반복 사용하는 경우, 반드시 필요한 경우에만 disconnect 시켜주어 연결의 지속성을 확보한다. (단, 보안성에 위배되지 않도록 사용하도록 한다.)   Reference   ※ Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Java"],
        "tags": ["Programming","Java","Java Secure Channel"],
        "url": "/java/jsch/",
        "teaser": null
      },{
        "title": "Leetcode Java Roman to Integer",
        "excerpt":"문제  Link   코드  class Solution {    public int romanToInt(String s) {     char[] cArr = s.toCharArray();     char lastWord = cArr[0];     int result = getRomanValue(lastWord);     for (int idx = 1; idx &lt; cArr.length; idx++) {       result += getRomanValue(cArr[idx]);       result -= getMultipleRomanValue(new StringBuilder().append(lastWord).append(cArr[idx]).toString());       lastWord = cArr[idx];     }     return result;   }    private int getRomanValue(char c) {     switch (c) {       case 'M': return 1000;       case 'D': return 500;       case 'C': return 100;       case 'L': return 50;       case 'X': return 10;       case 'V': return 5;       case 'I': return 1;       default: return 0;     }   }    private int getMultipleRomanValue(String s) {     switch (s) {       case \"CM\": case \"CD\": return 200;       case \"XC\": case \"XL\": return 20;       case \"IX\": case \"IV\": return 2;       default: return 0;     }   }  }   결과  Link   설명          주어진 문자열 s를 문자 배열 cArr 변수로 변환한다.            직전 문자를 저장하기 위한 lastWord에 cArr의 0번째 index 값을 저장하고, 결과를 저장하기 위한 result 변수에 해당 lastWord의 숫자로 초기화해준다.       반복문을 통해서 주어진 로마 숫자 표현식을 한 단어씩 숫자로 변환한다.            결과를 저장하기 위한 result 변수에 단일 로마 숫자 표현식의 숫자 값은 더하고, 복합 로마 숫자 표현식은 접두어 로마 숫자 표현식 문자의 숫자 값의 두 배를 빼준다.       복합 로마 숫자 표현식의 경우 접두어 로마 숫자 표현식 문자의 숫자값의 두 배를 빼주는 이유는 단일 로마 숫자 표현식에서 이미 더했기 때문에, 그 값을 포함하여 2배를 빼주는 것이다.       직전 문자를 저장하는 lastWord 변수에 해당 문자를 넣어준다.           반복이 끝나면 결과를 저장한 result 변수를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/roman-to-integer/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Common Prefix",
        "excerpt":"문제  Link   코드  class Solution {    public String longestCommonPrefix(String[] strs) {     String prefix = strs[0];     if (strs.length == 1) {       return prefix;     }     for (int idx = 1; idx &lt; strs.length; idx++) {       while (strs[idx].indexOf(prefix) != 0) {         prefix = prefix.substring(0, prefix.length() - 1);       }     }     return prefix;   }  }   결과  Link   설명          첫 문자열을 주어진 문제의 결과를 저장할 prefix 변수로 저장한다.            문제를 확인해보면 주어진 배열 strs의 크기는 1 ~ 200까지 이므로, 크기가 1인 경우 변수 prefix를 문제의 결과로 반환한다.       주어진 배열 strs의 크기가 2 이상인 경우 반복문을 통해서 각 단어의 공통된 시작 문자열을 탐색한다.            indexOf 메서드는 해당 문자열이 대상의 문자열에 존재하지 않으면 -1, 존재하면 해당 위치 시작점의 index를 반환되므로 반복문은 0이 아닐 때까지 진행한다.       위의 경우를 확인하여 첫 문자열 기준으로 한 문자씩 제거하면서 다른 문자열과 공통된 문자열을 탐색한다.           반복이 끝나면 공통된 문자열을 저장한 prefix 변수를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-common-prefix/",
        "teaser": null
      },{
        "title": "Leetcode Java 3sum",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     Arrays.sort(nums);     for (int i = 0; i &lt; nums.length - 2; i++) {       if (i == 0 || i &gt; 0 &amp;&amp; nums[i] != nums[i - 1]) {         int j = i + 1;         int k = nums.length - 1;         int sum = 0 - nums[i];         while (j &lt; k) {           if (nums[j] + nums[k] == sum) {             result.add(Arrays.asList(nums[i], nums[j], nums[k]));             while (j &lt; k &amp;&amp; nums[j] == nums[j + 1]) {               j++;             }             while (j &lt; k &amp;&amp; nums[k - 1] == nums[k]) {               k--;             }             j++;             k--;           } else if (nums[j] + nums[k] &lt; sum) {             j++;           } else {             k--;           }         }       }     }     return result;   }  }   결과  Link   설명          주어진 정수 배열 nums를 오름차순 정렬한다.       반복문을 통해서 주어진 정수들의 합이 0이 되는 세 숫자를 탐색한다.            첫 숫자 이후 두 숫자를 더 찾아야 하므로 $nums.length - 2$까지 반복을 수행한다.       i가 0인 경우와 i가 0초과이면서 nums[i - 1]의 값과 nums[i]의 값이 같지 않은 경우(중복되지 않은 경우)를 대상으로 탐색한다.                남은 두 숫자를 탐색하기 위해 $i + 1$ 부터 다음 숫자를 탐색할 변수 j와 $nums.length - 1$부터 이전 숫자를 탐색할 변수 k를 선언하고, 세 숫자의 합을 저장할 변수 sum은 -nums[i]값으로 초기화 한다.       변수 j의 값이 변수 k의 값과 크거나 같기 전까지 반복을 하여 나머지 두 숫자를 탐색한다.            nums[j] + nums[k]의 값이 sum과 동일하면 result 변수에 nums[i], nums[j], nums[k] 세 값을 List로 넣어주고, j와 k의 위치를 이동한다.                    변수 j는 변수 k의 값보다 작고, nums[j]의 값과 nums[j + 1]의 값이 같지 않을 때까지 값을 더해준다.           변수 k는 변수 j보다 크거나 같고, nums[k - 1]의 값과 nums[k]의 값이 같지 않을 때까지 값을 빼준다.                       nums[j] + nums[k]의 값이 sum보다 작으면 변수 j의 값을 더해준다.       그 외의 경우는 변수 k의 값을 빼준다.           반복이 완료되면 result 변수를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/3sum/",
        "teaser": null
      },{
        "title": "Leetcode Java 3sum Closest",
        "excerpt":"문제  Link   코드  class Solution {    public int threeSumClosest(int[] nums, int target) {     Arrays.sort(nums);     int result = nums[0] + nums[1] + nums[nums.length - 1];     for (int idx = 0; idx &lt; nums.length - 2; idx++) {       int start = idx + 1;       int end = nums.length - 1;       while (start &lt; end) {         int sum = nums[idx] + nums[start] + nums[end];         if (Math.abs(target - result) &gt; Math.abs(target - sum)) {           result = sum;         }         if (sum &gt; target) {           end--;         } else {           start++;         }       }     }     return result;   }  }   결과  Link   설명          주어진 정수 배열 nums를 오름차순 정렬한다.       주어진 정수 target의 인접한 세 값의 합을 저장할 result 변수의 초기값을 $nums[0] + nums[1] + nums[nums.length - 1]$로 초기화 한다.            임의의 값을 부여하면, target의 값과 유사한 값이 초기 값으로 설정될 수 있으므로 반복의 첫 값으로 초기화한다.           반복을 통해 첫 값을 제외한 두 pointer의 역할을 수행할 변수 start는 $idx + 1$로, 변수 end는 $nums.length - 1$로 설정해서 첫 pointer인 idx 이후의 값을 순차 탐색할 수 있도록 한다.            반복은 start 변수의 값이 end 변수의 값보다 작을(마주치지 않을) 때까지 반복한다.       임시로 세 pointer의 배열 값을 더하여 sum 변수를 설정한다.       만일 $target - result$의 절대값이 $target - sum$ 보다 클 경우에 result 변수에 sum 변수의 값을 주입한다.       만일 sum 변수의 값이 target의 값보다 크면 작은 값을 더해야 하므로 변수 end의 값을 내리고, 그렇지 않으면 변수 start의 값을 올려 더 큰 값을 더할 수 있도록 하여 반복을 계속 수행한다.           반복이 완료되면 세 값의 합이 target과 가장 인접한 result 변수를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/3sum-closest/",
        "teaser": null
      },{
        "title": "Jekyll Warning: Using the last argument as keyword parameters is deprecated",
        "excerpt":"Warning: Using the last argument as keyword parameters is deprecated     bunlde exec jekyll [serve/build] 등의 명령어를 사용해본 사람들 중 해당 메시지가 Console창에 끝도없이 출력되는 모습을 본 적이 있을 것이다.   모든 사람들이 이 문구를 보고 파악한 가장 큰 문제는 deprecated된 keyword parameters로, 무언가의 상하위 호환에 대한 오류인 점을 알 수 있을 것이다.   하지만 정확히 이 지긋지긋한 메시지를 제거하기 위한 명확한 가이드라인을 검색해서 찾아 해결하기 상당히 귀찮을 것이다. 해서, 이 불필요한 로그를 제거하는 방법을 공유하고자 한다.   Ruby version     루비는 처음부터 2.7을 사용하였고, 시작부터 해당 이슈가 있었기에 근본 문제부터 찾아보기로 한다.    위의 문제는 손쉽게 위의 사진에 표시된 내용임 확인 할 수 있었다.(링크로 본문이 연결된다.)   주요 내용은 “Ruby 3.0 이후에서는 위치 인수와 키워드 인수가 분리되므로 2.7 버전에서는 이에 대한 경고를 하여 코드를 수정해야 한다.”는 내용이다.   해결 방법 1안은 루비 버전을 내려서 메시지가 출력되지 않게 하는 방법이 있을 것이다.   해결 방법 2안은 사용하는 버전의 Plugin등을 사용하는 방법이 있을 것이다.   1안은 미래 지향적으로 좋은 방법은 아닐 것으로 판단하고 2안으로 탐색하고 진행하였다.   Plugin version     Jekyll 버전은 3.6.2를 고정으로 사용했으나, 3.x 버전이 다 해당 문제가 발생함을 확인하였다.    결국 Jekyll을 4.x로 올리는 방향을 고민하였지만, 역시나 여기에도 위의 함정이 있었다.(링크로 본문이 연결된다.)   Github Pages?     Github Pages는 Github 저장소에 Commit한 내용을 웹사이트로 자동으로 만들어 주는 서비스이다.   그럼 이 Github Pages를 사용하지 않으면 블로그 운영이 불가능한 할까? 물론 아니다.   하지만 이 문제는 Github Actions를 통해 해결이 가능한 문제임을 댓글들을 읽다보면 확인 가능하다.   Github Actions?     Github Actions는 Software의 Workflow를 자동화 및 커스터마이징하여 CI/CD 등의 원하는 작업을 직접 구현할 수 있는 도구를 제공하는 서비스를 말한다.   그럼 Github Pages를 통해 자동화 서비스를 받던 부분을 Github Actions로 구현하면 되는 부분이다.   Github Actions - workflow.yml     Github Actions의 중심 파일은 workflow.yml 파일이다.   # This is the name of our workflow. # Github will show it on its Website UI name: deploy # This configures our workflow to be triggered # only when we push to the master branch on:   push:     branches:       - master  # Here is where we define our jobs. # Which means the tasks we want Github to execute jobs:   build:     name: deploy     # Here we specify in whith OS we want it to run     runs-on: ubuntu-18.04     # Now we define which actions will take place.     # One after another     steps:       # This is the first action. It will make sure that we have       # all the necessary files from our repo, including our custom actions       # This action here is actually from a remote repo available from Githup itself       - uses: actions/checkout@v2       # This is our custom action. Here is where we will define our git commands       # to push our website updates to the `gh-pages` branch.       # Notice that we are specifying the path to the action here.       # We will create those files in a sec       - uses: ./.github/actions/build-dist-site         env:           # Now make sure you add this environment variable.           # This token will allow us to push to github directly           # without having to type in our password.           # The GITHUB_TOKEN is available by default            GITHUB_TOKEN: $           GITHUB_REPOSITORY: $           GITHUB_ACTOR: $      이 파일은 /.github/workflows/ 폴더 내에 존재해야 자동으로 인식한다.   secrets.GITHUB_TOKEN, secrets.GITHUB_REPOSITORY, secrets.GITHUB_ACTOR는 workflow 진행 시, 자동으로 제공되는 환경변수이다.   Github Actions - actions     workflow의 jobs.build.steps.uses 항목을 보면 알 수 있듯이 workflow에 대한 actions를 정의해야 한다.   actions는 action.yml, Dockerfile, entrypoint.sh 세 가지로 구성하였다.    Docker 기반이 아닌 Node.js 기반 등 다양한 환경의 actions가 제공이 되므로, 위의 내용을 보기 위해서는 Github -&gt; Repository -&gt; Actions에서 확인 가능하므로 참고바란다.   Github Actions - actions.yml     actions.yml 파일은 새 사이트 버전을 빌드하기 위한 행위를 설정한다.   물론 위에서 설명하였듯이 Docker 기반으로 빌드를 진행하도록 하였다.    # Ok, here the keys are pretty much self explanatory :) name: 'Deploy new version' description: 'Setup Ruby env and build new site version' author: 'GracefulSoul' runs:   using: 'docker'   image: 'Dockerfile'   Github Actions - Dockerfile     Docker 기반으로 빌드하기 위한 기본 Dockerfile이다.   기본으로 ruby:2-slim image 기반으로 구성한다.   마지막으로 ENTRYPOINT를 이용하여 shell file을 Docker가 실행되면 자동으로 수행하도록 해준다.   # Our Docker image will be based on ruby:2-slim # it is a very light docker image. FROM ruby:2-slim LABEL author=\"GracefulSoul\" LABEL version=\"1.0.0\"  # Lets install all dependencies # including git and Bundler 2.1.4 ENV BUNDLER_VERSION 2.1.4 RUN apt-get update &amp;&amp; \\   apt-get install --no-install-recommends -y \\   bats \\   build-essential \\   ca-certificates \\   curl \\   libffi6 \\   make \\   shellcheck \\   libffi6 \\   git-all \\   &amp;&amp; gem install bundler:2.1.4 \\   &amp;&amp; bundle config --global silence_root_warning 1  # This is our entrypoint to our custom scripts # more about that in a sec COPY entrypoint.sh /  # Use the entrypoint.sh file as the container entrypoint # when Github executes our Docker container ENTRYPOINT [\"sh\", \"/entrypoint.sh\"]   Github Actions - entrypoint.sh     초기 환경 변수를 선언한 부분이 이 부분에서 자동으로 Repository를 clone하여 build를 수행한다.   사용자 구성에 따라서 “Jekyll build done” 이후 blog project가 생성되는 폴더의 위치로 이동시켜주면 된다.   #!/bin/bash # Exit immediately if a pipeline returns a non-zero status. set -e  echo \"🚀 Starting deployment action\"  # Here we are using the variables # - GITHUB_ACTOR: It is already made available for us by Github. It is the username of whom triggered the action # - GITHUB_TOKEN: That one was intentionally injected by us in our workflow file. # Creating the repository URL in this way will allow us to `git push` without providing a password # All thanks to the GITHUB_TOKEN that will grant us access to the repository REMOTE_REPO=\"https://${GITHUB_ACTOR}:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git\"  # We need to clone the repo here. # Remember, our Docker container is practically pristine at this point git clone $REMOTE_REPO repo cd repo  # Install all of our dependencies inside the container # based on the git repository Gemfile echo \"⚡️ Installing project dependencies...\" bundle install  # Build the website using Jekyll echo \"🏋️ Building website...\" JEKYLL_ENV=production bundle exec jekyll build echo \"Jekyll build done\"  # Now lets go to the generated folder by Jekyll # and perform everything else from there cd ../posts  echo \"☁️ Publishing website\"  # We don't need the README.md file on this branch rm -f README.md  # Now we init a new git repository inside _site # So we can perform a commit git init git config user.name \"${GITHUB_ACTOR}\" git config user.email \"${GITHUB_ACTOR}@users.noreply.github.com\" git add . # That will create a nice commit message with something like: # Github Actions - Fri Sep 6 12:32:22 UTC 2019 git commit -m \"Github Actions - $(date)\" echo \"Build branch ready to go. Pushing to Github...\" # Force push this update to our gh-pages git push --force $REMOTE_REPO master:gh-pages # Now everything is ready. # Lets just be a good citizen and clean-up after ourselves rm -fr .git cd .. rm -rf repo echo \"🎉 New version deployed 🎊\"        내용을 작성 후 git push까지 진행하게 되면, 위의 사진과 같이 자동으로 workflow가 수행되게 된다.   The end     만일 모르고 Ruby 2.7이 EoS(End of Service)되고 3.0으로 올렸을 경우, 큰 문제에 직면했을 가능성이 있다.     물론 위의 사진처럼 아직 확정되지 않았지만, Ruby를 사용하고 코딩하는 개발자로서 이는 기본으로 파악해야 할 내용이다.   모든 경고 메시지 안에는 추후 발생할 상황을 예측 할 수 있으며, 이를 회피하기 위해서 사전에 해결하는 것이 현명한 방법이다.   Reference  Sujay Kundu - github pages와 actions를 사용하여 쉽게 jekyll blog를 배포하기  ","categories": ["Blog"],
        "tags": ["Blog","Jekyll"],
        "url": "/blog/jekyll-warning-message/",
        "teaser": null
      },{
        "title": "Leetcode Java Letter Combinations of a Phone Number",
        "excerpt":"문제  Link   코드  class Solution {    private static final String[] MAPPING = new String[] { \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" };    public List&lt;String&gt; letterCombinations(String digits) {     List&lt;String&gt; result = new LinkedList&lt;String&gt;();     if (!digits.isEmpty()) {       this.combination(\"\", digits, result);     }     return result;   }    private void combination(String prefix, String digits, List&lt;String&gt; result) {     if (prefix.length() == digits.length()) {       result.add(prefix);       return;     }     String letters = MAPPING[(digits.charAt(prefix.length()) - '0')];     for (int i = 0; i &lt; letters.length(); i++) {       this.combination(this.addCharToString(prefix, letters.charAt(i)), digits, result);     }   }    private String addCharToString(String s, Character c) {     StringBuilder sb = new StringBuilder(s);     sb.append(c);     return sb.toString();   }  }   결과  Link   설명     각 다이얼 숫자가 가진 문자들을 mapping 변수에 정의한다.            재귀호출로 재활용되는 변수이므로, 전역 변수로 지정한다.           각 다이얼 숫자가 가진 문자들의 복합 문자열을 저장하기 위한 변수 result를 선언한다.            순서에 맞추어 저장하기 위해서 LinkedList를 사용한다.                만일 주어진 정수열 digits의 길이가 0인 경우, 문자의 조합이 의미가 없으므로 문제의 결과로 빈 Collection인 result를 주어진 문제의 결과로 반환한다.       재귀 함수를 사용하여 주어진 문자열을 기반으로 결과를 변수 result에 저장하고 해당 재귀를 종료한다.            만일 주어진 문자열 digits의 길이와 결과의 문자열 길이인 prefix의 길이가 같거나 크다면 해당 문자열은 주어진 문제의 결과 중 하나이다.           주어진 문자열의 특정 자릿수의 다이얼 문자들을 letter에 임시 저장한다.            기존 문제들과 유사하게 특정 자릿수의 index를 가져오는 방법은 character 형의 숫자 문자를 ‘0’으로 빼주게 되면 Ascii code 10진수 기반으로 자기 자신의 숫자로 반환된다.           특정 자릿수의 다이얼 문자들을 한 자리씩 prefix에 덧붙이고 재귀 호출을 반복한다.            동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.       위의 4번의 조건에 의해 재귀 호출은 각각 마무리되고 결과를 변수 result에 저장하게된다.           반복이 끝나면 각 다이얼 숫자가 가진 문자들의 복합 문자열을 저장한 변수 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/letter-combinations-of-a-phone-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove Nth Node From End of List",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode removeNthFromEnd(ListNode head, int n) {     ListNode result = new ListNode(0, head);     ListNode pointer = result;     ListNode temp = result;     for (int i = 0; i &lt;= n; i++) {       pointer = pointer.next;     }     while (pointer != null) {       temp = temp.next;       pointer = pointer.next;     }     temp.next = temp.next.next;     return result.next;   }  }   결과  Link   설명     특정 노드의 값을 제거한 ListNode를 만들 result 변수를 next 값에 head를 넣고 생성한다.            테스트 파라미터가 ListNode(1, null), 1을 주어진 경우 해당 노드를 삭제해야 하기 때문에 문제를 수행하기위해 임의의 값과 주어진 문제의 ListNode를 이용하여 껍데기 역할인 ListNode(0, head)로 선언한다.                제거할 목표 노드의 위치를 탐색하기 위해 pointer와 temp를 result를 주입하여 만들어준다.       pointer는 주어진 정수 n번만큼 next값을 pointer에 주입하여 위치를 탐색하기 위한 초석을 만든다.            주어진 정수 n은 제거할 목표 노드의 역순 위치를 제공하므로, pointer를 먼저 이동하여 temp 노드가 제거할 목표의 위치까지 도달하기 위한 역할을 수행한다.           pointer가 null이 아닐 때 까지 반복을 수행하여 temp의 위치를 이동한다.            2번의 설명에 덧붙여서, 제거할 목표의 위치 전 노드의 위치로 이동을 해야 next 값에 next.next 값으로 넣어 줄 수 있으므로 주어진 정수 n번만큼 pointer를 이동시킨 것이다.       주어진 예제를 이용하여 설명하자면, “1 - 2 - 3(목표위치) - 4 - 5” 이 위치로 이동시키는 것이다.           목표 위치의 전 노드에 도달한 temp의 next 값에, temp.next.next 값을 주입한다.            변수 temp는 변수 result를 참조하여 만들었으므로, 특정 ListNode의 값이 변경되면 result 또한 해당 노드의 값이 동일하게 변경된다.           껍데기로 사용했던 변수 result 대신 변수 result의 next를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-nth-node-from-end-of-list/",
        "teaser": null
      },{
        "title": "Leetcode Java Valid Parentheses",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isValid(String s) {     Stack&lt;Character&gt; stack = new Stack&lt;&gt;();     for (char c : s.toCharArray()) {       switch (c) {       case '(':       case '{':       case '[':         stack.push(c);         break;       case ')':         if (stack.isEmpty() || !stack.pop().equals('(')) {           return false;         }         break;       case '}':         if (stack.isEmpty() || !stack.pop().equals('{')) {           return false;         }         break;       case ']':         if (stack.isEmpty() || !stack.pop().equals('[')) {           return false;         }         break;       }     }     return stack.isEmpty();   }  }   결과  Link   설명     주어진 문제의 검증을 위해 후입선출의 Stack을 사용하여 변수 stack을 정의한다.            문제의 요점은 소, 중, 대 괄호가 열고 닫힘이 정확히 맞는 부분을 요구하는 것이므로, 이 부분에 초점을 맞추어 Stack을 사용한다.       마지막으로 ‘(‘ 문자가 들어왔을 경우, ‘)’문자가 다음에 나오면 괄호의 순서에 맞게 닫히는 경우이다.       마지막으로 ‘(‘ 문자가 들어왔을 경우, ‘{‘, ‘[’ 문자가 나오면 그대로 누적하여 반대 문자가 나와서 괄호가 정상적으로 닫히는지 여부를 확인하여야 한다.           1번의 검증이 끝나서 변수 stack은 비어있을 것이므로, stack에 남은 문자가 남아있는지 여부를 주어진 문제의 결과로 제공한다.            순차적으로 열고 닫은 괄호의 경우, stack에는 아무 값도 없을 것이다.       만일 순차적이지 않은 문자열의 경우, stack에는 값이 남아있어야한다. (Ex. 문자열 ‘({))’의 경우, ‘}’ 문자가 나오지 않았으므로 반복은 종료되고 ‘{‘가 남아있는 stack은 비어있지 않으므로 주어진 문제의 결과는 false가 반환될 것이다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/valid-parentheses/",
        "teaser": null
      },{
        "title": "Leetcode Java Merge Two Sorted Lists",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {     if (l1 == null) {       return l2;     } else if (l2 == null) {       return l1;     } else {       if (l1.val &lt; l2.val) {         l1.next = mergeTwoLists(l1.next, l2);         return l1;       } else {         l2.next = mergeTwoLists(l1, l2.next);         return l2;       }     }   }  }   결과  Link   설명     주어진 두 ListNode l1, l2가 정렬되어 있으므로, 순차적으로 각 val의 값을 비교하여 ListNode를 합쳐주면 된다.            val 값이 작은 ListNode의 next의 ListNode와 다른 ListNode로 재귀호출이 수행된다.       한 ListNode의 next 값이 null이 되면 다른 ListNode의 모든 val 값은 마지막 비교한 상대 ListNode의 val 값보다 크므로 해당 ListNode를 반환한다.       이제 순차적으로 val 값이 작은 ListNode의 결과에 따라서 next 값에 재귀 호출 결과가 들어가게 된다.       이렇게 조건문이 수행된 역순으로 각 절차가 수행되게 되면, 마지막으로 수행된 값은 순서대로 두 ListNode를 합친 ListNode가 되어 주어진 문제의 결과로 반환된다.           예제     주어진 문제의 Example 1을 이용하여 작업 절차를 예제로 보여주겠다.      각 ListNode의 초기 값은 l1 = [1, 2, 4] &amp; l2 = [1, 2, 4]로, 재귀 호출이 반복되어 l1이 반환된다.            l1 = 4, l2 = null           마지막으로 수행된 재귀호출은 l1 = 4 &amp; l2 = 4 이므로, l1 &lt; l2를 만족하지 않아 l2.next에 l1이 들어가게 된다.            l1 = 4, l2 = [4, 4]           그 전의 경우는 l1 = 4 &amp; l2 = 3 이므로, l1 &lt; l2를 만족하지 않아 l2.next에 l2가 들어가게 된다.            l1 = 4, l2 = [3, 4, 4]           그 전의 경우는 l1 = 2 &amp; l2 = 3 이므로, l1 &lt; l2를 만족하여 l1.next에 l1이 들어가게 된다.            l1 = [2, 3, 4, 4], l2 = [3, 4, 4]           그 전의 경우는 l1 = 1 &amp; l2 = 3 이므로, l1 &lt; l2를 만족하여 l1.next에 l1이 들어가게 된다.            l1 = [1, 2, 3, 4, 4], l2 = [3, 4, 4]           최초 재귀 호출의 경우는 l1 = 1 &amp; l2 = 1 이므로, l1 &lt; l2를 만족하지 않아 l2.next에 l1이 들어가게 되어 l2가 주어진 문제의 결과로 반환된다.            l1 = [1, 2, 3, 4, 4], l2 = [1, 1, 2, 3, 4, 4]           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/merge-two-sorted-lists/",
        "teaser": null
      },{
        "title": "Leetcode Java Merge k Sorted Lists",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode mergeKLists(ListNode[] lists) {     return this.mergeListsRecursion(lists, 0, lists.length - 1);   }    private ListNode mergeListsRecursion(ListNode[] lists, int start, int end) {     if (start == end) {       return lists[start];     } else if (start &lt; end) {       int half = (start + end) / 2;       ListNode l1 = this.mergeListsRecursion(lists, start, half);       ListNode l2 = this.mergeListsRecursion(lists, half + 1, end);       return this.mergeTwoLists(l1, l2);     } else {       return null;     }   }    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {     if (l1 == null) {       return l2;     } else if (l2 == null) {       return l1;     } else {       if (l1.val &lt; l2.val) {         l1.next = mergeTwoLists(l1.next, l2);         return l1;       } else {         l2.next = mergeTwoLists(l1, l2.next);         return l2;       }     }   }  }   결과  Link   설명     주어진 ListNode의 배열을 절반으로 나누어 각각을 재귀호출을 통해서 ListNode를 합친다.            재귀 호출은 주어진 배열의 index가 0에서 $lists.length - 1$까지의 ListNode를 합쳐야 하므로, 해당 값으로 변수 start와 end로 해당 값을 받아 재귀 호출을 수행하도록 한다.           만일 변수 start의 값과 end의 값이 동일한 경우에는 ListNode를 합칠 이유가 없으므로, 주어진 배열 lists의 변수 start의 값의 ListNode를 반환한다.            start와 end의 값이 동일하므로, end의 값을 사용해도 된다.           만일 변수 start의 값이 end보다 작을 경우만 아래의 작업을 수행하고, 그 외는 초기 값인 null을 반환한다.            주어진 배열 lists를 절반으로 분할하여 ListNode를 하나로 합치기 위해서 half 변수를 $\\frac{start - end}{2}$의 값으로 초기화한다.       ListNode l1은 end 파라미터 자리에 half를 사용하여 재귀호출을 수행한 결과를 저장한다.       ListNode l2는 start 파라미터 자리에 $half + 1$을 사용하여 재귀호출을 수행한 결과를 저장한다.       각 재귀호출의 결과를 저장한 ListNode l1과 l2를 이전에 작성하였던 Merge Two Sorted Lists를 활용하여 하나의 ListNode로 합쳐준다.           재귀호출이 끝난 ListNode를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/merge-k-sorted-lists/",
        "teaser": null
      },{
        "title": "Leetcode Java Generate Parentheses",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; generateParenthesis(int n) {     List&lt;String&gt; list = new ArrayList&lt;&gt;();     this.generate(list, \"\", 0, 0, n);     return list;   }    private void generate(List&lt;String&gt; list, String str, int left, int right, int n) {     if (str.length() == n * 2) {       list.add(str);       return;     }     if (left &lt; n) {       this.generate(list, this.appendString(str, '('), left + 1, right, n);     }     if (right &lt; left) {       this.generate(list, this.appendString(str, ')'), left, right + 1, n);     }   }    private String appendString(String str, char c) {     return new StringBuilder(str).append(c).toString();   }  }   결과  Link   설명     주어진 정수 n의 크기만큼의 올바른 형식의 소괄호 모양을 만들기 위해서 최대 크기부터 재귀 호출을 사용한다.            올바른 형식의 최대 크기 소괄호 모양을 만들기 위해서는 ‘(‘ 문자열이 n개부터 시작하는 경우이다.       올바른 형식의 최소 크기 소괄호 모양을 만들기 위해서는 ‘(‘ 문자열이 1개부터 시작하는 경우이다.           만일 올바른 형식의 소괄호 모양을 저장하는 str의 크기가 주어진 정수 n의 2배일 경우, 결과를 저장하는 배열 list에 추가한다.            올바른 형식의 소괄호 문자열은 항상 ‘(‘ 문자열과 ‘)’ 문자열의 개수가 같으므로, 최대 문자열의 길이는 항상 $n \\times 2$이어야 한다.           변수 left가 주어진 숫자 n보다 작은 경우, ‘(‘ 문자를 문자열 str에 이어쓰고 $left + 1$을 하여 재귀 호출을 반복한다.            이 경우, 1번에서 이야기한 ‘(‘ 문자열이 n개부터 시작하는 문자열을 만들기 시작한다.           변수 right가 변수 left보다 작은 경우, ‘)’문자를 문자열 str에 이어쓰고 $rigth + 1$을 하여 재귀 호출을 반복한다.            이 경우, 1번에서 이야기한 ‘(‘ 문자열이 1개부터 시작하는 문자열을 만들기 시작한다.           재귀호출이 완료되면 결과를 저장하는 배열 list를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/generate-parentheses/",
        "teaser": null
      },{
        "title": "Leetcode Java Swap Nodes in Pairs",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode swapPairs(ListNode head) {     if (head == null || head.next == null) {       return head;     }     List&lt;Integer&gt; list = new ArrayList&lt;&gt;();     while (head != null) {       if (head.next == null) {         list.add(head.val);         head = head.next;       } else {         ListNode temp = head.next;         list.add(temp.val);         list.add(head.val);         head = head.next.next;       }     }     ListNode ln = null;     for (int idx = list.size(); idx &gt; 0; idx--) {       ln = new ListNode(list.get(idx - 1), ln);     }     return ln;   }  }   결과  Link   설명          주어진 ListNode head가 null이거나 head.next가 null인 경우, 위치를 변경할 ListNode가 없으므로 주어진 문제의 결과로 head를 반환한다.       반복을 통해 주어진 ListNode haed가 null이 될 때까지 val 값을 List에 모두 넣는다.            head.next가 null인 경우, 순서를 바꾸지 못하므로 head.val 값만 List에 넣는다.       head.next가 존재하는 경우, 순서를 바꿔주어야 하므로 head.next.val와 head.val값을 순서를 바꾸어 List에 넣는다.           반복이 완료되면 순서를 바꾸어준 List 기반으로 ListNode를 생성하여, 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/swap-nodes-in-pairs/",
        "teaser": null
      },{
        "title": "Leetcode Java Reverse Nodes in k-Group",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode reverseKGroup(ListNode head, int k) {     ListNode curr = head;     int count = 0;     while (curr != null &amp;&amp; count != k) {       curr = curr.next;       count++;     }     if (count == k) {       curr = this.reverseKGroup(curr, k);       while (count-- &gt; 0) {         ListNode tmp = head.next;         head.next = curr;         curr = head;         head = tmp;       }       head = curr;     }     return head;   }  }   결과  Link   설명          특정 위치까지 숫자를 반전시키기 위해 주어진 ListNode head를 변수 curr에 넣고, 변수 count를 0으로 정의한다.       ListNode curr이 null이 아니거나 count가 k보다 작을 때 까지 반복을 통해 ListNode를 이동한다.            이동시킨 ListNode curr은 반전시킬 위치 이후($k + 1$)의 위치까지 이동시켜, 이전 노드들을 반전시킬 수 있도록 한다.       count를 증가시켜, 반전시켜야 할 ListNode의 개수를 파악한다.           count와 k가 동일하면, 재귀 호출을 이용하여 k 배수만큼의 숫자를 반전시킨다.            2번 에서 $k + 1$까지 이동시킨 curr를 이용하여 재귀호출을 통해 다시 k자릿수가 될 경우, 반전시키고 그렇지 않은 경우 curr을 그대로 반환한다.       반전시키기 위해서 tmp 변수를 선언하여 ListNode의 순서를 역순으로 넣어준다.           반복을 통해 반전시킨 ListNode curr을 head에 넣고, 주어진 문제의 결과로 반환한다.            재귀 호출의 경우, k 배수가 안될 경우 주어진 head를 그대로 반환하기 위해서 반환의 기준을 head로 한다.       재귀 호출로 반복되는 경우, k 배수만큼 숫자를 반복으로 반전시킨다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reverse-nodes-in-k-group/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove Duplicates from Sorted Array",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode reverseKGroup(ListNode head, int k) {     int idx = 0;     for (int n : nums) {       if (idx == 0 || n &gt; nums[idx - 1]) {         nums[idx++] = n;       }     }     return idx;   }  }   결과  Link   설명     주어진 배열 nums는 이미 정렬이 되어 있으므로, 배열 내 이전 index의 값이 다른 경우의 개수만 확인하면 된다.            문제의 결과는 중복되지 않은 배열의 값의 개수이므로, 새 배열을 선언하여 넣지 않아도 된다.       배열의 첫 값은 무조건 중복되지 않은 값이므로, count를 증가시킨다.       가장 중요한 idx 값을 점층적으로 증가시키면서 nums[idx++] 값에 중복되지 않은 값을 넣는 이유는, 중복되지 않은 값을 비교하면서 count를 세기 위함이다.           반복이 종료되면, 중복되지 않은 값의 개수를 저장하는 idx를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-duplicates-from-sorted-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove Element",
        "excerpt":"문제  Link   코드  class Solution {    public int removeElement(int[] nums, int val) {     int i = 0;     for (int n : nums) {       if (n != val) {         nums[i++] = n;       }     }     return i;   }  }   결과  Link   설명     주어진 배열 nums을 반복으로 주어진 정수 val과 다른 값의 개수를 파악한다.            주어진 배열 nums의 내부 값이 val과 다르다면 i의 값을 점층적으로 증가시킨다.           반복이 종료되면 주어진 정수 val과 다른 값의 개수를 저장한 i의 값을 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-element/",
        "teaser": null
      },{
        "title": "Leetcode Java Implement strStr() Array",
        "excerpt":"문제  Link   코드  class Solution {    public int strStr(String haystack, String needle) {     if (needle.length() == 0) {       return 0;     }     if (haystack.length() == 0) {       return -1;     }     for (int i = 0; i &lt; haystack.length(); i++) {       if (i + needle.length() &gt; haystack.length()) {         return -1;       }       for (int j = 0; j &lt; needle.length(); j++) {         if (haystack.charAt(i + j) != needle.charAt(j)) {           break;         } else if (j == needle.length() - 1) {           return i;         }       }     }     return -1;   }  }   결과  Link   설명          주어진 문제는 Java에서 String 내 indexOf 메서드를 보면 금방 파악하는 문제이다.       주어진 변수 needle의 길이가 0인 경우, 소속된 문자열이 어느 위치든 포함이 되므로 0을 주어진 문제의 결과로 반환한다.            needle의 길이가 0인 경우는 ““이므로, 어느 문자열이든 첫 문자열에 포함된다.                주어진 변수 haystack의 길이가 0인 경우, 주어진 변수 needle이 어떠한 값이더라도 포함되지 않으므로 -1을 주어진 문제의 결과로 반환한다.       haystack과 needle을 각 문자 별로 반복하여 결과를 탐색한다.            단 haystack의 시작 문자의 index + needle의 문자열 길이가 haystack의 문자열 길이보다 클 경우에는 포함된 단어가 없으므로, -1을 주어진 문제의 결과로 반환한다.       만일 haystack의 i번째 문자와 needle의 0번째 문자열이 같은 경우 j를 증가시키며 비교를 한다.       만일 j의 길이가 needle의 길이와 같다면, needle의 문자열과 일치한 haystack의 첫 index인 i를 주어진 문제의 결과로 반환한다.           반복이 종료되면, 일치된 결과가 존재하지 않으므로 -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/implement-strstr/",
        "teaser": null
      },{
        "title": "Leetcode Java Divide Two Integers",
        "excerpt":"문제  Link   코드  class Solution {    public int divide(int dividend, int divisor) {     if (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) {       return Integer.MAX_VALUE;     } else {       return dividend / divisor;     }   }  }   결과  Link   설명     주어진 문제에 가장 큰 함정은 최소 값을 -1로 나눈 경우, Integer.MAX_VALUE보다 커진다는 점이다.            $-2,147,483,648 \\times -1 = 2,147,483,648 &gt; 2,147,483,647$ 이므로, 이 경우는 Integer.MAX_VALUE인 $2,147,483,647$을 주어진 문제로 반환한다.           그 외의 경우는 주어진 두 변수를 나눈($\\frac{dividned}{divisor}$) 몫을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/divide-two-integers/",
        "teaser": null
      },{
        "title": "MyBatis java.lang.NoSuchMethodException: java.lang.Long.<init>() 원인과 해결",
        "excerpt":"오류 발생     Mapper     &lt;!-- ... --&gt;   &lt;select id=\"getCustomer\" parameterType=\"java.lang.Long\"&gt;     SELECT * FROM customer     WHERE id = #{id}   &lt;/select&gt;   &lt;!-- ... --&gt;           간단히 주어진 고객 id를 이용하여, 해당 고객의 정보를 가져오는 쿼리를 Mapper에 생성하였다.            Console Log       org.apache.ibatis.exceptions.PersistenceException:  ### Error querying database.  Cause: org.apache.ibatis.reflection.ReflectionException: Error instantiating class java.lang.Long with invalid types () or values (). Cause: java.lang.NoSuchMethodException: java.lang.Long.&lt;init&gt;() ### The error may exist in gracefulsoul/mybatis/resouces/mapper/CustomerMapper.xml ### The error may involve gracefulsoul.mybatis.resouces.mapper.CustomerMapper.getCustomer ### The error occurred while handling results ### SQL: SELECT * FROM customer     WHERE id = ? ### Cause: org.apache.ibatis.reflection.ReflectionException: Error instantiating class java.lang.Long with invalid types () or values (). Cause: java.lang.NoSuchMethodException: java.lang.Long.&lt;init&gt;()      해당 쿼리를 수행하는 API를 호출하게 되면 갑자기 이런 오류가 발생한다.   오류 내용을 확인하면 MyBatis에서 Reflection을 사용하는데, java.lang.Long 클래스의 Default Constructor(기본 생성자)가 존재하지 않는다고 오류가 발생하였다.   원인 분석     Java Docs - java.lang.Long     /* line 932 */   /**     * The value of the {@code Long}.     *     * @serial     */   private final long value;    /**     * Constructs a newly allocated {@code Long} object that     * represents the specified {@code long} argument.     *     * @param   value   the value to be represented by the     *          {@code Long} object.     */   public Long(long value) {       this.value = value;   }    /**     * Constructs a newly allocated {@code Long} object that     * represents the {@code long} value indicated by the     * {@code String} parameter. The string is converted to a     * {@code long} value in exactly the manner used by the     * {@code parseLong} method for radix 10.     *     * @param      s   the {@code String} to be converted to a     *             {@code Long}.     * @throws     NumberFormatException  if the {@code String} does not     *             contain a parsable {@code long}.     * @see        java.lang.Long#parseLong(java.lang.String, int)     */   public Long(String s) throws NumberFormatException {       this.value = parseLong(s, 10);   }   /* line 967 */      위의 Java Docs 내 java.lang.Long 소스코드를 보면 Default Constructor가 존재하지 않는 것을 확인 할 수 있다.   MyBatis에서는 Reflection을 이용하여 동적인 파라미터 초기화를 수행하므로, 기본 생성자가 없으면 객체 초기화가 불가능하기 때문에 당연히 오류가 발생하게 된다.   그렇기 때문에 MyBatis에서 java.lang.Long을 parameterType으로 명시할 경우, 해당 타입의 기본 생성자가 없으므로 오류가 발생한다.   오류 해결     Mapper     &lt;!-- ... --&gt;   &lt;select id=\"getCustomer\"&gt;     SELECT * FROM customer     WHERE id = #{id}   &lt;/select&gt;   &lt;!-- ... --&gt;      해결 방법은 Mapper 내 getCustomer에 parameterType을 명시하지 않도록 처리하였다.   이렇게 실제 주입한 파라미터가 java.lang.Long이어도 오류가 발생하지 않는 이유는 AutoBoxing과 UnBoxing에 의해 타입 유추가 되어 위의 Exception이 발생하지 않는 것이다.  ","categories": ["Java"],
        "tags": ["Programming","Java","MyBatis"],
        "url": "/java/mybatis-nosuchmethodexception/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Valid Parentheses",
        "excerpt":"문제  Link   코드  class Solution {    public int longestValidParentheses(String s) {     Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();     int result = 0;     for (int idx = 0; idx &lt; s.length(); idx++) {       if (s.charAt(idx) == ')' &amp;&amp; !stack.isEmpty() &amp;&amp; s.charAt(stack.peek()) == '(') {         stack.pop();         result = Math.max(result, stack.isEmpty() ? idx + 1 : idx - stack.peek());       } else {         stack.push(idx);       }     }     return result;   }  }   결과  Link   설명          주어진 소괄호로 이루어진 문자열 s를 검증하기 위한 Stack과 문제의 결과를 저장할 result 변수를 선언한다.       주어진 문자열 s의 길이만큼 반복하면서 문자열 검증을 수행한다.            주어진 문자열 s의 idx번째 문자가 ‘(‘일 경우, 해당 index를 Stack에 저장한다.       주어진 문자열 s의 idx번째 문자가 ‘)’일 경우, Stack이 비어있지 않고, 주어진 문자열 s의 Stack에 최근 저장된 인덱스의 문자가 ‘(‘인 경우 문자열의 길이를 저장한다.                    Stack에 최근 저장된 인덱스의 문자 검증이 끝났으므로, 해당 값은 pop()으로 제거해준다.           주어진 문제의 결과를 저장한 result 변수와 Stack이 비어있으면 idx + 1, 그렇지 않으면 idx - stack에 남은 최근 인덱스의 결과 중 큰 값을 result 변수에 주입한다.                                 Stack이 비어있다는 것은, 모든 값이 소괄호의 조합으로 끝난 경우이므로, 해당 위치의 인 idx에 + 1을 더하여 길이를 산정한다.       Stack이 비어있지 않다는 것은, ‘(‘ 문자열이 남아있는 경우이므로, 해당 인덱스를 idx에서 빼서 문자열 중간의 소괄호의 조합의 길이를 산정한다.           반복이 종료되면 문제의 결과를 저장한 reulst 변수를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-valid-parentheses/",
        "teaser": null
      },{
        "title": "Leetcode Java Search in Rotated Sorted Array",
        "excerpt":"문제  Link   코드  class Solution {    public int search(int[] nums, int target) {     for (int idx = 0; idx &lt; nums.length; idx++) {       if (nums[idx] == target) {         return idx;       }     }     return -1;   }  }   결과  Link   설명          주어진 문제는 어렵게 생각할 필요 없이, 배열 내 주어진 target의 index를 반환하는 문제이다.            반복문을 통해 해당 값을 찾아서 index를 주어진 문제의 결과로 반환하면 된다.            단, 배열 내 target의 값이 존재하지 않을 경우, -1을 주어진 문제의 결과로 반환하면 된다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/search-in-rotated-sorted-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Valid Sudoku",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isValidSudoku(char[][] board) {     Set&lt;String&gt; set = new HashSet&lt;&gt;();     for (int i = 0; i &lt; board.length; i++) {       for (int j = 0; j &lt; board[i].length; j++) {         if (board[i][j] != '.') {           if (!set.add(this.appendString(i, board[i][j])) ||             !set.add(this.appendString(board[i][j], j)) ||             !set.add(this.appendString(i / 3, j / 3, board[i][j]))) {             return false;           }         }       }     }     return true;   }    private String appendString(int... ints) {     StringBuilder sb = new StringBuilder();     for (int idx = 0; idx &lt; ints.length; idx++) {       sb.append(ints[idx]);       if (idx &lt; ints.length - 1) {         sb.append(',');       }     }     return sb.toString();   }  }   결과  Link   설명     주어진 2차원 배열 board를 이용하여 스도쿠의 기본 틀로 사용이 가능한지를 검증하기 위해서는 아래의 기본 조건을 만족하여야 한다.            주어진 스도쿠의 크기는 $9 \\times 9$의 크기로 숫자는 1 ~ 9 까지 존재한다.       각 가로열에는 1 ~ 9 까지의 숫자가 고유하게 들어가야 한다.       각 세로열에는 1 ~ 9 까지의 숫자가 고유하게 들어가야 한다.       $3 \\times 3$ 크기로 나눈 9개의 정육면체 배열에 1 ~ 9 까지 숫자가 고유하게 들어가야 한다.           고유 값이 들어가는 조건을 검증하기 위해 Set을 정의하였다.            Set은 중복이 배제된 Collection으로, add(E e) 메서드는 e의 값이 중복되어 들어있는지 여부의 boolean 값을 반환한다.       그렇기 때문에 각 조건에 대한 값들을 누적해서 저장하다보면, 중복된 값이 있는지를 파악할 수 있다.                모든 배열의 내용을 반복하여 위의 경우에 중복된 값이 존재하는지를 검증한다.       ’.’이 아닌 숫자인 경우, 1번의 세 조건을 set에 String으로 저장하였다.            각 숫자 문자열의 Ascii code 10진수 값은 48(0) ~ 57(9) 이므로, 중복된 값을 저장하기 위해선 임의의 Format을 정의하여 값을 누적시키면 된다.       가로열 검증에는 i, board[i][j] 형태로 문자열을 정의하였다.       세로열 검증에는 board[i][j], j 형태로 문자열을 정의하였다.       $3 \\times 3$ 크기의 정육면체 검증에는 $\\frac{i}{3}$, board[i][j], $\\frac{j}{3}$ 형태로 문자열을 정의하였다.       $3 \\times 3$ 크기의 정육면체 검증에 쓰인 i와 j에 3을 나눠준 이유는 각 정육면체를 분류하기 위해서이다. (자세한건 아래에 그림으로 그렸다.)        동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.                만일 중복된 값이 있으면(add 메서드가 false를 반환하면) 주어진 문제의 결과로 false를 반환한다.       반복문이 끝난 경우 주어진 문제의 스도쿠 배열인 board가 정상이라는 의미이므로, 주어진 문제의 결과로 true를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/valid-sudoku/",
        "teaser": null
      },{
        "title": "Leetcode Java Find First and Last Position of Element in Sorted Array",
        "excerpt":"문제  Link   코드  class Solution {    public int[] searchRange(int[] nums, int target) {     int first = this.search(nums, target);     if (first == nums.length || nums[first] != target) {       return new int[] { -1, -1 };     } else {       return new int[] { first, this.search(nums, target + 1) - 1 };     }   }    private int search(int[] nums, int target) {     int low = 0;     int high = nums.length;     while (low &lt; high) {       int mid = (low + high) / 2;       if (nums[mid] &lt; target) {         low = mid + 1;       } else {         high = mid;       }     }     return low;   }  }   결과  Link   설명          주어진 문제는 반드시 $O\\log n$의 시간 복잡도로 풀어야 하는 조건을 반드시 명심해야 한다.       이진 탐색을 통해 주어진 배열 nums 안에 존재하는 target 정수가 존재하는 첫번째 index를 탐색한다.            0부터 nums의 길이를 기반으로 절반씩 나누어 target의 index를 탐색한다.                첫 탐색 결과 index가 주어진 배열 num의 길이와 같거나, 주어진 배열의 index번째 값이 target과 다른 경우 목표하는 값이 존재하지 않으므로 [-1, -1] 배열을 주어진 문제의 결과로 반환한다.       그렇지 않은 경우, 두 번째 이진 탐색을 target + 1 값으로 탐색하고, 반환된 index에 - 1을 하여 마지막 index를 탐색하여 first 값과 해당 index를 배열로 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-first-and-last-position-of-element-in-sorted-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Sudoku Solver",
        "excerpt":"문제  Link   코드  class Solution {    public void solveSudoku(char[][] board) {     if (board == null || board.length == 0) {       return;     }     this.solve(board);   }    private boolean solve(char[][] board) {     for (int i = 0; i &lt; board.length; i++) {       for (int j = 0; j &lt; board[i].length; j++) {         if (board[i][j] == '.') {           for (char c = '1'; c &lt;= '9'; c++) {             if (this.isValid(board, i, j, c)) {               board[i][j] = c;               if (this.solve(board)) {                 return true;               } else {                 board[i][j] = '.';               }             }           }           return false;         }       }     }     return true;   }    private boolean isValid(char[][] board, int row, int col, char c) {     for (int i = 0; i &lt; 9; i++) {       if (board[i][col] != '.' &amp;&amp; board[i][col] == c ||         board[row][i] != '.' &amp;&amp; board[row][i] == c ||         (           board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] != '.' &amp;&amp;           board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c         )       ) {         return false;       }     }     return true;   }  }   결과  Link   설명     이전의 Valid Sudoku 문제와 유사하게 기본 조건은 아래와 같이 동일하며, 주어진 변수 board에 완벽한 스도쿠 판을 채우는 문제이다.            주어진 스도쿠의 크기는 $9 \\times 9$의 크기로 숫자는 1 ~ 9 까지 존재한다.       각 가로열에는 1 ~ 9 까지의 숫자가 고유하게 들어가야 한다.       각 세로열에는 1 ~ 9 까지의 숫자가 고유하게 들어가야 한다.       $3 \\times 3$ 크기로 나눈 9개의 정육면체 배열에 1 ~ 9 까지 숫자가 고유하게 들어가야 한다.                반복을 통해 i는 row, j는 col 영역을 순환하며 ‘.’ 문자가 존재하는 경우만 1 ~ 9 까지 숫자가 들어갈 수 있는지를 검증한다.       다시 변수 c를 ‘1’ ~ ‘9’의 문자를 반복하여 들어갈 수 있는지를 1번의 기본 조건을 만족하는지 검증한다.            조건을 만족하는 경우 true를 반환하고, 만족하지 않는 경우 false를 반환한다.       만일 만족하지 않는 경우는 무시하고 다음 숫자로 다시 검색한다.           기본 조건을 만족하는 경우, 해당 위치에 문자를 주입하고, 다시 재귀 호출을 사용하여 처음부터 검증을 다시 수행한다.            재귀 호출의 결과가 true인 경우, 스도쿠 문자열의 배열이 정상적으로 끝난 경우이므로 true를 반환한다.       재귀 호출의 결과가 false인 경우, 해당 자리에 들어갈 숫자가 아니므로 board[i][j] 자리에 ‘.’ 문자열을 다시 넣어준다.                3번의 반복이 정상적으로 끝난 경우, 스도쿠 문자열의 배열이 정상적이지 않은 경우이므로 false를 반환한다.            2번의 반복이 정상적으로 끝난 경우, 스도쿠 문자열의 모든 문자열의 배열이 정상적으로 완료가 되었으므로, true를 반환한다.       각 반환의 결과가 최초 호출의 경우 해당 불리언 값을 주어진 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sudoku-solver/",
        "teaser": null
      },{
        "title": "Leetcode Java Combination Sum",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     this.getCombination(result, new ArrayList&lt;&gt;(), candidates, target, 0);     return result;   }    private void getCombination(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; list, int[] candidates, int target, int start) {     if (target == 0) {       result.add(new ArrayList&lt;&gt;(list));     } else if (target &gt; 0) {       for (int idx = start; idx &lt; candidates.length; idx++) {         list.add(candidates[idx]);         this.getCombination(result, list, candidates, target - candidates[idx], idx);         list.remove(list.size() - 1);       }     }   }  }   결과  Link   설명          주어진 배열 candidates의 값들을 이용하여 target의 값이 되는 조합을 탐색하는 문제이다.            탐색한 숫자의 조합을 저장할 컬렉션인 result를 정의한다.       재귀호출을 이용하여 숫자의 조합을 변수 result에 저장한다.            target이 0이면 숫자 조합의 합이 0이 되는 경우이므로, 해당 값의 조합을 변수 result에 넣는다.       target이 0보다 작으면 숫자 조합의 합이 target보다 큰 경우이므로, 무시한다.       target이 0보다 크면 숫자 조합의 합이 target보다 작은 경우이므로, 지속적으로 나머지 숫자의 합이 되는 값을 탐색하기 위해 주어진 배열 candidates를 반복하여 탐색한다.                    값을 list에 추가하고, 재귀호출을 통해서 조합을 지속 탐색한다.           주어진 문제의 합이 target보다 커서 무시한 조합이거나, target과 동일하여 result에 저장된 조합인 경우 재귀호출이 종료된다.           마지막으로 저장한 list의 값을 제거하고 다시 반복문을 통해서 조합을 탐색한다.                           재귀호출이 종료되면 숫자의 조합을 저장한 result 변수를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/combination-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Combination Sum II",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     Arrays.sort(candidates);     this.getCombination(result, new ArrayList&lt;&gt;(), candidates, target, 0);     return result;   }    private void getCombination(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; list, int[] candidates, int target, int start) {     if (target == 0) {       result.add(new ArrayList&lt;&gt;(list));     } else if (target &gt; 0) {       for (int idx = start; idx &lt; candidates.length; idx++) {         if (idx &gt; start &amp;&amp; candidates[idx - 1] == candidates[idx]) {           continue;         }         list.add(candidates[idx]);         this.getCombination(result, list, candidates, target - candidates[idx], idx + 1);         list.remove(list.size() - 1);       }     }   }  }   결과  Link   설명          이전 문제인 Combination Sum과 유사한 문제이다.            주어진 배열 candidates의 값들을 중복되지 않게 이용하여 target의 값이 되는 조합을 탐색하는 문제이다.            탐색한 숫자의 조합을 저장할 컬렉션인 result를 정의하고, 주어진 배열 candidates를 오름차순 정렬한다.       재귀호출을 이용하여 숫자의 조합을 변수 result에 저장한다.            target이 0이면 숫자 조합의 합이 0이 되는 경우이므로, 해당 값의 조합을 변수 result에 넣는다.       target이 0보다 작으면 숫자 조합의 합이 target보다 큰 경우이므로, 무시한다.       target이 0보다 크면 숫자 조합의 합이 target보다 작은 경우이므로, 지속적으로 나머지 숫자의 합이 되는 값을 탐색하기 위해 주어진 배열 candidates를 반복하여 탐색한다.                    만일 idx가 start 값보다 크고, 주어진 배열 candidates의 직전 값과 동일한 경우 해당 값을 무시하고 탐색을 계속한다.           값을 list에 추가하고, 재귀호출을 통해서 조합을 지속 탐색한다.           주어진 문제의 합이 target보다 커서 무시한 조합이거나, target과 동일하여 result에 저장된 조합인 경우 재귀호출이 종료된다.           마지막으로 저장한 list의 값을 제거하고 다시 반복문을 통해서 조합을 탐색한다.                           재귀호출이 종료되면 숫자의 조합을 저장한 result 변수를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/combination-sum-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java First Missing Positive",
        "excerpt":"문제  Link   코드  class Solution {    public int firstMissingPositive(int[] nums) {     int idx = 0;     while (idx &lt; nums.length) {       if (nums[idx] &gt;= 1 &amp;&amp; nums[idx] &lt;= nums.length &amp;&amp; nums[idx] &gt; nums[nums[idx] - 1]) {         this.swap(nums, idx, nums[idx] - 1);       } else {         idx++;       }     }     idx = 0;     while (idx &lt; nums.length &amp;&amp; nums[idx] == idx + 1) {       idx++;     }     return idx + 1;   }    private void swap(int[] nums, int left, int right) {     int temp = nums[left];     nums[left] = nums[right];     nums[right] = temp;   }  }   결과  Link   설명          주어진 배열 nums에 포함되지 않은 가능한 최소의 양의 정수 값을 구하는 문제이다.       주어진 배열 nums를 반복하기 위해 idx를 0으로 초기화 하고, 반복문을 통해 배열 내 값들을 정렬한다.            아래의 조건을 만족 하는 경우, 정렬을 하고 그렇지 않은 경우 idx 값을 증가시킨다.                    nums[idx] 값이 1보다 크거나 같다(양의 정수이다).           nums.length 값보다 작거나 같다(정렬된 양의 정수이다).           nums[idx] != nums[nums[idx] - 1]과 다르다(idx의 값이 idx번째 값인지를 검증한다).                           배열 내 값들이 정렬되면 idx 값을 0으로 다시 초기화 시키고 가능한 최소한의 양의 정수를 반복문을 통해 구한다.            만일 nums.length만큼 반복하되, nums[idx]가 1부터 시작하는 양의 정수로 정렬되는 경우 idx를 증가시킨다.       위의 경우가 아닌 경우, 반복문이 종료된다.           반복문이 종료되면, 정렬된 양의 정수의 index인 idx에 1을 추가하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/first-missing-positive/",
        "teaser": null
      },{
        "title": "Leetcode Java Trapping Rain Water",
        "excerpt":"문제  Link   코드  class Solution {    public int trap(int[] height) {     int result = 0;     if (height == null || height.length == 0) {       return result;     }       int left = 0;       int right = height.length - 1;     int leftMax = -1;     int rightMax = -1;     while (left &lt; right) {         leftMax = Math.max(leftMax, height[left]);         rightMax = Math.max(rightMax, height[right]);         if (leftMax &lt; rightMax) {           result += leftMax - height[left];           left++;         } else {           result += rightMax - height[right];           right--;         }       }     return result;   }  }   결과  Link   설명          주어진 배열 height를 이용하여 비를 최대로 담을 수 있는 양을 구하는 문제이다.            반복을 통해서 비를 담을 수 있는 최대 양을 저장하는 result를 정의한다.            주어진 배열이 없거나, 크기가 0인 경우(주어진 문제의 배열 최소 사이즈는 0이므로) result를 주어진 문제의 결과로 반환한다.       문제 풀이에 사용될 변수들을 선언한다.            탐색의 좌측 pointer인 left를 0으로 정의한다.       탐색의 우측 pointer인 right를 $height - 1$로 정의한다.       좌측의 최대 높이인 leftMax를 -1로 정의한다(height의 최소 높이는 0이다).       우측의 최대 높이인 rightMax를 -1로 정의한다(height의 최소 높이는 0이다).           right가 left보다 클 때까지 반복하여 비를 담을 수 있는 최대 양을 구한다.            leftMax와 height[left] 값 중 큰 값을 leftMax에 주입하고, rightMax 또한 rightMax와 height[right] 값 중 큰 값을 reightMax에 주입한다.       만일 leftMax가 작은 경우, result에 $leftMax - height[left]$ 값을 추가하고 left 값을 증가시키고 반복을 계속한다.       만일 rightMax가 작은 경우, result에 $rifght - heigth[right]$ 값을 추가하고 right 값을 감소시키고 반복을 계속한다.           반복이 끝나면 비를 담을 수 있는 최대 양을 저장한 result를 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/trapping-rain-water/",
        "teaser": null
      },{
        "title": "Leetcode Java Multiply Strings",
        "excerpt":"문제  Link   코드  class Solution {    public String multiply(String num1, String num2) {     StringBuilder sb = new StringBuilder();     for (int num : this.getNumberArray(num1, num2)) {       if (sb.length() != 0 || num != 0) {         sb.append(num);       }     }     return sb.length() == 0 ? \"0\" : sb.toString();   }      private int[] getNumberArray(String num1, String num2) {     int[] arr = new int[num1.length() + num2.length()];     for (int i = num1.length() - 1; i &gt;= 0; i--) {       for (int j = num2.length() - 1; j &gt;= 0; j--) {         int sum = ((num1.charAt(i) - '0') * (num2.charAt(j) - '0')) + arr[i + j + 1];         arr[i + j] += sum / 10;         arr[i + j + 1] = sum % 10;       }     }     return arr;   }  }   결과  Link   설명     주어진 문자열 num1과 num2의 길이의 합만큼 int 배열을 정의하여, 각 숫자의 곱의 숫자열을 저장할 변수 arr을 정의한다.            $1\\times1=1$, $9\\times9=81$이므로 두 문자열의 곱의 최대 자릿수는 각 문자열의 길이의 합보다 같거나 작다.           주어진 문자열 num1과 num2를 배열을 이용하여 각 숫자 별 곱을 구한다.            각 문자열을 반대로 반복하여 숫자의 곱을 구하고, 몫이 저장되는 $i + j + 1$의 자리의 숫자를 가져와 합쳐 변수 sum을 정의한다.       변수 sum의 몫인 $\\frac{sum}{10}$을 배열 arr의 $i + j$에 더한다.       변수 sum의 나머지인 $sum\\mod10$을 배열 arr의 $i + j + 1$에 주입한다.           반복문을 통해 arr 배열의 값을 StringBuilder에 저장하여, 두 문자열의 곱을 하나의 문자열로 저장하여 주어진 문제의 결과로 반환한다.            동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.       정수는 항상 0이 아닌 숫자로 시작하므로, 만일 첫 문자열에 0이 들어가는 경우를 제외하고 지속적으로 append를 하여 숫자열을 완성한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/multiply-strings/",
        "teaser": null
      },{
        "title": "Leetcode Java Wildcard Matching",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isMatch(String s, String p) {     boolean[][] dp = this.initDp(s, p);     for (int i = 1; i &lt; s.length() + 1; i++) {       for (int j = 1; j &lt; p.length() + 1; j++) {         if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '?') {           dp[i][j] = dp[i - 1][j - 1];         } else if (p.charAt(j - 1) == '*') {           dp[i][j] = dp[i - 1][j] || dp[i][j - 1];         } else {           dp[i][j] = false;         }       }     }     return dp[s.length()][p.length()];   }      private boolean[][] initDp(String s, String p) {     boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];     dp[0][0] = true;     for (int idx = 1; idx &lt; p.length() + 1; idx++) {       if (p.charAt(idx - 1) == '*') {         dp[0][idx] = dp[0][idx - 1];       }     }     return dp;   }  }   결과  Link   설명          주어진 문자열 p의 패턴 기반으로 s가 일치하는지를 검증하기 위하여 배열 dp를 [$s.length() + 1$][$p.length() + 1$]의 크기로 정의 한다.       초기 dp[0][0]은 true로 하여, 패턴의 길이만큼 반복하여 배열 dp를 초기화 한다.            만일, 패턴의 문자가 ‘*‘인 경우 모든 문자가 들어가도 상관 없으므로 dp[0][$idx - 1$]의 값을 dp[0][idx]에 넣어준다.       그 외의 값은 boolean의 기본 값인 false로 들어가게 된다.           초기화된 배열 dp를 이용하여 반복문을 통해 문자열과 비교를 한다.            주어진 문자열 s의 $i - 1$번째 자리와 p의 $j - 1$번째 자리와 같으면 동일 문자열이고, ‘?’이면 단일 임의 문자와 일치하므로 dp[i][j]의 값에 직전 대각의 값인 dp[$i - 1$][$j - 1$]을 주입한다.       주어진 문자열 p의 $j - 1$번째 자리가 ‘*‘인 경우, dp[i][j]의 값에 기 검증된 dp[$i - 1$][j] OR dp[i][$j - 1$]의 결과를 주입한다.       그 외의 경우엔 dp[i][j]에 false를 주입한다.           반복이 완료되면 주어진 문자열 p의 패턴과 s가 일치하는지의 결과인 dp[s.length()][p.length()]값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/wildcard-matching/",
        "teaser": null
      },{
        "title": "Leetcode Java Jump Game II",
        "excerpt":"문제  Link   코드  class Solution {    public int jump(int[] nums) {     int count = 0;     int target = 0;     int max = 0;     for (int idx = 0; idx &lt; nums.length - 1; idx++) {       max = Math.max(max, idx + nums[idx]);       if (idx == target) {         count++;         target = max;       }       if (target == nums.length - 1) {         break;       }     }     return count;   }  }   결과  Link   설명          최소의 점프로 배열의 마지막 자리에 도달하기 위한 횟수를 구하는 문제이다.       반복을 통해서 마지막 자리에 도달하기 위한 최소 점프 횟수를 구한다.            목표가 되는 지점이 가장 먼 지점으로 갈 수 있는 max를 구하기 위해 max와 점프 길이인 idx + nums[idx] 중 큰 값을 max에 주입한다.       idx가 목표 지점인 target인 경우, 점프 횟수인 count를 증가시키고 target에 다음 목표 지점인 max를 주입한다.                목표 지점인 target이 주어진 배열 nums의 마지막 값의 위치인 $nums.length - 1$인 경우, 반복을 종료한다.       반복이 종료되면 점프 횟수인 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/jump-game-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Permutations",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     this.getPermutations(result, new ArrayList&lt;&gt;(), nums);     return result;   }    private void getPermutations(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; list, int[] nums) {     if (list.size() == nums.length) {       result.add(new ArrayList&lt;Integer&gt;(list));     } else {       for (int idx = 0; idx &lt; nums.length; idx++) {         if (list.contains(nums[idx])) {           continue;         }         list.add(nums[idx]);         this.getPermutations(result, list, nums);         list.remove(list.size() - 1);       }     }   }  }   결과  Link   설명          주어진 배열 nums를 이용하여 각 숫자열의 고유 조합을 만드는 문제이다.            재귀 호출을 통해서 주어진 변수 nums로 임시 변수 list에 각 숫자의 고유 조합을 만들어 결과를 담는 변수 result에 주입하여 주어진 문제의 결과를 만들어준다.            임시 변수 list의 길이와 nums의 길이가 같다면, list가 각 숫자열의 고유 조합이므로 결과를 담는 변수 result에 주입한다.       그 외의 경우 주어진 변수 nums로 반복하여 고유 조합을 완성한다.            nums[idx]의 값이 임시 변수 list에 포함되는 경우는 제외하고 반복을 지속한다.       nums[idx]의 값이 임시 변수 list에 포함되지 않는 경우, nums[idx]의 값을 list에 넣어주고 재귀 호출을 반복한다.       재귀 호출이 끝난 경우, list의 마지막 값을 제거하고 반복문을 지속한다.           재귀 호출이 모두 완료되면 각 숫자열의 고유 조합을 저장한 result 변수를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/permutations/",
        "teaser": null
      },{
        "title": "Leetcode Java Permutations II",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     this.swap(nums);     this.getPermutations(result, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]);     return result;   }    private void getPermutations(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; list, int[] nums, boolean[] used) {     if (list.size() == nums.length) {       result.add(new ArrayList&lt;Integer&gt;(list));     } else {       for (int idx = 0; idx &lt; nums.length; idx++) {         if (used[idx] || (idx &gt; 0 &amp;&amp; nums[idx - 1] == nums[idx] &amp;&amp; !used[idx - 1])) {           continue;         }         list.add(nums[idx]);         used[idx] = true;         this.getPermutations(result, list, nums, used);         used[idx] = false;         list.remove(list.size() - 1);       }     }   }    private void swap(int[] nums) {     for (int i = 0; i &lt; nums.length - 1; i++) {       for (int j = i + 1; j &lt; nums.length; j++) {         if (nums[i] &gt; nums[j]) {           int temp = nums[j];           nums[j] = nums[i];           nums[i] = temp;         }       }     }   }  }   결과  Link   설명          이전에 Permutations(../permutations)와 비슷한 문제이지만, 주어진 배열 nums에 중복된 숫자열이 들어가는 것과 순서에 영향을 받는 것이 이 문제의 초점이다.       기본 순서를 정렬하기 위해 정렬을 통해 오름차순 정렬을 수행해준다.            정렬은 Arrays.sort()로 사용이 가능하지만, 선택 정렬로 구현하였다.                재귀 호출을 통해서 주어진 변수 nums로 임시 변수 list에 각 숫자의 고유 조합을 만들어 결과를 담는 변수 result에 주입하여 주어진 문제의 결과를 만들어준다.            임시 변수 list의 길이와 nums의 길이가 같다면, list가 각 숫자열의 고유 조합이므로 결과를 담는 변수 result에 주입한다.       그 외의 경우 주어진 변수 nums로 반복하여 usable을 통해 숫자열의 조합을 완성한다.            used[idx]의 값이 true이면 이미 사용한 값이므로, 다음 반복을 진행한다.       idx가 0보다 크고, nums[$idx - 1$]의 값이 nums[idx]의 값과 동일하며, $idx - 1$번째 자리의 값이 사용중이지 않다면, 다음 반복을 진행한다.       위의 두 경우를 제외하면 list에 nums[idx] 값을 넣고, 해당 위치의 값을 사용 중으로 체크하기 위해 used[idx]의 값을 true로 주입하여 재귀 호출을 반복한다.       재귀 호출이 끝난 경우 해당 위치의 값을 제거하므로 used[idx]의 값을 false로 주입하고, list의 마지막 값을 제거하고 반복문을 지속한다.           재귀 호출이 모두 완료되면 각 숫자열의 고유 조합을 저장한 result 변수를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/permutations-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Rotate Image",
        "excerpt":"문제  Link   코드  class Solution {    public void rotate(int[][] matrix) {     boolean[][] fixed = new boolean[matrix.length][matrix.length];     for (int i = 0; i &lt; matrix.length; i++) {       for (int j = 0; j &lt; matrix.length; j++) {         if (!fixed[i][j]) {           int temp = matrix[i][j];           matrix[i][j] = matrix[j][matrix.length - 1 - i];           matrix[j][matrix.length - 1 - i] = temp;           fixed[j][matrix.length - 1 - i] = true;         }       }     }   }  }   결과  Link   설명          간단히 2차원 배열을 90도 회전하는 문제이다.       주어진 배열 matrix를 이용하여 동일 크기인 2차원 fixed를 만든다.            어떠한 값이 기존 배열의 위치에서 90도 회전된 위치에 값을 주입하면, 반복문이 수행될 때 해당 위치에 도달 할 수 있으므로 해당 배열의 위치가 90도 회전되어 저장되었다는 표시를 남기기 위해 사용한다.           문제의 반환 값은 없으며, 주어진 배열 matrix를 회전시키면 되므로 반복문을 통해서 모든 요소를 90도 회전한다.            2차원 배열은 2중 반복문으로 호출하되, fixed[i][j]값이 false인 경우만 90도 회전시킨다.       기존 값을 90도 회전시키기 위해서는 matrix[i][j]의 값을 matrix[j][$matrix.length - 1 -i$]의 자리에 위치시켜야 한다.                    [0, 0] -&gt; [2, 0], [0, 1] -&gt; [2, 1], [0, 2] -&gt; [2, 2]                                      소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/rotate-image/",
        "teaser": null
      },{
        "title": "Leetcode Java Group Anagrams",
        "excerpt":"문제  Link   코드  class Solution {    private static final char A = 'a';    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {     Map&lt;String, List&lt;String&gt;&gt; result = new HashMap&lt;&gt;();     for (String str : strs) {       char[] chars = new char[26];       for (char chr : str.toCharArray()) {         chars[chr - A]++;       }       String key = String.valueOf(chars);       if (!result.containsKey(key)) {         result.put(key, new ArrayList&lt;&gt;());       }       result.get(key).add(str);     }     return new ArrayList&lt;&gt;(result.values());   }  }   결과  Link   설명          주어진 배열 strs에서 동일한 개수의 문자들이 사용된 단어를 그룹으로 생성하여 전체 그룹들을 반환하는 문제이다.            주어진 문제의 결과인 전체 그룹을 담을 Map인 result를 선언한다.       주어진 문자열을 반복하여 그룹을 지어준다.            문자의 반복 개수를 파악하기 위해 26 크기인 배열 chars를 정의한다.       영문자의 개수는 26개 이므로 크기를 26으로 설정하였다.                반복된 문자 str을 문자 배열로 치환하여 문자의 사용 개수를 확인한다.       사용된 문자의 배열 chars를 key로 사용하기 위해서 String으로 형 변환하여 result에 그룹으로 추가한다.            Java에서는 객체의 비교에 동일성과 동등성의 검증을 사용한다.       String을 정의 할 경우 JVM의 Constant Pool에 저장되고, 활용이 되므로 동일성 검증에도 통과한다.       만일 result에 String으로 형 변환한 key가 존재하지 않을 경우, 새로운 ArrayList를 정의하여 key의 값으로 넣어준다.       마지막으로, result에 key 값으로 배열을 가져와 반복된 문자 str을 넣어준다.           반복이 완료되면 전체 그룹을 담은 Map의 value들을 새로운 ArrayList에 담아 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/group-anagrams/",
        "teaser": null
      },{
        "title": "Leetcode Java Pow(x, n)",
        "excerpt":"문제  Link   코드  class Solution {    public double myPow(double x, int n) {     if (n == 0) {       return 1;     }     if (n == Integer.MIN_VALUE) {       x *= x;       n /= 2;     }     if (n &lt; 0) {       x = 1 / x;       n *= -1;     }     return (n % 2 == 0 ? 1 : x)  * this.myPow(x * x, n / 2);   }  }   결과  Link   설명          주어진 실수 x의 n제곱 결과를 구하는 문제이다.            주어진 정수 n이 0일 경우, 모든 숫자의 0제곱 값은 1이므로 주어진 문제의 결과로 1을 반환한다.       주어진 정수 n이 int형의 최솟값인 -2,147,483,648인 경우, 아래 4번대로 -1을 곱하면 Overflow가 발생하므로 먼저 예외처리를 수행하여 x의 제곱을 x에 주입하고, n을 2로 나누어준다.            제곱에 대한 공식을 검증해보면 $2^4=2^2 \\times 2^2=4^2$ 이므로, x의 제곱을 수행함으로써 n제곱을 $\\frac{n}{2}$제곱으로 변경하는 것이다.                주어진 정수 n이 0보다 작을 경우, n을 양의 정수로 전환하면서 $\\frac{1}{x}$를 x에 주입해준다.       재귀 호출을 통해 최종 결과를 구하고, 주어진 문제의 결과로 반환한다.            주어진 정수 n이 짝수이면 x는 x의 제곱을, n은 $\\frac{n}{2}$로 재귀 호출을 수행한 값을 사용한다.       주어진 정수 n이 홀수이면 x는 x의 제곱을, n은 $\\frac{n}{2}$로 재귀 호출을 수행한 값에 x를 다시 곱해준 값을 사용한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/powx-n/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Subarray",
        "excerpt":"문제  Link   코드  class Solution {    public int maxSubArray(int[] nums) {     int subSum = nums[0];     int result = subSum;     for (int idx = 1; idx &lt; nums.length; idx++) {       subSum = Math.max(subSum + nums[idx], nums[idx]);       result = Math.max(result, subSum);     }     return result;   }  }   결과  Link   설명          주어진 배열 nums의 부분 합이 가장 큰 값을 구하는 문제이다.            부분 합을 저장하는 subSum은 초기 값을 주어진 배열 nums의 첫 값을 주입하고, 가장 큰 부분 합의 값을 저장하는 result 또한 같은 값으로 정의한다.       주어진 배열 nums를 두 번째 값부터 부분 합을 구하여 최대가 되는 값을 구한다.            초기화를 주어진 배열 nums의 첫 값으로 하였으므로, 두 번째 값부터 반복문을 수행한다.       subSum을 주어진 배열 nums의 값을 더한 값과, subSum 값 중 큰 값을 subSum에 저장한다.       result와 subSum의 값 중 가장 큰 값을 result 변수에 저장한다.           반복이 종료되면, 가장 큰 부분 합을 저장한 변수 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-subarray/",
        "teaser": null
      },{
        "title": "Leetcode Java Spiral Matrix",
        "excerpt":"문제  Link   코드  class Solution {    public int maxSubArray(int[] nums) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     int rowSize = matrix.length;     int colSize = matrix[0].length;     int row = 0;     int col = 0;     int rowMax = rowSize - 1;     int colMax = colSize - 1;     while (result.size() &lt; rowSize * colSize) {       for (int idx = col; idx &lt;= colMax &amp;&amp; result.size() &lt; rowSize * colSize; idx++) {         result.add(matrix[row][idx]);       }       for (int idx = row + 1; idx &lt;= rowMax - 1 &amp;&amp; result.size() &lt; rowSize * colSize; idx++) {         result.add(matrix[idx][colMax]);       }       for (int idx = colMax; idx &gt;= col &amp;&amp; result.size() &lt; rowSize * colSize; idx--) {         result.add(matrix[rowMax][idx]);       }       for (int idx = rowMax - 1; idx &gt;= row + 1 &amp;&amp; result.size() &lt; rowSize * colSize; idx--) {         result.add(matrix[idx][col]);       }       row++;       col++;       rowMax--;       colMax--;     }     return result;   }  }   결과  Link   설명          주어진 배열 matrix를 외각부터 중심까지 순차적으로 숫자를 이어주는 문제이다.       아래의 기본 변수들을 정의한다.            변수 rowSize는 주어진 배열 matrix의 가로 길이이다.       변수 colSize는 주어진 배열 matrix의 세로 길이이다.       변수 row는 주어진 배열 matrix의 가로 시작 인덱스이다.       변수 col은 주어진 배열 matrix의 세로 시작 인덱스이다.       변수 rowMax는 주어진 배열 matrix의 가로 마지막 인덱스이다.       변수 colMax는 주어진 배열 matrix의 세로 마지막 인덱스이다.           순차적으로 숫자를 이어 넣은 result의 크기가 배열의 크기가 될 때 까지 반복하여 결과를 만들어준다.            col과 row 단위의 각 배열의 가장 바깥 값들을 한 줄씩 차례대로 넣는다.                    우측 -&gt; 아래 -&gt; 좌측 -&gt; 위 순으로 값들을 result에 넣는다.           한 바퀴를 돌고 나서, 한 칸씩 내부로 이동하기 위해 변수 row와 col은 증가시키고, rowMax와 colMax는 감소시킨다.                       가장 바깥 값들을 넣으면 다시 반복하여 다음 바깥 값들을 한 줄씩 차례대로 넣는다.           반복이 종료되면 주어진 배열 matrix를 외각부터 중심까지 순차적으로 숫자를 넣은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/spiral-matrix/",
        "teaser": null
      },{
        "title": "Leetcode Java Jump Game",
        "excerpt":"문제  Link   코드  class Solution {    public boolean canJump(int[] nums) {     int position = 0;     for (int idx = 0; idx &lt; nums.length; idx++) {       if (position &lt; idx) {         return false;       }       position = Math.max(idx + nums[idx], position);     }     return true;   }  }   결과  Link   설명          주어진 배열 num의 0번째 인덱스에서 시작하여 각 위치의 값만큼 이동하여 해당 배열의 마지막 위치까지 이동이 가능한지를 확인하는 문제이다.            현재의 위치를 저장하기 위한 변수 position을 배열의 시작 위치인 0으로 정의한다.       반복문을 통해 배열을 탐색하여 주어진 배열 nums의 마지막 위치에 도달하는지 확인한다.            현재 위치를 저장한 position이 반복을 수행하는 위치인 idx보다 작을 경우, nums[idx]의 값이 0이라는 의미이므로 주어진 문제의 결과로 false를 반환한다.       현재 위치를 저장한 position과 $idx + nums[idx]$의 값을 비교하여 position에 저장하고 반복을 계속한다.           반복이 종료되면 배열 nums의 마지막 위치에 도달 할 수 없다는 의미이므로, 주어진 문제의 결과로 true를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/jump-game/",
        "teaser": null
      },{
        "title": "Leetcode Java Merge Intervals",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] merge(int[][] intervals) {     if (intervals.length == 1) {       return intervals;     }     Arrays.sort(intervals, (i1, i2) -&gt; i1[0] - i2[0]);     List&lt;int[]&gt; result = new ArrayList&lt;&gt;();     result.add(intervals[0]);     for (int[] interval : intervals) {       int[] temp = result.get(result.size() - 1);       if (temp[1] &gt;= interval[0]) {         temp[1] = Math.max(temp[1], interval[1]);       } else {         result.add(interval);       }     }     return result.toArray(new int[result.size()][]);   } }   결과  Link   설명          주어진 2차원 배열 intervals을 이용하여 각 구간이 중첩되지 않은 구간들로 변경하는 문제이다.            만일 intervals의 크기가 1이라면, 구간이 중첩되지 않으므로 intervals를 주어진 문제의 결과로 반환한다.       주어진 배열 intervals의 첫 값을 기준으로 정렬을 수행한다.            주어진 배열 intervals의 내부 배열의 값은 시작 값, 종료 값으로 2개의 숫자로 구성되어 있으므로, 구간의 중첩을 명확하게 구분하기 위해서는 시작 값을 기준으로 정렬을 수행한다.           중첩되지 않은 구간들을 저장할 컬렉션 result를 정의한다.            중첩되지 않은 구간들을 구할 때, 정확한 배열의 크기를 초기에 확인하기 어려우므로 컬렉션으로 저장한다.           주어진 배열 intervals의 첫 값을 result에 저장하고, intervals를 반복하여 중첩되지 않은 구간들을 탐색한다.            임시 변수로 사용할 배열 temp에 변수 result에 마지막 값을 가져와서 임시 저장한다.       배열 temp의 종료 값과 주어진 배열 intervals의 배열 내 값인 interval의 시작 값을 비교하여 temp의 종료 값이 크거나 같은 경우 구간이 중첩되므로, temp[1]에 temp[1]과 interval[1] 중 큰 값을 저장한다.       위의 경우가 아닌 경우 구간이 중첩되지 않으므로, result에 interval 값을 저장한다.           반복이 종료되면 중첩되지 않은 구간들을 저장한 컬렉션인 result를 배열로 변경하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/merge-intervals/",
        "teaser": null
      },{
        "title": "Leetcode Java Insert Interval",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] insert(int[][] intervals, int[] newInterval) {     List&lt;int[]&gt; result = new ArrayList&lt;&gt;();     for (int i = 0; i &lt; intervals.length; i++) {       if (intervals[i][0] &gt; newInterval[1]) {         result.add(newInterval);         newInterval = intervals[i];       } else if (intervals[i][1] &gt;= newInterval[0]) {         newInterval = new int[] { Math.min(intervals[i][0], newInterval[0]), Math.max(intervals[i][1], newInterval[1]) };       } else {         result.add(intervals[i]);       }     }     result.add(newInterval);     return result.toArray(new int[result.size()][]);   }  }   결과  Link   설명          주어진 2차원 배열 intervals은 구간을 저장한 배열로, 주어진 newInterval 배열을 intervals에 포함시키는 문제이다.       결과를 제출할 result 변수를 정의한다.            주어진 배열 newInterval이 intervals의 구간에 포함될지, 추가될지 몰라 정확한 배열의 크기를 초기에 확인하기 어려우므로 컬렉션으로 저장한다.           주어진 배열 intervals를 반복하여 newInterval을 적용한다.            intervals[i][0]이 newInterval[1]보다 큰 경우, 해당 구간보다 작은 구간이므로 result에 newInterval을 추가하고 newInterval에 intervals[i]값을 넣는다.       intervals[i][1]이 newInterval[0]보다 크거나 같은 경우, 해당 구간에 포함되는 경우이므로, 새로운 구간을 생성한다.                    intervals의 시작 값과 newInterval의 시작 값 중 작은 값을 새로운 구간의 시작 값으로 설정한다.           intervals의 종료 값과 newInterval의 종료 값 중 큰 값을 새로운 구간의 종료 값으로 설정한다.                       그 외의 경우는 result에 intervals[i]를 추가한다.           반복이 종료되면, 마지막으로 newInterval을 result에 추가해준다.            구간의 적용을 위해 임시 저장된 구간이므로, 반드시 포함시켜야 한다.           새로운 구간들을 저장한 컬렉션인 result를 배열로 변경하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/insert-interval/",
        "teaser": null
      },{
        "title": "Leetcode Java Length of Last Word",
        "excerpt":"문제  Link   코드  class Solution {    public int lengthOfLastWord(String s) {     int result = 0;     for (int idx = s.length() - 1; idx &gt;= 0; idx--) {       if (s.charAt(idx) != ' ') {         result++;       } else {         if (result &gt; 0) {           break;         }       }     }     return result;   }  }   결과  Link   설명          주어진 문자열 s의 마지막 문자열의 길이를 구하는 문제이다.       주어진 문자열 s를 끝에서부터 탐색하여 문자열의 길이를 구한다.            result의 idx번째가 ‘ ‘ 문자가 아닌 경우에는 문자열의 길이를 저장하는 result를 증가시킨다.       result의 idx번째가 ‘ ‘ 문자인 경우, result가 0 이하면 아직 마지막 문자열이 시작되지 않았으므로 무시한다.       result의 idx번째가 ‘ ‘ 문자인 경우, result가 0 보다 크면 반복문을 종료한다.           반복문이 종료되면 마지막 문자열의 길이를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/length-of-last-word/",
        "teaser": null
      },{
        "title": "Leetcode Java Spiral Matrix II",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] generateMatrix(int n) {     int[][] result = new int[n][n];     int min = 0;     int max = n - 1;     int num = 1;     while (num &lt;= n * n) {       for (int idx = min; idx &lt;= max &amp;&amp; num &lt;= n * n; idx++) {         result[min][idx] = num++;       }       for (int idx = min + 1; idx &lt;= max - 1 &amp;&amp; num &lt;= n * n; idx++) {         result[idx][max] = num++;       }       for (int idx = max; idx &gt;= min &amp;&amp; num &lt;= n * n; idx--) {         result[max][idx] = num++;       }       for (int idx = max - 1; idx &gt;= min + 1 &amp;&amp; num &lt;= n * n; idx--) {         result[idx][min] = num++;       }       min++;       max--;     }     return result;   }  }   결과  Link   설명          기존 풀이한 Spiral Matrix와 비슷한 문제로, $n \\times n$ 배열에 순차적으로 숫자를 넣는 문제이다.       아래의 기본 변수들을 정의한다.            변수 result는 주어진 문제의 결과인 $n \\times n$ 배열이다.       변수 min은 주어진 배열 matrix의 가로와 세로의 시작 인덱스이다.       변수 max는 주어진 배열 matrix의 가로와 세로의 최대 인덱스이다.       변수 num은 배열 내 채워질 값이다.           반복문을 통해 순차적으로 배열 result의 외각부터 중심까지 변수 num을 증가시키며 num이 $n \\times n$의 크기가 될 때까지 넣어준다.            우측 -&gt; 아래 -&gt; 좌측 -&gt; 위 순으로 값들을 result에 넣는다.       외각 한바퀴를 돌면 min은 증가시키고, max는 증가시켜 반복문을 계속한다.           반복이 종료되면 외각부터 숫자를 넣어 완성된 배열인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/spiral-matrix-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Permutation Sequence",
        "excerpt":"문제  Link   코드  class Solution {    private List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();   private int factorial = 1;    public String getPermutation(int n, int k) {     this.initVariable(n);     StringBuilder sb = new StringBuilder();     for (int i = 0, j = k - 1; i &lt; n; i++) {       this.factorial /= (n - i);       int index = (j / this.factorial);       sb.append(this.nums.remove(index));       j -= index * this.factorial;     }     return sb.toString();   }    private void initVariable(int n) {     for (int idx = 1; idx &lt;= n; idx++) {       this.factorial *= idx;       this.nums.add(idx);     }   }  }   결과  Link   설명          주어진 정수 n을 이용하여 1부터 n까지의 연속된 숫자 배열의 조합을 순차적으로 생성할 때, k번째 숫자 조합을 구하는 문제이다.       주어진 문제를 위해 각 숫자를 저장한 컬렉션 nums와 n!의 결과를 저장할 factorial 변수를 선언한다.            factorial을 구하는 이유는, 일련된 숫자의 조합을 구하는 경우의 수가 $n!$개 나오기 때문이다.       예를 들어 n이 3일 경우, $3! = 1 \\times 2 \\times 3 = 6$이고 조합은 [123, 132, 213, 231, 312, 321]의 6가지 조합이 나오게 된다.       위의 경우 k가 3인 경우, 3번 째 조합인 213이 주어진 문제의 결과이다.           문제의 시작에 factorial과 nums를 초기화한다.            전역 변수로 선언 한 이유는, 해당 값들을 주입하고 모두 활용하여 문제의 종료에는 초기 값으로 설정되기 때문이다.       nums는 빈 ArrayList, factorial은 1로 문제가 종료되기 때문에 반복된 변수 선언보다, 전역변수로 활용하는 것이 효율적이기 때문이다.           주어진 문제의 결과는 String으로, 해당 숫자열을 동적인 문자열을 생성하기 위해 StringBuilder인 변수 sb를 선언한다.            동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.           i는 0 부터 각 자릿수만큼 반복하며, j는 $k - 1$을 주입하여 k번째 숫자의 조합을 생성한다.            각 자릿수의 경우의 수는 (n - i)이므로, $\\frac{factorial}{n - 1}$을 factorial에 주입한다.       배열 nums의 $\\frac{j}{factorial}$번째 index 값을 꺼내와 sb에 이어쓴다.                    $\\frac{j}{factorial}$번째 index 값을 가져오는 이유는, 2번의 경우와 같다.           nums의 특정 자릿수의 값을 꺼내오기 위해 remove 메서드를 호출하였는데, 이는 해당 자리의 값을 꺼내오므로 이후 자리부터 index가 당겨지게 된다.           예를 들어, 길이가 3인 nums의 값이 [1, 2, 3]인 경우 nums.remove(1)을 함으로써 길이가 2인 nums가 되며 값이 [1, 3]가 된다.                       특정 자릿수의 값이 구해지면, j에 $index \\times factorial$의 값을 빼준다.                    해당 이유도 2번의 경우와 같으므로, 자릿수가 구해지면 해당 자릿수 이후의 경우의 수가 넘어가지 않기 위해서이다.           예를 들면 2번의 예제에서 첫 자리가 1이 나온 경우, 3번째 이후 값은 의미가 없으므로 범위를 좁히기 위해서이다.                           반복이 종료되면 주어진 변수 n을 이용하여 1부터 n까지 연속된 숫자의 k번째 조합을 저장한 sb를 String으로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/permutation-sequence/",
        "teaser": null
      },{
        "title": "Leetcode Java Rotate List",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode rotateRight(ListNode head, int k) {     if (head == null || k == 0) {       return head;     }     ListNode temp = head;     int size = 1;     while (temp.next != null) {       temp = temp.next;       size++;     }     temp.next = head;     for (int idx = 0; idx &lt; size - (k % size); idx++) {       temp = temp.next;     }     head = temp.next;     temp.next = null;     return head;   }  }   결과  Link   설명          주어진 ListNode head를 k번 오른쪽으로 이동시킨 결과를 반환하는 문제이다.       아래의 두 경우에는 이동시키는 의미가 없으므로, 주어진 문제의 결과로 head를 그대로 반환한다.            주어진 head가 null일 경우, 이동시킬 값이 없으므로 의미가 없다.       주어진 k가 0일 경우, 이동시키지 않으므로 의미가 없다.                임시 ListNode temp를 head로 초기화 하고, 크기를 파악하기 위한 size 변수를 1로 초기화하여 선언한다.            temp.next가 null이 아닐 경우까지 반복하여 주어진 ListNode head의 size를 측정한다.       temp.next에 head를 주입하고, $size - (k \\mod size)$만큼 반복하여 시작 위치를 이동시킨다.            temp를 head로 초기화 하고, temp.next에 head를 주입함으로써 temp.next부터 head 객체들의 반복으로 구성이 된다.                    즉, temp의 값이 [5, null]에서 [5, [1, [2, [3, [4, [5, [1, [2, …]]]]]]]] 이렇게 구성이 된다.           그러므로 head가 반복 구성이 되므로, [1, [2, [3, [4, [5, x]]]]] 까지의 참조 값은 x부터 반복되는 객체들과 동일하다.                       temp에 temp.next값을 주입하여 시작되는 NodeList의 위치를 탐색한다.                head에 temp.next값을 넣어 시작되는 NodeList를 설정한다.       temp.next를 null로 주입하여 5번에서 설명한 반복 구성을 제거함으로써, 종료되는 NodeList를 설정한다.            temp.next의 값을 null로 주입하면, head에서 반복된 값의 다음 반복이 시작되는 NodeList의 next 값을 null로 설정하여 객체의 반복 구성을 제거한다.           6번과 7번을 통해 값이 정리된 head를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/rotate-list/",
        "teaser": null
      },{
        "title": "Leetcode Java Unique Paths",
        "excerpt":"문제  Link   코드  class Solution {    public int uniquePaths(int m, int n) {     return this.recursiveUniquePaths(m - 1, n - 1, new int[n][m]);   }    private int recursiveUniquePaths(int m, int n, int[][] path) {     if (m == 0 || n == 0) {       return 1;     } else if (path[n][m] &gt; 0) {       return path[n][m];     } else {       return path[n][m] = this.recursiveUniquePaths(m - 1, n, path) + this.recursiveUniquePaths(m, n - 1, path);     }   }  }   결과  Link   설명          주어진 정수 m는 2차원 배열의 세로, n은 가로 축으로 맨 처음 열과 행에서 출발하여 맨 마지막 열과 행에 도달하기 까지의 경우의 수를 구하는 문제이다.            재귀 호출을 호출할 때 각 위치에 도달하기 까지의 경우의 수를 저장하는 배열 path를 선언하여, 해당 위치의 경우의 수를 저장하고 다른 위치에서의 경우의 수를 측정할 때 활용한다.            재귀 호출을 통해 최종 위치의 값이 지정되면 해당 위치의 값을 주어진 문제의 결과로 반환한다.             m이 0이거나 n이 0인 경우, 1을 반환하여 경우의 수를 추가한다.       path[n][m]이 0보다 큰 경우, 해당 위치의 경우의 수가 존재하기 때문에 해당 값을 그대로 반환한다.       그 외의 경우 path[n, $m - 1$] 위치의 경우의 수와 path[$n - 1$, m]의 위치의 경우의 수를 재귀호출로 가져와 합쳐 path[n][m] 위치의 경우의 수로 넣는다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/unique-paths/",
        "teaser": null
      },{
        "title": "Leetcode Java Unique Paths II",
        "excerpt":"문제  Link   코드  class Solution {    public int uniquePathsWithObstacles(int[][] obstacleGrid) {     int[][] dp = new int[obstacleGrid.length + 1][obstacleGrid[0].length + 1];     dp[1][1] = obstacleGrid[0][0] != 1 ? 1 : 0;     for (int i = 1; i &lt; dp.length; i++) {       for (int j = 1; j &lt; dp[0].length; j++) {         dp[i][j] += obstacleGrid[i - 1][j - 1] != 1 ? dp[i][j - 1] + dp[i - 1][j] : 0;       }     }     return dp[obstacleGrid.length][obstacleGrid[0].length];   }  }   결과  Link   설명          기존 풀이한 Unique Paths와 비슷한 문제로, 시작점에서 출발하여 정해진 포인트를 거쳐 도착점까지 도달하는 경우의 수를 구하는 문제이다.            경우의 수를 구하기 위해 DP를 주어진 배열 obstacleGrid의 크기보다 한 사이즈 크게 정의한다.            초기 값인 db[1][1]은 obstacleGrid[0][0]의 값이 경유지인 1인 경우에는 0으로, 경유지가 아닌 경우 1로 설정한다.       dp를 반복하여 경유지를 거쳐 도착점까지 도달하는 경우의 수를 구한다.            dp[i][j]에 obstacleGrid[$i - 1$][$j - 1$]의 값이 경유지인 1인 경우 0을, 1이 아닌 경우 dp[i][$j - 1]의 값과 dp[$i - 1$][j]의 값을 합하여 넣어준다.           반복이 완료되면 경유지를 거쳐 도착지에 도달하기까지의 경우의 수인 dp[obstacleGrid.length][obstacleGrid[0].length]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/unique-paths-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Path Sum",
        "excerpt":"문제  Link   코드  class Solution {    public int minPathSum(int[][] grid) {     int[] dp = this.getDp(grid);     for (int i = 1; i &lt; grid.length; i++) {       for (int j = 0; j &lt; grid[i].length; j++) {         if (j == 0) {           dp[j] += grid[i][j];         } else {           dp[j] = grid[i][j] + Math.min(dp[j - 1], dp[j]);         }       }     }     return dp[grid[0].length - 1];   }    private int[] getDp(int[][] grid) {     int[] dp = new int[grid[0].length];     dp[0] = grid[0][0];     for (int j = 1; j &lt; grid[0].length; j++) {       dp[j] = dp[j - 1] + grid[0][j];     }     return dp;   }  }   결과  Link   설명          좌측 상단에서 시작해서 우측 하단으로 이동하기까지 배열 내 값의 합이 낮은 값을 탐색하는 문제이다.       누적 합을 구하기 위해 DP를 주어진 2차원 배열 grid의 열 길이만큼 정의한다.            각 이동 간 합을 순차적으로 보기 위해서는 grid와 동일 크기로 정의해도 되나, 최소 이동 횟수만 구하면 되므로 grid의 열 길이만큼 정의하여 이동 값의 합을 구한다.                정의한 DP에 첫 행을 반복하여 순차적으로 누계를 저장한다.       주어진 2차원 배열 grid를 반복하여 우측 하단 마지막 셀에 도달하기 까지 최소 합을 구한다.            DP를 주어진 배열 grid의 첫 행으로 초기화 하였으므로, 다음 행부터 반복을 수행한다.       첫 열의 경우, DP의 같은 열에 배열의 값을 누적시킨다.                    점진적으로 우측 하단으로 이동하므로, 첫 열은 하단으로 이동하는 경우로 판단한다.                       그 외의 경우, DP의 같은 열에 배열의 값과 DP[$j - 1$]과 DP[j]의 값 중 작은 값을 더한다.                    우측 하단으로 점진적으로 이동하면서 바로 아래칸으로 이동하는 경우와, 옆칸으로 이동하는 경우의 최소 값을 더하여 목적지에 도착하기 위한 최소 합을 구한다.                           반복이 완료되면, DP의 마지막 열 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-path-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Plus One",
        "excerpt":"문제  Link   코드  class Solution {    public int[] plusOne(int[] digits) {     for (int idx = digits.length - 1; idx &gt;= 0; idx--) {       if (digits[idx] == 9) {         digits[idx] = 0;       } else {         digits[idx]++;         return digits;       }     }     digits = new int[digits.length + 1];     digits[0] = 1;     return digits;   }  }   결과  Link   설명          주어진 배열 digits는 숫자 한 자리 씩 이어진 숫자열의 배열로, digits의 마지막 위치에 1을 더한 결과의 동일하게 숫자 한 자리 씩 이어진 배열을 만드는 문제이다.       주어진 배열 digits를 역순으로 반복하여 주어진 배열로 결과를 만들 수 있는지 확인한다.            digits[idx]의 값이 9인 경우 해당 자리의 1을 더하므로, 0을 주입한다.       digits[idx]의 값이 9가 아닌 경우 0 ~ 8까지 숫자이므로, 해당 자리의 값을 1 증가시키고 digits를 주어진 문제의 결과로 반환한다.           반복이 정상적으로 끝난 경우 모든 digits의 모든 자리가 9로 이루어진 경우이므로, digits에 $digits.length + 1$ 크기인 새 배열을 정의하고 맨 처음 자리에 1을 넣고 주어진 문제의 결과로 반환한다.            맨 처음 자리에 1을 넣고 다른 자리에 아무 값도 넣지 않은 이유는, Primitive Type인 int는 초기값이 0이므로 각 자리를 0으로 설정 할 필요가 없기 때문이다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/plus-one/",
        "teaser": null
      },{
        "title": "Leetcode Java Add Binary",
        "excerpt":"문제  Link   코드  class Solution {    public String addBinary(String a, String b) {     StringBuilder sb = new StringBuilder();     int aIdx = a.length() - 1;     int bIdx = b.length() - 1;     int carry = 0;     while(aIdx &gt;= 0 || bIdx &gt;= 0) {       int sum = carry;       if (aIdx &gt;= 0) {         sum += a.charAt(aIdx--) - '0';       }       if (bIdx &gt;= 0) {         sum += b.charAt(bIdx--) - '0';       }       sb.append(sum % 2);       carry = sum / 2;     }     return (carry == 1 ? sb.append(carry) : sb).reverse().toString();   }  }   결과  Link   설명          주어진 두 이진수로 이루어진 문자열 a와 b를 더한 값을 문자열로 반환하는 문제이다.       주어진 문제를 해결하기 위해 기본 변수를 정의한다.            주어진 문자열 a와 b를 합친 결과를 저장할 변수 sb를 정의한다.                    동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.                       주어진 문자열 a와 b를 역순으로 반복하기 위해 aIdx와 bIdx를 각 문자열의 길이에서 1을 뺀 값으로 정의한다.       두 이진 문자열의 합이 2가 넘어 앞 자리가 증가해야 하는 경우(올림의 경우)를 위해 변수 carry를 정의한다.           aIdx와 bIdx가 하나라도 0 이상일 때 까지 반복하여 주어진 문자열 a와 b의 합을 계산한다.            두 문자열 a와 b의 각 자릿수를 더하기 위해 sum 변수를 정의하고, 해당 값은 직전 값의 올림 값인 carry로 초기화 한다.       aIdx가 0 이상일 경우, sum에 a의 aIdx번째 값을 더해준다.       bIdx가 0 이상일 경우, sum에 b의 bIdx번째 값을 더해준다.                    위의 두 문자의 정수 값을 사용할 때 char의 int 값은 Ascii code의 값이므로, ‘0’을 빼서 해당 문자의 정수 값을 구하여 사용한다.                       위에서 구해진 sum을 이용하여 변수 sb에 $sum \\mod 2$의 값을 추가하고, carry에는 $\\frac{sum}{2}$의 값을 넣어주어 다음 자리의 계산에 활용한다.           반복이 종료되고 carry가 1일 경우 변수 sb에 carry값을 추가하고, 그렇지 않은 경우 변수 sb 그대로 문자열을 뒤집어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/add-binary/",
        "teaser": null
      },{
        "title": "Leetcode Java Sqrt(x)",
        "excerpt":"문제  Link   코드  class Solution {    public int mySqrt(int x) {     long result = x;     while (result * result &gt; x) {       result = (result + x / result) / 2;     }     return (int)result;   }  }   결과  Link   설명          주어진 정수 x의 제곱근을 구하는 문제이다.       변수 result를 int보다 큰 자료형인 long으로 정의한다.            제곱근을 구할 때 $result \\times result$의 값이 int형일 경우, 허용 범위를 초과하기 때문에 long으로 정의한다.           $result \\times result$가 주어진 정수 x보다 작을 때 까지 반복하여 제곱근 result를 구한다.            $result \\times result$가 주어진 정수 x보다 작으면, result에 $\\frac{result + \\frac{x}{result}}{2}$의 값을 넣는다.       위의 값을 result에 넣는 이유는 제곱근을 구하기 위해 근사값을 산정하기 위함이다.           반복문이 종료되면, 구해진 제곱근인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sqrtx/",
        "teaser": null
      },{
        "title": "Leetcode Java Climbing Stairs",
        "excerpt":"문제  Link   코드  Use Loop  class Solution {    public int climbStairs(int n) {     int result = 1;     for (int idx = 0, diff = 0; idx &lt; n; idx++) {       result += diff;       diff = result - diff;     }     return result;   }  }   Use Array  class Solution {    public int climbStairs(int n) {     int[] fibonacci = new int[n + 1];     fibonacci[0] = 1;     fibonacci[1] = 2;     for (int idx = 2; idx &lt; n; idx++) {       fibonacci[idx] = fibonacci[idx - 2] + fibonacci[idx - 1];     }     return fibonacci[n - 1];   }  }   결과  Link(Use Loop) Link(Use Array)   설명          주어진 정수 n을 1과 2의 조합으로 만들수 있는 고유 숫자열의 개수를 구하는 문제이다.       패턴을 파악해보면 아래와 같은 피보나치 수열로 구성되는 것을 확인 할 수 있다.            1 : 1 -&gt; 1       2 : 11 2 -&gt; 2       3 : 111 12 21 -&gt; 3       4 : 1111 112 121 211 22 -&gt; 5       5 : 11111 1112 1121 1211 2111 122 212 221 -&gt; 8       6 : 111111 11112 11121 11211 12111 21111 1122 1212 1221 2112 2121 2211 222 -&gt; 13       7 : 1111111 111112 111121 111211 112111 121111 211111 11122 11212 11221 12112 12121 12211 21112 21121 21211 22111 1222 2122 2212 2221 -&gt; 21           Loop를 사용하여 결과를 구한 첫 번째 코드는 피보나치 수열의 기본적인 개념을 사용한 것이다.            피보나치 수열로 구해진 결과를 저장할 result를 1로 초기화하여 정의한다.       주어진 정수 n의 크기만큼 반복하여 고유 숫자열의 개수를 구한다.       result는 diff값을 계속 더해주고, diff는 직전 값을 보관하기 위하여 $result - diff$ 값을 저장한다.       반복이 완료되면 고유 숫자열의 개수인 result를 주어진 문제의 결과로 반환한다.           Array를 사용하여 결과를 구한 두 번째 코드는 피보나치 수열을 그대로 구현하여 사용한 것이다.            피보나치 수열을 저장할 배열 fibonacci를 주어진 정수 n을 이용하여 $n + 1$로 정의한다.                    크기가 n이 아니라 $n + 1$로 하는 이유는 주어진 정수 n이 1일 경우, 배열의 초기 값인 1과 2를 추가할 때 ArrayIndexOutOfBoundsException이 발생하기 때문이다.                       2 ~ $n - 1$번까지 반복하여 fibonacci 배열을 구성한다.       반복이 완료되면 fibonacci[$n - 1$] 값을 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/climbing-stairs/",
        "teaser": null
      },{
        "title": "Leetcode Java Simplify Path",
        "excerpt":"문제  Link   코드  class Solution {    public String simplifyPath(String path) {     Stack&lt;String&gt; stack = new Stack&lt;&gt;();     for (String directory : path.split(\"/\")) {       switch (directory) {         case \"\":case \".\": continue;         case \"..\": this.popStackIsNotEmpty(stack); break;         default: stack.push(directory);       }     }     return this.getPath(stack);   }    private void popStackIsNotEmpty(Stack&lt;String&gt; stack) {     if (!stack.isEmpty()) {       stack.pop();     }   }    private String getPath(Stack&lt;String&gt; stack) {     StringBuilder sb = new StringBuilder();     for (String directory : stack) {       sb.append(\"/\").append(directory);     }     return sb.length() == 0 ? \"/\" : sb.toString();   }  }   결과  Link   설명          주어진 문자열 File path에 대한 절대 경로를 단순화된 표준 경로를 구하는 문제이다.            단순화된 표준 경로를 구하기 위해 변수 stack을 정의한다.       주어진 변수 path를 “/”를 구분자로 디렉토리 이름인 문자열을 분리하여 반복하여 단순화된 표준 경로를 구한다.            디렉토리 명이 ““이거나 “.”일 경우, 무시하고 계속 반복한다.       디렉토리 명이 “..”일 경우, 상위 경로를 의미하므로 stack이 비어있지 않은 경우에만 최근 값을 꺼낸다.       그 외의 경우, 디렉토리 이름을 stack에 저장한다.           3번을 통해 표준 경로를 만들기 위한 디렉토리 이름이 저장된 stack을 이용하여 아래 규칙을 만족하는 단순화된 표준 경로를 만든다.            Path의 첫 시작은 “/”으로 시작해야 한다.       각 디렉토리는 “/”로 구분된다.       경로의 마지막은 “/”로 끝나지 않는다.       경로는 루트 디렉터리에서 대상이 되는 파일 혹은 디렉터리로의 경로만 포함된다.           4번을 통해 조합된 단순화된 표준 경로를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/simplify-path/",
        "teaser": null
      },{
        "title": "Leetcode Java Edit Distance",
        "excerpt":"문제  Link   코드  class Solution {    public int minDistance(String word1, String word2) {     int[][] dp = this.initDp(word1.length(), word2.length());     for (int i = 0; i &lt; word1.length(); i++) {       for (int j = 0; j &lt; word2.length(); j++) {         if (word1.charAt(i) == word2.charAt(j)) {           dp[i + 1][j + 1] = dp[i][j];         } else {           dp[i + 1][j + 1] = 1 + Math.min(dp[i][j], Math.min(dp[i][j + 1], dp[i + 1][j]));         }       }     }     return dp[word1.length()][word2.length()];   }      private int[][] initDp(int len1, int len2) {     int[][] dp = new int[len1 + 1][len2 + 1];     for (int i = 0; i &lt; len1; i++) {       dp[i + 1][0] = i + 1;     }     for (int j = 0; j &lt; len2; j++) {       dp[0][j + 1] = j + 1;     }     return dp;   }  }   결과  Link   설명          주어진 문자열 word1으로 각 문자를 추가/수정/삭제하여 word2로 만들기 위한 최소 횟수를 구하는 문제이다.       문자열 word1을 word2로 변환하기 위한 횟수를 저장할 DP를 초기화 한다.            DP는 word1과 word2의 각 길이 + 1만큼으로 정의한다.       초기 DP[0][0]은 0으로 시작하여 0번째 행과 열은 각 문자열까지의 길이로 초기화 한다.           2번으로 초기화 한 DP를 이용하여 초기화된 0번째 행과 열을 제외한 모든 자리를 반복하여 word1을 word2로 만들기 위한 최소 횟수를 구한다.            word1의 i 번째 문자와 word2의 j 번째 문자가 동일하면 해당 문자를 변경하지 않아도 되므로, dp[i + 1][j + 1]의 값에 dp[i][j] 값을 넣어준다.       word1의 i 번째 문자와 word2의 j 번째 문자가 동일하지 않다면 해당 문자를 변경해야 하므로, dp[i + 1][j + 1]의 값에 해당 셀의 좌측, 좌측 상단 대각선, 상단의 값 중 가장 작은 값으로 넣어준다.           3번으로 완성된 DP의 마지막 값인 DP[word1.length()][word2.length()]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/edit-distance/",
        "teaser": null
      },{
        "title": "Leetcode Java Set Matrix Zeroes",
        "excerpt":"문제  Link   코드  class Solution {    public void setZeroes(int[][] matrix) {     this.setZeroesDownTop(matrix, this.setZeroesTopDown(matrix));   }    private boolean setZeroesTopDown(int[][] matrix) {     boolean isFirstColumnZero = false;     for (int i = 0; i &lt; matrix.length; i++) {       if (matrix[i][0] == 0) {         isFirstColumnZero = true;       }       for (int j = 1; j &lt; matrix[0].length; j++) {         if (matrix[i][j] == 0) {           matrix[i][0] = matrix[0][j] = 0;         }       }     }     return isFirstColumnZero;   }    private void setZeroesDownTop(int[][] matrix, boolean isFirstColumnZero) {     for (int i = matrix.length - 1; i &gt;= 0; i--) {       for (int j = matrix[0].length - 1; j &gt;= 1; j--) {         if (matrix[i][0] == 0 || matrix[0][j] == 0) {           matrix[i][j] = 0;         }       }       if (isFirstColumnZero) {         matrix[i][0] = 0;       }     }   }  }   결과  Link   설명     주어진 배열 matrix 내부에 0이 존재하는 열과 행의 모든 값에 0을 채우는 문제이다.            단, matrix를 내부에서 변경해야하므로 In-Place 알고리즘을 이용하여 변경해야 한다.           주어진 배열 matrix 내부에 0이 존재하는지 반복문을 통해 위에서 아래로 이동하며 확인한다.            첫 열이 0인 경우, isFirstColumnZero를 true로 바꾸어준다.       두 번째 열부터는 matrix[i][j]의 값이 0인 경우, matrix[i][0]와 matrix[0][j]를 0으로 넣어주어 해당 열과 행을 0으로 바꿀 준비를 한다.       반복이 종료되면 isFirstColumnZero를 다음 함수로 전달한다.           주어진 배열 matrix를 반복하여 내부에 0이 존재하는 행과 열에 0을 채워주어 주어진 문제의 풀이를 완료한다.            matrix[i][0] 혹은 matrix[0][j]가 0인 경우, 2번에서 0을 넣는 행과 열에 포함된 위치이므로 matrix[i][j]에 0을 넣어준다.       만일 isFirstcolumnZero가 true인 경우, 첫 열이 모두 0이 된다는 의미이므로 matrix[i][0]에 0을 넣어준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/set-matrix-zeroes/",
        "teaser": null
      },{
        "title": "Leetcode Java Set Search a 2D Matrix",
        "excerpt":"문제  Link   코드  class Solution {    public boolean searchMatrix(int[][] matrix, int target) {     int i = matrix.length - 1;     int j = 0;     while (i &gt;= 0 &amp;&amp; j &lt; matrix[0].length) {       if (matrix[i][j] == target) {         return true;       } else if (matrix[i][j] &gt; target) {         i--;       } else {         j++;       }     }     return false;   }  }   결과  Link   설명          주어진 정렬된 2차원 배열 matrix에 target 정수가 포함되어 있는지 확인하는 문제이다.       주어진 문제를 풀기 위해서 처음부터 끝까지 탐색하기 위한 기본 변수를 선언한다.            변수 i는 배열의 마지막 행의 위치인 $matrix.length - 1$로 선언한다.       변수 j는 배열의 처음 열의 위치인 0으로 선언한다.           반복문을 통해 배열의 마지막 행부터 처음 행까지 탐색한다.            matrix[i][j]의 값이 target과 동일하면 true를 주어진 문제의 결과로 반환한다.       matrix[i][j]의 값이 target보다 크면 i값을 낮추어 위의 행을 탐색한다.       matrix[i][j]의 값이 target보다 작으면 j값을 크게 하여 다음 열을 탐색한다.           반복문이 종료되면, target과 동일한 값이 없므으로 주어진 문제의 결과로 false를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/search-a-2d-matrix/",
        "teaser": null
      },{
        "title": "Leetcode Java Sort Colors",
        "excerpt":"문제  Link   코드  class Solution {    public void sortColors(int[] nums) {     int start = 0;     int end = nums.length - 1;     int idx = 0;     while (idx &lt;= end) {       switch (nums[idx]) {         case 0:           if (nums[start] != 0) {             this.swap(nums, idx, start);           }           start++;           idx++;           break;         case 2:           if (nums[end] != 2) {             this.swap(nums, idx, end);           }           end--;           break;         default:           idx++;           break;       }     }   }    private void swap(int[] nums, int idx1, int idx2) {     int temp = nums[idx2];     nums[idx2] = nums[idx1];     nums[idx1] = temp;   }  }   결과  Link   설명          각 색상을 나타내는 숫자인 0, 1, 2로 구성된 주어진 배열을 정렬하는 문제이다.       배열의 탐색을 위해 변수들을 정의한다.            변수 start는 배열의 첫 인덱스인 0으로 정의한다.       변수 end는 배열의 마지막 인덱스인 $nums.length - 1$으로 정의한다.       변수 idx는 포인터 역할을 하며, 배열의 첫 인덱스인 0으로 선언한다.           변수 idx의 값이 end가 될 때 까지 반복하여 주어진 배열을 정렬하여 문제를 해결한다.            nums[idx]의 값이 0인 경우, nums[start]의 값이 0이 아닌 값이면 배열 nums의 idx번째 값과 바꾸고 start와 idx의 값을 증가시킨다.       nums[idx]의 값이 2인 경우, nums[end]의 값이 2가 아닌 값이면 배열 nums의 idx번째 값과 바꾸고 end 값을 감소시킨다.       그 외인 nums[idx]의 값이 1인 경우, idx의 값을 증가시킨다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sort-colors/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Window Substring",
        "excerpt":"문제  Link   코드  class Solution {    public String minWindow(String s, String t) {     int[] charArray = new int[128];     for (char c : t.toCharArray()) {       charArray[c]++;     }     int start = 0;     int length = Integer.MAX_VALUE;     int counter = t.length();     for (int i = 0, j = 0; i &lt; s.length(); i++) {       if (charArray[s.charAt(i)]-- &gt; 0) {         counter--;       }       while (counter == 0) {         if (i - j + 1 &lt; length) {           length = i - j + 1;           start = j;         }         if (++charArray[s.charAt(j++)] &gt; 0) {           counter++;         }       }     }     return length == Integer.MAX_VALUE ? \"\" : s.substring(start, start + length);   }  }   결과  Link   설명          주어진 문자열 s에 문자열 t의 문자들이 포함된 최소 부분 문자열을 구하는 문제이다.            주어진 문자열 t의 문자 개수를 저장하기 위한 배열 charArray를 선언하고, t의 각 문자열의 숫자만큼 해당 배열의 ASCII 코드 자리의 숫자를 증가시킨다.       문제를 해결하기 위한 변수를 정의한다.            부분 문자열의 시작의 인덱스를 저장할 start 변수를 0으로 정의한다.       부분 문자열의 길이를 저장할 length 변수를 최대 정수 값인 Integer.MAX_VALUE로 저장한다.       문자열 t의 문자 개수를 저장하는 counter 변수를 문자열 t의 길이로 정의한다.           문자열 s의 길이만큼 반복하여 부분 문자열이 존재하는지를 확인하고, 존재 할 경우 부분 문자열의 시작과 문자열의 길이를 확인하여 start와 length 변수의 값으로 넣어준다.            배열 charArray 내 s의 i번째 자리 문자 ASCII 코드번째 값이 0보다 클 경우, 해당 값과 counter를 감소시킨다.       만일 counter의 값이 0일 경우, 주어진 문자열 t로 구성된 문자들이 문자열 s에 모두 포함되었으므로 부분 문자열을 구한다.                    $i - j + 1$이 length보다 작을 경우, length의 값에 $i - j + 1$을 넣고, start의 값에 j를 넣어준다.           배열 charArray 내 s의 j번째 자리 문자 ASCII 코드 값을 증가시키고, 해당 값이 0보다 클 경우 counter를 증가시킨다.                           반복이 완료되면 length가 변경되었는지를 확인하여 주어진 문제의 결과를 반환한다.            length의 값이 그대로 Integer.MAX_VALUE인 경우, 매칭된 부분 문자열이 없으므로 빈 문자열인 ““을 주어진 문제의 결과로 반환한다.       length의 값이 변경되었으면, 매칭된 부분 문자열이 존재하므로 주어진 문자열 s의 start 인덱스부터 $start + length$번째 문자열까지 잘라 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-window-substring/",
        "teaser": null
      },{
        "title": "Leetcode Java Combinations",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     if (k == 0) {       result.add(new ArrayList&lt;Integer&gt;());       return result;     } else if (k &gt; n) {       return result;     } else {       result = this.combine(n - 1, k - 1);       for (List&lt;Integer&gt; list : result) {         list.add(n);       }       result.addAll(this.combine(n - 1, k));       return result;     }   }  }   결과  Link   설명          1부터 주어진 정수 n까지의 숫자들을 이용하여 주어진 정수 k 크기의 배열을 중복되지 않은 숫자들의 조합을 만들어 배열로 반환하는 문제이다.            중복되지 않은 숫자들의 조합을 넣을 배열 result를 정의한다.       재귀 호출을 통해서 주어진 문제를 해결한다.            k가 0인 경우, result에 조합을 만들기 위한 새 배열을 만들어 반환한다.       k가 n보다 큰 경우, 주어진 배열의 크기 n보다 주어진 숫자 k가 적기 때문에 result를 그대로 반환한다.       그 외의 경우, 배열을 만들기 위해 result를 $n - 1$과 $k - 1$로 재귀 호출을 수행한 결과를 받아서 result 내 배열에 n을 모두 넣어주고, result에 $n - 1$과 k로 재귀 호출을 수행한 결과를 합쳐서 반환한다.           마지막으로 3번의 마지막 경우를 통해 최종 결과가 생성되고, 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/combinations/",
        "teaser": null
      },{
        "title": "Leetcode Java Subsets",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     this.recursive(result, new ArrayList&lt;&gt;(), nums, 0);     return result;   }    private void recursive(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; temp, int[] nums, int start) {     result.add(new ArrayList&lt;&gt;(temp));     for (int idx = start; idx &lt; nums.length; idx++) {       temp.add(nums[idx]);       this.recursive(result, temp, nums, idx + 1);       temp.remove(temp.size() - 1);     }   }  }   결과  Link   설명          주어진 배열 nums의 값들을 조합하여 하위 배열을 생성하는 문제이다.       재귀 호출을 수행하여 빈 배열부터 주어진 배열까지의 조합들을 생성한다.            하위 배열들을 저장할 result에 새로운 배열 temp를 활용하여 넣어준다.       start부터 nums의 크기만큼 반복하여 하위 배열들을 생성한다.       다시 반복이 수행되기 전 temp에 마지막 값을 제외하여 새로운 조합을 만들게 한다.           재귀호출이 완료되면 하위 배열들의 조합을 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/subsets/",
        "teaser": null
      },{
        "title": "Leetcode Java Word Search",
        "excerpt":"문제  Link   코드  class Solution {    public boolean exist(char[][] board, String word) {     char[] charArray = word.toCharArray();     for (int row = 0; row &lt; board.length; row++) {       for (int col = 0; col &lt; board[row].length; col++) {         if (this.check(board, row, col, charArray, 0)) {           return true;         }       }     }     return false;   }    private boolean check(char[][] board, int row, int col, char[] charArray, int idx) {     if (idx == charArray.length) {       return true;     } else if (row &lt; 0 || col &lt; 0 || row == board.length || col == board[row].length         || board[row][col] != charArray[idx]) {       return false;     } else {       board[row][col] = 0;       boolean exist = this.check(board, row, col + 1, charArray, idx + 1)           || this.check(board, row + 1, col, charArray, idx + 1)           || this.check(board, row, col - 1, charArray, idx + 1)           || this.check(board, row - 1, col, charArray, idx + 1);       board[row][col] = charArray[idx];       return exist;     }   }  }   결과  Link   설명          주어진 2차원 배열 board의 값들을 이어 주어진 문자열 word를 만들 수 있는지 검증하는 문제이다.            배열을 탐색하기 전에 주어진 문자열 word를 문자의 배열로 변환한다.       배열을 반복하여 주어진 문자열 word를 만들 수 있으면 주어진 문제의 결과로 true를 반환한다.            문자열 검증에 포인터로 사용되는 idx가 주어진 문자열 word의 길이와 같으면, true를 반환한다.       배열의 탐색에 사용되는 row와 col이 0보다 작거나 배열크기보다 큰 경우와 board[row][col]의 값이 charArray[idx]의 값과 동일하지 않으면, false를 반환한다.       그 외의 경우 현재 위치의 값을 0으로 초기화 하여 사용된 값을 표시하고 상하좌우의 값들을 이용하여 다음 문자가 존재하는지를 검증하고 다시 현재 위치의 값을 복원 후 검증한 값을 반환한다.           반복이 완료되면 주어진 2차원 배열 board의 값으로 문자열 word를 만들지 못한다는 의미이므로, 주어진 문제의 결과로 false를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/word-search/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove Duplicates from Sorted Array II",
        "excerpt":"문제  Link   코드  class Solution {    public int removeDuplicates(int[] nums) {     int count = 0;     for (int n : nums) {       if (count &lt; 2 || n &gt; nums[count - 2]) {         nums[count++] = n;       }     }     return count;   }  }   결과  Link   설명     주어진 배열 nums는 오름차순 된 정수를 담은 배열로, 2번 초과로 동일한 숫자가 나오지 않는 배열로 만들고 해당 위치를 반환하는 문제이다.            단, 주어진 배열 nums를 그대로 사용하여 변경해야하므로 In-Place 알고리즘을 이용하여 변경해야 한다.                주어진 배열을 만들고 마지막 위치를 저장할 count 변수를 선언한다.       nums를 반복하여 2번 초과로 동일한 숫자가 나오지 않는 배열을 만들고 위치를 계산한다.            2번 초과로 동일한 숫자가 나오지 않도록 아래의 두 경우를 고려하여 해당 위치에 그대로 값을 넣어준다.                    2번 이상까지 반복이 허용되므로, nums[count - 2]번째 값보다 n이 커야한다.           위의 경우를 생각해보면 처음 두 값은 동일한 값이 와도 상관이 없다.                                 다음 값을 넣을 때 확인이 되므로, 처음 두 값은 확인하지 않아도 된다.           반복이 종료되면 새롭게 값을 넣은 nums의 마지막 위치 값이자, 새로 정렬된 숫자의 개수인 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-duplicates-from-sorted-array-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Search in Rotated Sorted Array II",
        "excerpt":"문제  Link   코드  class Solution {    public boolean search(int[] nums, int target) {     for (int num : nums) {       if (num == target) {         return true;       }     }     return false;   }  }   결과  Link   설명          주어진 정렬되지 않은 배열 nums에서 target이 존재하는지 확인하는 문제이다.            반복문을 통해서 num과 target이 동일하면 true를 주어진 문제의 결과로 반환한다.            반복문이 종료되면 배열 nums에 target이 존재하지 않으므로, false를 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/search-in-rotated-sorted-array-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove Duplicates from Sorted List II",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode deleteDuplicates(ListNode head) {     return this.recursive(head, null);   }    private ListNode recursive(ListNode head, ListNode previous) {     if (head == null) {       return null;     } else {       if ((head.next != null &amp;&amp; head.val == head.next.val) || (previous != null &amp;&amp; head.val == previous.val)) {         return this.recursive(head.next, head);       } else {         head.next = this.recursive(head.next, head);         return head;       }     }   }  }   결과  Link   설명          주어진 ListNode인 head의 val 값이 중복된 ListNode를 모두 제거하고 중복되지 않은 값들을 가진 ListNode를 반환하는 문제이다.            재귀 호출을 통해서 head와 이전의 값을 privious 변수에 넣어 중복된 ListNode들을 제외하고 역순으로 ListNode를 만들어 주어진 문제의 결과로 반환한다.             head가 null인 경우, 주어진 ListNode인 head의 마지막 값이므로 그대로 반환한다.       head가 null이 아닌 경우, 아래의 경우를 확인하여 중복을 제거한 값을 찾기 위해서 재귀 호출을 반복한다.                    head.next가 존재하고, head.val 값과 head.next의 val 값이 동일하면 현재 값과 다음 값이 동일한 경우이다.           previous가 존재하고 head.val 값과 privious.val 값이 동일하면 이전 값과 현재 값이 동일한 경우이다.           위 두 경우는 중복된 값이 존재하므로 무시하고 재귀 호출의 값을 반환한다.           위 두 경우가 아니면 중복된 값이 존재하지 않으므로 head.next에 해당 재귀 호출의 값을 넣고 head를 반환한다.                       재귀 호출을 통해 역순으로 중복이 제거되어 만들어진 ListNode를 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-duplicates-from-sorted-list-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove Duplicates from Sorted List",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode deleteDuplicates(ListNode head) {     return this.recursive(head);   }    private ListNode recursive(ListNode head) {     if (head == null) {       return null;     } else {       if ((head.next != null &amp;&amp; head.val == head.next.val)) {         return this.recursive(head.next);       } else {         head.next = this.recursive(head.next);         return head;       }     }   }  }   결과  Link   설명          주어진 ListNode인 head의 val 값이 중복되지 않은 고유 값로 이루어진 ListNode를 반환하는 문제이다.            재귀 호출을 통해서 주어진 ListNode인 head의 중복된 값을 제거하고 역순으로 ListNode를 만들어 주어진 문제의 결과로 반환한다.             head가 null인 경우, 주어진 ListNode인 head의 마지막 값이므로 그대로 반환한다.       head가 null이 아닌 경우, head.next가 존재하고, head.val 값과 head.next의 val 값이 동일하면 현재 값과 다음 값이 동일한 경우이므로 무시하고 재귀 호출을 수행한 값을 반환한다.       위의 경우가 아니면 중복된 값이 존재하지 않으므로 head.next에 해당 재귀 호출의 값을 넣고 head를 반환한다.       재귀 호출을 통해 역순으로 중복이 제거되어 만들어진 ListNode를 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-duplicates-from-sorted-list/",
        "teaser": null
      },{
        "title": "Leetcode Java Largest Rectangle in Histogram",
        "excerpt":"문제  Link   코드  class Solution {    public int largestRectangleArea(int[] heights) {     int maxArea = 0;     Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();     for (int idx = 0; idx &lt; heights.length; idx++) {       maxArea = this.getMaxArea(heights, stack, maxArea, idx);       stack.push(idx);     }     return this.getMaxArea(heights, stack, maxArea, heights.length);   }      private int getMaxArea(int[] heights, Stack&lt;Integer&gt; stack, int maxArea, int idx) {     int _maxArea = maxArea;     while (!stack.isEmpty() &amp;&amp; (idx == heights.length || heights[idx] &lt; heights[stack.peek()])) {       int height = heights[stack.pop()];       int start = stack.isEmpty() ? -1 : stack.peek();       _maxArea = Math.max(_maxArea, height * (idx - start - 1));     }     return _maxArea;   }  }   결과  Link   설명          주어진 배열 heights는 히스토그램의 바의 높이이며, x축과 y축의 곱의 영역이 가장 큰 영역의 크기를 구하는 문제이다.       주어진 문제를 풀기 위한 두 변수를 정의한다.            최대 영역의 크기를 저장하는 maxArea를 정의한다.       최대 영역을 구하기 위한 시작 index를 FIFO로 저장할 Stack인 stack을 정의한다.           주어진 heights의 값들을 모두 반복하여 최대 길이를 저장한다.            아래의 경우가 모두 해당하는 경우, stack의 내부 값을 활용하여 최대 길이를 구한다.                    stack이 비어있지 않을 경우, 최대 영역을 구하기 위한 index가 저장되었을 경우이다.           idx와 heights의 길이가 동일하거나 heights[idx]의 값이 heights[stack.peek()]의 값보다 작을 경우, 길이가 작아지는 구간이다.                       변수 maxArea와 저장된 공통 높이인 heights[stack.pop()]에 $idx - start - 1$의 값을 곱해준다.                    start는 stack이 비어있을 경우 height의 높이가 처음 index부터 시작되므로, -1을 사용한다.           위의 경우가 아닌 경우 height의 높이가 시작되는 index가 존재하는 경우이므로, stack.pop()을 통해 stack에 저장된 이전 구간의 값을 가져온다.                       stack에 해당 위치인 idx를 넣어주고 반복을 계속 진행하여 가장 큰 영역을 구한다.           반복이 완료되면, 3번을 다시 반복하여 stack에 저장된 값을 활용해서 최대 길이를 다시 확인하고 해당 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/largest-rectangle-in-histogram/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximal Rectangle",
        "excerpt":"문제  Link   코드  class Solution {    public int maximalRectangle(char[][] matrix) {     if (matrix.length == 0) {       return 0;     }     int maxArea = 0;     int[] heights = new int[matrix[0].length];     for (char[] row : matrix) {       for (int idx = 0; idx &lt; row.length; idx++) {         if (row[idx] == '1') {           heights[idx]++;         } else {           heights[idx] = 0;         }       }       maxArea = Math.max(maxArea, this.getMaxArea(heights, new Stack&lt;&gt;()));     }     return maxArea;   }    public int getMaxArea(int[] heights, Stack&lt;Integer&gt; stack) {     int maxArea = 0;     for (int idx = 0; idx &lt;= heights.length; idx++) {       while (!stack.isEmpty() &amp;&amp; (idx == heights.length || heights[idx] &lt; heights[stack.peek()])) {         int height = heights[stack.pop()];         int start = stack.isEmpty() ? -1 : stack.peek();         maxArea = Math.max(maxArea, height * (idx - start - 1));       }       stack.push(idx);     }     return maxArea;   }  }   결과  Link   설명          주어진 2차원 배열 matrix를 이용하여 사각형 모양이 되는 부분 영역의 합이 가장 큰 값을 구하는 문제이다.            주어진 matrix의 길이가 0인 경우, 문제 풀이가 불가능하므로 0을 주어진 문제의 결과로 반환한다.       주어진 문제 풀이를 위해서 변수를 정의한다.            maxArea는 최대 영역의 크기를 저장하기 위해서 0으로 정의한다.       heights는 해당 문제를 Histogram 형식으로 전환하여 구하기 위해서 matrix[0]의 길이만큼의 크기로 int 배열을 정의한다.           주어진 matrix를 이용하여 Histogram 형식으로 구간 별 heights를 만들어 최대 영역을 구한다.            셀의 값이 1일 경우 최대 영역을 구하기 위해서 heights[idx]의 값을 증가시킨다.       셀의 값이 0일 경우 heights[idx]의 값을 0으로 설정하여 새로운 영역을 구할 수 있도록 한다.       부분 영역의 최대 값을 저장하는 maxArea와 heights를 이용하여 최대 영역을 구한 값의 합 중 큰 값을 maxArea에 저장한다.                    아래의 경우가 모두 해당하는 경우, heights와 stack을 활용하여 최대 길이를 구한다.                                 stack이 비어있지 않을 경우, 최대 영역을 구하기 위한 index가 저장되었을 경우이다.       idx와 heights의 길이가 동일하거나 heights[idx]의 값이 heights[stack.peek()]의 값보다 작을 경우, 길이가 작아지는 구간이다.       - 변수 maxArea와 저장된 공통 높이인 heights[stack.pop()]에 $idx - start - 1$의 값을 곱해준다.       start는 stack이 비어있을 경우 height의 높이가 처음 index부터 시작되므로, -1을 사용한다.       위의 경우가 아닌 경우 height의 높이가 시작되는 index가 존재하는 경우이므로, stack.pop()을 통해 stack에 저장된 이전 구간의 값을 가져온다.     - stack에 해당 위치인 idx를 넣어주고 반복을 계속 진행하여 최대 영역을 구한다.           반복이 완료되면 사각형 모양의 부분 영역의 합이 가장 큰 값을 저장한 maxArea의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximal-rectangle/",
        "teaser": null
      },{
        "title": "Leetcode Java Partition List",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode partition(ListNode head, int x) {     ListNode result = new ListNode(0, head);     ListNode temp = result;     ListNode pointer = result;     while (pointer.next != null) {       if (pointer.next.val &lt; x) {         if (pointer == temp) {           pointer = pointer.next;         } else if (temp.next != null &amp;&amp; pointer.next != null) {           this.swap(temp, pointer);         }         temp = temp.next;       } else {         pointer = pointer.next;       }     }     return result.next;   }    private void swap(ListNode ln1, ListNode ln2) {     ListNode temp = ln2.next;     ln2.next = temp.next;     temp.next = ln1.next;     ln1.next = temp;   }  }   결과  Link   설명          주어진 ListNode인 head의 내부 값들 중 주어진 정수 x보다 큰 값이 존재할 경우, 순서를 마지막으로 미루어 x보다 작은 값들을 우선 배치하고 그 이후 해당 값들을 주어진 순서대로 배치하는 문제이다.       주어진 문제를 풀기 위해 변수를 정의한다.            결과를 만들기 위한 변수인 result에 주어진 변수 head를 이용하여 new ListNode(0, head)를 넣어준다.       값의 위치를 변경하기 위한 임시 변수인 temp와 주어진 정수 x보다 큰 값을 찾기 위한 pointer 변수에 result를 각각 주입해준다.           pointer.next가 null이 아닐 때 까지 반복하여 주어진 정수 x보다 큰 값을 후순위로 미루어 값을 정렬해준다.            pointer.next.val의 값이 x보다 작은 경우 값을 확인한다.                    pointer와 temp가 동일한 경우 pointer의 위치가 temp와 동일하므로, pointer를 다음 ListNode로 이동시킨다.           temp.next와 pointer.next가 존재하는 경우, 각 next의 객체를 바꾸어준다.                                 pointer.next와 temp.next를 각각 바꾸어 순서를 변경한다.       - temp를 다음 ListNode로 이동시킨다.     - pointer.next.val의 값이 x보다 크거나 같은 경우, pointer를 다음 ListNode로 이동시킨다.           반복이 완료되면 껍데기로 감싸 넣었던 변수 result의 next 객체를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/partition-list/",
        "teaser": null
      },{
        "title": "Leetcode Java Merge Sorted Array",
        "excerpt":"문제  Link   코드  class Solution {    public void merge(int[] nums1, int m, int[] nums2, int n) {     int length = m + n - 1;     m--; n--;     while (n &gt;= 0) {       nums1[length--] = m &lt; 0 || nums1[m] &lt; nums2[n] ? nums2[n--] : nums1[m--];     }   }  }   결과  Link   설명          주어진 배열 nums1의 m자리 까지의 값들과, 주어진 배열 nums2의 n자리 까지의 값들을 오름차순으로 nums1에 다시 넣어주는 문제이다.            주어진 두 정수 m과 n을 합한 값에서 1을 뺀 값으로 변수 length를 정의한다.            주어진 두 정수 m과 n의 index를 활용하기 위하여 각각 1을 빼준다.            반복문을 통해 nums2의 값을 nums1에 오름차순으로 정렬된 순서로 넣어준다.             m이 0이 아니거나 nums1[m]이 nums2[n]보다 작을 경우 nums2[n] 값을 nums1[length] 값에 넣어주고, n과 length를 감소시킨다.       위의 경우가 아닌 경우 nums1[m]의 값을 nums1[length]에 넣어주고 m과 length를 감소시킨다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/merge-sorted-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Gray Code",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; grayCode(int n) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     result.add(0);     int increase = 1;     for (int i = 1; i &lt;= n; i++) {       for (int j = result.size(); j &gt; 0; j--) {         result.add(increase + result.get(j - 1));       }       increase *= 2;     }     return result;   }  }   결과  Link   설명          0부터 1 비트만 변경하면서 $2^n - 1$ 까지의 숫자들을 순차적으로 List에 넣어 반환하는 문제이다.       문제를 풀기 위한 변수를 정의한다.            결과를 반환하기 위한 변수인 List를 정의하여 초기 값인 0을 넣어준다.       2의 배수 증가치로 사용하기 위한 변수 increase를 정의한다.           1부터 n까지 반복하여 결과를 만들어 준다.            변수 result에 포함된 값들을 역순으로 활용하여 result에 $increase + result.get(j - 1)$ 값을 result에 다시 넣어준다.       위의 반복이 종료되면 increase 값을 2배로 증가시킨다.           반복이 완료되면 모든 값을 result에 넣었으므로, 변수 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/gray-code/",
        "teaser": null
      },{
        "title": "Leetcode Java Subsets II",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {     Arrays.sort(nums);     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     this.recursive(result, new ArrayList&lt;&gt;(), nums, 0);     return result;   }    private void recursive(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; temp, int[] nums, int start) {     result.add(new ArrayList&lt;&gt;(temp));     for (int idx = start; idx &lt; nums.length; idx++) {       if (idx &gt; start &amp;&amp; nums[idx] == nums[idx - 1]) {         continue;       }       temp.add(nums[idx]);       this.recursive(result, temp, nums, idx + 1);       temp.remove(temp.size() - 1);     }   }  }   결과  Link   설명          정렬되지 않은 주어진 배열 nums 안의 값들을 이용하여 중복되지 않은 부분 배열들을 만드는 문제이다.            중복된 부분 배열 생성을 사전에 방지하기 위해서 nums를 오름차순으로 정렬한다.       부분 배열들을 넣을 result 변수를 선언하고, 재귀 호출을 통해 부분 배열을 만들어 넣어준다.            부분 배열을 만드는 temp를 새 ArrayList 객체로 생성하여 result에 넣어준다.       전달받은 start부터 nums의 길이 미만까지 반복을 통해 부분 배열을 생성한다.       idx가 start보다 크고 nums[idx]와 nums[idx - 1]의 값이 동일한 경우, 중복된 값이므로 무시하고 반복을 계속 한다.       위의 경우가 아닌 경우 temp에 nums[idx]를 넣고 start에 idx + 1 값을 넣어 재귀 호출을 수행한다.       재귀 호출이 끝나면 temp의 마지막 값을 제거하고 반복을 계속 한다.           재귀 호출이 완료되면 중복되지 않은 부분 배열들을 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/subsets-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Decode Ways",
        "excerpt":"문제  Link   코드  class Solution {    public int numDecodings(String s) {     int[] dp = new int[s.length() + 1];     dp[s.length()] = 1;     dp[s.length() - 1] = s.charAt(s.length() - 1) != '0' ? 1 : 0;     for (int idx = s.length() - 2; idx &gt;= 0; idx--) {       if (s.charAt(idx) != '0') {         dp[idx] = dp[idx + 1] + (Integer.parseInt(s.substring(idx, idx + 2)) &lt;= 26 ? dp[idx + 2] : 0);       }     }     return dp[0];   }  }   결과  Link   설명     숫자로 이루어진 주어진 문자열 s를 이용하여 아래의 규칙으로 만들 수 있는 문자열 조합에 대한 경우의 수를 구하는 문제이다.            각 문자는 숫자랑 치환이 된다. (‘A’ = “1”, ‘B’ = “2”, …, ‘Z’ = “26”)       주어진 문자열 s가 “26”일 경우 “2” + “6” = ‘B’ + ‘F’, “26” = ‘Z’로 두 조합으로 구성이 가능하다.                변수 dp를 주어진 문자열 s의 길이 + 1만큼의 크기인 정수 배열로 정의한다.       정수 배열 dp의 초기 값을 설정한다.            dp[s.length()]에는 1을 넣어준다.       dp[s.length() - 1]에는 주어진 문자열 s의 마지막 문자가 ‘0’이 아닐 경우 1을, ‘0’일 경우 0을 넣어준다.           문자열을 역순으로 모두 반복하여 문자열 조합에 대한 경우의 수를 구한다.            문자가 ‘0’이 아닌 경우 dp[i]에 dp[i + 1]의 값과 두 자리의 문자열이 26 이하인지 확인하여 26 이하일 경우 dp[i + 2] 값을 합쳐 넣어준다.       문자가 ‘0’이 나올 경우, 해당 문자 숫자열 치환이 불가능하므로 무시한다.           반복이 완료되면 주어진 문자열 s의 첫 문자까지 확인하여 경우의 수를 산정한 dp[0]를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/decode-ways/",
        "teaser": null
      },{
        "title": "Leetcode Java Reverse Linked List II",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode reverseBetween(ListNode head, int left, int right) {     ListNode temp = new ListNode(0, head);     ListNode pre = temp;     ListNode cur = head;     int idx = 1;     while (cur.next != null &amp;&amp; idx != left) {       cur = cur.next;       pre = pre.next;       idx++;     }     while (cur.next != null &amp;&amp; idx != right) {       ListNode preNext = pre.next;       ListNode curNext = cur.next;       pre.next = cur.next;       cur.next = curNext.next;       curNext.next = preNext;       idx++;     }     return temp.next;   }  }   결과  Link   설명          주어진 ListNode인 head의 left번째 ListNode부터 right번째 ListNode를 역순으로 반전시키는 문제이다.       문제 해결을 위한 기본 변수를 정의한다.            주어진 ListNode인 head를 역순으로 반전시키기 위해 새로운 ListNode의 next값에 head를 넣은 temp를 정의한다.       head를 반전시키기 위한 임시변수인 pre와 cur을 temp와 head를 각각 넣어 정의한다.       반전시키는 구간을 체크하기 위한 index인 idx를 정의한다.                반전시키기 위한 시작 위치인 left 전까지 반복문을 통해 cur과 pre를 다음 값으로 넘겨준다.       반전이 끝나기 위한 종료 위치인 right까지 반복문을 통해 위치를 반전시켜준다.            pre의 next 값을 임시 저장할 preNext와 cur의 next 값을 임시 저장할 curNext를 정의한다.       pre의 next에 cur의 next를, cur의 next에 curNext의 next 값을, curNext의 next에 preNext 값을 넣어 위치를 left번째 위치부터 idx번째 위치까지 값을 반전시킨다.       idx를 증가시키고 반복을 계속한다.           반복이 완료되면 temp의 next를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reverse-linked-list-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Restore IP Addresses",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; restoreIpAddresses(String s) {     List&lt;String&gt; ipAddresses = new ArrayList&lt;&gt;();     this.recursive(s, ipAddresses, new StringBuilder(), 0, 0);     return ipAddresses;   }    private void recursive(String s, List&lt;String&gt; list, StringBuilder sb, int index, int part) {     if (index &gt; s.length() || part &gt; 4) {       return;     } else if (index == s.length() &amp;&amp; part == 4) {       list.add(sb.toString());       return;     } else {       for (int length = 1; length &lt;= 3; length++) {         if (index + length &gt; s.length()) {           break;         }         int num = Integer.valueOf(s.substring(index, index + length));         if (length == 1 || (length == 2 &amp;&amp; num &gt;= 10 &amp;&amp; num &lt;= 99) || (length == 3 &amp;&amp; num &gt;= 100 &amp;&amp; num &lt;= 255)) {           sb.append(num);           if (part &lt; 3) {             sb.append(\".\");           }           this.recursive(s, list, sb, index + length, part + 1);           if (part &lt; 3) {             sb.deleteCharAt(sb.length() - 1);           }           sb.delete(sb.length() - length, sb.length());         }       }     }   }  }   결과  Link   설명          주어진 문자열 s를 이용하여 만들 수 있는 IP 주소를 모두 만드는 문제이다.       재귀 호출을 이용하여 주어진 문자열 s를 이용한 IP를 StringBuilder를 통해 만들어 ipAddresses에 넣어준다.            동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.                문자열 s의 위치값인 index가 주어진 문자열 s의 길이보다 크거나 IP 주소의 구성의 4번째 파트(xxx.xxx.xxx.xxx)를 초과할 경우, 주어진 문자열로 IP 구성이 불가능하므로 반환시킨다.            문자열 s의 위치값인 index가 주어진 문자열 s의 길이와 같고 IP 주소의 구성이 되었을 경우, list에 동적 문자열 조합을 하는 sb를 list에 추가하고 반환시킨다.       3번과 4번의 경우가 아니면 최대 3문자까지 반복하여 IP 파트 구성을 한다.            index와 IP 구성하려는 length의 합이 s의 길이보다 크다면 반복을 종료한다.       part번째 파트를 구성하는 숫자를 검증하기 위해 num을 주어진 문자열 s의 index번째부터 $index + length$ 전까지 잘라 숫자로 변경하여 정의한다.       length가 1자리거나, length가 2자리이며 num이 10 ~ 99이거나, length가 3자리이며 num이 100 ~ 255일 경우 아래의 내용을 수행한다.                    우선 sb에 num을 이어 넣어주고 part가 3 미만일 경우, IP 주소의 구성을 위해 “.”을 이어 넣어준다.           index에 $index + length$, part에 $part + 1$을 넣어 재귀 호출을 수행한다.           다시 part가 3 미만일 경우, 반복 수행을 위해 sb의 마지막 한 자리를 삭제해준다.           주어진 s에서 사용한 문자열인 $sb.length() - length$부터 sb.length()까지의 길이만큼 sb에서 삭제해준다.                       위의 반복을 계속 수행하여 만들 수 있는 IP 주소를 모두 만들어 준다.           재귀 회출이 완료되면 ipAddresses를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/restore-ip-addresses/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Tree Inorder Traversal",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     this.recursive(result, root);     return result;   }    private void recursive(List&lt;Integer&gt; result, TreeNode node) {     if (node != null) {       this.recursive(result, node.left);       result.add(node.val);       this.recursive(result, node.right);     }   }  }   결과  Link   설명          이진 트리로 구성된 TreeNode를 전달하면, 각 노드 기준으로 좌측 자식 노드 -&gt; 루트 노드 -&gt; 우측 자식 노드 순으로 숫자를 나열하는 문제이다.       주어진 TreeNode인 root를 기준으로 재귀 호출을 통해 각 숫자들을 result에 넣어준다.            node가 null이 아닌 경우, 노드가 존재하므로 아래의 순서대로 순차 실행을 한다.                    좌측 자식 노드인 node.left를 node자리에 넣어 재귀 호출을 수행한다.           result에 node의 val 값을 넣어준다.           우측 자식 노드인 node.right를 node 자리에 넣어 재귀 호출을 수행한다.                           재귀 호출이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-tree-inorder-traversal/",
        "teaser": null
      },{
        "title": "Leetcode Java Unique Binary Search Trees II",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public List&lt;TreeNode&gt; generateTrees(int n) {     return this.recursive(1, n);   }    private List&lt;TreeNode&gt; recursive(int start, int end) {     List&lt;TreeNode&gt; result = new ArrayList&lt;&gt;();     if (start &gt; end) {       result.add(null);     }     for (int idx = start; idx &lt;= end; idx++) {       for (TreeNode left : this.recursive(start, idx - 1)) {         for (TreeNode right : this.recursive(idx + 1, end)) {           result.add(new TreeNode(idx, left, right));         }       }     }     return result;   }  }   결과  Link   설명          숫자 n이 주어지면 중복되지 않은 다양한 구성의 이진 트리를 생성하는 문제이다.       재귀호출을 통해 1부터 n까지 값을 가진 중복되지 않은 TreeNode들을 생성한다.            결과를 저장할 변수 result를 정의한다.       start가 end보다 큰 경우 결과가 없으므로, result에 null을 넣어준다.           아래의 반복을 수행하여 중복되지 않은 TreeNode를 만들어 변수 result에 넣어준다.            start 부터 end까지 반복한다.       start 부터 $idx - 1$까지 재귀호출을 수행하여 left에 들어갈 TreeNode를 만들어 반복을 수행한다.       $idx - 1$부터 end까지 재귀호출을 수행하여 right에 들어갈 TreeNode를 만들어 반복을 수행한다.       위의 세 반복을 통해 만들어진 idx, left, right를 이용하여 새 TreeNode를 result에 넣어준다.           반복이 완료되면 중복되지 않은 TreeNode를 넣은 변수 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/unique-binary-search-trees-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Unique Binary Search Trees",
        "excerpt":"문제  Link   코드  class Solution {    public int numTrees(int n) {     int[] dp = new int[n + 1];     dp[0] = 1;     dp[1] = 1;     for (int i = 2; i &lt;= n; i++) {       for (int j = 1; j &lt;= i; j++) {         dp[i] += dp[i - j] * dp[j - 1];       }     }     return dp[n];   }  }   결과  Link   설명          주어진 정수 n을 이용해서 이진 트리를 구성하는 경우의 수를 구하는 문제이다.            문제 풀이를 위해 dp를 주어진 정수인 n보다 1 크게 정의하고, 0과 1 자리에 1을 넣어 초기화 시킨다.            i는 dp의 초기화 되지 않은 2번째 자리에서 n까지 값을 증가시키며 반복한다.            j는 1부터 i까지 증가시키며 반복한다.       dp[n]을 구하기 위한 값을 풀어보면 아래와 같다.            $dp[2] = dp[0] * dp[1] + dp[1] * dp[0] = 2$       $dp[3] = dp[0] * dp[2] + dp[1] * dp[1] + dp[1] + dp[2] * dp[0] = 5$       $dp[n] = dp[0] * dp[n - 1] + dp[1] * dp[n - 2] + … + $ $dp[n - 2] * dp[1] + dp[n - 1] * dp[0]$       위의 식대로 풀이해보면, 3번과 4번의 반복을 수행하여 $dp[i] += dp[i - j] * dp[j - 1]$로 dp[i]의 값을 넣어준다.           반복이 완료되면 완성된 dp의 n번째 값인 dp[n]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/unique-binary-search-trees/",
        "teaser": null
      },{
        "title": "Leetcode Java Interleaving String",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isInterleave(String s1, String s2, String s3) {     if ((s1.length() + s2.length()) != s3.length()) {       return false;     }     boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];     dp[0][0] = true;     for (int i = 1; i &lt; dp.length; i++) {       dp[i][0] = dp[i - 1][0] &amp;&amp; (s1.charAt(i - 1) == s3.charAt(i - 1));     }     for (int i = 1; i &lt; dp[0].length; i++) {       dp[0][i] = dp[0][i - 1] &amp;&amp; (s2.charAt(i - 1) == s3.charAt(i - 1));     }     for (int i = 1; i &lt; dp.length; i++) {       for (int j = 1; j &lt; dp[0].length; j++) {         dp[i][j] = (dp[i - 1][j] &amp;&amp; (s1.charAt(i - 1) == s3.charAt(i + j - 1)))             || (dp[i][j- 1] &amp;&amp; (s2.charAt(j - 1) == s3.charAt(i + j - 1)));       }     }     return dp[s1.length()][s2.length()];   }  }   결과  Link   설명          주어진 문자열 s1과 s2를 이용하여 s3를 만들 수 있는지 검증하는 문제이다.            기본적으로 주어진 문자열 s1과 s2의 길이의 합이 주어진 문자열 s3와 같지 않으면, false를 문제의 결과로 반환한다.       변수 dp를 주어진 변수 s1과 s2의 길이보다 하나 더 큰 사이즈로 정의하고, dp[0][0]을 true로 초기화 한다.            dp의 첫 열을 s1의 길이만큼 반복하여 dp[$i - 1$][0]이 true이면서, s1와 s3의 $i - 1$번째 단어가 동일한지 확인한다.       dp의 첫 행을 s2의 길이만큼 반복하여 dp[][$i - 1$]이 true이면서, s2와 s3의 $i - 1$번째 단어가 동일한지 확인한다.           dp를 반복하여 주어진 문자열 s1과 s2를 이용하여 s3를 만들 수 있는지 확인하며 dp를 채워준다.            dp[i][j]에 dp[$i - 1$][j]의 값이 true이고 s1의 $i - 1$번째 자리와 s3의 $i + j - 1$번째 자리가 동일하거나, dp[i][$j - 1$]의 값이 true이고 s2의 $j - 1$번째 자리와 s3의 $i + j - 1$번째 자리가 동일한 경우 true를 넣고 아닌 경우 false를 넣어준다.           반복이 완료되면 주어진 문자열 s1과 s2를 이용하여 s3를 만들 수 있는지의 결과를 저장한 dp[s1.length()][s2.length()]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/interleaving-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Validate Binary Search Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public boolean isValidBST(TreeNode root) {     return this.recursive(root, null, null);   }    private boolean recursive(TreeNode root, Integer min, Integer max) {     if (root == null) {       return true;     } else if ((min != null &amp;&amp; root.val &lt;= min) || (max != null &amp;&amp; root.val &gt;= max)) {       return false;     } else {       return this.recursive(root.left, min, root.val) &amp;&amp; this.recursive(root.right, root.val, max);     }   }  }   결과  Link   설명     주어진 TreeNode인 root가 유효한 이진 검색 트리인지 검증하는 문제이다.            이진 검색 트리의 조건은 아래와 같다.                    노드의 왼쪽 아래 구성되는 노드의 값은 상위 노드의 값보다 작은 값이어야 한다.           노드의 오른쪽 아래 구성되는 노드의 값은 상위 노드의 값보다 큰 값이어야 한다.           루트 이하 모든 노드들은 위의 두 조건을 따른다.                           재귀 호출을 이용하여 min 값과 max 값을 이용하여 이진 검색 트리가 유효한지 검증한다.            root가 null인 경우 왼쪽 아래와 오른쪽 아래 노드가 없어 검증의 의미가 없으므로, true를 반환한다.       아래의 조건에 일치하면 이진 검색 트리 조건에 부합하지 않으므로, false를 반환한다.                    min이 null이 아니고 root의 val 값이 min보다 작거나 같다.           max가 null이 아니고 root의 val 값이 max보다 크거나 같다.                       그 외의 경우 root의 왼쪽 아래 구성되는 노드가 유효한지와 오른쪽 아래 구성되는 노드 기준의 검증 결과가 유효한지 검증하여 AND(논리곱)으로 연산한 결과를 반환한다.       최종 검증이 끝난 값을 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/validate-binary-search-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Recover Binary Search Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public void recoverTree(TreeNode root) {     TreeNode previous = null;     TreeNode first = null;     TreeNode second = null;     TreeNode temp = null;     while (root != null) {       if (root.left != null) {         temp = root.left;         while (temp.right != null &amp;&amp; temp.right != root) {           temp = temp.right;         }         if (temp.right != null) {           if (previous != null &amp;&amp; previous.val &gt; root.val) {             if (first == null) {               first = previous;             }             second = root;           }           previous = root;           temp.right = null;           root = root.right;         } else {           temp.right = root;           root = root.left;         }       } else {         if (previous != null &amp;&amp; previous.val &gt; root.val) {           if (first == null) {             first = previous;           }           second = root;         }         previous = root;         root = root.right;       }     }     if (first != null &amp;&amp; second != null) {       int t = first.val;       first.val = second.val;       second.val = t;     }   }  }   결과  Link   설명          주어진 TreeNode인 root는 이진 검색 트리로, 잘못된 두 값의 위치를 변경하여 정상적으로 만드는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            이전의 TreeNode를 저장할 변수인 previous를 정의한다.       두 잘못된 TreeNode를 저장할 변수인 first, second를 정의한다.       TreeNode를 임시 저장하여 사용 할 변수인 temp를 정의한다.                root가 null이 아닐 경우까지 반복을 수행하여 잘못된 두 값의 위치를 확인하여 변경한다.       root의 left가 null이 아닐 경우, 아래의 내용을 수행한다.            temp에 root의 left TreeNode를 저장한다.       temp의 right TreeNode가 null이나 root이면 temp의 right TreeNode를 temp에 넣어준다.       temp의 right TreeNode가 null이 아닌 경우, 아래의 내용을 수행한다.                    previous가 null이 아니고 previous의 val 값이 root의 val 값보다 큰 경우 잘못된 노드이므로 first가 null이면 first에 previous를 second에 root를 넣어준다.           previous에 root를, temp.right에 null을, root에 root의 right TreeNode를 넣어준다.                       temp의 right TreeNode가 null인 경우, temp.right에 root를, root에 root의 left TreeNode를 넣어준다.           root의 left가 null인 경우, 아래의 내용을 수행한다.            previous가 null이 아니고 previous의 val 값이 root의 val 값보다 큰 경우 잘못된 노드이므로 first가 null이면 first에 previous를 second에 root를 넣어준다.       previous에 root를, root에 root의 right TreeNode를 넣어준다.           반복이 완료되고 first와 second가 null이 아닌 경우, 잘못된 두 위치를 찾은 경우이므로 first의 val 값과 seconde의 val 값을 정상 노드로 바꾸어준다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/recover-binary-search-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Same Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public boolean isSameTree(TreeNode p, TreeNode q) {     if (p == null &amp;&amp; q == null) {       return true;     } else if (p == null || q == null) {       return false;     } else if (p.val == q.val) {       return this.isSameTree(p.left, q.left) &amp;&amp; this.isSameTree(p.right, q.right);     } else {       return false;     }   }  }   결과  Link   설명          주어진 TreeNode인 p와 q가 동일한 구조와 값을 가지고 있는지 검증하는 문제이다.            재귀 호출을 통해 p와 q가 동일한 구조와 값을 가지고 있는지 검증하여 결과를 주어진 문제의 결과로 반환한다.             p와 q가 null인 경우 TreeNode의 끝이 동일하므로, true를 반환한다.       p가 null이거나 q가 null인 경우 TreeNode의 끝이 다르므로, false를 반환한다.       p의 val 값과 q의 val 값이 동일하면 재귀 호출을 통해 p와 q의 left와 right를 각각 동일한 구조인지 다시 검증한 결과의 AND(논리곱) 결과를 반환한다.       그 외의 경우는 p와 q의 값이 다른 경우이므로, false를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/same-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Symmetric Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public boolean isSymmetric(TreeNode root) {     return this.recursive(root.left, root.right);   }    private boolean recursive(TreeNode p, TreeNode q) {     if (p == null &amp;&amp; q == null) {       return true;     } else if (p == null || q == null) {       return false;     } else if (p.val == q.val) {       return this.recursive(p.left, q.right) &amp;&amp; this.recursive(p.right, q.left);     } else {       return false;     }   }  }   결과  Link   설명          주어진 TreeNode인 root의 left와 right TreeNode가 대칭이 되는지 검증하는 문제이다.            재귀 호출을 통해 root의 left와 right가 대칭이 되는지 검증하여 결과를 주어진 문제의 결과로 반환한다.             p와 q가 null인 경우 TreeNode의 끝이 동일하므로, true를 반환한다.       p가 null이거나 q가 null인 경우 TreeNode의 끝이 다르므로, false를 반환한다.       p의 val 값과 q의 val 값이 동일하면 재귀 호출을 통해 서로 반대가 되는 p의 left와 q의 right, p의 right와 q의 left TreeNode가 각각 대칭되는 구조인지 다시 검증한 결과의 AND(논리곱) 결과를 반환한다.       그 외의 경우는 p와 q의 값이 다른 경우이므로, false를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/symmetric-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Tree Level Order Traversal",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     this.recursive(root, result, 0);     return result;   }    private void recursive(TreeNode treeNode, List&lt;List&lt;Integer&gt;&gt; result, int level) {     if (treeNode == null) {       return;     }     if (result.size() &lt; level + 1) {       result.add(new ArrayList&lt;&gt;());     }     result.get(level).add(treeNode.val);     this.recursive(treeNode.left, result, level + 1);     this.recursive(treeNode.right, result, level + 1);   }  }   결과  Link   설명          주어진 TreeNode인 root를 오름차순으로 level 별 val 값의 부분 집합을 만드는 문제이다.       재귀 호출을 이용하여 root를 내림차순의 level 별 부분 집합을 result에 넣어준다.            treeNode가 null인 경우 마지막 노드에서 재귀 호출을 한 것이므로, return 시킨다.       result의 size가 $level + 1$보다 작은 경우, level의 처음 값이므로 새로운 ArrayList를 result에 넣어준다.       result의 level번째 List를 가져와 treeNode의 val 값을 넣어준다.       left -&gt; right 순으로 값을 넣어주어야 하므로, treeNode의 left TreeNode를 1 증가시킨 level로 재귀 호출을 수행한다.       이후 right TreeNode도 1증가시킨 level로 재귀 호출을 수행한다.           재귀 호출이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-tree-level-order-traversal/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Tree Zigzag Level Order Traversal",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     this.recursive(root, result, 0);     return result;   }    private void recursive(TreeNode treeNode, List&lt;List&lt;Integer&gt;&gt; result, int level) {     if (treeNode == null) {       return;     }     if (result.size() &lt; level + 1) {       result.add(new ArrayList&lt;&gt;());     }     if (level % 2 == 0) {       result.get(level).add(treeNode.val);     } else {       result.get(level).add(0, treeNode.val);     }     this.recursive(treeNode.left, result, level + 1);     this.recursive(treeNode.right, result, level + 1);   }  }   결과  Link   설명          주어진 TreeNode root를 이용하여 tree의 level 별 val 값들의 집합을 모두 구하는 문제이다. 단, 짝수 번째 level의 경우 역순으로(right -&gt; left) val 값들의 집합으로 구성해야 한다.       이전의 Binary Tree Level Order Traversal과 유사한 문제이다.            단, 기존의 경우 모든 부분 집합의 정렬 순서가 left -&gt; right였다.       변경된 룰은 홀수 번째 level의 경우 부분 집합의 정렬 순서는 left -&gt; right이고, 짝수 번째 level의 경우 부분 집합이의 정렬 순서는 right -&gt; left이다.           재귀 호출을 이용하여 root의 각 level 별 val 값들의 집합을 result에 모두 넣어준다.            treeNode가 null인 경우, TreeNode의 마지막이므로 종료 시킨다.       result의 size가 $level + 1$보다 작은 경우, level의 처음 값이므로 새로운 ArrayList를 result에 넣어준다.       순차적으로 result의 level번째 List를 가져와 treeNode의 val 값을 넣어준다.                    $level \\mod 2$로 짝수인 경우, List의 뒤에 순차적으로 val 값을 넣어준다.           $level \\mod 2$로 홀수인 경우, List의 앞에 역순으로 val 값을 넣어준다.                       left -&gt; right 순으로 값을 넣어주어야 하므로, treeNode의 left TreeNode를 1 증가시킨 level로 재귀 호출을 수행한다.       이후 right TreeNode도 1증가시킨 level로 재귀 호출을 수행한다.           재귀 호출이 완료되면 root를 이용하여 level 별 val 값들의 집합으로 구성된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-tree-zigzag-level-order-traversal/",
        "teaser": null
      },{
        "title": "Java Simplified Encryption(Jasypt)",
        "excerpt":"Jasypt1     개발자가 암호화에 대한 이해도가 높지 않더라도 프로젝트에 암호화 기능을 추가 할 수 있도록 고안된 Java Library이다.   단방향 및 양방향 암호화 모두에 높은 보안, 표준 기반의 암호화 기술 등을 제공한다.   Spring 기반 애플리케이션과 Spring Security와 통합이 가능하다.   Bouncy Castle2     Java 및 C#용 경량 암호화 오픈 소스 API이다.   JCE(Java Cryptography Extension)3 공급자보다 더 보안적으로 강력한 암호화 패키지이다.   AES(Advanced Encryption Standard)4 알고리즘을 구현하였다.   Spring with Jasypt     Jasypt의 digesters와 encryptors를 Spring Bean으로 등록하여 Spring 애플리케이션 컨텍스트에서 인스턴스화와 종속성 주입을 지원한다.   Spring Bean으로 등록된 Jasypt의 digesters와 encryptors는 Thread-Safe하다.   Spring에서 Jasypt를 사용하기 위해서 PropertySource 인터페이스에 대한 암호화 인식 구현을 제공한다.   PooledPBE*Encryptor Bean  @Configuration public class PropertyEncryptConfig {    private static final String PASSWORD = \"GracefulSoul\";   private static final String SHA256_AES128_ALGORITHM = \"PBEWithSHA256And128BitAES-CBC-BC\";    @Bean   public PooledPBEStringEncryptor pooledPBEStringEncryptor() {     PooledPBEStringEncryptor pooledPBEStringEncryptor = new PooledPBEStringEncryptor();     pooledPBEStringEncryptor.setProvider(new BouncyCastleProvider());     pooledPBEStringEncryptor.setPoolSize(2);     pooledPBEStringEncryptor.setPassword(PASSWORD);     pooledPBEStringEncryptor.setAlgorithm(SHA256_AES128_ALGORITHM);     return pooledPBEStringEncryptor;   }  }     Spring Configuration Annotation으로 PropertyEncryptConfig를 정의하고, 내부에 PooledPBEStringEncryptor를 Bean으로 생성해준다.   Provider는 암복호화에 사용되는 공급자로, 일반적인 JCE보다 더 보안적으로 강력한 Bouncy Castle을 사용하는 것을 추천한다.   PoolSize는 암복호화 요청에 대한 Worker의 개수로 생각하면 된다. PoolSize만큼 Encryptor를 복제하여 사용하도록 되어있다.   Password는 암복호화에 사용되는 Key이다.   Algorithm은 Provider에서 제공되는 암복호화에 사용될 알고리즘을 지정하는 것이다.   위 항목들은 모두 필수 값으로 설정하지 않으면 IllegalArgumentException이 발생한다.   Used  jasypt.encryptor.bean=pooledPBEStringEncryptor user.drink=ENC(cPKFOgVppX+//d5nE206topFdbxaUuyWbP8lA45rb64=)  @Service public class UserService {    @Value(\"${user.drink}\")   private String drink;    public String getDrink() {     return this.drink;   }  }     application.properties에 위의 PooledPBEStringEncryptor를 이용하여 암호화 한 값을 ENC() 키워드 괄호 안에 넣어준다.   Spring Expression Language(SpEL)5을 사용하여 암복호화 사용을 Sample로 사용하였지만, 위에서 설명하였듯이 PropertySource 인터페이스에 대한 암호화 인식 구현을 통해 값을 가져올 경우 자동으로 복호화하여 사용되는 모든 항목에 적용이 된다.   단, Test code를 작성하는 경우에 Spring IOC에 의해 Bean이 생성되지 않으면 당연히 복호화는 동작하지 않는다.   Review     Spring Application을 업무용도로 개발 및 사용할 경우 application.properties 내부의 시스템의 URL과 Password를 난독화 해야 할 필요성이 존재하므로 Jasypt를 사용하면 쉽게 이를 해결 할 수 있다.   시스템의 난독화 및 암호화는 선택이 아니라 필수로 생각해야 할 만큼 사회에 대한 필수 요소로, 보안을 무시하고 개발하는 경우 개인 뿐 아니라 사회에 피해가 갈 수 있음을 개발자는 상시 고려해야 한다.   Reference   ※ Sample Code는 여기에서 확인 가능합니다.                 Jasypt-Home &#8617;                  Bouncy_Castle-Home &#8617;                  Java_Cryptography_Extension-Wiki &#8617;                  Advanced_Encryption_Standard-Wiki &#8617;                  Spring_Expression_Language &#8617;           ","categories": ["Java"],
        "tags": ["Programming","Java","Spring","Jasypt","Bouncy Castle"],
        "url": "/java/jasypt/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Depth of Binary Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public int maxDepth(TreeNode root) {     return this.recursive(root, 0);   }    private int recursive(TreeNode treeNode, int depth) {     if (treeNode == null) {       return depth;     } else {       return Math.max(this.recursive(treeNode.left, depth + 1), this.recursive(treeNode.right, depth + 1));     }   }  }   결과  Link   설명          주어진 TreeNode인 root의 최대 깊이를 구하는 문제이다.            재귀 호출을 통해서 root의 최대 깊이를 구하여 주어진 문제의 결과로 반환한다.             treeNode가 null인 경우 해당 노드의 마지막이므로, depth를 반환한다.       그 외의 경우에는 treeNode의 left와 right를 각각 $depth + 1$로 재귀호출을 수행한 결과 중 가장 큰 값을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-depth-of-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Construct Binary Tree from Preorder and Inorder Traversal",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public TreeNode buildTree(int[] preorder, int[] inorder) {     Map&lt;Integer, Integer&gt; inorderMap = new HashMap&lt;&gt;();     for (int idx = 0; idx &lt; inorder.length; idx++) {       inorderMap.put(inorder[idx], idx);     }     return this.recursive(preorder, inorderMap, 0, preorder.length - 1, 0);   }    private TreeNode recursive(int[] preorder, Map&lt;Integer, Integer&gt; inorderMap, int preStart, int preEnd, int inStart) {     if (preStart &gt; preEnd) {       return null;     }     TreeNode treeNode = new TreeNode(preorder[preStart]);     int inOrderIndex = inorderMap.get(treeNode.val);     int numsLeft = inOrderIndex - inStart;     treeNode.left = this.recursive(preorder, inorderMap, preStart + 1, preStart + numsLeft, inStart);     treeNode.right = this.recursive(preorder, inorderMap, preStart + numsLeft + 1, preEnd, inOrderIndex + 1);     return treeNode;   }  }   결과  Link   설명          주어진 정수 배열 preorder는 TreeNode의 val 값을 Root -&gt; Left -&gt; Right 순서로 정렬한 배열이며, inorder는 TreeNode의 val 값을 Left -&gt; Root -&gt; Right 순서로 정렬한 배열로, 두 배열을 참고하여 TreeNode를 만들어 반환하는 문제이다.            주어진 inorder의 순서를 기억하기 위해 inorderMap을 정의하여 inorder 배열의 해당 값 index를 저장한다.            재귀 호출을 이용하여 TreeNode를 만들어 주어진 문제의 결과로 반환한다.             preStart가 preEnd보다 큰 경우 다음 노드의 val 값을 설정하지 못한다는 의미이므로, return 시킨다.       문제 풀이에 필요한 기본 변수를 정의한다.                    변수 treeNode는 결과로 반환 할 TreeNode를 구성하기 위해 정의하며, preorder[preStart] 값으로 TreeNode를 생성하여 초기화 한다.           변수 inOrderIndex를 inorder 배열 내 treeNode val 값의 위치를 사용하기 위하여 정의한다.           변수 numsLeft는 inOrderIndex의 위치 값에서 preorder와 inorder 사이의 남은 값이 존재하는지를 의미하며, inOrderIndex에서 inStart를 뺀 값으로 정의한다.                       treeNode의 left의 TreeNode는 preStart에 1을 증가시키고, preEnd에 $preStart + numsLeft$를 넣어 재귀호출을 수행한 결과로 넣어준다.       treeNode의 right의 TreeNode는 preStart에 $preStart + numsLeft + 1$을, inStart에 $inOrderIndex + 1$을 넣어 재귀호출을 수행한 결과로 넣어준다.       위의 순서대로 만들어진 TreeNode는 반환 시키고, 최초 호출의 경우 만들어진 TreeNode를 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/construct-binary-tree-from-preorder-and-inorder-traversal/",
        "teaser": null
      },{
        "title": "Leetcode Java Construct Binary Tree from Inorder and Postorder Traversal",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public TreeNode buildTree(int[] inorder, int[] postorder) {     Map&lt;Integer, Integer&gt; inorderMap = new HashMap&lt;&gt;();     for (int idx = 0; idx &lt; inorder.length; idx++) {       inorderMap.put(inorder[idx], idx);     }     return this.recursive(postorder, inorderMap, 0, inorder.length - 1, 0, postorder.length - 1);   }    private TreeNode recursive(int[] postorder, Map&lt;Integer, Integer&gt; inorderMap, int inStart, int inEnd, int postStart, int postEnd) {     if (postStart &gt; postEnd || inStart &gt; inEnd) {       return null;     }     TreeNode treeNode = new TreeNode(postorder[postEnd]);     int inOrderIndex = inorderMap.get(treeNode.val);     int numsLeft = inOrderIndex - inStart;     treeNode.left = this.recursive(postorder, inorderMap, inStart, inOrderIndex - 1, postStart, postStart + numsLeft - 1);     treeNode.right = this.recursive(postorder, inorderMap, inOrderIndex + 1, inEnd, postStart + numsLeft, postEnd - 1);     return treeNode;   }  }   결과  Link   설명          주어진 정수 배열 inorder는 TreeNode의 val 값을 Left -&gt; Root -&gt; Right 순서로 정렬한 배열이며, postorder는 TreeNode의 val 값을 Left -&gt; Right -&gt; Root 순서로 정렬한 배열로, 두 배열을 참고하여 TreeNode를 만들어 반환하는 문제이다.            주어진 inorder의 순서를 기억하기 위해 inorderMap을 정의하여 inorder 배열의 해당 값 index를 저장한다.            재귀 호출을 이용하여 TreeNode를 만들어 주어진 문제의 결과로 반환한다.             postStart가 postEnd보다 크거나 inStart가 inEnd보다 큰 경우 다음 노드의 val 값을 설정하지 못한다는 의미이므로, return 시킨다.       문제 풀이에 필요한 기본 변수를 정의한다.                    변수 treeNode는 결과로 반환 할 TreeNode를 구성하기 위해 정의하며, postorder[postEnd] 값으로 TreeNode를 생성하여 초기화 한다.           변수 inOrderIndex를 inorder 배열 내 treeNode val 값의 위치를 사용하기 위하여 정의한다.           변수 numsLeft는 inOrderIndex의 위치 값에서 inorder와 postorder 사이의 남은 값이 존재하는지를 의미하며, inOrderIndex에서 inStart를 뺀 값으로 정의한다.                       treeNode의 left의 TreeNode는 inEnd에 $inOrderIndex - 1$을, postEnd에 $postStart + numsLeft - 1$을 넣어 재귀호출을 수행한 결과로 넣어준다.       treeNode의 right의 TreeNode는 inStart에 $inOrderIndex + 1$을, postStart에 $postStart + numsLeft$를, postEnd에 $postEnd - 1$을 넣어 재귀호출을 수행한 결과로 넣어준다.       위의 순서대로 만들어진 TreeNode는 반환 시키고, 최초 호출의 경우 만들어진 TreeNode를 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/construct-binary-tree-from-inorder-and-postorder-traversal/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Tree Level Order Traversal II",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     this.recursive(root, result, 0);     return result;   }    private void recursive(TreeNode treeNode, List&lt;List&lt;Integer&gt;&gt; result, int level) {     if (treeNode == null) {       return;     }     if (result.size() &lt; level + 1) {       result.add(0, new ArrayList&lt;&gt;());     }     this.recursive(treeNode.left, result, level + 1);     this.recursive(treeNode.right, result, level + 1);     result.get(result.size() - level - 1).add(treeNode.val);   }  }   결과  Link   설명          주어진 TreeNode인 root를 내림차순으로 level 별 val 값의 부분 집합을 만드는 문제이다.       재귀 호출을 이용하여 root를 내림차순의 level 별 부분 집합을 result에 넣어준다.            treeNode가 null인 경우 마지막 노드에서 재귀 호출을 한 것이므로, return 시킨다.       result의 size가 $level + 1$보다 작은 경우, level의 처음 값이므로 새로운 ArrayList를 result의 맨 처음에 넣어준다.       left -&gt; right 순으로 값을 넣어주어야 하므로, treeNode의 left TreeNode를 1 증가시킨 level로 재귀 호출을 수행한다.       이후 right TreeNode도 1증가시킨 level로 재귀 호출을 수행한다.       level에 대한 내림차순으로 정렬해야 하므로, result의 $result.size() - level - 1$번째 List를 가져와 treeNode의 val 값을 넣어준다.           재귀 호출이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-tree-level-order-traversal-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Convert Sorted Array to Binary Search Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public TreeNode sortedArrayToBST(int[] nums) {     return this.recursive(nums, 0, nums.length - 1);   }    private TreeNode recursive(int[] nums, int low, int high) {     if (low &gt; high) {       return null;     }     int mid = (low + high) / 2;     TreeNode treeNode = new TreeNode(nums[mid]);     treeNode.left = this.recursive(nums, low, mid - 1);     treeNode.right = this.recursive(nums, mid + 1, high);     return treeNode;   }  }   결과  Link   설명          주어진 정수 배열인 nums를 이용하여 TreeNode를 생성하는 문제이다.            재귀 호출을 이용하여 TreeNode를 만들어 주어진 문제의 결과로 반환한다.             low가 high보다 큰 경우 nums의 주어진 범위 내에서 TreeNode를 모두 생성한 것이므로, null을 return시킨다.       중앙값인 mid를 $\\frac{low + high}{2}$의 값을 구해서 TreeNode인 treeNode를 생성한다.       treeNode의 left에 low부터 $mid - 1$까지 재귀 호출을 수행하여 넣어준다.       treeNode의 right에 $mid + 1$부터 high까지 재귀 호출을 수행하여 넣어준다.       만들어진 treeNode를 반환한다. 최초 재귀 호출의 경우, 주어진 문제로 treeNode를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/convert-sorted-array-to-binary-search-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Convert Sorted List to Binary Search Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public TreeNode sortedListToBST(ListNode head) {     return this.recursive(head, null);   }    private TreeNode recursive(ListNode head, ListNode tail) {     if (head == null || head == tail) {       return null;     }     ListNode fast = head;     ListNode slow = head;     while (fast != tail &amp;&amp; fast.next != tail) {       fast = fast.next.next;       slow = slow.next;     }     TreeNode treeNode = new TreeNode(slow.val);     treeNode.left = this.recursive(head, slow);     treeNode.right = this.recursive(slow.next, tail);     return treeNode;   }  }   결과  Link   설명          주어진 ListNode를 이용하여 TreeNode를 구현하는 문제이다.            재귀 호출을 이용하여 TreeNode를 만들어 주어진 문제의 결과로 반환한다.             head가 null이면 풀이에 대한 대상이 null이고, head가 tail과 같으면 좌측 노드 생성이 root 노드 순서에 걸린 경우이므로, null을 반환한다.       head의 가운데 노드를 root로 하여 TreeNode를 생성하기 위해 fast와 slow에 head를 넣어준다.       fast와 fast의 next가 tail이 아닐 때 까지 fast는 두 노드를 이동하고, slow는 한 노드를 이동하여 slow를 head의 가운데 노드에 위치하도록 해준다.       가운데 위치한 slow를 이용하여 TreeNode를 생성한다.                    새 TreeNode인 treeNode를 정의하여 slow의 val 값으로 초기화해준다.           treeNode의 left TreeNode에 head와 slow의 재귀 호출을 수행한 결과를 넣어준다.           treeNode의 right TreeNode에 slow.next와 tail의 재귀 호출을 수행한 결과를 넣어준다.                       완성된 treeNode를 반환하고, 초기 재귀 호출의 경우 treeNode를 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/convert-sorted-list-to-binary-search-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Balanced Binary Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public boolean isBalanced(TreeNode root) {     return this.recursive(root) != -1;   }    private int recursive(TreeNode root) {     if (root == null) {       return 0;     }     int left = this.recursive(root.left);     int right = this.recursive(root.right);     if (left == -1 || right == -1 || Math.abs(left - right) &gt; 1) {       return -1;     } else {       return Math.max(left, right) + 1;     }   }  }   결과  Link   설명          주어진 TreeNode인 root가 균형을 이루고 있는지를 검증하는 문제이다.       재귀 호출을 이용하여 root가 균형을 이루고 있는지 검증한다.            root가 null인 경우 마지막 노드이므로, 0을 반환한다.       left를 root의 left TreeNode의 재귀 호출 결과로 정의한다.       right를 root의 right TreeNode의 재귀 호출 결과로 정의한다.       left와 right가 -1이거나, $left - right$의 절대값이 1 초과인 경우 불균형을 이루므로, -1을 반환한다.       위의 경우가 아닌 경우 left와 rigth의 최대 값에 1을 더하여 반환한다.           재귀 호출읠 결과가 -1이 아니면 균형을 이루고 있으므로 true를, -1이면 균형을 이루고 있지 않으므로 false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/balanced-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Depth of Binary Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public int minDepth(TreeNode root) {     if (root == null) {       return 0;     }     List&lt;TreeNode&gt; queue = new ArrayList&lt;&gt;();     queue.add(root);     int depth = 1;     while (!queue.isEmpty()) {       int queueSize = queue.size();       for (int idx = 0; idx &lt; queueSize; idx++) {         TreeNode treeNode = queue.remove(0);         if (treeNode.left == null &amp;&amp; treeNode.right == null) {           return depth;         }         if (treeNode.left != null) {           queue.add(treeNode.left);         }         if (treeNode.right != null) {           queue.add(treeNode.right);         }       }       depth++;     }     return depth;   }  }   결과  Link   설명          주어진 TreeNode인 root의 최소 깊이를 구하는 문제이다.            root가 null인 경우 최소 깊이를 구할 수 없으므로, 0을 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            TreeNode의 각 노드 값을 임시 저장하기 위한 Queue 역할을 수행할 List를 정의하고, root를 초기 값으로 넣어준다.       최소 깊이를 계산할 변수 depth를 1로 정의한다.           queue가 비어있지 않을 때까지 반복하여 아래를 수행한다.            queue에 저장된 개수를 먼저 임시 저장하고 해당 횟수만큼 반복하여 TreeNode를 검증한다.       queue에 저장된 첫 TreeNode를 꺼내온다.       해당 treeNode의 left와 right가 null인 경우 자식이 없는 끝단 노드이므로, depth를 주어진 문제의 결과로 반환한다.       treeNode의 left가 null이 아닌 경우, queue에 해당 TreeNode를 넣어준다.       treeNode의 right가 null이 아닌 경우, queue에 해당 TreeNode를 넣어준다.       queue에 저장된 횟수만큼 반복이 끝나면 depth를 증가시키고 맨 처음의 반복을 수행해준다.           반복이 완료되면 최소 깊이를 저장한 변수 depth를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-depth-of-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Path Sum",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public boolean hasPathSum(TreeNode root, int targetSum) {     if (root == null) {       return false;     } else if (root.left == null &amp;&amp; root.right == null &amp;&amp; targetSum - root.val == 0) {       return true;     } else {       int sum = targetSum - root.val;       return this.hasPathSum(root.left, sum) || this.hasPathSum(root.right, sum);     }   }  }   결과  Link   설명          주어진 TreeNode인 root의 마지막 노드까지의 val 값들의 합이 targetSum이 되는 줄기가 존재하는지 검증하는 문제이다.            재귀 호출을 이용하여 targetSum과 동일한지를 검증하고 주어진 문제의 결과로 반환한다.             root가 null인 경우 존재하지 않은 노드 혹은 주어진 문제의 TreeNode가 null인 경우이므로, false를 반환한다.       root의 left와 right가 null이면 마지막 노드이므로, $targetSum - root.val$이 0인 경우 true를 반환한다.       그 외의 경우는 마지막 노드가 아니므로, root의 left와 right TreeNode를 $targetSum - root.val$ 값으로 재귀 호출을 수행한 결과들의 OR(논리합) 결과를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/path-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Path Sum II",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     this.recursive(root, new ArrayList&lt;&gt;(), result, targetSum);     return result;   }    public void recursive(TreeNode root, List&lt;Integer&gt; temp, List&lt;List&lt;Integer&gt;&gt; result, int targetSum) {     if (root == null) {       return;     }     temp.add(new Integer(root.val));     if (root.left == null &amp;&amp; root.right == null &amp;&amp; targetSum == root.val) {       result.add(new ArrayList&lt;&gt;(temp));     }     this.recursive(root.left, temp, result, targetSum - root.val);     this.recursive(root.right, temp, result, targetSum - root.val);     temp.remove(temp.size() - 1);   }  }   결과  Link   설명          주어진 TreeNode인 root의 마지막 노드까지의 val 값들의 합이 targetSum이 되는 줄기들의 val 값의 집합들을 모두 찾는 문제이다.       재귀 호출을 이용하여 targetSum과 동일한지를 검증하고 해당 val 값의 집합을 result에 넣어준다.            root가 null인 경우 해당 TreeNode가 존재하지 않으므로, return 시킨다.       temp ArrayList에 root의 val 값을 넣어준다.       root의 left와 right가 null이면 마지막 노드이므로, $targetSum - root.val$이 0인 경우 result에 temp를 새 ArrayList로 생성하여 넣어준다.       left와 right TreeNode도 각각 targetSum에 $targetSum - root.val$을 넣어 재귀 호출을 수행하여 각 val 값들의 합이 targetSum이 되는 줄기를 모두 탐색한다.       반복이 끝나기 전에 해당 TreeNode의 val 값을 제거해준다.           재귀 호출이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/path-sum-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Flatten Binary Tree to Linked List",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public void flatten(TreeNode root) {     this.recursive(root, null);   }    private TreeNode recursive(TreeNode treeNode, TreeNode temp) {     if (treeNode == null) {       return temp;     }     treeNode.right = this.recursive(treeNode.left, this.recursive(treeNode.right, temp));     treeNode.left = null;     return treeNode;   }  }   결과  Link   설명          주어진 TreeNode의 val 값을 이용하여 우측으로 정렬된 TreeNode로 변경하는 문제이다.            재귀 호출을 이용하여 주어진 TreeNode인 root와 임시 변수인 temp를 이용하여 우측으로 정렬된 TreeNode로 변경하여 주어진 문제를 해결한다.             treeNode가 null인 경우 마지막 노드이므로, temp를 반환한다.       treeNode의 right TreeNode에 treeNode의 right TreeNode와 temp로 재귀 호출한 결과를 다시 treeNode의 left TreeNode와 재귀 호출한 결과를 넣어준다.       TreeNode의 left TreeNode는 값을 제거해야 하므로, null을 넣어준다.       위의 단계를 수행하고 treeNode를 반환해준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/flatten-binary-tree-to-linked-list/",
        "teaser": null
      },{
        "title": "Leetcode Java Distinct Subsequences",
        "excerpt":"문제  Link   코드  class Solution {    public int numDistinct(String s, String t) {     int[][] dp = this.initDp(s.length(), t.length());     for (int j = 1; j &lt; t.length() + 1; j++) {       for (int i = 1; i &lt; s.length() + 1; i++) {         dp[i][j] = dp[i - 1][j];         if (s.charAt(i - 1) == t.charAt(j - 1)) {           dp[i][j] += dp[i - 1][j - 1];         }       }     }     return dp[s.length()][t.length()];   }    private int[][] initDp(int row, int col) {     int[][] dp = new int[row + 1][col + 1];     for (int i = 0; i &lt; row + 1; i++) {       dp[i][0] = 1;     }     return dp;   }  }   결과  Link   설명          주어진 문자열 s의 각 문자열을 이용하여 문자열 t를 몇 개 만들수 있는지 경우의 수를 구하는 문제이다.            DP를 s와 t의 길이보다 하나 더 크게 만들어주고, 첫 열을 1로 초기화 해준다.       주어진 문자열 s와 t의 길이만큼 반복하여 dp를 만들어준다.            dp[i][j]에 윗 행의 값인 dp[$i - 1$][j]의 값을 넣어준다.       주어진 문자열 s의 $i - 1$번째 문자와 t의 $j - 1$번째 값이 동일하면 대각선의 위치인 dp[$i - 1$][$j - 1$] 값을 추가해준다.           완성된 DP의 dp[s.length()][t.length()] 값은 주어진 문자열 s를 이용하여 t를 만들 수 있는 경우의 수를 나타내므로, 이 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/distinct-subsequences/",
        "teaser": null
      },{
        "title": "Leetcode Java Populating Next Right Pointers in Each Node",
        "excerpt":"문제  Link   코드  /* // Definition for a Node. class Node {     public int val;     public Node left;     public Node right;     public Node next;      public Node() {}          public Node(int _val) {         val = _val;     }      public Node(int _val, Node _left, Node _right, Node _next) {         val = _val;         left = _left;         right = _right;         next = _next;     } }; */ class Solution {    public Node connect(Node root) {     this.recursive(root, null);     return root;   }    private void recursive(Node curr, Node next) {     if (curr == null) {       return;     }     curr.next = next;     this.recursive(curr.left, curr.right);     this.recursive(curr.right, curr.next == null ? null : curr.next.left);   }  }   결과  Link   설명          주어진 Node인 root를 이용하여 각 node를 이어주는 문제이다.       재귀 호출을 이용하여 주어진 Node인 root의 next가 null인 경우, 다음 Level의 좌측 첫 Node를 넣어 이어준다.            curr이 null인 경우 해당 노드가 존재하지 않으므로, 그만 수행한다.       curr의 next에 next를 넣어 다음 노드로 이동시킨다.       curr의 left Node와 right Node를 재귀 호출을 수행하여 left Node의 next에 right Node가 연결되도록 엮어준다.       curr의 next Node가 null이 아닌 경우, curr.next의 left Node가 curr의 right Node의 next에 연결되도록 엮어준다.       curr의 next Node가 null인 경우, 그대로 next 자리에 null을 넣어 재귀 호출을 수행한다.           재귀 호출이 완료되면 엮어진 Node인 root를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/populating-next-right-pointers-in-each-node/",
        "teaser": null
      },{
        "title": "Leetcode Java Populating Next Right Pointers in Each Node II",
        "excerpt":"문제  Link   코드  /* // Definition for a Node. class Node {     public int val;     public Node left;     public Node right;     public Node next;      public Node() {}          public Node(int _val) {         val = _val;     }      public Node(int _val, Node _left, Node _right, Node _next) {         val = _val;         left = _left;         right = _right;         next = _next;     } }; */ class Solution {    public Node connect(Node root) {     this.recursive(root, null);     return root;   }    private void recursive(Node curr, Node pre) {     if (curr == null) {       return;     }     if (curr.left != null) {       curr.left.next = curr.right;     }     while (curr.next == null &amp;&amp; pre != null &amp;&amp; pre.next != null) {       pre = pre.next;       curr.next = (pre.left != null) ? pre.left : pre.right;     }     this.recursive(curr.right, curr);     this.recursive(curr.left, curr);   }  }   결과  Link   설명     지난번 Populating Next Right Pointers in Each Node 문제와 유사하게, 주어진 Node인 root를 이용하여 각 node를 이어주는 문제이다.            단, 연결하는 중간에 빠진 노드가 존재하므로 해당 노드를 건너 뛰고 연결하여야 한다.           재귀 호출을 이용하여 주어진 Node인 root의 next가 null인 경우, 동일 Level 내에서 다음에 존재하는 Node를 넣어 이어준다.            curr이 null인 경우 해당 노드가 존재하지 않으므로, 그만 수행한다.       curr의 left TreeNode가 null이 아닌 경우 curr TreeNode의 left와 right 자식 노드가 모두 존재한다는 의미이므로, curr.left의 next TreeNode에 curr의 right TreeNode를 넣어준다.       curr의 next TreeNode가 null이고, pre TreeNode가 null이 아니고, pre의 right TreeNode가 null이 아닌 경우 계속 반복문을 통해서 아래를 수행한다.                    pre TreeNode에 pre의 next TreeNode를 넣어준다.           curr의 next TreeNode에 pre의 left가 null이 아니면 pre의 left TreeNode를, 아니면 pre의 right TreeNode를 넣어준다.                       curr의 right TreeNode와 curr을 이용하여 재귀 호출을 수행한다.       curr의 left TreeNode와 curr을 이용하여 재귀 호출을 수행한다.           재귀 호출이 완료되면 엮어진 Node인 root를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/populating-next-right-pointers-in-each-node-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Pascal's Triangle",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     while (result.size() &lt; numRows) {       List&lt;Integer&gt; list = new ArrayList&lt;&gt;();       list.add(1);       if (result.size() &gt; 1) {         List&lt;Integer&gt; pre = result.get(result.size() - 1);         for (int i = 1; i &lt; result.size(); i++) {           list.add(pre.get(i - 1) + pre.get(i));         }       }       if (result.size() &gt; 0) {         list.add(1);       }       result.add(list);     }     return result;   }  }   결과  Link   설명          주어진 정수 numRows 높이의 파스칼의 삼각형을 만드는 문제이다.       결과를 저장하는 result의 크기가 파스칼의 삼각형 목표 높이인 numRows를 만족하지 않을 때까지 반복하여 주어진 정수 numRows 높이의 파스칼의 삼각형을 완성한다.            새 list를 생성하여 처음 값으로 1을 넣어 준다.       결과를 저장하는 result의 크기가 1보다 큰 경우, 아래를 수행한다.                    파스칼의 삼각형의 윗 층을 변수 pre에 넣어준다.           1부터 결과를 저장한 result의 크기만큼 반복하여 변수 pre의 현재 위치의 -1번째 값과 현재 위치의 값의 합을 list에 넣어준다.                       결과를 저장하는 result의 크기가 0이 아닌 경우, list에 1을 넣어 파스칼 삼각형의 한 줄을 완성해준다.       결과를 저장하는 result에 파스칼 삼각형의 한 줄을 만든 list를 넣어준다.           반복문이 완료되면 파스칼의 삼각형을 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/pascals-triangle/",
        "teaser": null
      },{
        "title": "Leetcode Java Pascal's Triangle II",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; getRow(int rowIndex) {     List&lt;Integer&gt; list = new ArrayList&lt;&gt;();     long num = 1;     for (int idx = 0; idx &lt;= rowIndex; idx++) {       list.add((int)num);       num = num * (rowIndex - idx) / (idx + 1);     }     return list;   }  }   결과  Link   설명     기존 Pascal’s Triangle와 동일하게 파스칼의 삼각형에 대한 문제이다.            단, 파스칼의 삼각형에서 주어진 정수 rowIndex번째 행만 만드는 문제이다.           문제 풀이에 필요한 변수를 정의한다.            파스칼의 rowIndex번째 행의 값들을 넣을 list를 생성한다.       파스칼의 삼각형의 값들을 계산하기 위한 지역 변수인 num을 long형으로 정의한다.                    long형으로 정의하는 이유는 아래의 이후 값을 계산하는 로직에서 Overflow가 발생 할 수 있기 때문이다.                       0부터 rowIndex까지 반복하여 파스칼의 삼각형 rowIndex번째 행을 만들어준다.                    list에 int형으로 변환한 num 값을 넣어준다.           num은 $num \\times \\frac{rowIndex - idx}{idx + 1}$ 값으로 넣어준다.                           반복문이 완료되면 파스칼의 삼각형을 저장한 list를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/pascals-triangle-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Triangle",
        "excerpt":"문제  Link   코드  class Solution {    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) {     int[] dp = new int[triangle.size() + 1];     for (int i = triangle.size() - 1; i &gt;= 0; i--) {       List&lt;Integer&gt; row = triangle.get(i);       for (int j = 0; j &lt; row.size(); j++) {         dp[j] = Math.min(dp[j], dp[j + 1]) + row.get(j);       }     }     return dp[0];   }  }   결과  Link   설명     주어진 삼각형의 값들을 저장한 List인 triangle을 이용하여 위에서 아래로 이동하며 만들어진 합이 최소인 값을 찾는 문제이다.            단, 이동 할 때 자신의 위치와 자신의 위치 + 1인 위치로 이동이 가능하다.       예를 들어 아래의 삼각형에서 현재 위치가 2인 경우, 5와 4로만 이동이 가능하다.              1   2 3  5 4 6 8 9 7 10           최소 값을 저장하기 위한 배열 dp를 주어진 triangle의 크기보다 1 크게 정의한다.       반복문을 이용하여 bottom-up으로 최소가 되는 합을 구한다.            반복적인 메모리 소모를 지양하기 위하여 triangle의 i번째 row를 지역 변수로 정의한다.       또 다시 반복문을 이용하여 row의 크기만큼 반복하여 dp의 값을 넣어준다.                    dp[i]에 dp[j]와 dp[$j + 1$]의 값 중 최소 값과 row의 j번째 값의 합을 넣어준다.           bottom-up으로 삼각형의 밑에서 위로 역순으로 탐색을 하므로, 각 값의 최소 값을 역행하여 수행하면 dp[0]에는 가장 최소가 되는 합계만 남아있게 된다.           예를 들어 위의 삼각형으로 예를 들면, 1 -&gt; 2 -&gt; 4 -&gt; 7의 합인 14가 되기 위해서 위의 내용을 반복하여 만들어보면 [13, 11, 13] -&gt; [13, 14] -&gt; [14]가 완성된다.                           반복문이 완료되면 초기화된 dp의 0번째 값을 넣어준다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/triangle/",
        "teaser": null
      },{
        "title": "Leetcode Java Best Time to Buy and Sell Stock",
        "excerpt":"문제  Link   코드  class Solution {    public int maxProfit(int[] prices) {     int min = prices[0];     int max = 0;     for (int idx = 0; idx &lt; prices.length; idx++) {       if (prices[idx] &lt; min) {         min = prices[idx];       }       max = Math.max(max, prices[idx] - min);     }     return max;   }  }   결과  Link   설명     주식에 대한 가격 정보를 담은 배열 prices를 이용하여 이익이 나올 수 있는 구간의 최대 금액을 찾는 문제이다.            단, 이득이 되는 구간이 없는 경우 0을 주어진 문제의 결과로 반환해야 한다.           주어진 문제를 풀기 위한 변수를 정의한다.            변수 min을 주식의 저점(저가 지점)을 저장하기 위해 정의하여 prices의 첫 값으로 초기화 시킨다.       변수 max를 최대 이득이 되는 금액을 저장하기 위해 정의하여 0으로 초기화 시킨다.           반복문을 이용하여 주어진 prices 배열을 순회하여 최대 이득이 되는 금액을 탐색한다.            만일 prices[idx]의 값이 min보다 작은 구간이면, min에 prices[idx] 값을 저장하여 최대 이익을 계속 탐색시킨다.       최대 이익을 저장하는 max에 현재 최대 이익인 max의 값과 $prices[idx] - min$의 값 중 큰 값을 저장하고 반복문을 계속 수행한다.           반복이 완료되면 최대 이익을 저장한 변수 max를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/best-time-to-buy-and-sell-stock/",
        "teaser": null
      },{
        "title": "Leetcode Java Best Time to Buy and Sell Stock II",
        "excerpt":"문제  Link   코드  class Solution {    public int maxProfit(int[] prices) {     int idx = 0;     int sum = 0;     int min = 0;     while (idx &lt; prices.length) {       while (idx &lt; prices.length - 1 &amp;&amp; prices[idx] &gt;= prices[idx + 1]) {         idx++;       }       min = prices[idx++];       while (idx &lt; prices.length - 1 &amp;&amp; prices[idx] &lt;= prices[idx + 1]) {         idx++;       }       sum += prices.length &gt; idx ? prices[idx++] - min : 0;     }     return sum;   }  }   결과  Link   설명          주식에 대한 가격 정보를 담은 배열 prices를 이용하여 이익이 되는 값들의 합이 최대인 결과를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            idx는 이익을 발생시킬 수 있는 최소와 최대 index를 구하기 위한 임시 변수이다.       sum은 각 이익들의 합을 저장하기 위한 변수이다.       min은 이익을 발생시킬 수 있는 최소 index의 값을 임시 저장하기 위한 변수이다.           주어진 배열 prices를 반복하여 최대 이익의 합을 구한다.            반복을 통해 idx가 $prices.length - 1$보다 작고 현재의 값이 다음 값보다 크거나 같을 경우, idx를 증가시킨다.       위에서 증가된 idx의 위치는 최소한의 이익 실현이 가능한 시작 위치이므로, min에 prices[idx] 값을 저장하고 idx를 증가시킨다.       반복을 통해 idx가 $prices.length - 1$보다 작고 현재의 값이 다음 값보다 작거나 같을 경우, idx를 증가시킨다.       위에서 증가된 idx의 위치는 이익 실현이 가능한 위치이거나 prices의 크기를 벗어난 경우이므로, prices의 길이보다 idx가 작으면 sum에 $prices[idx] - min$을 더한다.           반복이 완료되면 최대 이익의 합을 저장한 변수 sum을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/best-time-to-buy-and-sell-stock-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Best Time to Buy and Sell Stock III",
        "excerpt":"문제  Link   코드  class Solution {    public int maxProfit(int[] prices) {     int[] buy = new int[] { Integer.MAX_VALUE, Integer.MAX_VALUE };     int[] sell = new int[2];     for (int price : prices) {       buy[0] = Math.min(buy[0], price);       sell[0] = Math.max(sell[0], price - buy[0]);       buy[1] = Math.min(buy[1], price - sell[0]);       sell[1] = Math.max(sell[1], price - buy[1]);     }     return sell[1];   }  }   결과  Link   설명          주식에 대한 가격 정보를 담은 배열 prices를 이용하여 이익이 되는 값들 중 두 값의 합이 최대인 값을 구하는 문제이다.            두 값의 합이 최대인 값을 구해야 하므로, 구매와 판매 가격을 저장할 buy와 sell을 크기 2의 정수 배열로 정의한다.       주어진 배열 prices를 반복하여 두 값의 합이 최대인 구간을 찾는다.            첫 번째 구매 가격인 buy[0]는 buy[0]와 price 중 최소값으로 넣어준다.       첫 번째 판매 이익인 sell[0]는 sell[0]와 $price - buy[0]$ 중 최대값으로 넣어준다.       두 번째 구매 가격인 buy[1]은 buy[1]과 $price - sell[0]$ 중 최소값으로 넣어준다.       두 번째 판매 이익인 sell[1]은 sell[1]과 $price - buy[1]$ 중 최대값으로 넣어준다.                    두 번째 거래의 경우, 첫 번째 거래의 판매 이익을 두 번째 구매 비용에 통합하여 두 번째 판매 이익이 결국 두 판매 이익을 합친 결과가 되는 것이다.                           반복이 완료되면 두 판매 이익을 저장한 sell[1]을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/best-time-to-buy-and-sell-stock-iii/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Tree Maximum Path Sum",
        "excerpt":"문제  Link   코드  class Solution {    private int max = Integer.MIN_VALUE;    public int maxPathSum(TreeNode root) {     this.recursive(root);     return max;   }    private int recursive(TreeNode node) {     if (node == null) {       return 0;     }     int left = Math.max(0, this.recursive(node.left));     int right = Math.max(0, this.recursive(node.right));     max = Math.max(max, node.val + left + right);     return node.val + Math.max(left, right);   }  }   결과  Link   설명          주어진 TreeNode인 root를 이용하여 경로 합이 가장 큰 값을 탐색하는 문제이다.            bottom-up으로 max값을 찾기 위해서 전역 변수 max을 정의하고, int의 최소값인 Integer.MIN_VALUE로 초기화 한다.       재귀 호출을 이용하여 경로합이 가장 큰 값을 max에 넣어준다.            node가 null인 경우 해당 노드가 존재하지 않으므로 0을 반환한다.       node의 left를 재귀 호출을 수행한 값과 0 중 큰 값을 변수 left에 저장한다.       node의 right를 재귀 호출을 수행한 값과 0 중 큰 값을 변수 left에 저장한다.       전역 변수 max와 $node.val + left + rgiht$의 값 중 큰 값을 max에 저장한다.       위의 두 변수인 left와 right 값에 사용하기 위한 node.val와 left와 right 중 큰 값의 합을 반환한다.           재귀 호출이 완료되면 전역 변수인 max를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-tree-maximum-path-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Valid Palindrome",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isPalindrome(String s) {     char[] charArr = s.toCharArray();     for (int i = 0, j = charArr.length - 1; i &lt; j;) {       if (!Character.isLetterOrDigit(charArr[i])) {         i++;       } else if (!Character.isLetterOrDigit(charArr[j])) {         j--;       } else if (Character.toLowerCase(charArr[i++]) != Character.toLowerCase(charArr[j--])) {         return false;       }     }     return true;   }  }   결과  Link   설명          주어진 문자열 s가 영숫자 문자열만 포함하여 앞뒤로 읽어도 같은 문자열(이하 회문)이 되는지를 검증하는 문제이다.            주어진 문자열 s를 문자의 배열로 변환하여 변수 charArr를 정의한다.       반복을 통해서 i는 처음부터, j는 뒤에서부터 i가 j보다 작을 때 까지 반복한다.            만일 charArr[i]가 문자나 숫자가 아닌 경우 무시해야 하므로, i를 증가시킨다.       만일 charArr[j]가 문자나 숫자가 아닌 경우 무시해야 하므로, j를 감소시킨다.       그 외의 경우 charArr[i]와 charArr[j]가 같지 않으면 회문이 되지 못하므로, false를 주어진 문제의 결과로 반환한다.           반복이 완료되면 해당 문자열이 회문이므로, true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/valid-palindrome/",
        "teaser": null
      },{
        "title": "Leetcode Java Word Ladder",
        "excerpt":"문제  Link   코드  class Solution {    public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) {     if (!wordList.contains(endWord)) {       return 0;     }     Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordList);     Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();     queue.add(beginWord);     int length = 1;     while (!queue.isEmpty()) {       int queueSize = queue.size();       for (int i = 0; i &lt; queueSize; i++) {         char[] wordCharArr = queue.poll().toCharArray();         for (int j = 0; j &lt; wordCharArr.length; j++) {           char temp = wordCharArr[j];           for (char chr = 'a'; chr &lt;= 'z'; chr++) {             wordCharArr[j] = chr;             String dest = new String(wordCharArr);             if (wordSet.contains(dest)) {               if (dest.equals(endWord)) {                 return length + 1;               }               queue.add(dest);               wordSet.remove(dest);             }           }           wordCharArr[j] = temp;         }       }       length++;     }     return 0;   }  }   결과  Link   설명          주어진 문자열 beginWord를 endWord로 변환하기 위한 가장 짧은 순서를 배열 wordList에서 찾아서 변환 횟수를 구하는 문제이다.            wordList에 endWord가 존재하지 않으면, 변환이 불가능하므로 0을 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수들을 정의한다.            wordSet은 주어진 List인 wordList의 동적으로 확인하여 제거하기 위해 변환하여 정의한다.       queue는 변환되는 단어를 임시 저장하기 위해 LinkedList로 정의하고, 변환하기 위한 처음 단어로 beginWord를 넣어 초기화한다.       length는 변환 횟수를 저장하기 위한 변수로 1로 초기화한다.           변환 시킬 단어를 저장한 queue가 비어있지 않을 때 까지 반복하여 변환 횟수를 계산한다.            queue는 단어를 임시 저장시키는 용도로, 변동이 가능하므로 queue에 담긴 단어의 개수를 임시로 queueSize 변수에 넣어 저장한다.       queueSize만큼 반복하여 변환 횟수를 계산한다.                queue에 담긴 단어를 꺼내와 문자의 배열로 정의하고, 해당 단어의 길이만큼 반복을 수행한다.       wordCharArr[j]의 값을 temp 변수에 넣고, a부터 z까지 반복하여 wordCharArr[j]에 넣어 wordSet에 해당 단어가 존재하는지 확인한다.            변환된 값이 endWord와 같다면 해당 변환에서 endWord로 변환이 완료 된 것이므로, 변환 횟수를 저장한 length에 1을 더하여 주어진 문제의 결과로 반환한다.       변환된 값이 존재하는 경우, queue에 해당 단어를 넣고, wordSet에 해당 단어를 제거한다.                반복이 완료되면 wordCharArr[j]에 다시 temp를 넣어준다.            queueSize만큼 반복이 완료되면 length를 증가시켜 변환 횟수를 증가시킨다.       위의 절차들이 완료되면 변환이 불가능하므로, 0을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/word-ladder/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Consecutive Sequence",
        "excerpt":"문제  Link   코드  class Solution {    public int longestConsecutive(int[] nums) {     if (nums.length == 0) {       return 0;     }     Arrays.sort(nums);     int curr = nums[0];     int sum = 1;     int count = 1;     for (int i = 1; i &lt; nums.length; i++) {       if (nums[i - 1] == nums[i]) {         continue;       } else if (nums[i] == curr + 1) {         curr++;         sum++;         count = Math.max(count, sum);       } else {         curr = nums[i];         sum = 1;       }     }     return count;   }  }   결과  Link   설명          주어진 숫자 배열 nums의 값들을 이용하여 가장 많이 연속된 숫자의 개수를 계산하는 문제이다.            배열 nums가 비어있을 경우, 주어진 문제의 결과로 0을 반환한다.            연속된 숫자들을 효율적으로 확인하기 위해서 배열을 정렬해준다.       문제 풀이에 필요한 변수를 정의한다.            curr은 주어진 배열 nums의 값을 하나씩 가져와 저장할 임시 변수로, nums[0]으로 초기화 한다.       sum은 연속된 숫자의 합을 저장할 변수로, 1로 초기화 한다.       count는 연속된 숫자의 개수가 최대인 값을 저장하는 변수로, 1로 초기화 한다.           주어진 배열 nums를 반복하여 연속된 숫자가 최대인 개수를 계산한다.            nums[$i - 1$]의 값과 nums[i]의 값이 동일하면, 반복 계속 진행한다.       nums[i]의 값이 $curr + 1$이면 curr과 sum을 증가시키고, sum과 count 중 큰 값을 count에 넣어준다.       그 외의 경우 연속된 숫자가 아니므로, curr에 nums[i]를 넣고 sum을 1로 초기화 한다.           반복이 완료되면 연속된 숫자의 개수가 최대인 값을 저장한 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-consecutive-sequence/",
        "teaser": null
      },{
        "title": "Leetcode Java Sum Root to Leaf Numbers",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public int sumNumbers(TreeNode root) {     return this.recursive(root, 0);   }    private int recursive(TreeNode node, int sum) {     if (node == null) {       return 0;     } else if (node.left == null &amp;&amp; node.right == null) {       return sum * 10 + node.val;     } else {       return this.recursive(node.left, sum * 10 + node.val) + this.recursive(node.right, sum * 10 + node.val);     }   }  }   결과  Link   설명     주어진 TreeNode인 root를 이용하여 마지막 node까지 이동하며 val 값을 순차적으로 이어준 결과들을 합친 값을 구하는 문제이다.            아래의 예제를 보면, 1 -&gt; 2, 1 -&gt; 3으로 되어, 12 + 13인 25가 문제의 결과가 된다.          1 2 3                           재귀 호출을 이용하여 root 노드에서 부터 최종 합을 구하여 문제의 결과로 반환한다.            node가 null인 경우, 마지막 노드이므로 해당 val 값은 0으로 반환한다.       node의 left와 right가 null인 경우, 기존 더해진 sum에 10을 곱하고, node의 val 값을 더하여 반환한다.       그 외의 경우 node의 left와 right를 재귀 호출한 값의 합을 반환한다.       최종 재귀 호출을 수행하여 순차적으로 이어준 값의 합을 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sum-root-to-leaf-numbers/",
        "teaser": null
      },{
        "title": "Leetcode Java Surrounded Regions",
        "excerpt":"문제  Link   코드  class Solution {    public void solve(char[][] board) {     for (int i = 0; i &lt; board.length; i++) {       if (board[i][0] == 'O') {         this.dfs(i, 1, board);       }       if (board[i][board[0].length - 1] == 'O') {         this.dfs(i, board[0].length - 2, board);       }     }     for (int i = 0; i &lt; board[0].length; i++) {       if (board[0][i] == 'O') {         this.dfs(1, i, board);       }       if (board[board.length - 1][i] == 'O') {         this.dfs(board.length - 2, i, board);       }     }     for (int i = 1; i &lt; board.length - 1; i++) {       for (int j = 1; j &lt; board[0].length - 1; j++) {         if (board[i][j] == 'o') {           board[i][j] = 'O';         } else if (board[i][j] == 'O') {           board[i][j] = 'X';         }       }     }   }    private void dfs(int i, int j, char[][] board) {     if (i == 0 || j == 0 || i == board.length - 1 || j == board[0].length - 1 || board[i][j] == 'X' || board[i][j] == 'o') {       return;     }     if (board[i][j] == 'O') {       board[i][j] = 'o';     }     this.dfs(i + 1, j, board);     this.dfs(i - 1, j, board);     this.dfs(i, j + 1, board);     this.dfs(i, j - 1, board);   }  }   결과  Link   설명          주어진 ‘O’와 ‘X’의 값들로 차있는 2차원 배열 board를 이용하여 4방향이 ‘X’로 이루어진 ‘O’만 남기고 나머지를 ‘X’로 바꾸는 문제이다.            0부터 행의 개수만큼 반복하여 외각의 값인 board[i][0]과 board[i][$board[0].legnth - 1$]의 값이 ‘O’인지 검증하여 그 옆의 값 위주로 검증하여 주변이 ‘X’인 ‘O’만 ‘o’로 변경하여 대상을 표시한다.            0부터 열의 개수만큼 반복하여 외각의 값인 board[0][i]]과 board[$board.legnth - 1$][i]의 값이 ‘O’인지 검증하여 그 옆의 값 위주로 검증하여 주변이 ‘X’인 ‘O’만 ‘o’로 변경하여 대상을 표시한다.            외각을 제외한 모든 행과 열을 반복하여 수정된 board를 이용하여 ‘o’인 값만 ‘O’로 변경해주고, 나머지는 ‘X’로 전부 바꾸어주어 문제를 해결한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/surrounded-regions/",
        "teaser": null
      },{
        "title": "Leetcode Java Palindrome Partitioning",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;String&gt;&gt; partition(String s) {     List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();     this.recursive(s, 0, result, new ArrayList&lt;&gt;());     return result;   }    private void recursive(String s, int index, List&lt;List&lt;String&gt;&gt; result, List&lt;String&gt; temp) {     if (index == s.length()) {       result.add(new ArrayList&lt;&gt;(temp));     } else {       for (int i = index; i &lt; s.length(); i++) {         if (this.isPalindrome(s, index, i)) {           temp.add(s.substring(index, i + 1));           this.recursive(s, i + 1, result, temp);           temp.remove(temp.size() - 1);         }       }     }   }    private boolean isPalindrome(String s, int start, int end) {     while (start &lt; end) {       if (s.charAt(start++) != s.charAt(end--)) {         return false;       }     }     return true;   }  }   결과  Link   설명          주어진 문자열 s를 이용하여 앞뒤로 읽어도 같은 문자열(이하 회문)을 모두 찾는 문제이다.            재귀 호출을 이용하여 List인 result에 회문의 조합을 확인하여 넣어준다.            index가 s.length()와 동일한 경우 마지막 문자열까지 탐색한 경우이므로, result에 회문을 저장한 temp를 새 객체로 생성하여 넣어준다.       그 외의 경우 index부터 s.length()까지 반복하여 문자열 s의 index부터 i까지의 부분 문자열이 회문인 경우 아래를 수행한다.            반복을 통한 회문을 저장하는 변수 temp에 해당 문자열을 넣어준다.       index를 $i + 1$로 변경하고 재귀 호출을 수행하여 문자열 s의 회문을 탐색한다.       위의 재귀 호출이 완료되면 해당 문자열 중 마지막 입력된 문자열을 제거하고 다시 반복문을 수행한다.           재귀 호출이 완료되면 주어진 문자열 s의 회문 조합을 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/palindrome-partitioning/",
        "teaser": null
      },{
        "title": "Leetcode Java Palindrome Partitioning II",
        "excerpt":"문제  Link   코드  class Solution {    public int minCut(String s) {     boolean dp[][] = new boolean[s.length() + 1][s.length() + 1];     int min[] = new int[s.length()];     for (int i = 0; i &lt; s.length(); i++) {       min[i] = i;       for (int j = 0; j &lt;= i; j++) {         if (s.charAt(i) == s.charAt(j) &amp;&amp; (j + 1 &gt; i - 1 || dp[j + 1][i - 1])) {           dp[j][i] = true;           min[i] = j == 0 ? 0 : Math.min(min[i], min[j - 1] + 1);         }       }     }     return min[s.length() - 1];   }  }   결과  Link   설명          이전의 Palindrome Partitioning과 유사한 문제로, 주어진 문자열 s를 앞뒤로 읽어도 같은 문자열(이하 회문)의 조합으로 자르기 위한 최소 횟수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            DP를 저장할 dp를 2차원 boolean 배열의 $s.legnth() + 1 \\times s.length() + 1$ 크기로 정의한다.       최소 횟수를 저장할 정수 배열인 min을 s.length() 크기로 정의한다.           문자열 s의 처음부터 길이만큼 반복하여 회문의 조합으로 자르기 위한 최소 횟수를 구한다.            min[i]에 i값을 기본값 으로 넣어준다.           다시 문자열 s의 처음부터 i까지 반복하여준다.            문자열 s의 i번째 문자와 j번째 문자가 동일하고, $j + 1$이 $i - 1$보다 크거나 dp[$j + 1$][$i - 1$]의 값이 true 일 경우 아래를 수행한다.                    dp[j][i]에 true를 넣어준다.           min[i]에 j가 0일 경우 0을, 그렇지 않은 경우 min[i]와 min[j - 1] + 1 중 작은 값을 넣어준다.                           반복이 완료되면 회문의 조합으로 자르기 위한 최소 횟수를 저장한 배열 min의 마지막 값인 min[$s.length() - 1$]을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/palindrome-partitioning-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Clone Graph",
        "excerpt":"문제  Link   코드  /* // Definition for a Node. class Node {     public int val;     public List&lt;Node&gt; neighbors;     public Node() {         val = 0;         neighbors = new ArrayList&lt;Node&gt;();     }     public Node(int _val) {         val = _val;         neighbors = new ArrayList&lt;Node&gt;();     }     public Node(int _val, ArrayList&lt;Node&gt; _neighbors) {         val = _val;         neighbors = _neighbors;     } } */ class Solution {    public Node cloneGraph(Node node) {     Map&lt;Integer, Node&gt; map = new HashMap&lt;Integer, Node&gt;();     return this.recursive(node, map);   }    private Node recursive(Node node, Map&lt;Integer, Node&gt; map) {     if (node == null) {       return null;     } else if (map.containsKey(node.val)) {       return map.get(node.val);     } else {       Node temp = new Node(node.val);       map.put(temp.val, temp);       for (Node neighbor : node.neighbors) {         temp.neighbors.add(this.recursive(neighbor, map));       }       return temp;     }   }  }   결과  Link   설명          주어진 Node인 node를 이용하여 동일한 Node를 만드는 문제이다.            Node를 node.val 기준으로 임시 저장하기 위한 Map을 정의한다.            재귀 호출을 수행하여 동일한 Node를 만들어 주어진 문제의 결과로 반환한다.             node가 null인 경우 주어진 Node가 null인 경우이므로, 그대로 null을 반환한다.       map에 node.val가 존재하는 경우 기존에 만들었던 Node가 존재한다는 의미이므로, map에서 해당 Node를 꺼내서 반환한다.       그 외의 경우 map에 존재하지 않는 Node이므로, node.val 값을 이용하여 새 Node를 만든 후 map에 임시 저장하고 재귀 호출을 이용하여 Neighbors를 찾아 추가하고 새 노드인 temp를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/clone-graph/",
        "teaser": null
      },{
        "title": "Leetcode Java Gas Station",
        "excerpt":"문제  Link   코드  class Solution {    public int canCompleteCircuit(int[] gas, int[] cost) {     int fill = 0;     int use = 0;     int tank = 0;     int start = 0;     for (int idx = 0; idx &lt; gas.length; idx++) {       fill += gas[idx];       use += cost[idx];       tank += gas[idx] - cost[idx];       if (tank &lt; 0) {         tank = 0;         start = idx + 1;       }     }     return fill &lt; use ? -1 : start;   }  }   결과  Link   설명     주어진 정수 배열 gas는 해당 위치에서 주유할 수 있는 양이고, cost는 해당 위치까지 이동하기 위해 사용되는 가스의 양을 의미하여 한 바퀴 순회하기 위한 시작 index를 찾는 문제이다.            단, 한 바퀴 순회가 불가능하다면 -1을 주어진 문제의 결과로 반환해야 한다.       또한 모든 문제에는 유일한 결과만 존재한다.           주어진 문제를 풀기 위한 변수를 정의한다.            fill은 주유소에 도달하여 채우는 gas의 합을 저장한다.       use는 다음 주유소까지 이동하기 위해 사용되는 cost의 합을 저장한다.       tank는 자동차에 남은 가스의 양을 나타낸다.       start는 한 바퀴 순회하기 위한 시작 index를 저장한다.           주어진 배열 gas 혹은 cost의 길이만큼 반복하여 각 변수에 해당하는 값들을 저장한다.            주유소에서 채우는 양을 저장하는 변수 fill에 idx번째 gas를 누계한다.       이동하기 위해 사용되는 변수 use에 idx번째 cost를 누계한다.       자동차에 남은 가스의 양을 나타내는 변수 tank에 idx번째 gas와 idx번째 cost의 차이를 누계한다.       tank가 0 미만으로 내려간 경우 idx번째 위치까지 이동이 불가능하므로, 시작 위치를 저장하는 변수 start를 다음 위치인 $idx + 1$로 바꾸어주고 tank는 0으로 초기화 시킨다.           반복이 완료되면 주유한 양을 저장한 fill과 사용한 양을 저장한 use을 비교하여 주어진 문제여 결과를 반환한다.            변수 fill보다 use가 더 큰 경우 순회가 불가능하므로, -1을 주어진 문제의 결과로 반환한다.       변수 fill보다 use가 작거나 같은 경우 순회가 가능하므로, 시작 위치를 저장한 start를 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/gas-station/",
        "teaser": null
      },{
        "title": "Leetcode Java Candy",
        "excerpt":"문제  Link   코드  class Solution {    public int candy(int[] ratings) {     int[] candies = new int[ratings.length];     Arrays.fill(candies, 1);     for (int idx = 1; idx &lt; candies.length; idx++) {       if (ratings[idx - 1] &lt; ratings[idx]) {         candies[idx] = candies[idx - 1] + 1;       }     }     for (int idx = candies.length - 2; idx &gt;= 0; idx--) {       if (ratings[idx] &gt; ratings[idx + 1]) {         candies[idx] = Math.max(candies[idx], candies[idx + 1] + 1);       }     }     int sum = 0;     for (int candy : candies) {       sum += candy;     }     return sum;   }  }   결과  Link   설명     주어진 아이들의 점수를 저장한 정수 배열 ratings를 이용하여, 아래의 요구 사항에 맞춰 사탕을 아이들에게 분배하기 위한 최소 개수를 구하는 문제이다.            각 어린이는 최소 한 개 이상의 캔디를 받는다.       주변 아이들보다 점수가 높은 아이는 더 많은 캔디를 받는다.                아이들에게 분배하는 캔디 개수를 저장하기 위한 정수 배열 candies를 ratings의 크기와 동일하게 만들고, 최소 분배 개수인 1을 배열의 모든 자리에 넣어준다.            좌측에서 우측으로 탐색하여 우측에 있는 아이가 점수가 높은 경우, 좌측에 있는 아이가 받는 캔디 개수보다 하나 더 받게 한다.            우측에서 좌측으로 다시 탐색하여 좌측에 있는 아이가 점수가 높은 경우, 좌측에 있는 아이가 받는 캔디의 개수와 우측에 있는 아이가 받는 캔디의 개수에 하나를 더한 값 중 큰 개수를 받게 한다.       아이들이 받는 캔디의 개수를 저장한 candies를 변수 sum에 누계하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/candy/",
        "teaser": null
      },{
        "title": "Leetcode Java Single Number",
        "excerpt":"문제  Link   코드  class Solution {    public int singleNumber(int[] nums) {     int result = 0;     for (int num : nums) {       result ^= num;     }     return result;   }  }   결과  Link   설명          주어진 정수 배열 nums에서 하나만 포함된 숫자를 탐색하는 문제이다.            결과를 저장할 정수 result를 정의한다.       반복문을 통해 배타적 논리합(XOR)를 수행하여 결과를 result에 넣어준다.            배타적 논리합은 짝수번 수행할 경우, 0이 되므로 홀수번 수행한 결과만 남게 된다.       2개씩 들어간 숫자들은 위의 경우로 0이 되고, 1개만 들어가 있는 목표 숫자만 남는 것이다.           하나만 포함된 숫자를 넣은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/single-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Copy List with Random Pointer",
        "excerpt":"문제  Link   코드  class Solution {    public Node copyRandomList(Node head) {     return this.recursive(head, new HashMap&lt;&gt;());   }    private Node recursive(Node node, Map&lt;Node, Node&gt; map) {     if (node == null) {       return null;     } else if (map.containsKey(node)) {       return map.get(node);     } else {       Node temp = new Node(node.val);       map.put(node, temp);       temp.next = this.recursive(node.next, map);       temp.random = this.recursive(node.random, map);       return temp;     }   }  }   결과  Link   설명     주어진 임의 포인터와 다음 Node를 이어주는 연결된 Node인 head를 이용하여 동일한 형태로 새롭게 구성된 연결된 Node를 만드는 문제이다.            임의 포인터와 Node들은 주어진 Node인 head와 연결된 모든 Node들과 연관되어서는 안된다.           재귀 호출을 이용하여 주어진 Node인 head를 Map을 새로 정의하여 동일한 형태로 새롭게 구성된 연결된 Node를 만들어 주어진 문제의 결과로 반환한다.            head가 null인 경우 해당 Node가 존재하지 않는다는 의미이므로, null을 반환한다.       map에 node가 존재하는 경우 이전에 해당 값에 해당하는 Node를 만나서 새로운 Node로 만들어 map에 저장된 경우이므로, map에서 node를 꺼내 반환한다.       그 외의 경우 새로운 Node를 만들어야 하므로, node를 이용하여 새로운 Node인 temp를 만들어 map에 넣어주고 temp.next와 temp.random의 Node는 재귀 호출을 이용하여 Node를 연결시켜주고 temp를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/copy-list-with-random-pointer/",
        "teaser": null
      },{
        "title": "Leetcode Java Word Break",
        "excerpt":"문제  Link   코드  class Solution {    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {     boolean[] dp = new boolean[s.length() + 1];     Set&lt;String&gt; wordSet = new HashSet&lt;&gt;();     wordSet.addAll(wordDict);     dp[0] = true;     for (int i = 1; i &lt;= s.length(); i++) {       for (int j = i - 1; j &gt;= 0; j--) {         dp[i] = dp[j] &amp;&amp; wordSet.contains(s.substring(j, i));         if (dp[i]) {           break;         }       }     }     return dp[s.length()];   }  }   결과  Link   설명          주어진 문자열 s에 문자열의 List인 wordDict의 문자열들이 포함되는지 검증하는 문제이다.       문제를 풀기 위해 변수를 정의한다.            dp는 문자열 길이보다 하나 크게 정의하여 문자열 포함에 대한 검증에 활용하며, 0번째 값을 true로 초기화한다.       wordSet은 주어진 문자열의 List를 중복을 제거하여 사용하기 위해 wordDict의 값들을 넣어 초기화 한다.           문자열을 차례대로 반복하여 wordSet에 포함된 단어가 있는지 검증한다.            dp[i]에 dp[j]의 결과와 wordSet에 문자열 s의 j번째부터 i번째까지 자른 값이 존재하는지 결과를 AND(논리곱) 결과를 넣어준다.       만일 dp[i]가 true인 경우 i를 증가시켜 다음 문자열부터 다시 검증한다.           반복이 완료되면 문자열이 포함되는지 검증한 결과인 dp[s.length()]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/word-break/",
        "teaser": null
      },{
        "title": "Leetcode Java Word Break II",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) {     return this.recursive(s, wordDict, new HashMap&lt;&gt;());   }    private List&lt;String&gt; recursive(String s, List&lt;String&gt; wordDict, Map&lt;String, List&lt;String&gt;&gt; map) {     if (map.containsKey(s)) {       return map.get(s);     } else {       List&lt;String&gt; result = new ArrayList&lt;&gt;();       for (String word : wordDict) {         if (s.startsWith(word)) {           String temp = s.substring(word.length());           if (temp.length() == 0) {             result.add(word);           } else {             for (String sub : this.recursive(temp, wordDict, map)) {               result.add(String.join(\" \", word, sub));             }           }         }       }       map.put(s, result);       return result;     }   }  }   결과  Link   설명          주어진 List wordDict를 이용하여 문자열 s를 만들 수 있는 모든 경우의 수를 찾는 문제이다.            재귀 호출을 이용하여 map에 문자열을 저장하고, wordDict를 이용하여 문자열 s를 만들 수 있는 모든 경우의 수를 찾아 주어진 문제의 결과로 반환한다.             문제의 결과를 저장하기 위한 변수 result를 정의한다.       map에 문자열 s가 존재하는 경우 저장한 문자열을 가져와 반환한다.       map에 문자열 s가 존재하지 않는 경우 wordDict를 반복하여 아래의 문자열 검증을 수행한다.                    문자열 s가 word로 시작되는 경우, 해당 문자열을 잘라 temp를 정의한다.           temp의 길이가 0인 경우 result에 추가한다.           temp의 길이가 0이 아닌 경우, 재귀 호출을 이용하여 문자열을 조합하여 result에 추가한다.                       map에 결과를 저장하여 문자열을 임시 보관하고 결과를 저장한 result를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/word-break-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Linked List Cycle",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * class ListNode {  *     int val;  *     ListNode next;  *     ListNode(int x) {  *         val = x;  *         next = null;  *     }  * }  */ class Solution {    public boolean hasCycle(ListNode head) {     if (head == null) {       return false;     }     ListNode fast = head;     ListNode slow = head;     while (fast.next != null &amp;&amp; fast.next.next != null) {       fast = fast.next.next;       slow = slow.next;       if (fast == slow) {         return true;       }     }     return false;   }  }   결과  Link   설명          주어진 ListNode head가 순회하는 포인트가 존재하는지를 검증하는 문제이다.            head가 null인 경우 순회가 불가능하므로, false를 주어진 문제의 결과로 반환한다.            검증을 위해 fast와 slow를 head를 주입하여 정의한다.       fast.next와 fast.next.next가 null이 아닐 때 까지 반복하여 검증을 수행한다.            fast에 fast.next.next 값을 주입하여 다다음 ListNode로 이동한다.       slow에 slow.next 값을 주입하여 다음 ListNode로 이동한다.       fast와 slow가 동일하면 순회가 되는 포인트가 있는 경우이므로, true를 주어진 문제의 결과로 반환한다.           반복이 종료되면 null이 되는 순간이 존재한다는 의미이므로, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/linked-list-cycle/",
        "teaser": null
      },{
        "title": "Leetcode Java Linked List Cycle II",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * class ListNode {  *     int val;  *     ListNode next;  *     ListNode(int x) {  *         val = x;  *         next = null;  *     }  * }  */ class Solution {    public boolean hasCycle(ListNode head) {     if (head == null) {       return null;     }     ListNode fast = head;     ListNode slow = head;     while (fast != null &amp;&amp; fast.next != null) {       fast = fast.next.next;       slow = slow.next;       if (fast == slow) {         ListNode search = head;         while (slow != search) {           slow = slow.next;           search = search.next;         }         return search;       }     }     return null;   }  }   결과  Link   설명          주어진 ListNode head가 순회의 시작점인 ListNode를 찾는 문제이다.            head가 null인 경우 순회가 불가능하므로, null을 주어진 문제의 결과로 반환한다.            검증을 위해 fast와 slow를 head를 주입하여 정의한다.       fast와 fast.next가 null이 아닐 때 까지 반복하여 검증을 수행한다.            fast에 fast.next.next 값을 주입하여 다다음 ListNode로 이동한다.       slow에 slow.next 값을 주입하여 다음 ListNode로 이동한다.       fast와 slow가 동일하면 순회가 되는 포인트가 있는 경우이므로, 순회의 시작점을 탐색한다.                    search 변수를 임시 정의하여 주어진 ListNode인 head를 주입한다.           slow와 search가 동일한 결과가 나올 때 까지 slow와 search를 각각 다음 ListNode로 이동시킨다.           반복이 완료되면 순회의 시작점인 search를 주어진 문제의 결과로 반환한다.                           모든 반복이 완료되고 결과가 나오지 않는 경우 순회가 되지 않는다는 의미이므로, null을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/linked-list-cycle-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Reorder List",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public void reorderList(ListNode head) {     if (head == null || head.next == null) {       return;     }     ListNode node = this.reverseHalfAfterMiddleListNodes(head);     ListNode temp1 = head;     ListNode temp2 = node.next;     while (temp1 != node) {       node.next = temp2.next;       temp2.next = temp1.next;       temp1.next = temp2;       temp1 = temp2.next;       temp2 = node.next;     }   }    private ListNode reverseHalfAfterMiddleListNodes(ListNode node) {     ListNode mid = this.findMiddleListNode(node);     ListNode cur = mid.next;     while (cur.next != null) {       ListNode temp = cur.next;       cur.next = temp.next;       temp.next = mid.next;       mid.next = temp;     }     return mid;   }    private ListNode findMiddleListNode(ListNode node) {     ListNode fast = node;     ListNode slow = node;     while (fast.next != null &amp;&amp; fast.next.next != null) {       fast = fast.next.next;       slow = slow.next;     }     return slow;   }  }   결과  Link   설명     주어진 ListNode인 head를 아래의 순서대로 재 정렬하는 문제이다.            node[0] -&gt; node[last] -&gt; node[1] -&gt; node[last] -&gt; … -&gt; node[$n - 2$] -&gt; node[last]       node[last]는 각 노드 수행에 있어 마지막에 위치한 노드의 값이다.       Ex) 1, 2, 3, 4, 5 -&gt; 1, 5, 2, 3, 4 -&gt; 1, 5, 2, 4, 3           주어진 ListNode인 head의 중간 위치를 탐색한다.            문제 풀이에 필요한 변수를 정의한다.                    fast는 slow보다 끝을 먼저 탐색하기 위해 이동하는 임시 ListNode로, head를 주입해준다.           slow는 fast ListNode 기준으로 중간 ListNode에 위치하는 ListNode로, head를 주입해준다.                       fast.next와 fast.next.next가 null이 아닐 때 까지 fast는 2칸, slow는 1칸 이동하여 slow를 head의 중간 ListNode로 이동시켜준다.           2번에서 탐색한 주어진 ListNode인 head의 중간 ListNode를 이용하여 중간 이후의 ListNode들의 순서를 반전시켜준다.            문제 풀이에 필요한 변수를 정의한다.                    mid는 2번에서 탐색한 head의 중간 ListNode의 값을 넣어준다.           cur은 반전시키기 위한 mid의 다음 ListNode를 저장하는 ListNode로, mid.next로 값을 넣어준다.                       cur.next가 null이 아닐 때 까지 반복하여 mid와 cur의 next값을 바꾸어, mid의 모든 ListNode의 순서를 반전시켜준다.           3번에서 반전시킨 node를 가져와서 1번에서 설명한 순서대로 재 정렬을 수행한다.            문제 풀이에 필요한 변수를 정의한다.                    node는 3번에서 head의 중간 이후 ListNode를 반전시킨 노드를 넣어준다.           temp1은 재 정렬을 수행하기 위한 임시 변수로, head를 넣어준다.           temp2 또한 재 정렬을 수행하기 위한 임시 변수로, node의 next ListNode를 넣어준다.                       temp1이 node와 같지 않을 때 까지 각 변수들의 값을 바꾸어주며 1번에서 설명한 순서대로 정렬을 수행한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reorder-list/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Tree Preorder Traversal",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {     return this.recursive(root, new ArrayList&lt;&gt;());   }    private List&lt;Integer&gt; recursive(TreeNode treeNode, List&lt;Integer&gt; list) {     if (treeNode != null) {       list.add(treeNode.val);       this.recursive(treeNode.left, list);       this.recursive(treeNode.right, list);     }     return list;   }  }   결과  Link   설명     preorder 순으로 주어진 TreeNode인 root의 하위 ListNode val 값을 List에 넣는 문제이다.            preorder는 root -&gt; left -&gt; right 순이다.           재귀 호출을 이용하여 List에 preorder 순으로 val 값들을 넣어 주어진 문제의 결과로 반환한다.            treeNode가 null이 아닌 경우 존재하는 TreeNode이므로 아래를 수행한다.                    list에 treeNode.val 값을 넣어준다.           treeNode.left를 재귀 호출 수행하여 treeNode의 left TreeNode 하위 val 값을 list에 넣어준다.           treeNode.right를 재귀 호출 수행하여 treeNode의 right TreeNode 하위 val 값을 list에 넣어준다.                       list를 반환하여 계속 list에 TreeNode의 val 값을 preorder 순으로 넣어준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-tree-preorder-traversal/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Tree Postorder Traversal",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {     return this.recursive(root, new ArrayList&lt;&gt;());   }    private List&lt;Integer&gt; recursive(TreeNode treeNode, List&lt;Integer&gt; list) {     if (treeNode != null) {       this.recursive(treeNode.left, list);       this.recursive(treeNode.right, list);       list.add(treeNode.val);     }     return list;   }  }   결과  Link   설명     preorder 순으로 주어진 TreeNode인 root의 하위 ListNode val 값을 List에 넣는 문제이다.            preorder는 left -&gt; right -&gt; root 순이다.           재귀 호출을 이용하여 List에 preorder 순으로 val 값들을 넣어 주어진 문제의 결과로 반환한다.            treeNode가 null이 아닌 경우 존재하는 TreeNode이므로 아래를 수행한다.                    treeNode.left를 재귀 호출 수행하여 treeNode의 left TreeNode 하위 val 값을 list에 넣어준다.           treeNode.right를 재귀 호출 수행하여 treeNode의 right TreeNode 하위 val 값을 list에 넣어준다.           list에 treeNode.val 값을 넣어준다.                       list를 반환하여 계속 list에 TreeNode의 val 값을 preorder 순으로 넣어준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-tree-postorder-traversal/",
        "teaser": null
      },{
        "title": "Leetcode Java LRU Cache",
        "excerpt":"문제  Link   코드  class LRUCache {    private Map&lt;Integer, Node&gt; map = new HashMap&lt;&gt;();    private Node head = new Node(0, 0);   private Node tail = new Node(0, 0);    private int capacity;    public LRUCache(int capacity) {     this.capacity = capacity;     this.head.next = this.tail;     this.tail.prev = this.head;   }    public int get(int key) {     if (this.map.containsKey(key)) {       Node node = this.map.get(key);       this.remove(node);       this.insert(node);       return node.value;     } else {       return -1;     }   }    public void put(int key, int value) {     if (this.map.containsKey(key)) {       this.remove(this.map.get(key));     }     if (this.map.size() == this.capacity) {       this.remove(this.tail.prev);     }     this.insert(new Node(key, value));   }    private void remove(Node node) {     this.map.remove(node.key);     node.prev.next = node.next;     node.next.prev = node.prev;   }    private void insert(Node node) {     this.map.put(node.key, node);     Node next = this.head.next;     this.head.next = node;     node.prev = this.head;     next.prev = node;     node.next = next;   }      }  public class Node {      public Node prev;     public Node next;     public int key;     public int value;      public Node() {     }      public Node(int key, int value) {         this.key = key;         this.value = value;     }  }  /**  * Your LRUCache object will be instantiated and called as such:  * LRUCache obj = new LRUCache(capacity);  * int param_1 = obj.get(key);  * obj.put(key,value);  */   결과  Link   설명     Least recently used(LRU)로 캐시를 저장하는 알고리즘을 구현하는 문제이다.            생성자인 LRUCache(int capacity)는 캐시의 크기를 capacity로 입력받는다.       메서드인 get(int key)은 캐시에 key가 존재하면 값을 반환하고, 존재하지 않으면 -1를 반환한다.       메서드인 put(int key, int value)은 key 값이 존재하면 해당 value의 값을 주어진 value의 값으로 변경하고, 존재하지 않는 경우 key-value 쌍을 캐시에 저장한다.                    단, capacity의 크기를 초과하는 경우 가장 최근에 사용된 key-value 쌍을 제거한다.                           문제 풀이에 필요한 전역 변수를 정의한다.            변수 map은 캐시를 저장 하는 변수이다.       변수 head와 tail은 Node를 연결해서 사용하기 위하여 선언한 변수이다.       변수 capacity는 생성자를 통해 주입받은 캐시의 크기를 저장하기 위한 변수이다.           문제 풀이에 필요한 Node 클래스를 정의한다.            Node를 연결하기 위해 해당 node 이전의 Node를 저장할 변수 prev를 정의한다.       Node를 연결하기 위해 해당 node 이후의 Node를 저장할 변수 next를 정의한다.       Node의 key 값을 저장할 변수 key를 정의한다.       Node의 value 값을 저장할 변수 value를 정의한다.       Node를 생성하기 위한 기본 생성자를 정의한다.       Node를 생성할 때 key와 value를 입력받아 전역 변수에 넣어줄 생성자를 정의한다.           주어진 생성자인 LRUCache(int capacity)를 완성한다.            주입된 capacity를 전역변수 capacity에 저장한다.       head.next에 tail을 넣고, tail.prev에 head를 넣어 서로를 연결시켜준다.           주어진 메서드인 get과 put을 활용 할 때 순서를 변경하고 캐시에서 해당 Node를 빼기 위한 remove 메서드를 정의한다.            캐시인 map에서 주어진 Node인 node를 삭제한다.       node의 연결을 수정하기 위해 node.prev.next에 node.next를, node.next.prev에 node.prev를 넣어준다.           주어진 메서드인 get과 put을 활용 할 때 순서를 변경하고 캐시에서 해당 Node를 추가하기 위한 remove 메서드를 정의한다.            캐시인 map에 node.key값을 이용하여 node를 넣어준다.       node의 연결을 수정하기 위해 head.next를 지역 변수 next에 저장하고, node를 넣고 next와 node를 연결시켜준다.           주어진 메서드인 get(int key)를 완성한다.            캐시를 저장한 map에 key를 이용하여 Node가 존재하는지 검증하여 아래를 수행한다.                    Node가 존재하는 경우, 지역 변수인 node에 저장한 후 캐시인 map에 remove 메서드와 insert 메서드를 통해 Node 순서를 갱신하고 node.value를 반환한다.           Node가 존재하지 않는 경우, -1을 반환한다.                           주어진 메서드인 put(int key, int value)를 완성한다.            캐시를 저장한 map에 key를 이용하여 Node가 존재하면, 해당 Node를 remove 메서드로 제거해준다.       map의 크기가 capacity와 동일한 경우, 최근 사용한 변수인 tail.prev Node를 remove 메서드로 제거해준다.       주어진 key와 value를 이용하여 새 Node를 생성하고 캐시인 map에 추가해준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/lru-cache/",
        "teaser": null
      },{
        "title": "Leetcode Java Insertion Sort List",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode insertionSortList(ListNode head) {     ListNode result = new ListNode();     ListNode curr = head;     ListNode next = null;     ListNode temp = null;     while (curr != null) {       next = curr.next;       temp = result;       while (temp.next != null &amp;&amp; temp.next.val &lt; curr.val) {         temp = temp.next;       }       curr.next = temp.next;       temp.next = curr;       curr = next;     }     return result.next;   }  }   결과  Link   설명          주어진 ListNode head를 이용하여 오름차순으로 정열하는 문제이다.       문제 풀이에 필요한 변수들은 정의한다.            curr은 현재 노드를 저장할 ListNode로, head를 넣어 초기화 시켜준다.       next는 다음 노드를 저장할 ListNode로, null로 초기화 한다.       result는 결과를 저장할 ListNode로, 새 ListNode를 넣어준다.       temp는 임시 변수로 사용할 ListNode로, null로 초기화 한다.           반복문을 통해 curr이 null이 아닐 때 까지 반복한다.            next에 curr.next를, temp에 result를 넣어준다.       temp.nexst가 null이 아니고, temp.next.val이 curr.val보다 작을 때 까지 반복하여 temp에 temp.next를 넣어준다.       curr.next에 temp.next를, temp.next에 curr을, curr에 next를 넣어 순서를 바꾸어준다.           반복이 완료되면 정렬된 ListNode인 result.next를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/insertion-sort-list/",
        "teaser": null
      },{
        "title": "Leetcode Java Sort List",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode sortList(ListNode head) {     if (head == null || head.next == null) {       return head;     }     ListNode prev = null;     ListNode fast = head;     ListNode slow = head;     while (fast != null &amp;&amp; fast.next != null) {       prev = slow;       fast = fast.next.next;       slow = slow.next;     }     prev.next = null;     return this.merge(this.sortList(head), this.sortList(slow));   }    private ListNode merge(ListNode l1, ListNode l2) {     ListNode listNode = new ListNode();     ListNode temp = listNode;     while (l1 != null &amp;&amp; l2 != null) {       if (l1.val &lt; l2.val) {         temp.next = l1;         l1 = l1.next;       } else {         temp.next = l2;         l2 = l2.next;       }       temp = temp.next;     }     if (l1 != null) {       temp.next = l1;     }     if (l2 != null) {       temp.next = l2;     }     return listNode.next;   }  }   결과  Link   설명          주어진 ListNode인 head를 이용하여 오름차순으로 정렬하는 문제이다.            주어진 ListNode인 head가 null이거나, head.next가 null인 경우 head를 반환한다.       문제 풀이에 필요한 변수들은 정의한다.            prev는 slow의 이전 node를 저장할 ListNode로, null로 초기화 한다.       fast와 slow는 head의 중앙 지점을 찾을 ListNode로, 각각 head로 초기화 한다.                fast와 fast.next가 null이 아닐 때 까지 반복하여 prev에 slow를 저장하고, fast는 다다음 ListNode로, slow는 다음 ListNode로 이동시킨다.            반복이 종료되면 prev.next에 null을 넣어 중앙을 기준으로 앞 부분은 slow에, 뒷 부분은 head에 저장되도록 연결을 끊어준다.       head와 slow를 재귀 호출을 이용하여 수행한 결과를 합쳐서 주어진 문제의 결과로 반환한다.            결과를 저장할 listNode 변수를 정의하고, 임시 변수로 사용할 temp에도 listNode를 넣어준다.       l1과 l2가 null이 아닐 때 까지 반복하여 l1과 l2의 val 값이 작은 순서대로 temp.next에 넣어주고, 사용한 ListNode를 다음 값으로 넘겨주고 temp를 temp.next로 이동시킨다.       반복문이 종료된 이후 l1 혹은 l2가 null이 아니면, temp.next에 해당 ListNode를 넣어 이어주고 listNode.next를 반환시킨다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sort-list/",
        "teaser": null
      },{
        "title": "Leetcode Java Evaluate Reverse Polish Notation",
        "excerpt":"문제  Link   코드  class Solution {    public int evalRPN(String[] tokens) {     Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();     for (String token : tokens) {       switch (token) {         case \"+\":           stack.push(stack.pop() + stack.pop());           break;         case \"-\":           stack.push((-1) * stack.pop() + stack.pop());           break;         case \"*\":           stack.push(stack.pop() * stack.pop());           break;         case \"/\":           int n1 = stack.pop(), n2 = stack.pop();           stack.push(n2 / n1);           break;         default:           stack.push(Integer.parseInt(token));       }     }     return stack.pop();   }  }   결과  Link   설명     주어진 문자열 배열 tokens를 이용하여 주어진 숫자와 연산 기호를 이용하여 최종 연산된 값을 구하는 문제이다.            값의 패턴은 숫자1, 숫자2, 연산자1 순으로 들어가서 숫자1 연산자1 숫자2 형식으로 구하면 된다.       Ex) [“1”, “2”, “+”] -&gt; $1 + 2 = 3$, [“1”, “2”, “3”, “-“, “+”] -&gt; $1 + (2 - 3) = 0$                문자열을 순차적으로 넣고 FILO로 추출하기 위해 변수 stack을 정의한다.       주어진 문자열의 배열 tokens를 반복하여 숫자들의 연산을 수행한다.            ”+”, “-“, “*”, “/” 연산자가 나올 경우, stack에 넣은 최근 두 값을 가져와 해당 연산을 수행하여 stack에 다시 넣어준다.       그 외의 문자열은 Integer 형태로 형 변환을 수행하여 stack에 넣어준다.           반복이 완료되면 stack에 저장된 최종 연산된 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/evaluate-reverse-polish-notation/",
        "teaser": null
      },{
        "title": "Leetcode Java Reverse Words in a String",
        "excerpt":"문제  Link   코드  class Solution {    public String reverseWords(String s) {     char[] charArr = s.toCharArray();     int length = charArr.length;     this.reverse(charArr, 0, length - 1);     this.reverseWords(charArr, length);     return this.cleanSpaces(charArr, length);   }    private void reverse(char[] charArr, int i, int j) {     while (i &lt; j) {       char temp = charArr[i];       charArr[i++] = charArr[j];       charArr[j--] = temp;     }   }    private void reverseWords(char[] charArr, int length) {     int i = 0;     int j = 0;     while (i &lt; length) {       while (i &lt; j || i &lt; length &amp;&amp; charArr[i] == ' ') {         i++;       }       while (j &lt; i || j &lt; length &amp;&amp; charArr[j] != ' ') {         j++;       }       this.reverse(charArr, i, j - 1);     }   }    private String cleanSpaces(char[] charArr, int length) {     int i = 0;     int j = 0;     while (j &lt; length) {       while (j &lt; length &amp;&amp; charArr[j] == ' ') {         j++;       }       while (j &lt; length &amp;&amp; charArr[j] != ' ') {         charArr[i++] = charArr[j++];       }       while (j &lt; length &amp;&amp; charArr[j] == ' ') {         j++;       }       if (j &lt; length) {         charArr[i++] = ' ';       }     }     return new String(charArr).substring(0, i);   }  }   결과  Link   설명     주어진 문자열 s의 단어들의 순서를 반전시키는 문제이다.            단 주어진 문자열 s에서 복수개 공백을 사용한 경우, 하나의 공백으로 변환해야 한다.       또한 주어진 문자열 s의 앞과 뒤에 포함된 공백은 제거해야 한다.           문제 풀이에 필요한 변수들을 정의한다.            charArr은 s를 문자 배열로 만들어 반전시키기 위해 정의한다.       length는 charArr의 길이를 저장할 변수이다.                charArr의 모든 문자를 반전시킨다.       공백(‘ ‘)으로 구분하여 문자열을 반전시켜 원래의 단어로 복원시킨다.            문제 풀이에 필요한 변수들을 정의한다.                    i는 단어의 시작 index를 저장하기 위한 변수이다.           j는 단어의 종료 index를 저장하기 위한 변수이다.                       단어를 찾는 기본 원칙은 공백(‘ ‘)을 구분하여 단어를 찾아 i와 j를 정의한다.       3번에서 사용한 방식으로 i부터 $j - 1$까지 문자를 반전시켜 해당 문자열을 원래의 단어로 복원시킨다.           문제의 세부 요건인 공백(‘‘)에 대한 부분을 제거하기 위해 모든 문자열을 탐색하여 조건을 충족시킨 문자열로 변환하여 주어진 문제의 결과로 반환한다.            문제 풀이에 필요한 변수들을 정의한다.                    i는 세부 요건을 충족한 문자열을 완성하기 위한 index로 사용하는 변수이다.           j는 전체 문자열을 탐색하기 위한 index이다.                       charArr의 전체 문자들을 반복하여 세부 요건들을 충족시킨다.                    j가 length보다 작고 charArr[j]가 공백(‘ ‘)일 경우, j를 증가시켜 단어의 시작 위치를 찾는다.           j가 length보다 작고 charArr[j]가 공백(‘ ‘)이 아닐 경우, charArr[i]에 charArr[j]를 넣어 순차적인 문장을 만들어주고 i와 j를 증가시킨다.           j가 length보다 작고 charArr[j]가 공백(‘ ‘)일 경우, j를 증가시켜 다음 단어의 시작 위치를 찾는다.           마지막 반복을 통해서 j가 length보다 작을 경우, charArr[i]에 공백(‘ ‘)을 넣어주고 i를 증가시켜준다.                       반복이 완료되면 charArr를 새로운 문자열로 바꾸고, 문자열의 처음부터 i 번째 전까지 잘라 요구 사항을 충족하년 문자열로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reverse-words-in-a-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Product Subarray",
        "excerpt":"문제  Link   코드  class Solution {    public int maxProduct(int[] nums) {     int max = nums[0];     int length = nums.length;     int left = 1;     int right = 1;     for (int idx = 0; idx &lt; length; idx++) {       left = (left == 0 ? 1 : left) * nums[idx];       right = (right == 0 ? 1 : right) * nums[length - 1 - idx];       max = Math.max(max, Math.max(left, right));     }     return max;   }  }   결과  Link   설명          주어진 정수 배열 nums의 부분 집합의 곱이 최대인 값을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            nums는 부분 집합의 곱이 최대인 값을 저장하기 위한 변수이다.       length는 nums의 길이를 저장하는 변수이다.       left는 left-right로 이동하며 곱한 값을 저장하기 위한 변수이다.       right는 right-left로 이동하며 곱한 값을 저장하기 위한 변수이다.           배열 nums를 반복하여 부분 집합의 곱이 최대인 값을 구한다.            left가 0인 경우 1과, 그렇지 않은 경우 left와 nums[idx]값의 곱을 다시 left에 넣어준다.       right가 0인 경우 1과, 그렇지 않은 경우 left와 nums[$length - 1 - idx$]값의 곱을 다시 right에 넣어준다.                    각 left와 right가 0인 경우 nums[$idx - 1$]값 혹은 nums[$length - 1 - idx - 1$]값이 0이어서 곱의 결과가 0으로 저장된 경우이므로, 다음 계산을 위해 1로 변환하는 것이다.                       max를 left, right, max 중 가장 큰 값으로 넣어준다.           반복이 종료되면 부분 집합의 곱이 최대인 값을 저장한 max를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-product-subarray/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Minimum in Rotated Sorted Array",
        "excerpt":"문제  Link   코드  class Solution {    public int findMin(int[] nums) {     int left = 0;     int right = nums.length - 1;     while (left &lt; right) {       int mid = (left + right) / 2;       if (nums[mid] &gt; nums[right]) {         left = mid + 1;       } else {         right = mid;       }     }     return nums[left];   }  }   결과  Link   설명          주어진 배열 nums를 n번 회전한 배열로, 오름차순으로 정렬되었을 때 최소 숫자를 탐색하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            left는 nums 배열의 시작 index로, 이진 탐색에 사용될 변수이다.       right는 nums 배열의 마지막 index로, 이진 탐색에 사용될 변수이다.           left가 right보다 작을 때 까지 반복하여 left에 배열의 최소값의 index를 넣어준다.            중앙값인 mid는 $frac{(left + right)}{2}$ 값으로 넣어 nums[mid]의 값과 nums[right]의 값 중 어느 값이 큰지 검증한다.                    nums[mid]의 값이 클 경우, left에 $mid + 1$를 넣어 탐색 구간을 좁혀준다.           nums[right]의 값이 크거나 같을 경우, right에 mid를 넣어 탐색 구간을 좁혀준다.                           반복이 완료되면 오름차순 정렬을 수행했을 경우 최소값이 되는 nums[left]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-minimum-in-rotated-sorted-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Minimum in Rotated Sorted Array II",
        "excerpt":"문제  Link   코드  class Solution {    public int findMin(int[] nums) {     int left = 0;     int right = nums.length - 1;     while (left &lt; right) {       int mid = left + ((right - left) / 2);       if (nums[mid] &gt; nums[right]) {         left = mid + 1;       } else if (nums[mid] &lt; nums[right]) {         right = mid;       } else {         right--;       }     }     return nums[left];   }  }   결과  Link   설명     이전 문제인 Find Minimum in Rotated Sorted Array와 비슷하게 주어진 배열 nums의 최소 값을 찾는 문제이다.            단, 이전 문제와는 달리 주어진 배열 nums에 중복된 값이 포함된다.           문제 풀이에 필요한 변수를 정의한다.            left는 nums 배열의 시작 index로, 이진 탐색에 사용될 변수이다.       right는 nums 배열의 마지막 index로, 이진 탐색에 사용될 변수이다.           left가 right보다 작을 때 까지 반복하여 left에 배열의 최소값의 index를 넣어준다.            중앙값인 mid는 $left + frac{(right - left)}{2}$ 값으로 넣어 nums[mid]의 값과 nums[right]의 값을 비교한한다.                    nums[mid]의 값이 nums[right]의 값보다 클 경우, left에 $mid + 1$를 넣어 탐색 구간을 좁혀준다.           nums[mid]의 값이 nums[right]의 값보다 작을 경우, right에 mid를 넣어 탐색 구간을 좁혀준다.           nums[mid]의 값이 nums[right]의 값과 같은 경우, right를 감소시켜 중복된 값을 무시한다.                           반복이 완료되면 오름차순 정렬을 수행했을 경우 최소값이 되는 nums[left]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-minimum-in-rotated-sorted-array-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Min Stack",
        "excerpt":"문제  Link   코드  class MinStack {    private Node node;    /** initialize your data structure here. */   public MinStack() {   }    public void push(int val) {     if (node == null) {       node = new Node(val, val, null);     } else {       node = new Node(val, Math.min(val, node.min), node);      }   }    public void pop() {     node = node.prev;   }    public int top() {     return this.node.val;   }    public int getMin() {     return this.node.min;   }  }  public class Node {    public int val;   public int min;   public Node prev;    public Node() {   }    public Node(int val, int min, Node prev) {     this.val = val;     this.min = min;     this.prev = prev;   }  }  /**  * Your MinStack object will be instantiated and called as such:  * MinStack obj = new MinStack();  * obj.push(val);  * obj.pop();  * int param_3 = obj.top();  * int param_4 = obj.getMin();  */   결과  Link   설명     아래의 메서드를 구현하는 문제이다.            생성자인 MinStack()은 Stack 객체를 초기화 한다.       메서드인 push(val)은 val을 Stack에 넣는다.       메서드인 pop()은 Stack의 가장 마지막 값을 제거한다.       메서드인 top()은 Stack의 가장 첫 값을 반환한다.       메서드인 getMin()은 Stack의 최솟값을 반환한다.           문제 풀이에 기본이 되는 Node 객체를 선언한다.            Node는 현재 값, 최솟값, 이전 Node를 저장할 수 있다.       생성자를 통해 위의 기본 변수들의 값을 넣을 수 있다.           push(val) 메서드를 구현한다.            전역 변수인 node가 null인 경우, 새로운 Node를 val값으로 생성하여 node에 넣어준다.       전역 변수인 node가 null이 아닌 경우, 새로운 Node를 전역 변수 node와 val 값, val 값과 node.min 값 중 가장 작은 값으로 생성하여 node에 넣어준다.           pop() 메서드를 구현한다.            전역 변수인 node에 node.prev를 넣어 마지막 Node의 연결을 끊어준다.           top() 메서드를 구현한다.            전역 변수인 node의 val 값을 반환한다.           getMin() 메서드를 구현한다.            전역 변수인 node의 min 값을 반환한다.           참고  해당 문제는 요구 조건을 만족하는 Stack을 구현하는 문제로, java.util.Stack을 사용하는 것은 문제 취지에 맞지 않는 것으로 판단된다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/min-stack/",
        "teaser": null
      },{
        "title": "Leetcode Java Intersection of Two Linked Lists",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode(int x) {  *         val = x;  *         next = null;  *     }  * }  */ public class Solution {    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {     if (headA == null || headB == null) {       return null;     }     ListNode listNodeA = headA;     ListNode listNodeB = headB;     while (listNodeA != listNodeB) {       listNodeA = listNodeA == null ? headB : listNodeA.next;       listNodeB = listNodeB == null ? headA : listNodeB.next;     }     return listNodeA;   }  }   결과  Link   설명     주어진 ListNode headA와 headB를 이용하여 공통된 부분 ListNode를 찾는 문제이다.            공통된 부분 ListNode가 없을 경우, null을 주어진 문제의 결과로 반환한다.                headA 혹은 headB가 null인 경우, 공통된 부분이 없기 때문에 null을 주어진 문제의 결과로 반환한다.            임시 변수 listNodeA에는 headA를, listNodeB에는 headB를 넣어 정의한다.       listNodeA와 listNodeB가 같지 않을 때 까지 반복하여 공통된 부분 ListNode를 찾는다.            listNodeA가 null인 경우, headB를 listNodeA에 넣어 공통된 부분 ListNode를 찾는다.       listNodeA가 null이 아닌 경우, listNodeA.next를 listNodeA에 넣어 다음 ListNode로 이동시킨다.       listNodeB가 null인 경우, headA를 listNodeB에 넣어 공통된 부분 ListNode를 찾는다.       listNodeB가 null이 아닌 경우, listNodeB.next를 listNodeA에 넣어 다음 ListNode로 이동시킨다.                    listNodeA와 listNodeB의 길이가 다른 경우 서로 전환하여 수행하면 같은 길이가 되므로 탐색이 가능하다.           1 -&gt; 2 -&gt; 3 -&gt; 4 &amp; 5 -&gt; 3 -&gt; 4 두 ListNode가 있다고 할 때 아래와 같이 수행되면서 공통된 부분 ListNode를 탐색하게 된다.             listNodeA : 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; (null)5 -&gt; [3 -&gt; 4 -&gt; null] listNodeB : 5 -&gt; 3 -&gt; 4 -&gt; (null)1 -&gt; 2 -&gt; [3 -&gt; 4 -&gt; null]                                   1 -&gt; 2 -&gt; 3 &amp; 4 -&gt; 5 두 ListNode가 있다고 할 때 아래와 같이 수행되면서 공통된 부분 ListNode를 탐색하게 된다.             listNodeA : 1 -&gt; 2 -&gt; 3 -&gt; (null)4 -&gt; 5 -&gt; [null] listNodeB : 4 -&gt; 5 -&gt; (null)1 -&gt; 2 -&gt; 3 -&gt; [null]                                                   위의 반복이 종료되면 공통된 부분으로 구성된 listNodeA와 listNodeB 둘 중 아무 ListNode를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/intersection-of-two-linked-lists/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Peak Element",
        "excerpt":"문제  Link   코드  class Solution {    public int findPeakElement(int[] nums) {     int length = nums.length;     if (length == 1) {       return 0;     }     int left = 0;     int right = length - 1;     while (left + 1 &lt; right) {       int mid = left + (right - left) / 2;       if (nums[mid] &lt; nums[mid + 1]) {         left = mid;       } else {         right = mid;       }     }     return nums[left] &gt; nums[right] ? left : right;   }  }   결과  Link   설명          주어진 정수 배열 nums의 가장 높은 값을 찾아 index를 반환하는 문제이다.            주어진 정수 배열의 크기가 1인 경우, 탐색할 필요가 없으므로 0을 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            left는 left -&gt; right 방향으로 탐색하기 위한 변수로, 0으로 초기화한다.       right는 right -&gt; left 방향으로 탐색하기 위한 변수로, 주어진 배열인 nums의 크기로 초기화한다.           $left + 1$이 right보다 작을 때까지 반복하여 최고 값이 되는 위치를 탐색한다.            임시 변수인 mid에 $left + frac{right - left}{2}$를 넣고 nums[mid]의 값과 nums[mid + 1]의 값을 비교한다.                    nums[mid]의 값이 nums[mid + 1]의 값보다 작을 경우, left에 mid를 넣어준다.           nums[mid]의 값이 nums[mid + 1]의 값보다 크거나 같은 경우, right에 mid를 넣어준다.                           반복이 완료되면 nums[left]의 값과 nums[right]의 값을 비교하여 주어진 문제의 결과로 반환한다.            nums[left]가 nums[right]의 값보다 큰 경우, left를 주어진 문제의 결과로 반환한다.       nums[left]가 nums[right]의 값보다 작거나 같은 경우, right를 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-peak-element/",
        "teaser": null
      },{
        "title": "Python Selenium Chromedriver Timeout",
        "excerpt":"오류 발생  Python 3.8.12 (default, Sep  3 2021, 02:24:44) [GCC 10.2.1 20210110] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. &gt;&gt;&gt; from selenium import webdriver &gt;&gt;&gt; options = webdriver.ChromeOptions() &gt;&gt;&gt; options.add_argument('--headless') &gt;&gt;&gt; options.add_argument('--no-sandbox') &gt;&gt;&gt; options.add_argument('--disable-dev-shm-usage') &gt;&gt;&gt; driver = webdriver.Chrome(executable_path='/app/chromedriver', chrome_options=options) &lt;stdin&gt;:1: DeprecationWarning: use options instead of chrome_options Traceback (most recent call last):   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;   File \"/usr/local/lib/python3.8/site-packages/selenium/webdriver/chrome/webdriver.py\", line 76, in __init__     RemoteWebDriver.__init__(   File \"/usr/local/lib/python3.8/site-packages/selenium/webdriver/remote/webdriver.py\", line 157, in __init__     self.start_session(capabilities, browser_profile)   File \"/usr/local/lib/python3.8/site-packages/selenium/webdriver/remote/webdriver.py\", line 252, in start_session     response = self.execute(Command.NEW_SESSION, parameters)   File \"/usr/local/lib/python3.8/site-packages/selenium/webdriver/remote/webdriver.py\", line 321, in execute     self.error_handler.check_response(response)   File \"/usr/local/lib/python3.8/site-packages/selenium/webdriver/remote/errorhandler.py\", line 242, in check_response     raise exception_class(message, screen, stacktrace) selenium.common.exceptions.SessionNotCreatedException: Message: session not created from timeout: Timed out receiving message from renderer: 600.000   (Session info: headless chrome=93.0.4577.63)   오류 확인     selenium 모듈로 chromedriver를 이용하여 session을 생성하려고 execute하였으나, reponse를 받지 못하고 timeout으로 SesionNotCreatedException이 발생 한 것으로 확인 되었음.   chromedriver를 통해 정상적인 session을 생성하지 못했다는(응답이 지연되었다는) 것은 chromedriver을 사용할 경우 문제가 발생하는 이유가 존재하는 것으로 판단 됨.   오류 조사  Selenium Timed out receiving message from renderer     Docker container 내부 Testing 결과 1%의 비율로 해당 오류가 발생하는 것으로 판단되었다는 내용.   Brandon Schabell의 답변 내용과 해당 댓글에 존재하는 Chromium Bugs - Issue 794017: Linux Chrome startup is flaky on ChromeDriver waterfall without –disable-gpu 내용을 참고해보자.   위 내용을 읽어보면 VM에서 비정상적으로 GPU를 사용하려는 시도가 있어 Chromedirver를 사용할 경우 ‘–disable-gpu’ 옵션을 사용하면 안정적으로 동작이 가능한 것으로 판단이 된다.   How to solve that makes my screen all black     해당 게시자의 말에 따르면 GPU를 사용하였을 경우, 블랙 스크린(응답 없음)이 발생하여 Disabled 처리하였다는 내용이다.   위의 내용에 따르면 특정 환경에서 Windows 또한 GPU를 사용하는 설정이 Chrome에 비정상적인 영향을 발생시킨다는 것을 확인 할 수 있다.   결론     Chrome의 GPU 사용 기능에는 버그가 존재한다.            Chrome의 GPU를 사용하는 설정은 물론 애플리케이션의 성능 향상을 위한 옵션으로 개발 된 것으로 판단된다.       하지만 GPU를 사용하는 경우에도 해당 설정이 애플리케이션 실행에 치명적인 오류가 발생할 수 있으며, 해당 오류에 대한 처리가 미흡하거나 정확히 파악하지 못한 버그가 존재한다고 볼 수 있다.           Chrome을 안정적으로 사용하기 위해서는 GPU 사용 설정을 꺼야한다.            모든 OS 환경에서 Chrome을 안정적으로 사용하기 위해서 아직까지는 GPU 사용 설정을 끄는 것이 이로울 듯 하다.                    ‘Windows에서는 설정 &gt; 고급 &gt; 시스템 &gt; 가능한 경우 하드웨어 가속 사용’을 Off로 설정한다.           Linux에서는 Chromedriver option에 존재하는 ‘–disable-gpu’을 실행 Command에 넣어 사용한다.                          ","categories": ["Python"],
        "tags": ["Programming","Python","Selenium"],
        "url": "/python/selenium-chromedriver-timeout/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Gap",
        "excerpt":"문제  Link   코드  class Solution {    public int maximumGap(int[] nums) {     int length = nums.length;     if (length &lt; 2) {       return 0;     }     int min = nums[0];     int max = nums[0];     for (int num : nums) {       min = Math.min(min, num);       max = Math.max(max, num);     }     if (min == max) {       return 0;     }     int gap = (int) Math.ceil((double) (max - min) / (length - 1));     int bucketMin[] = new int[length];     int bucketMax[] = new int[length];     Arrays.fill(bucketMin, Integer.MAX_VALUE);     Arrays.fill(bucketMax, Integer.MIN_VALUE);     for (int num : nums) {       int idx = (num - min) / gap;       bucketMin[idx] = Math.min(bucketMin[idx], num);       bucketMax[idx] = Math.max(bucketMax[idx], num);     }     for (int idx = 0; idx &lt; bucketMin.length; ++idx) {       if (bucketMin[idx] != Integer.MAX_VALUE) {         gap = Math.max(gap, bucketMin[idx] - min);         min = bucketMax[idx];       }     }     return gap;   }  }   결과  Link   설명     주어진 정수 배열 nums를 정렬된 상태의 인접한 두 값의 최대 차이를 구하는 문제이다.            단, 주어진 정수 배열 nums의 크기가 2 미만일 경우 주어진 문제의 결과로 0을 반환한다.       문제 풀이의 알고리즘은 Linear time으로 동작해야 하며, Linear extra space을 사용해야한다.                주어진 배열 크기가 2 미만인 경우, 0을 주어진 문제의 결과로 반환한다.            주어진 배열 nums의 값 중 최솟값과 최댓값을 저장하기 위한 min과 max를 정의하고, nums를 순회하여 min에 최솟값을, max에 최댓값을 넣어준다.            min과 max가 동일한 값일 경우 nums에 동일한 값들만 있을 경우이므로, 0을 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            gap은 최소 가능한 차이를 나타내며, $\\frac{max - min}{length - 1}$의 값을 올림한 값을 저장한다.       bucketMin과 bucketMax는 nums를 순회할 때 차이의 최솟값과 최댓값을 저장할 배열로, 주어진 배열 nums의 크기로 생성한다.                bucketMin에는 int형의 최댓값(2,147,483,647)을, bucketMax에는 int형의 최솟값(-2,147,483,648)을 채워준다.       주어진 배열 nums를 반복하여 bucketMin과 bucketMax를 채워준다.            각 배열의 index를 저장할 idx에 $\\frac{num - min}{gap}$의 값을 넣어준다.       bucketMin[idx]에는 bucketMin[idx]와 num 중 작은 값을 넣어준다.       bucketMax[idx]에는 bucketMax[idx]와 num 중 큰 값을 넣어준다.           bucketMin을 반복하여 nums 배열의 정렬된 상태에서의 인접한 두 값의 최대 차이를 구한다.            bucketMin[idx]와 int형의 최댓값(2,147,483,647)이 아닌 경우만 아래를 수행한다.                    gap에 gap과 $bucketMin[idx] - min$의 값 중 큰 값을 넣어준다.           min에는 bucketMax[idx] 값을 임시 저장시켜준다.                           반복이 완료되면 nums의 정렬된 상태의 인접한 두 값의 최대 차이를 저장한 gap을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-gap/",
        "teaser": null
      },{
        "title": "Leetcode Java Compare Version Numbers",
        "excerpt":"문제  Link   코드  class Solution {    public int compareVersion(String version1, String version2) {     String[] splitVersion1 = version1.split(\"\\\\.\");     String[] splitVersion2 = version2.split(\"\\\\.\");     for (int idx = 0; idx &lt; splitVersion1.length || idx &lt; splitVersion2.length; idx++) {       int int1 = idx &lt; splitVersion1.length ? Integer.parseInt(splitVersion1[idx]) : 0;       int int2 = idx &lt; splitVersion2.length ? Integer.parseInt(splitVersion2[idx]) : 0;       if (int1 &gt; int2) {         return 1;       } else if (int1 &lt; int2) {         return -1;       }     }     return 0;   }  }   결과  Link   설명     주어진 문자열 version1과 version2은 숫자열과 점(.) 만 포함된 버전 표기법으로, 어느 문자열의 버전이 더 높은지에 따라 결과를 반환하는 문제이다.            version1의 버전이 높으면 1을, version2의 버전이 높으면 -1을, 동일하면 0을 주어진 문제의 결과로 반환한다.                version1과 version2를 점(.)을 구분자로 배열로 변경하여 각자 splitVersion1, splitVersion2에 넣어준다.       splitVersion1과 splitVersion2 중 가장 값이 많이 들어가 있는 배열 기준으로 반복을 수행하여 높은 버전을 확인한다.            각 버전 중 하위 버전 값이 없을(배열의 크기가 더 작은) 경우, 0으로 비교를 수행한다.       version1의 부분 버전(splitVersion1의 idx번째 숫자) 값이 높을 경우, 1을 주어진 문제의 결과로 반환한다.       version2의 부분 버전(splitVersion2의 idx번째 숫자) 값이 높을 경우, -1을 주어진 문제의 결과로 반환한다.           반복이 완료되면 동일한 버전이므로, 0을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/compare-version-numbers/",
        "teaser": null
      },{
        "title": "Leetcode Java Fraction to Recurring Decimal",
        "excerpt":"문제  Link   코드  class Solution {    public String fractionToDecimal(int numerator, int denominator) {     StringBuilder result = new StringBuilder();     if ((numerator &gt; 0 &amp;&amp; denominator &lt; 0) || (numerator &lt; 0 &amp;&amp; denominator &gt; 0)) {       result.append(\"-\");     }     long numeratorLong = Math.abs((long) numerator);     long denominatorLong = Math.abs((long) denominator);     result.append(numeratorLong / denominatorLong);     long remainder = numeratorLong % denominatorLong;     if (remainder == 0) {       return result.toString();     }     result.append(\".\");     Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;();     while (remainder != 0) {       if (!map.containsKey(remainder)) {         map.put(remainder, result.length());       } else {         result.insert(map.get(remainder), \"(\");         result.append(\")\");         return result.toString();       }       remainder *= 10;       result.append(remainder / denominatorLong);       remainder %= denominatorLong;     }     return result.toString();   }  }   결과  Link   설명     주어진 분수 표기법의 변수들인 numerator(분자)와 denominator(분모)를 이용하여 소수 표기법으로 변환하는 문제이다.            단, 순환소수인 경우 순환마디를 소괄호()로 감싸 표기한다.           결과를 동적으로 생성하기 위해 StringBuilder인 result를 정의한다.            동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.                주어진 분자인 numerator와 분모인 denominator의 곱이 음의 정수(-)가 되는 경우는 초기 값에 “-“ 기호를 넣어준다.            주어진 분자인 numerator와 분모인 denominator을 양의 정수인 long 형태로 각각 변경하여 numeratorLong과 denominatorLong을 정의한다.       result에 $\\frac{numeratorLong}{denominatorLong}$의 정수 값을 넣어주고, 나머지 값은 remainder 변수를 정의하여 넣어준다.            remainder가 0일 경우 나눗셈의 결과가 정수가 되는 경우이므로, result를 문자형으로 전환하여 주어진 문제의 결과로 반환한다.           result에 소수점(.)을 추가하고, 순환마디를 구하기 위해 map을 정의하고 remainder가 0이 아닐 때 까지 반복하여 result를 완성한다.            map에 remainder가 key로 존재하지 않은 경우, 아래를 수행한다.                    key는 remainder, value는 순환마디의 시작 위치인 result의 길이로 넣어준다.           remainder에 10을 곱하여 result에 $\\frac{remainder}{dominatorLong}$의 정수 값을 넣어주고, remainder에는 나머지 값을 넣어주고 반복을 계속 수행한다.                       map에 remainder가 key로 존재하는 경우, 아래를 수행한다.                    map에서 해당 remainder 값인 순환마디의 시작 위치를 가져와 해당 위치에 “(“ 문자를 넣어주고, result에 “)”문자를 넣어 순환 마디를 소괄호()로 감싸준다.           순환소수가 저장된 result를 문자형으로 전환하여 주어진 문제의 결과로 반환한다.                           반복이 완료되면 순환소수가 아닌 result를 문자형으로 전환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/fraction-to-recurring-decimal/",
        "teaser": null
      },{
        "title": "Leetcode Java Two Sum II - Input array is sorted",
        "excerpt":"문제  Link   코드  class Solution {    public int[] twoSum(int[] numbers, int target) {     int left = 0;     int right = numbers.length - 1;     while (left &lt; right) {       if (numbers[left] + numbers[right] == target) {         break;       } else if (numbers[left] + numbers[right] &gt; target) {         right--;       } else {         left++;       }     }     return new int[] { left + 1, right + 1 };   }  }   결과  Link   설명     주어진 배열 numbers은 오름차순으로 정렬된 정수 배열로, 두 값을 이용하여 target을 만족시키는 값의 순번을 반환하는 문제이다.            배열 내 index가 아니라 배열 내 몇 번째에 위치한 값인지를 반환하는것이다.           문제 풀이를 위한 변수를 정의한다.            left는 좌측에서 left-right 순으로 값을 탐색하여 두 값중 작은 값의 index를 저장하는 변수이다.       right는 우측에서 right-left 순으로 값을 탐색하여 두 값중 큰 값의 index를 저장하는 변수이다.           left가 right보다 작을 때 까지 두 값의 합이 target을 만족시키는 값의 index를 탐색한다.            $numbres[left] + numbers[right]$의 값이 target 값과 동일하면, 반복을 종료한다.       $numbres[left] + numbers[right]$의 값이 target 값보다 크면, right를 감소시켜 더 작은 값을 이용하여 비교를 한다.       $numbres[left] + numbers[right]$의 값이 target 값보다 작으면, left를 증가시켜 더 큰 값을 이용하여 비교를 한다.           반복이 완료되면 left와 right를 각각 1씩 증가시키고 배열로 만들어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/two-sum-ii-input-array-is-sorted/",
        "teaser": null
      },{
        "title": "Leetcode Java Excel Sheet Column Title",
        "excerpt":"문제  Link   코드  class Solution {    public String convertToTitle(int columnNumber) {     StringBuilder result = new StringBuilder();     while (columnNumber &gt; 0) {       result.append((char) ('A' + (--columnNumber % 26)));       columnNumber /= 26;     }     if (result.length() &gt; 1) {       result.reverse();     }     return result.toString();   }  }   결과  Link   설명          주어진 정수 columnNumber를 이용하여 엑셀의 컬럼명을 가져오는 문제이다.       결과를 동적으로 생성하기 위해 StringBuilder인 result를 정의한다.            동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.           columnNumber가 0보다 클 때까지 반복하여 result에 엑셀 컬럼명을 넣는다.            result에 $’A’ + (–columnNumber % 26)$의 값을 문자로 변환하여 넣어준다.                    영어 대문자는 총 26개가 존재하며, ‘A’ 문자 기준으로 ‘Z’가 되기 위해서는 $’A’ + 25$의 ASCII 코드 값이 되어야 한다.           그렇기 때문에 ‘A’가 되기위해서는 columnNumber를 1을 뺀 후 26을 나눈 나머지 값을 이용하여 ‘A’문자의 ASCII 코드 값을 합치는 것이다.           간단한 예를 들어 columnNumber가 1인 경우, 엑셀 필드명이 ‘A’로 반환되어야 하므로 $’A’(65) + 1$의 결과는 ‘B’(66)이 되버리기 때문에 1을 빼주는 것이다.                       columnNumber에 26을 나눈 값을 다시 넣어주고 반복을 계속 수행한다.           result에 들어간 문자가 1개 초과인 경우 result.reverse()를 통해 앞뒤를 반전시켜준다.            StringBuilder의 append() method는 Stack처럼 넣은 순서대로 들어가기 때문에 2개 이상인 경우 앞뒤를 반전시켜주어야 원하는 필드 명이 완성된다.       StringBuilder의 insert() method를 사용하면 첫 자리에 후입 문자가 들어갈 수 있지만 매 문자의 삽입 시, 순서의 변경을 위한 메모리가 낭비되므로 append()와 reverse()를 활용한다.           완성된 엑셀의 컬럼명을 저장한 result를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/excel-sheet-column-title/",
        "teaser": null
      },{
        "title": "Leetcode Java Majority Element",
        "excerpt":"문제  Link   코드  class Solution {    public int majorityElement(int[] nums) {     int result = 0;     int count = 0;     for (int num : nums) {       if (count == 0) {         result = num;       }       if (num != result) {         count--;       } else {         count++;       }     }     return result;   }  }   결과  Link   설명          주어진 배열 nums에 속한 정수 중 과반수 이상 들어있는 값을 찾는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 과반수 이상 존재하는 값을 저장하기 위한 변수이다.       count는 result에 저장된 정수가 과반수 이상 존재하는지를 검증하기 위한 변수이다.           주어진 배열 nums를 반복하여 과반수 이상 존재하는 값을 변수 result에 넣는다.            count가 0일 경우 처음 시작이거나 타 값이 더 많이 존재하는 경우이므로, result에 num을 넣어준다.       반복되는 정수 num이 result와 같지 않으면 count를 감소시키고, 같으면 count를 증가시킨다.           반복이 완료되면 과반수 이상 존재하는 정수를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/majority-element/",
        "teaser": null
      },{
        "title": "Leetcode Java Excel Sheet Column Number",
        "excerpt":"문제  Link   코드  class Solution {    public int titleToNumber(String columnTitle) {     int result = 0;     for (int idx = 0; idx &lt; columnTitle.length(); idx++) {       result *= 26;       result += columnTitle.charAt(idx) - 'A' + 1;     }     return result;   }  }   결과  Link   설명     지난 Excel Sheet Column Title와 반대로, 주어진 엑셀 컬럼명인 columnTitle을 이용하여 정수형으로 바꾸는 문제이다.            ‘A’(1) ~ ‘Z’(26)으로 구성되어 있으며, 복합 문자열 ‘AA’의 정수형 값은 27이다.                주어진 엑셀 컬럼명인 columnTitle을 정수형을 바꾸어 넣기 위한 변수 result를 정의한다.       columnTitle의 각 문자를 반복하여 result에 컬럼명을 정수형으로 변환하여 합쳐준다.            result의 값에 26을 곱하여 기존 자리의 값을 증가시켜준다.                    각 자리에 해당하는 문자열의 값에 $26^{(columnTitle.length - (idx + 1))}$을 곱해주는 것으로, 먼저 result에 26을 곱해준다.           예를 들어, columnTitle이 ‘ABC’로 주어졌을 경우 $’A’(1) * 26^2 + ‘B’(2) * 26^1 + ‘C’(3) * 26^0 = 676 + 52 + 3 = 731$이 된다.                       result의 값에 idx번째 문자의 값을 더해준다.                    가져온 문자에 ‘A’의 ASCII 코드 값을 빼고 1을 더함으로써, 1번의 설명에 해당하는 1~26까지 값으로 변환해서 result에 더해주는 것이다.                           반복이 완료되면 columnTitle을 정수형으로 바꾸어 저장된 값을 담은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/excel-sheet-column-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Factorial Trailing Zeroes",
        "excerpt":"문제  Link   코드  class Solution {    public int trailingZeroes(int n) {     int count = 0;     while (n != 0) {       n /= 5;       count += n;     }     return count;   }  }   결과  Link   설명     주어진 정수 n을 Factorial을 사용하여 n! 값 뒷자리에 존재하는 0의 개수를 구하는 문제이다.            간단히 주어진 문제를 직관적으로 보면, n! 값 뒷자리에 존재하는 0의 개수는 10이 몇 개 곱해졌는지를 파악하면된다.       위의 내용을 깊이 파고들면 $2 \\times 5 = 10$이므로 소수인 2는 5!, 10! 이하의 모든 값들에 포함되는 값으로, n! 내에 존재하는 5의 개수만 파악하면 해결 가능한 문제이다.                주어진 정수 n을 이용하여 n! 내 존재하는 5의 개수를 세기 위한 변수인 count를 정의한다.       주어진 정수 n이 0이 되기 전까지 반복하여 count에 5의 개수를 더한다.            주어진 정수 n을 5로 나눈 결과를 n에 다시 주입한다.       count에 n을 더하여 5의 개수를 넣어준다.                    n!내 5의 개수를 구하는 가장 효율적인 방법은, n에서 5를 계속 나누어 준 몫의 합이 해당 개수가 된다.                           n! 값 뒤에 존재하는 0의 개수를 넣은 변수 count의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/factorial-trailing-zeroes/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Search Tree Iterator",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class BSTIterator {    private Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    public BSTIterator(TreeNode root) {     this.pushAllTreeNode(root);   }    public int next() {     TreeNode treeNode = stack.pop();     this.pushAllTreeNode(treeNode.right);     return treeNode.val;    }    public boolean hasNext() {     return !stack.isEmpty();   }    private void pushAllTreeNode(TreeNode treeNode) {     while (treeNode != null) {       stack.push(treeNode);       treeNode = treeNode.left;     }   }  }  /**  * Your BSTIterator object will be instantiated and called as such:  * BSTIterator obj = new BSTIterator(root);  * int param_1 = obj.next();  * boolean param_2 = obj.hasNext();  */   결과  Link   설명     주어진 BSTIterator Class를 완성하는 문제이다.            해당 Class는 이진 검색 트리(BST)를 순회하는 객체이다.       순차적인 TreeNode를 반환하기 위하여 TreeNode를 Stack에 보관하여 사용한다.           BSTIterator(TreeNode root) 생성자를 완성한다.            생성자는 주어진 TreeNode인 root를 이용하여 객체를 초기화 한다.       TreeNode를 Root에서 Left 순으로 저장하여 FILO로 stack에 저장한다.           hasNext() 메서드를 완성한다.            TreeNode의 다음 TreeNode이 존재하는지를 검증하는 메서드로, stack이 비어있지 않으면 다음 TreeNode가 존재한다고 판단한다.           next() 메서드를 완성한다.            stack에서 가장 마지막으로 저장된 TreeNode를 가져와서 반환한다.       단, 반환하기 전에 해당 TreeNode의 right TreeNode를 stack에 저장시켜야 다음 next() 메서드 호출 시, 해당 TreeNode의 right TreeNode를 반환할 수 있다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-search-tree-iterator/",
        "teaser": null
      },{
        "title": "Leetcode Java Dungeon Game",
        "excerpt":"문제  Link   코드  class Solution {    public int calculateMinimumHP(int[][] dungeon) {     int row = dungeon.length;     int col = dungeon[0].length;     int[][] health = new int[row][col];     for (int i = row - 1; i &gt;= 0; i--) {       for (int j = col - 1; j &gt;= 0; j--) {         if (i == row - 1 &amp;&amp; j == col - 1) {           health[i][j] = Math.max(1, 1 - dungeon[i][j]);         } else if (i == row - 1) {           health[i][j] = Math.max(health[i][j + 1] - dungeon[i][j], 1);         } else if (j == col - 1) {           health[i][j] = Math.max(health[i + 1][j] - dungeon[i][j], 1);         } else {           health[i][j] = Math.min(Math.max(health[i + 1][j] - dungeon[i][j], 1), Math.max(health[i][j + 1] - dungeon[i][j], 1));         }       }     }     return health[0][0];   }  }   결과  Link   설명     주어진 2차원 배열인 dungeon을 이용하여 dungeon[0][0]에서 dungeon[$dungeon.length - 1$][$dungeon[0].length - 1$]에 도달하기까지 숫자들의 합이 양의 정수가 되는 최소한의 health를 찾는 문제이다.            단, 이동은 오른쪽과 아래로만 가능하다.           문제 풀이에 필요한 변수를 정의한다.            row는 주어진 2차원 배열 dungeon 행의 개수를 저장한 변수이다.       col은 주어진 2차원 배열 dungeon 열의 개수를 저장한 변수이다.       health는 주어진 2차원 배열 dungeon을 탐색할 때 필요한 health를 산정하기 위해 사용될 2차원 배열로, dungeon과 동일한 크기로 선언한다.           dungeon[$row - 1$][$col - 1$]부터 시작해서 역순으로 탐색에 필요한 최소한의 health를 구한다.            시작 위치인 dungeon[$row - 1$][$col - 1$]인 경우, 1과 $1 - dungeon[i][j]$ 중 큰 값을 넣어준다.       i가 마지막 행인 $row - 1$인 경우, 우측 값에서 현재 값을 뺀 값과 1 중 큰 값을 넣어준다.       j가 마지막 열인 $col - 1$인 경우, 아래 값에서 현재 값을 뺀 값과 1 중 큰 값을 넣어준다.       그 외의 경우, 우측 값에서 현재 값을 뺀 값과 1중 큰 값과 아래 값에서 현재 값을 뺀 값과 1 중 큰 값 중 작은 값을 넣어준다.           반복이 완료되면 health[0][0]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/dungeon-game/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Combine Two Tables",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT Person.FirstName, Person.LastName, Address.City, Address.State FROM Person LEFT OUTER JOIN Address ON Person.PersonId = Address.PersonId   결과  Link   설명     Person Table과 Address Table을 JOIN하는 기초적인 문제이다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/combine-two-tables/",
        "teaser": null
      },{
        "title": "Leetcode Java Largest Number",
        "excerpt":"문제  Link   코드  class Solution {    public String largestNumber(int[] nums) {     String result = Arrays.stream(nums)         .mapToObj(String::valueOf)         .sorted((s1, s2) -&gt; (s2 + s1).compareTo(s1 + s2))         .collect(Collectors.joining(\"\"));     return result.startsWith(\"00\") ? \"0\" : result;   }   }   결과  Link   설명          양의 정수로만 이루어진 주어진 배열 nums를 이용하여 가장 큰 숫자의 문자형을 만드는 문제이다.       주어진 배열을 Arrays를 활용하여 가장 큰 숫자의 문자형으로 만들어준다.            stream 메서드를 이용하여 nums를 Stream 객체로 전환한다.       mapToObj 메서드를 이용하여 int형의 값들을 String으로 변환한다.       sorted 메서드를 이용하여 내부 값들을 정렬시켜준다.                    배열 내 값들을 문자열의 조합으로 더 큰 값이 앞으로 갈 수 있도록 정렬한다.                       collect 메서드를 이용하여 배열을 문자열로 연결시켜준다.           조합된 문자열이 “00”으로 시작될 경우 “0”을, 그 외의 경우 result를 주어진 문제의 결과로 반환한다.            조합된 문자열이 “00”인 경우, 0이 가장 큰 값이므로 “00”, “000” 등의 값들을 정수인 “0”으로 바꾸어 주는 것이다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/largest-number/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Nth Highest Salary",
        "excerpt":"문제  Link   코드  CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN DECLARE Num int; SET Num = N - 1;   RETURN (       # Write your MySQL query statement below.       SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT Num, 1   ); END   결과  Link   설명          Employee Table의 N번째 Salary 값을 가져오는 getNthHighestSalary FUNCTION을 완성하는 문제이다.            INPUT PARAMETER인 N을 이용하여 Num 변수에 N - 1을 넣어준다.            Employee Table을 Salary 기준으로 정렬하여 DISTCINT된 Salary의 값을 LIMIT을 이용하여 Num번째 값 이후 1개를 가져오면 된다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/nth-highest-salary/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Rank Scores",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT s1.Score, COUNT(DISTINCT s2.SCORE) AS 'Rank' FROM Scores s1 INNER JOIN Scores s2 ON s1.Score &lt;= s2.Score GROUP BY s1.Id ORDER BY s1.Score DESC   결과  Link   설명          Scores Table에서 Score 별 Rank를 메겨서 높은 순서대로 정렬하는 문제이다.            Scores Table을 두 번 호출하여 서로 INNER JOIN한다.            s1.Score 보다 작은 s2.Score를 JOIN 걸어 RANK를 메긴다.            집계함수를 사용하므로, s1.Id으로 GROUP하고 s1.Score를 DESC로 정렬한다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/rank-scores/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Second Highest Salary",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT MAX(Salary) AS 'SecondHighestSalary' FROM Employee WHERE Salary NOT IN (     SELECT MAX(Salary) FROM Employee )   결과  Link   설명          Employee Table의 두 번째 높은 Salary 값을 구하는 문제이다.            Employee Table의 가장 큰 Salary 값을 제외한 가장 큰 Salary를 구하면 된다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/second-highest-salary/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Consecutive Numbers",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT DISTINCT Num AS ConsecutiveNums FROM Logs l1 WHERE (l1.Id + 1, Num) IN (SELECT * FROM Logs) AND (l1.Id + 2, Num) IN (SELECT * FROM Logs) #WHERE EXISTS ( #    SELECT 1 FROM Logs l2 #    WHERE l2.Id = l1.Id + 1 AND l1.Num = l2.Num #) #AND EXISTS ( #    SELECT 1 FROM Logs l2 #    WHERE l2.Id = l1.Id + 2 AND l1.Num = l2.Num #)   결과  Link   설명          Logs Table에서 연속된 Id에 동일한 Num이 들어가 있는 모든 Id를 반환하는 문제이다.            Logs Table에 $Id + 1$과 Num, $Id + 2$와 Num이 존재하는지를 검증하면 된다.             WHERE 조건문의 IN과 EXISTS는 비슷한 용도로 사용하지만, 일반적으로 데이터가 많을수록 EXISTS가 적을수록 IN이 효율적이다.          ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/consecutive-numbers/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Customers Who Never Order",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT Customers.Name AS 'Customers' FROM Customers LEFT OUTER JOIN Orders ON Customers.Id = Orders.CustomerId WHERE Orders.Id IS NULL   결과  Link   설명          Customers Table에서 한번도 주문하지 않은 고객을 찾는 문제이다.            Customers와 Orders Table을 LEFT OUTER JOIN을 이용하여 Orders의 Id가 Null인 대상의 Name만 출력하면 된다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/customers-who-never-order/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Department Highest Salary",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT Department.Name AS 'Department'     , Employee.Name AS 'Employee'     , Employee.Salary FROM Employee INNER JOIN Department ON Employee.DepartmentId = Department.Id WHERE (Employee.DepartmentId, Employee.Salary) IN (     SELECT DepartmentId, MAX(Salary)     FROM Employee     GROUP BY DepartmentId )   결과  Link   설명          Employee, Department Table을 이용하여 부서 별 가장 높은 급여를 받는 직원들을 찾는 문제이다.            Employee와 Department Table을 INNER JOIN 수행한다.            서브 쿼리를 이용하여 DepartmentId 별 가장 높은 급여를 찾아 2번의 결과에서 해당 부서 별 급여를 받는 인원의 Department.Name, Employee.Name, Employee.Salary를 출력한다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/department-highest-salary/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Department Top Three Salaries",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT Department.Name AS 'Department'     , Employee.Name AS 'Employee'     , Employee.Salary FROM Employee INNER JOIN Department ON Employee.DepartmentId = Department.Id LEFT OUTER JOIN Employee temp ON Department.Id = temp.DepartmentId AND Employee.Salary &lt; temp.Salary GROUP BY Department.Name     , Employee.Name     , Employee.Salary HAVING COUNT(DISTINCT temp.Salary) &lt; 3   결과  Link   설명          Employee, Department Table을 이용하여 부서 별 가장 높은 급여를 받는 3명의 직원들을 찾는 문제이다.            Employee와 Department Table을 INNER JOIN 수행한다.            비교를 위한 Employee Table을 temp란 별칭으로 LEFT OUTER JOIN을 이용하여 Department Table의 Id가 동일하고 Employee Table의 Salary보다 큰 값을 넣어준다.            그룹 함수를 이용하여 중복되지 않은 temp.Salary가 3개 미만인 개수만 대상으로 Department.Name, Employee.Name, Employee.Salary을 출력한다.             Employee와 Department Table을 JOIN된 결과에서 LEFT OUTER JOIN으로 Employee를 급여 기준으로 걸었기 때문에, 급여가 높은 인원만큼의 Row가 추가 생성된다.       이 Row를 기준으로 COUNT를 세서 3개 미만인 경우만 출력되게 한 것이다.          ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/department-top-three-salaries/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Duplicate Emails",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT Email FROM Person GROUP BY Email HAVING COUNT(*) &gt; 1   결과  Link   설명          Person Table에서 중복 사용된 Email을 찾는 문제이다.            간단한 집계함수를 이용하여 Email이 중복된 개수가 1개 초과인 Email만 출력한다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/duplicate-emails/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Employees Earning More Than Their Managers",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT Employee.Name as 'Employee' FROM Employee INNER JOIN Employee managers ON Employee.ManagerId = managers.Id Where Employee.Salary &gt; managers.Salary   결과  Link   설명          모든 직원과 매니저 정보가 저장된 Employee Table을 이용하여 매니저보다 급여가 많은 직원의 이름을 찾는 문제이다.            Employee를 다시 INNER JOIN을 걸어, ManagerId가 Null이 아닌 직원들에게 Manager 정보를 넣어 Salary를 비교하여 매니저보다 급여가 높은 직원의 Name만 출력한다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/employees-earning-more-than-their-managers/",
        "teaser": null
      },{
        "title": "Leetcode Java Repeated DNA Sequences",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; findRepeatedDnaSequences(String s) {     Set&lt;String&gt; result = new HashSet&lt;&gt;();     Set&lt;String&gt; temp = new HashSet&lt;&gt;();     for (int idx = 0; idx + 9 &lt; s.length(); idx++) {       String sequence = s.substring(idx, idx + 10);       if (!temp.add(sequence)) {         result.add(sequence);       }     }     return new ArrayList&lt;&gt;(result);   }  }   결과  Link   설명          주어진 DNA 서열인 s에서 두 번 이상 존재하는 10글자의 DNA 서열을 모두 찾는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 두 번 이상 존재하는 10글자의 DNA 서열을 저장하는 변수이다.       temp는 두 번 이상 존재하는지 DNA 서열을 모두 저장하기 위한 변수이다.           주어진 문자열을 처음부터 마지막 10자리가 되는 $s.length() - 10$번째 까지 반복하여 두 번 이상 존재하는 10자리의 DNA 서열을 모두 찾는다.            sequence에 idx부터 10자리의 DNA 서열을 저장한다.       temp에 sequence를 넣어주고, 이미 들어가 있을 경우 result에도 넣어준다.           반복이 종료되면 전체 DNA 서열인 s에서 두 번 이상 존재하는 DNA 서열이 저장된 result를 ArrayList로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/repeated-dna-sequences/",
        "teaser": null
      },{
        "title": "Leetcode Java Best Time to Buy and Sell Stock IV",
        "excerpt":"문제  Link   코드  class Solution {    public int maxProfit(int k, int[] prices) {     int length = prices.length;     if (k &gt;= length / 2) {       return this.getMaxProfit(prices, length);     } else {       return this.getMaxProfitUsingDp(k, prices, length);     }   }    private int getMaxProfit(int[] prices, int length) {     int max = 0;     for (int idx = 1; idx &lt; length; idx++) {       if (prices[idx] &gt; prices[idx - 1]) {         max += prices[idx] - prices[idx - 1];       }     }     return max;   }    private int getMaxProfitUsingDp(int k, int[] prices, int length) {     int[][] dp = new int[k + 1][length];     for (int i = 1; i &lt;= k; i++) {       int max = dp[i - 1][0] - prices[0];       for (int j = 1; j &lt; length; j++) {         dp[i][j] = Math.max(dp[i][j - 1], prices[j] + max);         max = Math.max(max, dp[i - 1][j] - prices[j]);       }     }     return dp[k][length - 1];   }  }   결과  Link   설명          주어진 배열인 prices는 주식 가격으로, 주어진 정수인 k번 까지 거래를 통해 발생 할 수 있는 최대 이익을 구하는 문제이다.            주어진 배열인 prices 크기의 절반보다 k가 크거나 같을 경우 3번을, k가 작을 경우 4번을 수행한다.       매매와 매도의 횟수가 최대 거래 횟수인 k를 넘지 못하기 때문에 직전 값의 차이로만 계산해도 최대 이익을 구할 수 있으므로 반복문을 통해 최대 이익을 계산한다.            최대 이익을 저장할 변수 max를 정의한다.       두 번째 값인 1부터 주어진 배열 prices의 크기인 length 전까지 반복하여 다음 주식의 가격이 높을 경우, max에 해당 차이 값을 더해준다.       반복이 완료되면, 주어진 배열인 prices를 이용하여 최대 k번 거래 후 최대 이익이 되는 max를 주어진 문제의 결과로 반환한다.           매매와 매도의 횟수가 최대 거래 횟수인 k번의 각 경우를 따져야 하기 때문에, DP를 이용하여 k번 거래 동안 발생 가능한 최대 이익을 계산한다.            DP를 활용하기 위한 배열 dp를 [$k + 1$][length]의 크기로 정의한다.       최소 거래 횟수인 1부터 최대 거래 횟수인 k번까지 반복하여 DP를 초기화한다.       각 거래 횟수에 따라 최대 이익을 저장할 max를 dp[$i - 1$][0]의 값과 prices[0]의 값 차이를 넣어준다.       prices 배열을 탐색하여 dp에 최대 이익을 넣어준다.       dp[i][j]에 이전 값인 dp[i][$j - 1$]의 값과 $prices[j] + max$의 값 중 큰 값을 넣어준다.       max에 max와 동일 prices 배열의 값 위치에 직전 거래 횟수의 이익 중 큰 값을 넣어 횟수와 무관한 최대 이익을 max에 저장시키고 반복을 계속 수행한다.       모든 반복이 완료되어 dp의 값이 채워지면, 주어진 배열인 prices를 이용하여 최대 k번 거래 후 최대 이익이 되는 dp[k][length - 1]의 값을 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/best-time-to-buy-and-sell-stock-iv/",
        "teaser": null
      },{
        "title": "Leetcode Java Rotate Array",
        "excerpt":"문제  Link   코드  class Solution {    public void rotate(int[] nums, int k) {     k %= nums.length;     this.reverse(nums, 0, nums.length - 1);     this.reverse(nums, 0, k - 1);     this.reverse(nums, k, nums.length - 1);   }    private void reverse(int[] nums, int start, int end) {     while (start &lt; end) {       int temp = nums[start];       nums[start++] = nums[end];       nums[end--] = temp;     }   }  }   결과  Link   설명          주어진 배열인 nums를 k번 값을 뒤에 있는 값을 앞으로 오게 회전하는 문제이다.       k에 nums.length로 나눈 나머지를 넣어준다.            nums를 nums.length번 회전하면 같은 위치이므로, 횟수를 줄여준다.           세 번 배열의 값들을 반전시킴으로써 원하는 배열의 형태를 만들어준다.            nums를 처음 값부터 마지막 값까지 반전시킨다.       nums를 처음 값부터 $k - 1$ 번째 위치의 값까지 반전시킨다.       nums를 k 번째 위치의 값부터 마지막 값까지 반전시킨다.                    세 번의 반전을 통해서 k번 회전시킨 결과와 동일하게 된다.           nums가 [1, 2, 3, 4, 5] &amp; k가 3의 경우를 예를 든다.                                 기본 회전의 경우, [5, 1, 2, 3, 4] -&gt; [4, 5, 1, 2, 3] -&gt; [3, 4, 5, 1, 2]       위의 반전의 경우, [5, 4, 3, 2, 1] -&gt; [3, 4, 5, 2, 1] -&gt; [3, 4, 5, 1, 2]           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/rotate-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Reverse Bits",
        "excerpt":"문제  Link   코드  public class Solution {    // you need treat n as an unsigned value   public int reverseBits(int n) {     int result = 0;     for (int i = 0; i &lt; 32; i++) {       result = (result &lt;&lt;= 1) + (n &amp; 1);       n &gt;&gt;= 1;     }     return result;   }  }   결과  Link   설명          주어진 정수 n의 32bit code를 반전한 정수를 구하는 문제이다.            결과를 저장할 result 변수를 0으로 초기화한다.       32번 반복을 통해 주어진 정수 n의 32bit code를 반전시켜 result에 저장한다.            result의 bit를 좌측으로 한 칸 이동시킨 값과 n과 1의 Bit 논리곱(AND)인 ‘&amp;’을 이용하여 두 값이 동일하게 1인지를 검증한 결과의 합을 result에 넣어준다.       n의 bit를 우측으로 한 칸 이동시킨다.           반복이 완료되면 주어진 정수 n의 32bit code를 반전시킨 정수를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reverse-bits/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of 1 Bits",
        "excerpt":"문제  Link   코드  public class Solution {    // you need to treat n as an unsigned value   public int hammingWeight(int n) {     int result = 0;     while (n != 0) {       result += n &amp; 1;       n &gt;&gt;&gt;= 1;     }     return result;   }  }   결과  Link   설명          32bit code인 n에 포함된 1의 개수를 구하는 문제이다.            32bit code인 n에 포함된 1의 개수를 저장하기 위한 변수 result를 정의하고 0으로 초기화한다.       n이 0이 되기 전까지 반복하여 1의 개수를 구한다.            result에 n과 1의 Bit 논리곱(AND)인 ‘&amp;’의 결과를 더해준다.       n의 bit code 첫 값들을 우측으로 1칸씩 밀어주고, 맨 처음 값에 0을 채워준다.           반복이 완료되면 32bit code인 n에 포함된 1의 개수를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-1/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Delete Duplicate Emails",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below DELETE Person FROM Person, Person temp WHERE Person.Email = temp.Email AND Person.Id &gt; temp.Id   결과  Link   설명          Person Table 내 각 중복된 Email 데이터들 중 Id가 가장 낮은 데이터들만 제외한 모든 데이터를 삭제하는 문제이다.            Person Table을 두 번 호출하여 EQUI JOIN으로 동일한 Email의 데이터를 연결한다.            p1의 Id가 p2의 Id보다 큰 p1의 데이터들을 모두 삭제한다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/delete-duplicate-emails/",
        "teaser": null
      },{
        "title": "Leetcode Java House Robber",
        "excerpt":"문제  Link   코드  public class Solution {    public int rob(int[] nums) {     int length = nums.length;     int[][] dp = new int[length + 1][2];     for (int i = 0; i &lt; length; i++) {       dp[i + 1][0] = Math.max(dp[i][0], dp[i][1]);       dp[i + 1][1] = nums[i] + dp[i][0];     }     return Math.max(dp[length][0], dp[length][1]);   }  }   결과  Link   설명          주어진 정수 배열 nums를 이용하여 인접하지 않은 값들의 합이 가장 큰 값을 찾는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 주어진 배열 nums의 길이를 넣은 변수이다.       dp는 문제 풀이에 필요한 DP를 만들기 위한 배열로, [$length + 1$][2] 사이즈로 초기화 한다.           nums를 순회하면서 주어진 dp를 초기화 한다.            dp[$i + 1$][0]에는 이전 값들인 dp[i][0]의 값과 dp[i][1]의 값 중 큰 값을 넣어준다.       dp[$i + 1$][1]에는 nums[i]와 dp[i][0]의 합을 넣어준다.                    dp[i][0]의 값은 dp[$i - 1$][0]의 값과 dp[$i - 1$][1]의 값 중 큰 값이므로, nums[i]와 인접하지 않은 값이다.                           반복이 완료되면 각 인접하지 않은 값들의 합을 저장한 dp[length][0]의 값과 dp[length][1]의 값 중 큰 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/house-robber/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Rising Temperature",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT Weather.Id FROM Weather INNER JOIN Weather temp ON TO_DAYS(Weather.RecordDate) - TO_DAYS(temp.RecordDate) = 1 WHERE Weather.Temperature &gt; temp.Temperature   결과  Link   설명          Weather Table에서 이전 날보다 날씨가 더 올라간 데이터의 Id를 출력하는 문제이다.            Weather Table을 두 번 호출하여 INNER JOIN으로 Weather.RecordDate를 TO_DAYS 함수로 형 변환한 값과 temp.RecordDate를 TO_DAYS 함수로 형변환 한 값의 차이가 1인 경우를 조인한다.            Weather.Temperature가 temp.Temperature보다 큰 데이터들의 Id를 출력한다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/rising-temperature/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Tree Right Side View",
        "excerpt":"문제  Link   코드  public class Solution {    public List&lt;Integer&gt; rightSideView(TreeNode root) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     this.recursive(result, root, 0);     return result;   }    private void recursive(List&lt;Integer&gt; list, TreeNode treeNode, int level) {     if (treeNode == null) {       return;     }     if (list.size() == level) {       list.add(treeNode.val);     }     this.recursive(list, treeNode.right, level + 1);     this.recursive(list, treeNode.left, level + 1);   }  }   결과  Link   설명          주어진 TreeNode인 root를 이용하여 top-bottom 순으로 동일 Level 내 가장 우측에 존재하는 TreeNode의 val 값을 List에 넣는 문제이다.       재귀 호출을 이용하여 List에 top-bottom 순으로 동일 Level 내 가장 우측에 존재하는 TreeNode의 val 값을 넣어준다.            treeNode가 null인 경우 진행이 불가능하므로 반환한다.       list.size()와 level이 동일한 경우, 해당 TreeNode의 val 값을 List에 넣어준다.       treeNode.right -&gt; treeNode.left 순으로 재귀 호출을 수행하여 각 Level 내 가장 우측에 존재하는 TreeNode 의 val 값을 넣어준다.           재귀 호출이 완료되면 top-bottom 순으로 동일 Level 내 가장 우측에 존재하는 TreeNode의 val 값을 넣은 List인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-tree-right-side-view/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Islands",
        "excerpt":"문제  Link   코드  public class Solution {    public int numIslands(char[][] grid) {     int result = 0;     for (int i = 0; i &lt; grid.length; i++)       for (int j = 0; j &lt; grid[0].length; j++) {         if (grid[i][j] == '1') {           this.dfs(grid, i, j);           result++;         }       }     return result;   }    private void dfs(char[][] grid, int i, int j) {     if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; grid.length &amp;&amp; j &lt; grid[0].length &amp;&amp; grid[i][j] == '1') {       grid[i][j] = '0';       this.dfs(grid, i + 1, j);       this.dfs(grid, i - 1, j);       this.dfs(grid, i, j + 1);       this.dfs(grid, i, j - 1);     }   }  }   결과  Link   설명     주어진 2차원 배열 grid를 이용하여 섬의 개수를 구하는 문제이다.            grid는 바다를 ‘0’으로 육지를 ‘1’로 표현하며, 인접하지 않은 ‘1’은 섬을 의미한다.           주어진 grid를 반복하여 섬의 개수를 구한다.            grid[i][j]의 값이 1인 경우, 배열 내 인접한 육지인 ‘1’을 바다인 ‘0’로 변경하고 result를 증가시킨다.           반복이 완료되면 섬의 개수를 저장한 변수 result의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-islands/",
        "teaser": null
      },{
        "title": "Leetcode Java Bitwise AND of Numbers Range",
        "excerpt":"문제  Link   코드  public class Solution {    public int rangeBitwiseAnd(int left, int right) {     int count = 0;     while (left != right) {       left &gt;&gt;= 1;       right &gt;&gt;= 1;       count++;     }     return left &lt;&lt; count;   }  }   결과  Link   설명          주어진 정수 left와 right의 binary code 중 공통된 접두사를 찾아 해당 값을 반환하는 문제이다.            공통된 접두사를 찾기 위해 이동한 횟수를 저장할 변수인 count를 정의하고 0으로 초기화 한다.       left와 right가 동일한 값이 되기 전까지 두 값의 bit를 한 칸 오른쪽으로 이동시키고, count를 증가시킨다.            left와 right의 bit를 우측으로 계속 이동하다 동일한 값이 되는 구간이 두 값의 공통된 접두사가 되는 지점이다.           공통된 접두사가 저장된 left에 우측으로 이동한 횟수인 count만큼 좌측으로 이동시켜 해당 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/bitwise-and-of-numbers-range/",
        "teaser": null
      },{
        "title": "Leetcode Java Happy Number",
        "excerpt":"문제  Link   코드  public class Solution {    public boolean isHappy(int n) {     Set&lt;Integer&gt; set = new HashSet&lt;&gt;();     int sum = 0;     while (set.add(n)) {       sum = 0;       while (n &gt; 0) {         sum += Math.pow(n % 10, 2);         n /= 10;       }       if (sum == 1) {         return true;       } else {         n = sum;       }     }     return false;   }  }   결과  Link   설명          주어진 정수 n의 각 자릿수의 제곱을 더한 값을 앞의 방식대로 계속 수행했을 경우, 1이 되는지 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            set은 n의 각 자릿수의 제곱을 더한 값이 반복되는지 확인하기 위한 변수이다.       sum은 각 자릿수의 제곱을 더한 값을 임시 저장하는 변수이다.           set에 n을 넣었을 경우, 중복되지 않았을 경우 아래를 반복한다.            sum을 0으로 초기화 하고, 각 자릿수의 제곱을 sum에 더하고 n을 10으로 나눈 값을 n에 다시 넣어준다.       sum이 1인 경우, 주어진 문제의 결과로 true를 반환한다.       sum이 1이 아닌 경우, n에 sum을 넣고 반복을 계속 수행한다.           반복이 종료된 경우 반복된 값이 계속 발생하는 경우이므로, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/happy-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove Linked List Elements",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ public class Solution {    public ListNode removeElements(ListNode head, int val) {     if (head == null) {       return null;     }     ListNode next = this.removeElements(head.next, val);     if (head.val == val) {       return next;     } else {       head.next = next;       return head;     }   }  }   결과  Link   설명          주어진 ListNode인 head에서 val값을 가진 ListNode를 제거하고 앞과 뒤의 ListNode를 이어주는 문제이다.            주어진 ListNode인 head가 null인 경우, null을 반환한다.       head.next를 이용하여 재귀 호출을 수행한 결과를 next에 넣어둔다.            head.val의 값과 val 값이 동일한 경우, 다음 노드의 결과인 next를 반환한다.       head.val의 값과 val 값이 동일하지 않은 경우, head.next에 그대로 next를 넣고 head를 반환한다.           재귀 호출이 완료되면 val값이 포함된 ListNode를 제거한 head가 완성된다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-linked-list-elements/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Primes",
        "excerpt":"문제  Link   코드  class Solution {    public int countPrimes(int n) {     if (n &lt; 3) {       return 0;     }     int result = n / 2;     boolean[] notPrime = new boolean[n];     for (int i = 3; i * i &lt; n; i += 2) {       if (notPrime[i]) {         continue;       }       for (int j = i * i; j &lt; n; j += 2 * i) {         if (!notPrime[j]) {           result--;           notPrime[j] = true;         }       }     }     return result;   }  }   결과  Link   설명          주어진 정수 n 미만의 양의 정수 중 소수의 개수를 구하는 문제이다.            주어진 정수가 3 미만일 경우, 가장 작은 소수인 2를 포함하지 않으므로 0을 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            result는 소수의 개수를 저장하기 위한 변수로, $\\frac{n}{2}$의 정수 값을 넣어준다.                    주어진 정수 n 미만의 소수의 개수는 항상 $\\frac{n}{2}$의 정수 값보다 같거나 작다.           주어진 n이 5일 경우, 소수의 개수는 2, 3로 2개이다.           주어진 n이 10일 경우, 소수의 개수는 2, 3, 5, 7로 4개이다.           주어진 n이 20일 경우, 소수의 개수는 2, 3, 5, 7, 11, 13, 17, 19로 8개 이다.                       notPrime은 소수가 아닌 값을 체크하기 위한 배열의 변수로, 주어진 정수 n의 사이즈로 초기화 한다.                    boolean형의 초기 값은 false로, 모든 값이 소수가 아닌 것으로 체크를 한다.                           3 이상의 소수는 2 단위로 증가하기 때문에, 3부터 $i \\times i$미만까지 2씩 증가시키며 반복을 수행한다.            i가 소수인 경우, 반복을 계속 수행해준다.       $i \\times i$부터 n 전까지 $i \\times 2$ 값들을 반복하며 아래를 수행한다.                    2의 배수인 값은 소수가 아니기 때문에, 소수의 개수를 저장한 result의 값을 감소시킨다.           위와 동일한 이유로 notPrime에 소수가 아닌 값(false)으로 저장한다.                           반복이 완료되면 주어진 정수 n 미만의 양의 정수 중 소수의 개수를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-primes/",
        "teaser": null
      },{
        "title": "Leetcode Java Isomorphic Strings",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isIsomorphic(String s, String t) {     int[] sm = new int[256];     int[] tm = new int[256];     for (int i = 0; i &lt; s.length(); i++) {       if (sm[s.charAt(i)] != tm[t.charAt(i)]) {         return false;       } else {         sm[s.charAt(i)] = tm[t.charAt(i)] = i + 1;       }     }     return true;   }  }   결과  Link   설명          주어진 문자열 s와 t가 동일한 형태의 문자열인지 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            sm과 tm은 각 문자열이 동일한 형태인 문자열인지 검증하기 위한 배열로, ASCII 코드의 문자수인 256으로 설정한다.           주어진 문자열 s와 t를 반복하여 동일한 형태의 문자열인지 검증한다.            sm 배열 내 s의 i번째 문자의 ASCII 코드 번호에 위치한 값과 tm 배열 내 t의 i번째 문자의 ASCII 코드 번호에 위치한 값이 동일하지 않으면 동일한 형태의 문자열이 아니므로, false를 주어진 문제의 결과로 반환한다.       위의 경우가 아니면 sm 배열 내 s의 i번째 문자의 ASCII 코드 번호에 위치한 값과 tm 배열 내 t의 i번째 문자의 ASCII 코드 번호에 위치한 값에 $i + 1$을 넣어 동일하게 발생한 위치를 저장한다.           반복이 완료되면 주어진 문자열 s와 t가 동일한 형태의 문자열이므로, true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/isomorphic-strings/",
        "teaser": null
      },{
        "title": "Leetcode Java Reverse Linked List",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode reverseList(ListNode head) {     ListNode listNode = null;     while (head != null) {       ListNode temp = head.next;       head.next = listNode;       listNode = head;       head = temp;     }     return listNode;   }  }   결과  Link   설명          주어진 ListNode인 head를 역순으로 바꾸는 문제이다.            역순으로 바꾼 ListNode를 저장하기 위한 listNode를 정의한다.       head가 null이 아닐 때 까지 반복하여 listNode에 역순으로 넣어준다.            temp에 head의 next ListNode를 넣어주고, head.next에 listNode를 넣어준다.       listNode에 다시 head를 넣어주고, head에 temp를 넣어줌으로써 순서를 반전시킨다.           반복이 완료되면 역순으로 저장한 listNode를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reverse-linked-list/",
        "teaser": null
      },{
        "title": "Leetcode Java Course Schedule",
        "excerpt":"문제  Link   코드  class Solution {    public boolean canFinish(int numCourses, int[][] prerequisites) {     List&lt;Integer&gt;[] graph = new List[numCourses];     int[] courses = new int[numCourses];     for (int i = 0; i &lt; numCourses; i++) {       graph[i] = new ArrayList&lt;&gt;();     }     for (int[] req : prerequisites) {       graph[req[1]].add(req[0]);       courses[req[0]]++;     }     ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;();     for (int i = 0; i &lt; numCourses; i++) {       if (courses[i] == 0) {         result.add(i);       }     }     for (int i = 0; i &lt; result.size(); i++) {       for (int course : graph[result.get(i)]) {         if (--courses[course] == 0) {           result.add(course);         }       }     }     return result.size() == numCourses;   }  }   결과  Link   설명     주어진 정수 numCourses는 수강해야 하는 총 과목 수로, 주어진 2차원 배열 prerequisites를 이용하여 numCourses 만큼의 과목을 수료할 수 있는지 검증하는 문제이다.            prerequisites은 각 과목 정보를 [과목 번호, 선행 과목 번호]로 담고 있으며, 이는 해당 과목을 수료하기 위해선 선행 과목을 수료해야 함을 나타낸다.           문제 풀이에 필요한 변수를 정의한다.            graph는 선행 과목을 수료했을 경우 수강 가능한 과목 번호를 저장할 컬렉션의 배열이다.       courses는 과목 존재 여부에 대한 정보를 담은 배열이다.                0부터 numCourses 전까지 반복하여 graph에 ArrayList를 다 넣어준다.            수료 가능한 과목 번호를 담을 result 컬렉션을 정의하고, 0부터 numCourses까지 반복하여 과목 정보가 없을 경우 과목 번호를 넣어준다.       result 배열을 순회하여 graph[result.get(i)]에 존재하는 값들을 반복하여 courses[course]에 저장된 과목 정보를 감소시키며 result에 course 번호를 넣어준다.            graph[result.get(i)] 저장된 값들은 result의 i번째 과목을 수료했을 경우, 수료 가능한 과목의 코드들이다.       위의 해당 값을 반복하여 courses의 값을 감소시키고, result에 해당 과목을 넣어 수강 과목 목록에 추가시키는 것이다.           수료 가능한 과목의 개수인 result의 크기와 numCourses가 동일한지 여부를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/course-schedule/",
        "teaser": null
      },{
        "title": "Leetcode Java Implement Trie (Prefix Tree)",
        "excerpt":"문제  Link   코드  class Trie {    private TrieNode root;    public Trie() {     root = new TrieNode();   }    public void insert(String word) {     TrieNode node = root;     for (int idx = 0; idx &lt; word.length(); idx++) {       int num = word.charAt(idx) - 'a';       if (node.children[num] == null) {         node.children[num] = new TrieNode();       }       node = node.children[num];     }     node.isWord = true;   }    public boolean search(String word) {     return this.match(word, true);   }    public boolean startsWith(String prefix) {     return this.match(prefix, false);   }    private boolean match(String str, boolean isWord) {     TrieNode node = root;     for (int idx = 0; idx &lt; str.length(); idx++) {       int num = str.charAt(idx) - 'a';       if (node.children[num] == null) {         return false;       }       node = node.children[num];     }     return isWord ? node.isWord : true;   }  }  class TrieNode {    public boolean isWord;   public TrieNode[] children;    public TrieNode() {     this.children = new TrieNode[26];   }  }  /**  * Your Trie object will be instantiated and called as such:  * Trie obj = new Trie();  * obj.insert(word);  * boolean param_2 = obj.search(word);  * boolean param_3 = obj.startsWith(prefix);  */   결과  Link   설명     탐색 트리의 일종인 Trie 객체를 완성하는 문제이다.            생성자인 Trie()는 Trie 객체를 초기화한다.       메서드인 insert(String word)는 주어진 문자열 word를 Trie에 삽입한다.       메서드인 search(String word)는 주어진 문자열 word가 Trie에 존재하는지 유무를 반환한다.       메서드인 startsWith(String prefix)는 기 삽입된 문자열 중 주어진 문자열 prefix로 시작하는 문자열의 유무를 반환한다.           문제 풀이에 필요한 TrieNode 클래스를 정의한다.            isWord는 해당 단어까지의 문자열이 단어로 존재하는지 여부를 저장하는 변수이다.       children은 해당 단어까지의 문자열 이후의 문자열을 이어주기 위한 변수로, 객체 생성 시 다음 문자를 저장하기 위해 알파벳의 개수인 26 크기의 TrieNode 배열로 초기화 한다.           문제 풀이에 필요한 변수를 정의한다.            root는 Trie의 가장 최상위 노드를 저장하기 위한 변수이다.           주어진 생성자인 Trie()를 완성한다.            전역 변수인 TreeNode를 초기화 시켜 순차적인 문자열 입력이 가능하도록 한다.           주어진 메서드인 insert(String word)를 완성한다.            전역 변수인 root를 지역 변수인 node에 복사해준다.                    주어진 root를 점층적으로 내려가며 단어의 완성을 할 때, 기존 값들을 보호하기 위해서 node에 복사하여 node를 변경하며 수행하는 것이다.                       주어진 word를 한 문자씩 반복하여 node 아래로 문자열을 TrieNode에 연결시켜준다.                    주어진 word의 idx번째 문자에서 ‘a’를 빼 0(a) ~ 25(z))까지 숫자를 num에 넣어준다.           node.children의 num번째 TrieNode가 null인 경우, 하위 문자열을 이어주기 위해서 새 TrieNode를 넣어준다.           node에 node.children[num]을 넣어 이후 문자들을 이용하여 Trie를 완성한다.                       반복이 완료되면 마지막 TrieNode의 isWord를 true로 바꾸어 해당 문자열까지 입력된 단어임을 체크해준다.           주어진 메서드인 search(String word)와 startsWith(String prefix)는 동일하게 검색을 수행하는 메서드로, 공통된 역할을 수행하는 match(String str, boolean isWord)를 먼저 만들어준다.            전역 변수인 root를 지역 변수인 node에 복사해준다.                    주어진 root를 점층적으로 내려가며 단어를 검색 할 때, 기존 값들을 보호하기 위해서 node에 복사하여 node를 변경하며 수행하는 것이다.                       주어진 str을 한 문자씩 반복하여 해당 문자열이 존재하는지 탐색한다.                    주어진 str의 idx번째 문자에서 ‘a’를 빼 0(a) ~ 25(z)까지 숫자를 num에 넣어준다.           node.children의 num번째 TrieNode가 null인 경우, 해당 문자열이 존재하지 않으므로 false를 반환한다.           node에 node.children[num]을 넣어 이후 문자들을 계속 탐색한다.                       반복이 완료되면 isWord에 따라 각 값을 반환한다.                    isWord가 true인 경우, node.isWord의 값을 통해 입력된 값인지 여부를 반환한다.           isWord가 false인 경우, 입력된 값인지 여부에 상관없이 true를 반환한다.                           주어진 메서드인 search(String word)를 완성한다.            6번에서 완성한 match(String str, boolean isWord)를 이용하여, isWord를 true로 줌으로써 입력된 값이 존재하는지 여부를 반환한다.           주어진 메서드인 startsWith(String prefix)를 완성한다.            6번에서 완성한 match(String str, boolean isWord)를 이용하여, isWord를 false로 줌으로써 입력된 값인지 유무에 상관없이 존재하는지 여부를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/implement-trie-prefix-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Size Subarray Sum",
        "excerpt":"문제  Link   코드  class Solution {      public int minSubArrayLen(int target, int[] nums) {     int length = nums.length;     int result = length + 1;     int index = 0;     for (int i = 0; i &lt; length; i++) {       target -= nums[i];       while (target &lt;= 0) {         result = Math.min(result, i - index + 1);         target += nums[index++];       }     }     return result % (length + 1);   }  }   결과  Link   설명          주어진 배열 nums를 이용하여 부분 배열을 만들고 해당 값들의 합이 주어진 정수 target이 되기 위한 최소 배열 크기를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 주어진 배열 nums의 크기를 저장한 변수로 nums.length로 정의한다.       result는 결과를 구하기 위한 변수로 $length + 1$로 정의한다.       index는 부분 배열의 마지막 위치를 지정할 인덱스로, 0으로 정의한다.           nums를 반복하여 target이 되는 최소 배열 크기를 구한다.            target에 nums[i]값을 빼준다.       target이 0 이상이 될 때 까지 아래를 수행한다.                    result에 부분 배열의 합이 target이 되는 최소 배열의 크기인 result와 $i - index + 1$ 중 작은 값을 넣어준다.           target에 nums[index] 값을 더해 이전 값으로 돌려주어 최소 배열의 크기를 다시 계산할 수 있도록 초기화한다.                           반복이 완료되면 result에 $length + 1$을 나눈 나머지 값을 주어진 문제의 결과로 반환한다.            result가 $length + 1$이 되는 경우, 모든 값을 더해도 target이 완성되지 않는 경우이다.       위의 경우, result가 초기 값인 $length + 1$이 되므로 0을 반환하기 위한 예외 처리이다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-size-subarray-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Course Schedule II",
        "excerpt":"문제  Link   코드  class Solution {      public int[] findOrder(int numCourses, int[][] prerequisites) {     List&lt;Integer&gt;[] graph = new ArrayList[numCourses];     int[] courses = new int[numCourses];     for (int i = 0; i &lt; numCourses; i++) {       graph[i] = new ArrayList&lt;&gt;();     }     for (int[] req : prerequisites) {       courses[req[0]]++;       graph[req[1]].add(req[0]);     }     int index = 0;     int[] result = new int[numCourses];     Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();     for (int i = 0; i &lt; numCourses; i++) {       if (courses[i] == 0) {         queue.add(i);         result[index++] = i;       }     }     while (!queue.isEmpty()) {       int cur = queue.poll();       for (int course : graph[cur]) {         if (--courses[course] == 0) {           queue.add(course);           result[index++] = course;         }       }     }     return index == numCourses ? result : new int[0];   }  }   결과  Link   설명     지난번 Course Schedule과 유사하지만, 주어진 정수 numCourses는 수강해야 하는 총 과목 수로, 주어진 2차원 배열 prerequisites를 이용하여 수료 가능한 과목 번호를 찾는 문제이다.            prerequisites은 각 과목 정보를 [과목 번호, 선행 과목 번호]로 담고 있으며, 이는 해당 과목을 수료하기 위해선 선행 과목을 수료해야 함을 나타낸다.           문제 풀이에 필요한 변수를 정의한다.            graph는 선행 과목을 수료했을 경우 수강 가능한 과목 번호를 저장할 컬렉션의 배열이다.       courses는 과목 존재 여부에 대한 정보를 담은 배열이다.                0부터 numCourses 전까지 반복하여 graph에 ArrayList를 다 넣어준다.       문제 풀이에 필요한 추가 변수를 정의한다.            index는 아래의 result 배열에 과목 번호를 담을 위치를 지정한다.       result는 수료 가능한 과목 번호를 담을 배열로, numCourses 크기로 정의한다.       queue는 수료 가능한 과목 번호를 임시로 담을 큐이다.           courses 배열을 처음부터 끝까지 반복하여 courses[i]의 값이 0일 경우만 아래를 수행한다.            queue와 result[index]에 i를 넣어주고 index는 증가시킨다.           queue의 값들을 모두 사용할 때 까지 반복하여 아래를 수행한다.            queue에 저장된 값을 꺼내와 graph의 해당 값인 수료 가능한 과목 번호를 각 course로 정의하여 아래를 반복한다.       courses[course]의 값을 1 감소시킨 결과가 0인 경우 해당 course 수행 이후 다음 수료 과목을 탐색해야 하므로, queue에 다시 course 값을 넣어준다.       result의 index번째 값에 course 값을 넣어주고, index를 증가시킨다.           index와 numCourses의 값들이 동일한지를 검증하여 결과를 반환한다.            index와 numCourses의 값들이 동일하면, 수료 가능한 과목들을 모두 채운 result를 주어진 문제의 결과로 반환한다.       index와 numCourses의 값들이 동일하지 않으면, 수료 가능한 과목들을 모두 채우지 못하므로 새로운 배열을 만들어 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/course-schedule-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Design Add and Search Words Data Structure",
        "excerpt":"문제  Link   코드  class WordDictionary {    private TrieNode root;    public WordDictionary() {     this.root = new TrieNode();   }    public void addWord(String word) {     TrieNode node = root;     for (int idx = 0; idx &lt; word.length(); idx++) {       int num = word.charAt(idx) - 'a';       if (node.children[num] == null) {         node.children[num] = new TrieNode();       }       node = node.children[num];     }     node.isWord = true;   }    public boolean search(String word) {     return this.match(root, word.toCharArray(), 0);   }    private boolean match(TrieNode node, char[] charArray, int index) {     if (index == charArray.length) {       return node.isWord;     }     if (charArray[index] == '.') {       for (int idx = 0; idx &lt; node.children.length; idx++) {         if (node.children[idx] != null &amp;&amp; this.match(node.children[idx], charArray, index + 1)) {           return true;         }       }     } else {       int num = charArray[index] - 'a';       return node.children[num] != null &amp;&amp; this.match(node.children[num], charArray, index + 1);     }     return false;   }  }  class TrieNode {    public boolean isWord;   public TrieNode[] children;    public TrieNode() {     this.children = new TrieNode[26];   }  }  /**  * Your WordDictionary object will be instantiated and called as such:  * WordDictionary obj = new WordDictionary();  * obj.addWord(word);  * boolean param_2 = obj.search(word);  */   결과  Link   설명     지난번 Implement Trie (Prefix Tree)와 유사한 문제로, WordDictionary 클래스를 완성하는 문제이다.            단, 주어진 문자열 word에 “.”이 들어간 경우, 어느 문자열이 들어와도 상관이 없다.       생성자인 WordDictionary()는 WordDictionary 객체를 초기화 한다.       메서드인 addWord(word)는 주어진 문자열 word를 WordDictionary 객체에 저장한다.       메서드인 search(word)는 주어진 문자열 word가 WordDictionary 객체에 주입된 문자열 중 존재하는지 유무를 반환한다.           문제 풀이에 필요한 TrieNode 클래스를 정의한다.            isWord는 해당 단어까지의 문자열이 단어로 존재하는지 여부를 저장하는 변수이다.       children은 해당 단어까지의 문자열 이후의 문자열을 이어주기 위한 변수로, 객체 생성 시 다음 문자를 저장하기 위해 알파벳의 개수인 26 크기의 TrieNode 배열로 초기화 한다.           문제 풀이에 필요한 변수를 정의한다.            root는 주어진 문제를 Trie를 이용하여 풀기위해, Trie의 가장 최상위 노드를 저장하기 위한 변수이다.           주어진 생성자인 WordDictionary()를 완성한다.            전역 변수인 TreeNode인 root를 초기화 시켜 순차적인 문자열 입력이 가능하도록 한다.           주어진 메서드인 addWord(word)를 완성한다.            전역 변수인 root를 지역 변수인 node에 복사해준다.                    주어진 root를 점층적으로 내려가며 단어의 완성을 할 때, 기존 값들을 보호하기 위해서 node에 복사하여 node를 변경하며 수행하는 것이다.                       주어진 word를 한 문자씩 반복하여 node 아래로 문자열을 TrieNode에 연결시켜준다.                    주어진 word의 idx번째 문자에서 ‘a’를 빼 0(a) ~ 25(z))까지 숫자를 num에 넣어준다.           node.children의 num번째 TrieNode가 null인 경우, 하위 문자열을 이어주기 위해서 새 TrieNode를 넣어준다.           node에 node.children[num]을 넣어 이후 문자들을 이용하여 Trie를 완성한다.                       반복이 완료되면 마지막 TrieNode의 isWord를 true로 바꾸어 해당 문자열까지 입력된 단어임을 체크해준다.           주어진 메서드인 search(word)를 완성하려면 “.”인 경우 node.children을 전체 순회해야 하기 때문에, 재귀 호출을 위한 match(node, charArray, index)를 먼저 완성한다.            index가 charArray.length와 동일한 경우 검색 문자열의 마지막이기 때문에, 주입된 문자열인지 여부를 저장하는 node.isWord를 반환한다.       charArray[index]의 값이 “.”인 경우, 아래를 수행한다.                    node.children을 모두 확인하여 node.children[idx]이 존재하는 경우를 우선 확인한다.           이후 재귀 호출을 이용하여 이후 문자열들이 존재하고 주입된 문자열인 경우, true를 반환한다.                       charArray[index]의 값이 “.”이 아닌 경우, 아래를 수행한다.                    지역 변수 num을 정의하여 반복 사용되는 $charArray[index] - ‘a’$를 넣어준다.           node.children을 모두 확인하여 node.children[num]이 존재하는 경우를 우선 확인한다.           이후 재귀 호출을 이용하여 이후 문자열들이 존재하고 주입된 문자열인지 확인하여 해당 결과를 반환한다.                       그 외의 경우 주입된 문자열 중에 word가 존재하지 않는다는 의미이므로, false를 반환한다.           주어진 메서드인 search(word)를 완성한다.            6에서 완성한 match(node, charArray, index) 메서드를 이용하여 첫 문자열부터 확인하기 위해 index를 0부터 검색한 결과를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/design-add-and-search-words-data-structure/",
        "teaser": null
      },{
        "title": "Leetcode Java Word Search II",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; findWords(char[][] board, String[] words) {     List&lt;String&gt; result = new ArrayList&lt;&gt;();     TrieNode root = this.initTrieNode(words);     for (int i = 0; i &lt; board.length; i++) {       for (int j = 0; j &lt; board[i].length; j++) {         this.dfs(board, i, j, root, result);       }     }     return result;   }    private void dfs(char[][] board, int i, int j, TrieNode node, List&lt;String&gt; result) {     char c = board[i][j];     int num = c - 'a';     if (c == '.' || node.children[num] == null) {       return;     }     node = node.children[num];     if (node.word != null) {       result.add(node.word);       node.word = null;     }     board[i][j] = '.';     if (i &gt; 0) {       this.dfs(board, i - 1, j, node, result);     }     if (j &gt; 0) {       this.dfs(board, i, j - 1, node, result);     }     if (i &lt; board.length - 1) {       this.dfs(board, i + 1, j, node, result);     }     if (j &lt; board[0].length - 1) {       this.dfs(board, i, j + 1, node, result);     }     board[i][j] = c;   }    private TrieNode initTrieNode(String[] words) {     TrieNode root = new TrieNode();     for (String word : words) {       TrieNode node = root;       for (char c : word.toCharArray()) {         int num = c - 'a';         if (node.children[num] == null) {           node.children[num] = new TrieNode();         }         node = node.children[num];       }       node.word = word;     }     return root;   }  }  class TrieNode {    public String word;   public TrieNode[] children;    public TrieNode() {     this.children = new TrieNode[26];   }  }   결과  Link   설명          주어진 2차원 배열 board를 이용하여 인접한 문자들의 조합이 주어진 배열 words에 있는 단어 중 만들 수 있는 단어들을 찾는 문제이다.       문제 풀이에 필요한 TrieNode 클래스를 정의한다.            word는 주어진 단어를 이용하여 TrieNode를 완성하고, 마지막 TrieNode에 해당 단어를 저장하기 위한 변수이다.       children은 해당 단어까지의 문자열 이후의 문자열을 이어주기 위한 변수로, 객체 생성 시 다음 문자를 저장하기 위해 알파벳의 개수인 26 크기의 TrieNode 배열로 초기화 한다.           주어진 단어들인 words를 이용하여 Trie를 완성한다.            Trie를 만들기 위해 최상위 TrieNode인 root를 정의한다.       주어진 단어들인 words를 반복하여 TrieNode를 만들어준다.                    전역 변수인 root를 지역 변수인 node에 복사해준다.                                 주어진 root를 점층적으로 내려가며 단어의 완성을 할 때, 기존 값들을 보호하기 위해서 node에 복사하여 node를 변경하며 수행하는 것이다.       - 주어진 word를 한 문자씩 반복하여 node 아래로 문자열을 TrieNode에 연결시켜준다.       주어진 word의 idx번째 문자에서 ‘a’를 빼 0(a) ~ 25(z))까지 숫자를 num에 넣어준다.       node.children의 num번째 TrieNode가 null인 경우, 하위 문자열을 이어주기 위해서 새 TrieNode를 넣어준다.       node에 node.children[num]을 넣어 이후 문자들을 이용하여 Trie를 완성한다.       - 반복이 완료되면 마지막 TrieNode의 word에 해당 단어를 넣어준다.           2차원 배열인 board를 반복하여 모든 위치에서 주어진 word를 만들 수 있는지를 검증하여 가능한 단어들만 result에 넣어준다.            board[i][j]의 문자를 c, c - ‘a’를 num 변수에 넣어준다.       c가 ‘.’인 경우 해당 문자의 위치는 검증이 시작된 자리이고, node.children[num]이 null인 경우 주어진 문자에 존재하지 않으므로 수행을 중단한다.       node에 node.children[num]을 넣어주고, node.word가 null이 아니면 주어진 words에 포함된 단어이므로 result에 넣어주고 node.word를 null로 변환하여 중복으로 들어가지 않도록 한다.       board[i][j]를 ‘.’으로 바꾸어 해당 문자열 검증의 시작 위치임을 표시해준다.       board[i][j]를 기준으로 상하좌우 네 방향으로 재귀 호출을 수행하여 문자열 검증을 진행한다.       검증이 완료된 이후 board[i][j]에 c를 넣어 원래 상태의 board로 복구한다.           반복이 완료되면 주어진 배열인 words에 있는 단어들 중 주어진 2차원 배열 board를 이용하여 만들 수 있는 단어들만 추려낸 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/word-search-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java House Robber II",
        "excerpt":"문제  Link   코드  class Solution {    public int rob(int[] nums) {     if (nums.length == 1) {       return nums[0];     } else {       return Math.max(this.getMax(nums, 0), this.getMax(nums, 1));     }   }    private int getMax(int[] nums, int start) {     int pre = 0;     int cur = 0;     for (int i = start; i &lt; nums.length + start - 1; i++) {       int temp = cur;       cur = Math.max(pre + nums[i], cur);       pre = temp;     }     return cur;   }  }   결과  Link   설명     지난번 House Robber와 유사한 문제로, 주어진 정수 배열 nums를 이용하여 인접하지 않은 값들의 합이 가장 큰 값을 찾는 문제이다.            단, 주어진 배열 nums의 처음 값과 마지막 값은 인접하다고 판단한다.                주어진 배열 nums의 길이가 1이면 값이 하나밖에 없으므로 최댓값인 nums[0]을 주어진 문제의 결과로 반환한다.       그 외의 경우 첫 값을 제외한 경우와, 마지막 값을 제외한 경우 중 가장 큰 값을 주어진 문제의 결과로 반환한다.            문제의 조건 중 처음 값과 마지막 값이 인접하다는 조건이 있으므로, 첫 값을 제외한 경우와 마지막 값을 제외한 경우의 두 경우를 확인하는 것이다.       이전까지 최댓값을 저장할 변수인 pre와 현재의 최댓값을 저장할 변수인 cur을 정의한다.       start부터 $nums.length + start - 1$까지 반복하여 아래를 수행한다.                    지역 변수인 temp를 정의하여 cur의 값을 임시 저장시킨다.           cur에 $pre + nums[i]$와 cur의 값 중 큰 값을 넣어 인접하지 않은 값들의 최댓값을 저장시킨다.           pre에 그 전까지 최댓값이었던 temp 값을 넣어주고 반복을 계속 수행한다.                       반복이 완료되면 최댓값을 저장한 cur을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/house-robber-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Shortest Palindrome",
        "excerpt":"문제  Link   코드  class Solution {    public String shortestPalindrome(String s) {     int start = 0;     for (int end = s.length() - 1; end &gt;= 0; end--) {       if (s.charAt(start) == s.charAt(end)) {         start++;       }     }     if (start == s.length()) {       return s;     }     String str = s.substring(start);     return new StringBuilder(str)         .reverse()         .append(this.shortestPalindrome(s.substring(0, start)))         .append(str)         .toString();   }  }   결과  Link   설명          주어진 문자열 s를 이용하여 최소 크기의 회문(앞뒤로 동일한 문자열)을 만드는 문제이다.       지역 변수 start를 0으로 정의하고, 문자열 s를 마지막 자리부터 첫 자리까지 반복하여 회문이 되는 구간을 찾는다.            s의 start번째 문자와 s의 end번째 문자가 동일하다면 start를 증가시켜 회문이 되는 문자열의 구간을 확인한다.                반복이 완료되고 start와 주어진 문자열 s의 길이가 동일한 경우, s가 회문이므로 s를 주어진 문제의 결과로 반환한다.       지역 변수 str을 주어진 문자열 s의 start 위치의 문자 부터 마지막 문자까지 잘라 넣어준다.            구해진 start 위치의 문자부터 마지막 문자는 회문이 되는 문자열을 제외한 문자로, 접두와 접미에 넣어줄 문자를 임시 보관한다.           새 StringBuilder를 정의하여 str과 재귀 호출을 이용하여 회문을 만들어 주어진 문제의 결과로 반환한다.            동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.       빈 StringBuilder에 str을 넣고, 문자열의 앞뒤를 반전시켜준다.                    회문을 만들기 위해 회문이 되는 구간을 제외한 나머지 문자열을 앞뒤로 넣어주기 위해서, 처음 들어가는 접두 부분은 반전시켜 넣어준다.                       주어진 문자열 s의 첫 문자부터 start 위치의 문자까지 문자열을 이용하여 재귀 호출을 수행하고, 해당 결과를 위의 문자열에 이어준다.                    재귀 호출을 통해 회문이 되는 문자열을 검증하여 문자열을 이어주기 위함이다.                       마지막으로 다시 str을 넣고, 문자열로 변경하여 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/shortest-palindrome/",
        "teaser": null
      },{
        "title": "Leetcode Java Kth Largest Element in an Array",
        "excerpt":"문제  Link   코드  class Solution {    public int findKthLargest(int[] nums, int k) {     Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();     for (int num : nums) {       queue.add(num);       if (queue.size() &gt; k) {         queue.poll();       }     }     return queue.poll();   }  }   결과  Link   설명          주어진 정수 배열 nums의 k번째 큰 숫자를 찾아 반환하는 문제이다.       숫자를 순위를 지정하여 저장하고 활용하기 위해서 PriorityQueue를 정의한다.            PriorityQueue는 기본적으로 낮은 숫자가 우선적으로 정렬되어 관리과 되며, 기존 Queue의 FILO방식이 아니다.                    예를 들어, 아래와 같이 3 -&gt; 1 순으로 넣으면 1 -&gt; 3 순으로 나오게 된다.             Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); queue.add(3); queue.add(1); System.out.println(queue.poll()); // 1 System.out.println(queue.poll()); // 3                                   하지만, 반대의 순서도 가능하다.             Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(Collections.reverseOrder()); queue.add(3); queue.add(1); System.out.println(queue.poll()); // 3 System.out.println(queue.poll()); // 1                                               위의 PriorityQueue의 특성으로 Queue의 크기를 k까지 관리하면, k번째로 큰 값은 Queue의 가장 앞에 저장이 되게 된다.           주어진 배열인 nums의 값들을 반복하여 Queue에 값들을 넣어 크기를 관리한다.            queue에 nums에 속한 숫자인 num을 넣어준다.       queue의 크기가 k보다 크게 되면, queue.poll()을 통해서 Queue 내의 가장 작은 값을 빼고 반복을 계속 수행한다.           반복이 완료되면 주어진 배열인 nums의 가장 큰 k번째 값까지 저장된 queue에서 가장 작은 숫자인 k번째 큰 값을 빼서 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/kth-largest-element-in-an-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Combination Sum III",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     this.getCombination(result, new ArrayList&lt;&gt;(), k, n, 1);     return result;   }    private void getCombination(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; list, int size, int target, int start) {     if (list.size() &gt; size || target &lt; 0) {       return;     } else if (list.size() == size &amp;&amp; target == 0) {       result.add(new ArrayList&lt;&gt;(list));     } else {       for (int idx = start; idx &lt; 10; idx++) {         list.add(idx);         this.getCombination(result, list, size, target - idx, idx + 1);         list.remove(list.size() - 1);       }     }   }  }   결과  Link   설명     주어진 정수인 k 크기의 컬렉션으로 해당 내 값들의 합이 주어진 정수인 n이 되기까지의 조합을 모두 찾는 문제이다.            단, 배열 내의 값은 1 ~ 9 까지의 숫자만 허용이 된다.           결과를 넣을 컬렉션인 result를 선언하고, 새 컬렉션을 정의하여 result에 크기가 k이고, 합이 n인 조합을 모두 넣어준다.            list의 크기가 size를 초과하고 target이 0보다 작으면, 주어진 문제의 결과의 대상이 되지 않으므로 무시한다.       list의 크기가 size와 동일하고 target이 0과 같으면, 주어진 문제의 결과의 대상이 되므로, result에 새 컬렉션을 정의하여 넣어준다.       그 외의 경우는 주어진 문제의 결과를 구하기 위한 과정이므로, start부터 10 미만까지 반복하여 탐색을 진행한다.                    list에 idx 값을 넣어주고, 재귀 호출을 이용하여 target에 $target - idx$값을, start에 $idx + 1$을 넣어 결과 탐색을 계속 진행한다.           재귀 호출이 끝나면, 마지막으로 넣어준 idx 값을 제거하기 위해 list의 마지막 값을 제거해주고 반복을 계속 진행한다.                           합이 n이 되기 위한 k크기의 조합을 모두 넣은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/combination-sum-iii/",
        "teaser": null
      },{
        "title": "Leetcode Java Contains Duplicate",
        "excerpt":"문제  Link   코드  class Solution {    public boolean containsDuplicate(int[] nums) {     Set&lt;Integer&gt; set = new HashSet&lt;&gt;();     for (int num : nums) {       if (!set.add(num)) {         return true;       }     }     return false;   }  }   결과  Link   설명          주어진 배열 nums 중 중복된 값이 있는지 검증하는 문제이다.            Set은 중복을 배제한 값을 저장하는 컬렉션으로, 주어진 문제를 검증하기 위해 변수 set을 정의한다.       nums를 반복하여 주어진 nums 중 중복된 값이 있는지 검증한다.            set에 nums의 값들을 넣을 때 중복된 값이 있으면 true를 주어진 문제의 결과로 반환한다.           반복이 완료되면 중복된 값이 없으므로 false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/contains-duplicate/",
        "teaser": null
      },{
        "title": "Leetcode Java The Skyline Problem",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; getSkyline(int[][] buildings) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     Queue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;((a, b) -&gt; b[2] - a[2]);     int index = 0;     int[] building = null;     while (building != null || index &lt; buildings.length) {       if (building == null) {         building = buildings[index];         this.addPoint(result, building[0], building[2]);       } else if (index &lt; buildings.length &amp;&amp; buildings[index][0] &lt;= building[1]) {         if (buildings[index][2] &gt; building[2]) {           if (buildings[index][0] == building[0]) {             result.remove(result.size() - 1);           }           if (buildings[index][1] &lt;= building[1]) {             queue.add(building);           }           building = buildings[index];           this.addPoint(result, building[0], building[2]);         } else if (buildings[index][1] &gt; building[1]) {           queue.add(buildings[index]);         }         index++;       } else {         int[] lower = queue.poll();         while (lower != null &amp;&amp; lower[1] &lt;= building[1]) {           lower = queue.poll();         }         if (lower == null) {           this.addPoint(result, building[1], 0);         } else if (lower[2] &lt; building[2]) {           this.addPoint(result, building[1], lower[2]);         }         building = lower;       }     }     return result;   }    private void addPoint(List&lt;List&lt;Integer&gt;&gt; result, int point, int height) {     List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();     temp.add(point);     temp.add(height);     result.add(temp);   }  }   결과  Link   설명     주어진 배열인 buildings를 이용하여 x축(point)이 중복되지 않은 y축(height)의 값들을 배열로 넣어 반환하는 문제이다.            buildings 배열은 [left, right, height]의 세 값이 존재한다.                    left는 건물의 좌측 가장자리에 해당하는 x축 값이다.           right는 건물의 우측 가장자리에 해당하는 x축 값이다.           height는 건물의 높이로 y축 값이다.                           문제 풀이에 필요한 변수를 정의한다.            result는 x축(point)이 중복되지 않은 y축(height)의 값들을 넣기 위한 컬렉션이다.       queue는 building의 값을 저장할 Queue로, 넣은 빌딩의 정보를 높이 순으로 활용하기 위해 PriorityQueue를 사용한다.       index는 buildings 배열을 순차적으로 활용하기 위한 인덱스로 0으로 초기화한다.       building은 buildings 배열의 값을 넣기 위한 변수이다.                buiding이 null이 아니거나 index가 buildings.length보다 작을 때 까지 반복하여 모든 result에 중복되지 않은 x축(point)과 y축(height)을 찾아 넣어준다.            building이 null인 경우, buildings[index]를 building에 넣어주고 result에 x축과 y축의 정보를 컬렉션으로 넣어준다.       index가 buildings.length보다 작아 아직 결과 탐색이 가능하고 buildings[index][0]의 값이 building[1]이 커서 x축이 겹치지 않은 건물이므로 아래를 수행한다.            buildings[index][2]의 값이 building[2]의 값보다 크면, 기존 건물보다 높은 건물이므로 아래를 수행한다.                    buildings[index][0]의 값이 building[0]의 값이 동일한 경우, 건물의 시작 위치가 동일하므로 building의 값으로 들어간 result의 마지막 값을 제거해준다.           buildings[index][1]의 값이 building[1]의 값보다 작거나 같으면, 건물의 종료 위치가 building이 더 이후이므로 queue에 building을 넣어준다.           building에 buildings[index]의 값을 넣어 반복을 계속 수행한다.                       buildings[index][1]의 값이 building[1]의 값보다 크면, building보다 건물의 종료 위치가 더 이후이므로 queue에 buildings[index]를 넣어 반복을 계속 수행한다.       building의 index번째 값을 사용했으므로, index를 증가시키고 반복을 계속 수행한다.           그 외의 경우, queue의 값을 이용하여 result에 point를 넣어준다.            lower에 queue에 있는 값을 빼서 넣어준다.       lower이 null이 아니고 lower[1]의 값이 building[1]의 값보다 작거나 같을 때 까지 queue의 값을 lower에 넣어준다.       lower이 null인지 검증하여 result에 값을 넣어준다.                    lower이 null인 경우, result에 building[1]의 값과 0을 이용하여 컬렉션을 만들어 넣어준다.           lower이 null이 아닌 경우, building[1]의 값과 lower[2]의 값을 이용하여 컬렉션을 만들어 넣어준다.                       building에 lower 값을 넣어주고 반복을 계속 수행한다.           반복이 완료되면 x축(point)이 중복되지 않은 y축(height)의 값들을 넣은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/the-skyline-problem/",
        "teaser": null
      },{
        "title": "Leetcode Java Contains Duplicate II",
        "excerpt":"문제  Link   코드  class Solution {    public boolean containsNearbyDuplicate(int[] nums, int k) {     Set&lt;Integer&gt; set = new HashSet&lt;&gt;();     for (int idx = 0; idx &lt; nums.length; idx++) {       if (idx &gt; k) {         set.remove(nums[idx - k - 1]);       }       if (!set.add(nums[idx])) {         return true;       }     }     return false;   }  }   결과  Link   설명          주어진 배열 nums의 내부 값 중 임의 동일한 두 값이 배열 내 k 거리안에 존재하는지를 확인하는 문제이다.            k번째 거리까지 값을 넣어 검증에 사용하기 위한 set을 정의한다.       반복을 통해 nums의 모든 값을 탐색하여 1번에서 이야기한 조건에 충족하는지를 검증한다.            idx가 k보다 크게 되면 조건의 범위에서 벗어난 nums[$idx - k - 1$] 값을 set에서 제거한다.       set에 nums[idx] 값을 추가할 때 해당 값이 set에 존재하는 경우, true를 주어진 문제의 결과로 반환한다.           반복이 끝나면 조건에 충족한 값이 존재하지 않으므로, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/contains-duplicate-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Contains Duplicate III",
        "excerpt":"문제  Link   코드  class Solution {    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {     if (nums.length == 0 || k == 0) {       return false;     } else if (t == 0) {       return this.containsNearbyDuplicate(nums, k);     } else {       Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;();       for (int idx = 0; idx &lt; nums.length; idx++) {         Long key = (long)(nums[idx] / t) - (nums[idx] &lt; 0 ? 1 : 0);         if (map.get(key) != null             || ((map.get(key - 1) != null &amp;&amp; nums[idx] - map.get(key - 1) &lt;= t))             || ((map.get(key + 1) != null &amp;&amp; map.get(key + 1) - nums[idx] &lt;= t))) {           return true;         }         map.put(key, nums[idx]);         if (idx &gt;= k) {           map.remove((long) nums[idx - k] / t);         }       }       return false;     }   }    private boolean containsNearbyDuplicate(int[] nums, int k) {     Set&lt;Integer&gt; set = new HashSet&lt;&gt;();     for (int idx = 0; idx &lt; nums.length; idx++) {       if (idx &gt; k) {         set.remove(nums[idx - k - 1]);       }       if (!set.add(nums[idx])) {         return true;       }     }     return false;   }  }   결과  Link   설명          지난 번 Contains Duplicate II와 비슷한 문제로, 주어진 배열 nums의 내부 값 중 임의 두 값의 차이가 t가 나는 값이 배열 내 k 거리안에 존재하는지를 확인하는 문제이다.            주어진 배열 nums에 값이 없거나 k가 0인 경우, 문제 풀이가 불가능하므로 false를 주어진 문제의 결과로 반환한다.            t가 0인 경우 위에서 이야기한 지난 번 문제(Contains Duplicate II)와 동일한 문제이므로, 두 값의 동일한 값이 k번째에 있는지 검증 결과를 주어진 문제의 결과로 반환한다.       그 외의 경우 아래를 통해 검증하고 해당 결과를 주어진 문제의 결과로 반환한다.            값을 임시로 저장하기 위해 map을 정의한다.       주어진 배열 nums를 반복하여 문제를 검증한다.       key는 map의 key로 사용하기 위해 $\\frac{nums[idx]}{t}$의 값에 음수인 경우 1을 빼준 값을 넣어준다.       아래 조건을 충족하면 true를 주어진 문제의 결과로 반환한다.                    map에 key 값이 존재하면 두 값의 차이가 t 미만으로 조건을 충족한다.           $key - 1$의 값이 존재하고, $nums[idx] - map.get(key - 1)$의 값이 t 이하이면 nums[idx]의 값이 map에 있는 $key - 1$ 키의 값보다 크면서 두 값의 차이가 t 이하이므로 조건을 충족한다.           $key + 1$의 값이 존재하고, $map.get(key + 1) - nums[idx]$의 값이 t 이하이면 map에 있는 $key - 1$ 키의 값이 nums[idx]의 값보다 크면서 두 값의 차이가 t 이하이므로 조건을 충족한다.                       위의 경우가 아니면, map에 key를 이용하여 nums[idx]의 값을 넣어준다.       idx가 k보다 커지게 되면, map에서 조건 범위를 벗어나는 $\\frac{nums[idx - k]}{t}$가 key인 값을 제거해준다.           반복이 종료되면 해당 조건을 충족하지 못하므로 false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/contains-duplicate-iii/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximal Square",
        "excerpt":"문제  Link   코드  class Solution {    public int maximalSquare(char[][] matrix) {     int max = 0;     int row = matrix.length;     int col = matrix[0].length;     int[][] dp = new int[row + 1][col + 1];     for (int i = 0; i &lt; row; i++) {       for (int j = 0; j &lt; col; j++) {         if (matrix[i][j] == '1') {           dp[i + 1][j + 1] = Math.min(dp[i][j], Math.min(dp[i][j + 1], dp[i + 1][j])) + 1;           max = Math.max(max, dp[i + 1][j + 1]);         }       }     }     return max * max;   }  }   결과  Link   설명          주어진 2차원 배열 matrix를 이용하여 정사각형 모양인 1로 구성된 부분 배열의 최대 크기를 찾는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            max는 1로 이루어진 부분 배열의 최대 길이를 저장하기 위한 변수로, 0으로 초기화한다.       row는 matrix 행의 개수를 저장한다.       col는 matrix 열의 개수를 저장한다.       dp는 1로 이루어진 부분 배열의 최대 크기를 구하기 위한 DP로, 크기를 matrix보다 하나 큰 [$row + 1$][$col + 1$]로 초기화한다.           matrix를 순회하여 dp를 이용하여 max의 값을 넣어준다.            matrix[i][j]의 값이 ‘1’인 경우 아래를 수행한다.                    dp[$i + 1$][$j + 1$]에 dp[i][j], dp[i][$j + 1$], dp[$i + 1$][j] 값 중 가장 작은 값을 찾아 해당 부분 배열이 동일한 값인지를 검증하고 1을 더한 값을 넣어준다.           max에 max와 dp[$i + 1$][$j + 1$] 값 중 큰 값을 넣어 정사각형 모양인 1로 구성된 부분 배열 한 변의 길이를 넣어준다.                           반복이 완료되면 정사각형 모양인 1로 구성된 부분 배열 한 변의 길이를 저장한 max를 이용하여 $max \\times max$를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximal-square/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Complete Tree Nodes",
        "excerpt":"문제  Link   코드  class Solution {  //  Default //  public int countNodes(TreeNode root) { //    return root == null ? 0 : 1 + this.countNodes(root.left) + this.countNodes(root.right); //  }    public int countNodes(TreeNode root) {     int depth = this.getDepth(root);     if (depth == -1) {       return 0;     } else {       if (this.getDepth(root.right) == depth - 1) {         return (1 &lt;&lt; depth) + this.countNodes(root.right);       } else {         return (1 &lt;&lt; (depth - 1)) + this.countNodes(root.left);       }     }   }    private int getDepth(TreeNode root) {     return root == null ? -1 : 1 + this.getDepth(root.left);   }  }   결과  Link   설명     주어진 Complete binary tree(완전 이진 트리), TreeNode인 root를 이용하여 모든 노드의 숫자를 구하는 문제이다.            단, O(n) 미만의 시간 복잡도로 풀이하여야 한다.       단순히 재귀 호출로 root의 모든 노드를 탐색하여 구하는 주석 처리된 Default의 경우 O(n)의 시간 복잡도이므로 출제된 의도와 상반되게 된다.           depth에 root로 재귀 호출을 사용하여 가장 좌측 노드의 최대 depth를 구해 넣는다.            완전 이진 트리의 경우 기본적으로 마지막 레벨의 모든 노드는 가능한 왼쪽에 존재하므로, 좌측의 TreeNode를 기준으로 계산한다.                depth가 0인 경우, 자식 노드가 없는 경우이므로 0을 반환한다.       depth가 0이 아닌경우, root의 right TreeNode를 이용하여 2번에 사용된 방법으로 최대 depth를 계산하고 $depth - 1$과 동일한지 검증한다.            높이가 x인 이진 트리의 전체 노드의 숫자는 $2^x - 1$로, 비트 연산으로는 $(1 « x) - 1$로 계산이 가능하므로, 아래의 검증에 활용한다.       동일하면 root를 기준으로 우측의 leaf(노드)의 최대 depth가 좌측과 같은 경우이므로, depth까지 노드의 수를 위의 공식으로 계산한 결과에 root의 우측 기준으로 노드를 재귀 호출을 이용하여 모든 노드의 수를 계산한다.                    전체 노드의 숫자에 우측 노드가 없는 노드들의 개수를 감소시킨다.                       동일하지 않으면 root를 기준으로 우측의 leaf(노드)의 최대 depth가 좌측보다 낮은 경우이므로, $depth - 1$까지 노드의 수를 위의 공식으로 계산한 결과에 root의 좌측 기준으로 노드를 재귀 호출을 이용하여 모든 노드의 수를 계산한다.                    $depth - 1$까지 전체 노드의 숫자에 좌측에 남은 노드들을 센다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-complete-tree-nodes/",
        "teaser": null
      },{
        "title": "Leetcode Java Rectangle Area",
        "excerpt":"문제  Link   코드  class Solution {    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) { int left = Math.max(ax1, bx1);     int x = Math.min(ax2, bx2) - Math.max(ax1, bx1);     int y = Math.min(ay2, by2) - Math.max(ay1, by1);     if (x &gt; 0 &amp;&amp; y &gt; 0) {       return ((ax2 - ax1) * (ay2 - ay1)) + ((bx2 - bx1) * (by2 - by1)) - (x * y);     } else {       return ((ax2 - ax1) * (ay2 - ay1)) + ((bx2 - bx1) * (by2 - by1));     }   }  }   결과  Link   설명          주어진 좌표 정보들을 이용하여 a와 b 두 사각형으로 만들어진 2차원 공간의 부피를 구하는 문제이다.       문제를 풀기위한 변수를 정의한다.            x는 ax와 bx의 각 위치를 이용하여 겹쳐진 공간의 x축 길이를 넣어준다.       y는 ay와 by의 각 위치를 이용하여 겹쳐진 공간의 y축 길이를 넣어준다.           x와 y의 길이에 따라 주어진 문제의 결과를 반환한다.            x와 y의 길이가 0보다 클 경우, 사각형 a와 b의 겹쳐진 공간이 존재하므로 사각형 a와 b의 부피의 합에 겹쳐진 공간의 부피인 $x \\times y$의 값을 빼서 주어진 문제의 결과로 반환한다.       x 혹은 y의 길이가 0보다 작을 경우, 사각형 a와 b의 겹쳐진 공간이 존재하지 않으므로, a와 b의 부피의 합을 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/rectangle-area/",
        "teaser": null
      },{
        "title": "Leetcode Java Basic Calculator",
        "excerpt":"문제  Link   코드  class Solution {    public int calculate(String s) {     int result = 0;     int length = s.length();     int sign = 1;     Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();     for (int idx = 0; idx &lt; length; idx++) {       char c = s.charAt(idx);       switch (c) {         case ' ':           break;         case '+':           sign = 1;           break;         case '-':           sign = -1;           break;         case '(':           stack.push(result);           stack.push(sign);           result = 0;           sign = 1;           break;         case ')':           result = result * stack.pop() + stack.pop();           break;         default:           int sum = c - '0';           while (idx &lt; length - 1 &amp;&amp; Character.isDigit(s.charAt(idx + 1))) {             sum = sum * 10 + s.charAt(idx + 1) - '0';             idx++;           }           result += sum * sign;       }     }     return result;   }  }   결과  Link   설명          수학 공식을 문자열로 저장한 s를 계산하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 주어진 문자열 s를 이용하여 계산된 결과를 넣는 변수이다.       length는 주어진 문자열 s의 길이를 저장하는 변수이다.       sign은 덧셈과 뺄셈를 구분하기 위한 변수이다.       stack은 계산에 필요한 숫자를 저장하기 위해 사용하는 변수이다.           주어진 문자열 s를 이용하여 계산을 진행한다.            c에 s의 idx번쨰 문자를 넣어준다.       c가 공백(‘ ‘)인 경우, 무시하고 진행한다.       c가 ‘+’인 경우, sign에 1을, ‘-‘인 경우에 sign에 -1을 넣어준다.       c가 ‘(‘인 경우, stack에 result와 sign을 넣어주고 result를 0으로 sign은 1로 초기화 한다.       c가 ‘)’인 경우, result에 stack에서 꺼낸 값을 곱하고 다음 stack의 값을 더해준다.       그 외에는 c가 숫자인 경우이므로, 아래의 계산을 수행한다.                    sum에 c에 ‘0’의 ASCII 코드 값을 빼서 숫자를 만들어 넣어준다.           idx가 $legnth - 1$ 미만이고, s의 $idx + 1$ 번째 문자가 숫자인 경우 반복하여 sum에 $sum \\times 10$에 s의 $idx + 1$ 번째 문자에 ‘0’의 ASCII 코드 값을 빼서 숫자를 만들어 더한 값을 넣어주고 idx를 증가시킨다.           result에 sum에 sign 값을 곱해서 넣어준다.                           반복이 완료되면 계산된 결과를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/basic-calculator/",
        "teaser": null
      },{
        "title": "Leetcode Java Implement Stack using Queues",
        "excerpt":"문제  Link   코드  class MyStack {    Queue&lt;Integer&gt; main;   Queue&lt;Integer&gt; sub;    public MyStack() {     this.main = new LinkedList&lt;Integer&gt;();     this.sub = new LinkedList&lt;Integer&gt;();   }    public void push(int x) {     while (!this.main.isEmpty()) {       this.sub.add(this.main.poll());     }     this.main.add(x);     while (!this.sub.isEmpty()) {       this.main.add(this.sub.poll());     }    }    public int pop() {     return this.main.poll();   }    public int top() {     return this.main.peek();   }    public boolean empty() {     return this.main.isEmpty();   }  }  /**  * Your MyStack object will be instantiated and called as such:  * MyStack obj = new MyStack();  * obj.push(x);  * int param_2 = obj.pop();  * int param_3 = obj.top();  * boolean param_4 = obj.empty();  */   결과  Link   설명     queue 2개를 사용하여 LIFO의 stack과 같은 MyStack 클래스를 완성하는 문제이다.            메서드인 push(int x)는 x를 받아 stack의 위에 넣어준다.       메서드인 pop()은 stack의 맨 위에 있는 값을 꺼내 반환한다.       메서드인 top()은 stack의 맨 위에 있는 값을 반환한다.       메서드인 empty() stack이 비어있는지 유무를 반환한다.           문제 풀이에 필요한 변수를 정의한다.            main은 stack처럼 사용하기 위한 queue이다.       sub는 main의 값을 역순으로 넣기 위한 queue이다.           주어진 생성자인 MyStack()를 완성한다.            main과 sub에 LinkedList로 초기화 시켜준다.           주어진 메서드인 push(int x)를 완성한다.            main에 있는 값을 sub에 순차적으로 넣어주고, main에 x를 먼저 넣어준다.       다시 sub에 있는 값을 main에 넣어 순서를 유지시켜준다.       queue의 경우 FIFO이기 때문에, main의 값을 sub로 옮긴 후 main에 주어진 x를 넣고 sub의 값을 main으로 옮기면 LIFO와 같은 효과를 낼 수 있다.           주어진 메서드인 pop()을 완성한다.            main에 있는 첫 값을 꺼내서 반환한다.           주어진 메서드인 top()을 완성한다.            main에 있는 첫 값을 꺼내지 않고 반환한다.           주어진 메서드인 empty()를 완성한다.            main에 비어있는지 여부를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/implement-stack-using-queues/",
        "teaser": null
      },{
        "title": "Leetcode Java Invert Binary Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public TreeNode invertTree(TreeNode root) {     if (root == null) {       return null;     } else if (root.left != null || root.right != null) {       TreeNode left = root.left;       root.left = this.invertTree(root.right);       root.right = this.invertTree(left);     }     return root;   }  }   결과  Link   설명          주어진 TreeNode인 root의 자식 노드들의 좌우 위치를 반대로 바꾸어 주는 문제이다.            root가 null인 경우 끝 노드이므로, null을 반환한다.       root의 left 혹은 right 자식 노드가 존재하는 경우, 아래를 수행하여 좌우 위치를 반대로 바꾸어 준다.            임시 변수인 left를 정의하여 root.left TreeNode를 넣어준다.       root.left에 root.right를 이용하여 재귀 호출을 수행한 결과를 넣어준다.       root.right에 left를 이용하여 재귀 호출을 수행한 결과를 넣어준다.           자식 노드들의 좌우 위치를 반대로 바꾼 root를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/invert-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Basic Calculator II",
        "excerpt":"문제  Link   코드  class Solution {    public int calculate(String s) {     int sum = 0;     int pre = 0;     char sign = '+';     for (int idx = 0; idx &lt; s.length(); idx++) {       char c = s.charAt(idx);       if (c == ' ') {         continue;       } else if (Character.isDigit(c)) {         int num = c - '0';         while (idx &lt; s.length() - 1 &amp;&amp; Character.isDigit(s.charAt(idx + 1))) {           num = num * 10 + (s.charAt(idx + 1) - '0');           idx++;         }         switch (sign) {           case '+':             sum += pre;             pre = num;             break;           case '-':             sum += pre;             pre = -num;             break;           case '*':             pre *= num;             break;           case '/':             pre /= num;             break;         }       } else {         sign = c;       }     }     return sum + pre;   }  }   결과  Link   설명          지난 번 Basic Calculator와 비슷한 문제로, 사칙연산을 이용한 수학 공식이 담긴 문자열 s를 계산하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            sum은 사칙 연산의 결과를 저장하기 위한 변수로, 0으로 초기화 시킨다.       pre는 사칙 연산을 수행할 때 사용되는 두 숫자열 중 앞의 숫자열을 넣어 저장할 변수로, 0으로 초기화 시킨다.       sign은 사칙 연산에 사용되는 기호를 넣어 저장하는 변수로, ‘+’로 초기화 시킨다.                문자열 s의 길이만큼 반복하여 계산을 수행한다.            s의 idx번째 문자가 ‘ ‘(공백)일 경우, 반복을 계속 수행한다.       s의 idx번째 문자가 숫자열인 경우, 아래의 계산을 수행한다.            num에 s의 idx번째 문자를 ‘0’을 뺀 숫자로 변환한 값을 넣어준다.       s의 idx번째 문자 이후가 숫자인 경우 반복하여 num에 10을 곱하고, $idx + 1$번째 문자를 ‘0’을 뺀 숫자로 변환하여 더한 후 idx를 증가시킨다.       반복이 완료되면 sign에 따라 값을 넣어준다.                    ’+’인 경우, sum에 pre를 더해주고, pre에 num을 넣어준다.           ’-‘인 경우, sum에 pre를 더해주고, pre에 -num을 넣어준다.           ‘*‘인 경우, pre에 num을 곱해준다.           ’/’인 경우, pre에 num을 나눠준다.                                그 외인 경우 사칙연산 기호이기 때문에, sing에 s의 idx번째 문자를 넣어준다.       모든 반복이 완료되면 계산된 결과와 중간 값을 저장한 sum과 pre의 합을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/basic-calculator-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Summary Ranges",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; summaryRanges(int[] nums) {     List&lt;String&gt; result = new ArrayList&lt;&gt;();     for (int idx = 0; idx &lt; nums.length; idx++) {       int num = nums[idx];       while (idx &lt; nums.length - 1 &amp;&amp; nums[idx] == nums[idx + 1] - 1) {         idx++;       }       if (num == nums[idx]) {         result.add(String.valueOf(num));       } else {         result.add(String.join(\"-&gt;\", String.valueOf(num), String.valueOf(nums[idx])));       }     }     return result;   }  }   결과  Link   설명     주어진 중복된 정수가 없는 오르참순으로 정렬된 배열인 nums를 이용하여 숫자들의 요약된 범위를 만드는 문제이다.            [a, b]에서 a와 b가 같지 않을 경우, “a-&gt;b”로 표현한다.       [a, b]에서 a와 b가 같은 경우, “a”로 표현한다.       예를 들어 [0, 1, 2, 4, 6, 7]의 경우, [“0-&gt;2”, “4”, “6-&gt;7”]로 표현이 된다.                주어진 문제의 결과를 담기 위해 result를 List로 정의한다.       nums를 반복하여 숫자들의 요약된 범위를 result에 넣어준다.            num에 nums[idx]값을 임시 저장시킨다.       idx가 $nums.length - 1$이하이고, nums[idx]의 값과 $nums[idx + 1] - 1$의 값이 같을 때 까지 idx를 증가시켜 연속된 숫자들을 축약한다.       임시 저장한 num의 값과 nums[idx] 값이 같을 경우, result에 num의 값을 String으로 변환하여 넣어준다.       임시 저장한 num의 값과 nums[idx] 값이 다를 경우, result에 num과 nums[idx]의 값을 이용하여 “num-&gt;nums[idx]”형태로 넣어준다.           반복이 종료되면 숫자들의 요약된 범위를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/summary-ranges/",
        "teaser": null
      },{
        "title": "Leetcode Java Majority Element II",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; majorityElement(int[] nums) {     int[] element = new int[2];     int[] count = new int[2];     for (int num : nums) {       if (element[0] == num) {         count[0]++;       } else if (element[1] == num) {         count[1]++;       } else if (count[0] == 0) {         element[0] = num;         count[0]++;       } else if (count[1] == 0) {         element[1] = num;         count[1]++;       } else {         count[0]--;         count[1]--;       }     }     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     count[0] = count[1] = 0;     for (int num : nums) {       if (element[0] == num) {         count[0]++;       } else if (element[1] == num) {         count[1]++;       }     }     for (int idx = 0; idx &lt; count.length; idx++) {       if (count[idx] &gt; nums.length / 3) {         result.add(element[idx]);       }     }     return result;   }  }   결과  Link   설명     주어진 배열인 nums를 이용하여 nums의 크기를 n이라고 했을 때, $\\frac{n}{3}$ 이상 발생한 숫자를 모두 찾아 반환하는 문제이다.            보이어-무어의 과반수 투표 알고리즘을 기반으로 풀이를 한다.           문제 풀이를 위한 변수를 정의한다.            element는 많이 발생한 두 숫자를 넣어 결과의 후보군을 저장하기 위한 배열이다.       count는 element의 동일한 index번째 숫자의 개수를 저장하기 위한 배열이다.           주어진 배열인 nums를 반복하여 아래를 순차적으로 확인한다.            element[0]의 값과 num이 동일하면, count[0]을 증가시키고 반복을 계속 수행한다.       element[1]의 값과 num이 동일하면, count[1]을 증가시키고 반복을 계속 수행한다.       count[0]이 0인 경우, element[0]에 num을 넣고 count[0]을 증가시키고 반복을 계속 수행한다.       count[1]이 0인 경우, element[1]에 num을 넣고 count[1]을 증가시키고 반복을 계속 수행한다.       그 외의 경우, count[0]과 count[1]을 감소시킨다.                결과를 넣을 컬렉션인 result를 정의하고, count 배열을 0으로 초기화한다.            nums를 다시 반복하여 element에 저장된 후보군들이 nums에 존재하는 개수를 계산한다.            후보군을 저장한 element들의 count가 $\\frac{nums.length}{3}$ 초과인지를 확인하여 result에 넣어준다.       주어진 배열인 nums의 $\\frac{n}{3}$ 이상 발생한 숫자들을 모두 넣은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/majority-element-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Kth Smallest Element in a BST",
        "excerpt":"문제  Link   코드  class Solution {    public int kthSmallest(TreeNode root, int k) {     Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();     while (root != null) {       stack.push(root);       root = root.left;     }     while (k != 0) {       TreeNode n = stack.pop();       if (--k == 0) {         return n.val;       }       TreeNode right = n.right;       while (right != null) {         stack.push(right);         right = right.left;       }     }     return -1;   }  }   결과  Link   설명     주어진 TreeNode인 root에서 k번째로 작은 값을 찾는 문제이다.            root의 자식 노드들 순차적으로 넣을 stack을 정의한다.                root가 null이 되기 전까지 root를 넣고, root에 root의 left Treenode를 넣어준다.       k가 0이 아닐 때 까지 반복하여 k번째로 작은 값을 찾는다.            stack에서 최근 넣은 TreeNode를 꺼내 지역 변수 n에 넣어준다.       k를 감소시킨 값이 0인 경우 n의 val 값이 k번째로 작은 값이므로, n.val의 값을 주어진 문제의 결과로 반환한다.       n의 right TreeNode를 지역 변수 right에 넣어준다.       right가 null이 아닐 때 까지 반복하여 stack에 right를 넣고, 다음으로 right에 right의 left TreeNode를 넣어준다.           반복이 완료되면 해당 값이 존재하지 않으므로, -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/kth-smallest-element-in-a-bst/",
        "teaser": null
      },{
        "title": "Leetcode Java Power of Two",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isPowerOfTwo(int n) {     if (n &gt; 0) {       return (n &amp; (n - 1)) == 0;     } else {       return false;     }   }  }   결과  Link   설명     2를 거듭제곱(Exponentiation)하여 나온 결과가 정수 n이 되는지 검증하는 문제이다.            단, 반복과 재귀 호출을 사용하지 않고 푸는 방식을 요구한다.           n이 0 초과일 경우, 아래의 경우의 따라 주어진 문제의 결과로 반환한다.            n과 $n - 1$의 AND(&amp;) 비트 연산자의 결과가 0인 경우 true를, 아니면 false를 반환한다.                    2의 배수는 2진수로 맨 앞자리가 1이고 뒷자리는 0으로 채워지며, 2의 배수에서 1을 뺀 경우 맨 앞자리가 0이고 뒷자리는 1로 채워지므로 2의 배수와 2의 배수에서 1을 뺀 값의 AND(&amp;) 비트 연산을 수행한 결과는 무조건 0이 될 수 밖에 없다.           간단한 예제로 n이 4인 경우, 4는 2진수로 100, $4 - 1 = 3$이므로 2진수로 011로 표현이 된다.           위의 설명을 토대로 비트 연산을 통해 $100 &amp; 011 = 0$이 된다.                           n이 0 이하일 경우 2의 거듭제곱으로 표현이 불가능하므로, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/power-of-two/",
        "teaser": null
      },{
        "title": "Leetcode Java Implement Queue using Stacks",
        "excerpt":"문제  Link   코드  class MyQueue {    private Stack&lt;Integer&gt; input;   private Stack&lt;Integer&gt; output;    public MyQueue() {     this.input = new Stack&lt;&gt;();     this.output = new Stack&lt;&gt;();   }    public void push(int x) {     this.input.push(x);   }    public int pop() {     this.move();     return this.output.pop();   }    public int peek() {     this.move();     return this.output.peek();   }    public boolean empty() {     return this.input.empty() &amp;&amp; this.output.empty();   }    private void move() {     if (this.output.empty()) {       while (!this.input.empty()) {         this.output.push(this.input.pop());       }     }   }  }  /**  * Your MyQueue object will be instantiated and called as such:  * MyQueue obj = new MyQueue();  * obj.push(x);  * int param_2 = obj.pop();  * int param_3 = obj.peek();  * boolean param_4 = obj.empty();  */   결과  Link   설명     지난 Implement Stack using Queues와 반대되는 문제로, Stack 2개를 사용하여 FIFO의 queue와 같은 MyQueue 클래스를 완성하는 문제이다.            메서드인 push(int x)는 x를 받아 queue에 넣어준다.       메서드인 pop()은 queue의 맨 앞에 있는 값을 꺼내 반환한다.       메서드인 peek()는 queue의 맨 앞에 있는 값을 반환한다.       메서드인 empty()는 queue가 비어있는지 여부를 반환한다.           문제 풀이에 필요한 변수를 정의한다.            input은 값이 들어오면 들어갈 stack이다.       output은 값이 들어온 MyQueue의 값을 반환하기 위한 stack이다.           주어진 생성자인 MyQueue()를 완성한다.            input과 output에 Stack으로 초기화 시켜준다.           주어진 메서드인 push(int x)를 완성한다.            input에 주어진 x 값을 넣어준다.           주어진 메서드인 pop()과 peek()를 사용하기 전에 input의 값을 output으로 이동하기 위한 move() 메서드를 완성한다.            output이 비어있을 경우, input의 값들을 모두 꺼내서 output에 넣어 역순으로 정렬시켜준다.       stack의 경우 LIFO이기 때문에, input에 있는 값을 output에 넣으면 거꾸로 쌓이게 되어 Queue와 같이 순차적으로 FIFO와 같은 효과를 낼 수 있다.           주어진 메서드인 pop()을 완성한다.            5번에서 정의한 move() 메서드를 수행하여 값을 역순으로 정렬한다.       output에 있는 가장 위의 값을 꺼내서 반환한다.           주어진 메서드인 peek()를 완성한다.            5번에서 정의한 move() 메서드를 수행하여 값을 역순으로 정렬한다.       output에 있는 가장 위의 값을 반환한다.           주어진 메서드인 empty()를 완성한다.            input과 output 두 개의 stack이 모두 비어있는지 여부를 반환한다.       input으로 들어온 값을 output에서 다 쓴 경우, 남아있는 값이 없으므로 비어있다고 볼 수 있다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/implement-queue-using-stacks/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Digit One",
        "excerpt":"문제  Link   코드  class Solution {    public int countDigitOne(int n) {     int result = 0;     for (int unit = 1; unit &lt;= n; unit *= 10) {       int quotient = n / unit;       int remainder = n % unit;       result += (((quotient + 8) / 10) * unit) + (quotient % 10 == 1 ? remainder + 1 : 0);     }     return result;   }  }   결과  Link   설명          주어진 정수 n 이하의 정수에 포함되는 숫자 1의 개수를 구하는 문제이다.            숫자 1이 포함되는 개수를 저장하기 위한 변수 result를 정의하고 0으로 초기화한다.       1부터 n 이하의 10의 승수로 반복하여 1의 개수를 산정한다.            몫을 저장할 quotient에 $\\frac{n}{unit}$의 값을, 나머지를 저장할 remainder에 n을 unit으로 나눈 나머지 값을 넣어준다.       result에 $(((quotient + 8) / 10) * unit) + (quotient % 10 == 1 ? remainder + 1 : 0)$ 값을 더해준다.                    $((quotient + 8) / 10) * unit$에서 위의 값에서 10을 나눈 값에 unit을 곱하는 이유는, unit의 단위(10의 승수) 별 1의 개수를 산정하기 위한 로직이다.           $quotient + 8$를 하는 이유는 n이 20 이후의 숫자인 경우, 10 ~ 19까지의 1의 개수인 10개를 보정하기 위한 로직이다.           $quotient % 10 == 1 ? remainder + 1 : 0$는 11와 같은 특수 행의 경우 1의 개수를 추가 산정하기 위해 $remainder + 1$의 결과를 더해주는 것이다.                           반복이 완료되면 주어진 정수 n 이하의 정수에 포함되는 숫자 1의 개수를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-digit-one/",
        "teaser": null
      },{
        "title": "Leetcode Java Palindrome Linked List",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isPalindrome(ListNode head) {     ListNode fast = head;     ListNode slow = head;     ListNode prev = null;     while (fast != null &amp;&amp; fast.next != null) {       fast = fast.next.next;       ListNode temp = prev;       prev = slow;       slow = slow.next;       prev.next = temp;     }     if (fast != null) {       slow = slow.next;     }     while (prev != null &amp;&amp; prev.val == slow.val) {       slow = slow.next;       prev = prev.next;     }     return prev == null;   }  }   결과  Link   설명          주어진 ListNode인 head의 val 값들이 앞뒤로 읽어도 같은 문자열(이하 회문)이 되는지 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            fast와 slow는 주어진 노드 head의 중간 지점을 탐색하기 위한 ListNode로, head를 각각 넣어 초기화한다.       prev는 주어진 노드 head의 처음부터 중간 지점까지 값들을 반전시켜 저장할 ListNode로, null로 초기화 한다.           fast와 fast.next가 null이 아닐 때 까지 반복하여 아래를 수행한다.            fast에 fast.next.next ListNode를 넣어 두 개의 ListNode를 이동시킨다.       temp에 지금까지 반전시킨 ListNode인 prev를 넣어 임시 보관한다.       prev에 slow의 ListNode를 넣어 현재 위치의 ListNode를 넣어준다.       slow는 slow.next를 넣어 fast의 위치보다 $\\frac{1}{2}$ 지점에 위치하게 하여 head의 중간 지점에 위치하도록 유도한다.       prev.next에 temp를 다시 넣어주어 slow까지 진행된 ListNode를 반전시킨 값을 유지한다.           fast가 null이 아닌 경우 ListNode가 홀수로 존재한다는 의미이므로, 회문의 중앙값에 위치한 slow에 다음 위치로 이동시키기 위해 slow.next를 넣어 다음 위치부터 회문 검증을 수행하도록 한다.            예를 들어 1,2,3,2,1 인 경우, 아래와 같다.                    fast는 1,2,3,2,1 에 위치한다.           slow는 1,2,3,2,1에 위치한다.           prev는 2,1의 값들이 존재한다.           slow와 prev를 검증하기 위해 slow에 다음 ListNode인 slow.next를 넣어 1,2,3,2,1에 위치시키도록 하여 회문의 중심이 되는 3을 기준으로 검증을 수행할 수 있도록 한다.                                prev가 null이 아니고, prev.val의 값과 slow.val 값이 동일할 때 까지 반복하여 slow와 prev에 next ListNode들을 각각 넣어준다.       prev가 null인 경우 5번의 검증을 통해 회문인 ListNode로 판단되므로 true를, 아닌 경우 회문인 ListNode가 아니므로 false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/palindrome-linked-list/",
        "teaser": null
      },{
        "title": "Leetcode Java Lowest Common Ancestor of a Binary Search Tree",
        "excerpt":"문제  Link   코드  class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {     while ((root.val - p.val) * (root.val - q.val) &gt; 0) {       root = root.val &gt; p.val ? root.left : root.right;     }     return root;   }  }   결과  Link   설명          주어진 이진 탐색 트리(BST)인 root에서 TreeNode p와 q의 최소의 공통된 부모 노드인 LCA를 찾는 문제이다.       주어진 TreeNode인 root의 val 값에 p의 val 값을 뺀 값과 root의 val 값에 q의 val 값을 뺀 값이 0보다 큰 경우 root의 노드가 해당 노드보다 큰 val 값을 가진 경우이므로, 아래를 수행하고 반복을 계속 수행한다.            root의 val 값이 p의 val 값보다 큰 경우, root의 left TreeNode를 root에 넣어준다.       root의 val 값이 p의 val 값보다 같거나 작은 경우, root의 right TreeNode를 root에 넣어준다.           반복이 완료되면 최소의 공통된 부모 노드를 저정한 root를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/lowest-common-ancestor-of-a-binary-search-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Lowest Common Ancestor of a Binary Tree",
        "excerpt":"문제  Link   코드  class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {     if (root == null || root == p || root == q) {       return root;     } else {       TreeNode left = lowestCommonAncestor(root.left, p, q);       TreeNode right = lowestCommonAncestor(root.right, p, q);       if (left == null) {         return right;       } else if (right == null) {         return left;       } else {         return root;       }     }   }  }   결과  Link   설명          지난번 Lowest Common Ancestor of a Binary Search Tree와 비슷한 문제로, 주어진 이진 트리인 root에서 TreeNode p와 q의 최소의 공통된 부모 노드인 LCA를 찾는 문제이다.            root가 null이면 진행이 불가능하고, p와 q 중 하나의 TreeNode가 root와 동일한 경우 최상위인 root가 최소의 공통된 부모 노드이므로 root를 주어진 문제의 결과로 반환한다.            그 외의 경우 root의 left와 right TreeNode를 이용하여 각각 재귀 호출한 결과를 left와 right에 넣어준다.            left와 right의 결과에 따라 주어진 문제의 결과를 반환한다.             left가 null인 경우 left TreeNode를 기준으로 p와 q의 최소의 공통된 부모 노드를 찾지 못했으므로, right를 주어진 문제의 결과로 반환한다.       right가 null인 경우 right TreeNode를 기준으로 p와 q의 최소의 공통된 부모 노드를 찾지 못했으므로, left를 주어진 문제의 결과로 반환한다.       left와 right가 둘 다 null인 경우 p와 q의 최소의 공통된 부모 노드가 root밖에 존재하지 않으므로, root를 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/lowest-common-ancestor-of-a-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Product of Array Except Self",
        "excerpt":"문제  Link   코드  class Solution {    public int[] productExceptSelf(int[] nums) {     int length = nums.length;     int[] result = new int[length];     result[0] = 1;     for (int idx = 1; idx &lt; length; idx++) {       result[idx] = result[idx - 1] * nums[idx - 1];     }     int right = 1;     for (int idx = length - 1; idx &gt;= 0; idx--) {       result[idx] *= right;       right *= nums[idx];     }     return result;   }  }   결과  Link   설명     주어진 nums를 이용하여 동일한 위치 값의 곱셈 결과가 모든 요소를 곱한 값과 동일한 배열을 만드는 문제이다.            O(n)의 시간 복잡도를 가지는 알고리즘을 작성해야 한다.       나눗셈 연산자를 사용하지 말아야 한다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장하여 활용하기 위한 변수이다.       result는 nums의 같은 위치의 값의 곱이 모든 요소를 곱한 값과 동일한 값을 만들기 위한 배열로, 첫 값인 result[0]에 1을 넣어준다.           result의 두 번째 위치부터 반복하여 result[idx] 값을 넣어준다.            result[idx]에 result[$idx - 1$]의 값과 nums[$idx - 1$]의 값의 곱을 넣어준다.           우측에서부터 result에 결과를 채우기 위해 반복하여 아래를 수행한다.            result[idx]에 right와 곱한 값을 넣어준다.       right에 nums[idx]의 값과 곱한 값을 넣어준다.           반복이 완료되어 result가 채워지면 result를 주어진 문제의 결과를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/product-of-array-except-self/",
        "teaser": null
      },{
        "title": "Leetcode Java Sliding Window Maximum",
        "excerpt":"문제  Link   코드  class Solution {    public int[] maxSlidingWindow(int[] nums, int k) {     int length = nums.length;     int[] left = new int[length];     int[] right = new int[length];     for (int i = 0; i &lt; length; i += k) {       int max = Integer.MIN_VALUE;       for (int j = i; j &lt; i + k &amp;&amp; j &lt; length; j++) {         max = Math.max(max, nums[j]);         left[j] = max;       }     }     int decrement = length % k == 0 ? k : length % k;     for (int i = length - 1; i &gt;= 0; i -= decrement, decrement = k) {       int max = Integer.MIN_VALUE;       for (int j = i; j &gt; i - decrement &amp;&amp; j &gt;= 0; j--) {         max = Math.max(max, nums[j]);         right[j] = max;       }     }     int[] result = new int[length - k + 1];     for (int i = k - 1; i &lt; length; i++) {       if ((i + 1) % k == 0) {         result[i - k + 1] = left[i];       } else {         result[i - k + 1] = Math.max(left[i], right[i - k + 1]);       }     }     return result;   }  }   결과  Link   설명          주어진 정수 배열 nums를 이용하여 k개 단위의 군집을 정해 해당 군집의 숫자 중 가장 큰 값을 모아 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 주어진 정수 배열 nums의 길이를 저장하기 위한 변수이다.       left와 right는 좌측과 우측 기준에서 큰 값을 저장하기 위한 임시 변수이다.           좌측 기준으로 nums의 크기 전까지 k 단위로 이동하면서 아래를 수행한다.            최대 값을 저장하기 위한 임시 변수인 max에 Integer의 최소값을 넣어준다.       i부터 $i + k$와 nums의 크기 전까지 증가하면서 nums[j]와 max의 값 중 큰 값을 max에 넣고, left[j]에 해당 max 값을 넣어준다.                nums의 길이가 k의 배수인 경우 k를, 그렇지 않은 경우 nums의 길이에서 k를 나눈 나머지 값을 넣어준다.       우측 기준으로 nums의 크기 부터 처음 값까지 decrement 단위로 이동하면서 아래를 수행한다.            최대 값을 저장하기 위한 임시 변수인 max에 Integer의 최소값을 넣어준다.       i부터 $i - decrement$ 초과, 0 이상인 경우까지 점층적으로 감소시키며 반복하여 max와 nums[j]의 값 중 큰 값을 max에 넣고 right[j]에 해당 max 값을 넣어준다.                결과를 저장할 result 배열을 $length - k + 1$ 크기로 정의한다.       $k - 1$부터 nums의 길이 만큼 점층적으로 증가시키며 반복하여 아래를 수행한다.            $i + 1$의 값이 k의 배수인 경우 좌측 기준으로 최대 값을 정의한 left의 값이 정확하므로, result[$i - k + 1$]에 left[i]를 넣어준다.       그 외의 경우, left[i]와 right[$i - k + 1$]의 값 중 큰 값을 result[$i - k + 1$]에 넣어준다.           반복이 종료되어 result에 모든 값이 채워지면 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sliding-window-maximum/",
        "teaser": null
      },{
        "title": "Leetcode Java Search a 2D Matrix II",
        "excerpt":"문제  Link   코드  class Solution {    public boolean searchMatrix(int[][] matrix, int target) {     int row = matrix.length - 1;     int col = 0;     while (row &gt;= 0 &amp;&amp; col &lt;= matrix[0].length - 1) {       if (target == matrix[row][col]) {         return true;       } else if (target &lt; matrix[row][col]) {         row--;       } else if (target &gt; matrix[row][col]) {         col++;       }     }     return false;   }  }   결과  Link   설명     주어진 2차원 배열인 matrix에 target의 값이 존재하는지를 검증하는 문제이다.            left-right 순으로 배열 내 값들이 오름차순 정렬되어 있다.       top-bottom 순으로 배열 내 값들이 오름차순 정렬되어 있다.           문제 풀이에 필요한 변수를 정의한다.            행의 위치를 저장할 row에 마지막 행의 위치인 $matrix.length - 1$를 넣어준다.       열의 위치를 저장할 col에 처음 열의 위치인 0을 넣어준다.           row가 첫 행인 0보다 크거나 같고, col이 마지막 열인 $matrix[0].length - 1$보다 작거나 같을 때 까지 반복하여 검증을 수행한다.            target의 값과 matrix[row][col]의 값이 동일한 경우 matrix에 target의 값이 존재하므로, true를 주어진 문제의 결과를 반환한다.       target의 값이 matrix[row][col]의 값보다 작은 경우, row를 감소시켜 그 위의 행에서 반복을 통해 검증을 계속 수행한다.                    top-bottom 순으로 배열 내 값들이 오름차순 정렬되어 있으므로, target의 값이 작으면 행을 위로 이동하여 값의 비교를 수행한다.                       target의 값이 matrix[row][col]의 값보다 큰 경우, col을 증가시켜 옆의 행들의 값을 이용하여 검증을 계속 수행한다.                    left-right 순으로 배열 내 값들이 오름차순 정렬되어 있으므로, target의 값이 크면 열을 우측으로 이동하여 값의 비교를 수행한다.                           반복이 완료되면 해당 배열 내 target의 값이 존재하지 않는다는 의미이므로, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/search-a-2d-matrix-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Different Ways to Add Parentheses",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; diffWaysToCompute(String expression) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     for (int idx = 0; idx &lt; expression.length(); idx++) {       char c = expression.charAt(idx);       if (c == '-' || c == '+' || c == '*') {         List&lt;Integer&gt; first = this.diffWaysToCompute(expression.substring(0, idx));         List&lt;Integer&gt; second = this.diffWaysToCompute(expression.substring(idx + 1));         for (int num1 : first) {           for (int num2 : second) {             switch (c) {               case '-':                 result.add(num1 - num2);                 break;               case '+':                 result.add(num1 + num2);                 break;               case '*':                 result.add(num1 * num2);                 break;             }           }         }       }     }     if (result.isEmpty()) {       result.add(Integer.valueOf(expression));     }     return result;   }  }   결과  Link   설명     수학 계산식이 저장된 주어진 문자열 expression를 기반으로 부분 계산을 활용하여 나올 수 있는 값들을 구하는 문제이다.            부분 계산이란 소괄호()를 특정 연산 단위로 분리해서 계산을 한 결과를 말한다.                부분 계산의 결과를 저장할 컬렉션인 result를 컬렉션으로 정의한다.       expression을 한 글자 씩 반복하여 idx번째 문자가 ‘-‘, ‘+’, ‘*‘의 계산 연산자인 경우, 아래를 수행한다.            first에 expression의 처음부터 idx번째 전까지 각 부분 계산을 결과를 넣기 위해 재귀 호출을 수행하고 해당 결과를 넣어준다.       seconde에 expression의 $idx + 1$번째부터 끝까지 각 부분 계산을 결과를 넣기 위해 재귀 호출을 수행하고 해당 결과를 넣어준다.                first와 second를 모두 반복하여 c의 연산자에 따른 결과를 result에 넣어준다.            반복이 완료되고 result가 비어있으면 재귀 호출을 통해서 expression에 숫자만 넘어온 경우이므로, result에 expression을 형 변환하여 넣어준다.       expression을 이용한 결과를 모두 저장한 result를 반환하며, 최초 호출의 경우 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/different-ways-to-add-parentheses/",
        "teaser": null
      },{
        "title": "Leetcode Java Valid Anagram",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isAnagram(String s, String t) {     int[] alphabet = new int[26];     for (char c : s.toCharArray()) {       alphabet[c - 'a']++;     }     for (char c : t.toCharArray()) {       alphabet[c - 'a']--;     }     for (int idx = 0; idx &lt; alphabet.length; idx++) {       if (alphabet[idx] != 0) {         return false;       }     }     return true;   }  }   결과  Link   설명     주어진 문자열 s와 t를 이용하여 아나그램(Anagram)인지 검증하는 문제이다.            아나그램(Anagram)이란 한 문자열을 재 배열하여 만드는 문자열이다.                정수 배열인 alphabet을 영소문자의 개수인 26개 사이즈로 정의한다.       주어진 문자열 s의 각 문자를 활용하여 alphabet 배열 내 각 위치의 값을 증가시킨다.            s를 한 문자씩 떼어 ‘a’를 뺀 숫자는 a(0)~z(25)까지 존재하므로, 해당 위치의 값을 증가시켜 개수를 가산한다.           주어진 문자열 t의 각 문자를 활용하여 alphabet 배열 내 각 위치의 값을 감소시킨다.            s를 한 문자씩 떼어 ‘a’를 뺀 숫자는 a(0)~z(25)까지 존재하므로, 해당 위치의 값을 감소시켜 개수를 감산한다.                alphabet 배열을 처음부터 끝까지 확인하여 특정 위치의 값이 0이 아닌 경우 주어진 문자열 t는  s를 이용하여 아나그램으로 만들 수 없는 문자열이므로, 주어진 문제의 결과로 false를 반환한다.       반복이 완료되면 주어진 문자열 t는  s를 이용하여 아나그램으로 만들 수 있는 문자열이므로, 주어진 문제의 결과로 true를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/valid-anagram/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Tree Paths",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; binaryTreePaths(TreeNode root) {     List&lt;String&gt; result = new ArrayList&lt;&gt;();     this.recursive(root, result, new StringBuilder(), 0);     return result;   }    public void recursive(TreeNode root, List&lt;String&gt; list, StringBuilder stringBuilder, int length) {     if (root == null) {       return;     }     stringBuilder.append(root.val);     if (root.left == null &amp;&amp; root.right == null) {       list.add(stringBuilder.toString());     } else {       stringBuilder.append(\"-&gt;\");       this.recursive(root.left, list, stringBuilder, stringBuilder.length());       this.recursive(root.right, list, stringBuilder, stringBuilder.length());     }     stringBuilder.setLength(length);   }  }   결과  Link   설명          주어진 이진 트리인 root를 이용하여 root부터 leaf까지 이어진 모든 결과를 반환하는 문제이다.            root부터 leaf까지 이어진 모든 결과를 담을 result 컬렉션을 정의한다.       StringBuilder를 활용한 재귀 호출을 이용하여 result에 모든 경우의 수를 넣어준다.            root가 null인 경우 수행이 불가능하므로, 종료한다.       root의 val 값을 stringBuilder에 넣어 값을 이어준다.       root의 left와 right TreeNode가 null인 경우 더 이어줄 node가 없으므로, stringBuilder의 결과를 list에 넣어준다.       그 외의 경우 stringBuilder에 “-&gt;” 키워드를 넣어주고, root의 left와 right TreeNode를 순서대로 재귀 호출 수행한다.                    단, stringBuilder의 길이를 각각 넣어준다.                       수행이 완료되면 stringBuilder에 length 값을 주입하여 length 번째 이후에 등록된 값들을 제거해준다.           재귀 호출이 완료되면 root부터 leaf까지 이어진 모든 결과를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-tree-paths/",
        "teaser": null
      },{
        "title": "Leetcode Java Add Digits",
        "excerpt":"문제  Link   코드  class Solution {    public int addDigits(int num) {     return ((num - 1) % 9) + 1;   }  }   결과  Link   설명     주어진 num을 이용하여 각 자릿수를 더한 값으로 결과를 만들어 한 자리가 될 때 까지 수행한 결과를 반환하는 문제이다.            단, 반복이나 재귀 호출 없이 O(1)의 시간 복잡도로 만드는 것을 요구한다.           주어진 num에 1을 뺀 값에 9를 나눈 나머지 값의 1을 더한 결과를 주어진 문제의 결과로 반환한다.            해당 문제의 결과는 num이 0인 경우를 제외한 모든 숫자에는 1 이상의 숫자가 포함되기 때문에, 각 자리의 합을 통해 한 자리의 숫자를 만들게 되면 1 ~ 9 까지의 결과만 존재한다.       num의 자리에 $num - 1$, 9로 나눈 나머지의 값에 1을 더하는 보정치를 적용하여 결과를 적용한다.       아래의 예를 보자.                    주어진 num이 99인 경우, $9 + 9 = 18$, $1 + 8 = 9$로 결과는 9가 나온다.           단순히 9로 나누는 경우, $99 % 9 = 0$으로 원하는 결과가 나오지 않는다.           위의 보정을 통해 $((99 - 1) % 9) + 1 = 9$로 값을 빼서 나눈 결과에 1을 더해주면 제시된 결과와 동일한 결과가 나온다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/add-digits/",
        "teaser": null
      },{
        "title": "Leetcode Java Single Number III",
        "excerpt":"문제  Link   코드  class Solution {    public int[] singleNumber(int[] nums) {     int bit = 0;     for (int num : nums) {       bit ^= num;     }     int diff = bit &amp; -bit;     int single = 0;     for (int num : nums) {       if ((diff &amp; num) != 0) {         single ^= num;       }     }     return new int[] { single, bit ^ single };   }  }   결과  Link   설명          주어진 배열 nums를 이용하여 한 번만 포함된 두 숫자를 찾는 문제이다.            한 번만 포함된 숫자를 저장하기 위한 변수 bit를 정의하고 0으로 초기화한다.            nums를 반복하여 모든 숫자에 XOR(^) 비트 연산자를 이용하여 두 번 발생하는 숫자를 무시하고 단일 발생하는 숫자들만 bit에 해당 연산자의 결과로 넣어준다.            bit와 -bit를 이용하여 AND(&amp;) 비트 연산자 결과인 마지막 세트 비트를 diff에 넣어준다.            단일 발생한 임의 값을 저장하기 위하여 single 변수를 정의하고 0으로 초기화한다.       nums를 반복하여 모든 숫자를 탐색하여 단일 발생한 값을 single에 넣어준다.            diff와 num의 AND(&amp;) 비트 연산 결과가 0이 아닌 경우, single과 num 값의 XOR(^) 비트 연산 결과를 single에 넣어준다.           bit와 single의 XOR(^) 비트 연산 결과로 단일 발생한 두 번째 값을 찾아 해당 값과, single의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/single-number-iii/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Trips and Users",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT request_at AS 'Day',   ROUND(COUNT(IF(status != 'completed', TRUE, NULL)) / COUNT(*), 2) AS 'Cancellation Rate' FROM Trips WHERE request_at BETWEEN '2013-10-01' AND '2013-10-03' AND client_id NOT IN (   SELECT users_Id FROM Users WHERE banned = 'Yes' ) AND driver_id NOT IN (   SELECT users_Id FROM Users WHERE banned = 'Yes' ) GROUP BY request_at;   결과  Link   설명          2013년 10월 01일부터 03일까지 날자 별 취소율을 구하는 문제이다.            Trips 테이블에 request_at의 날자가 ‘2013-10-01’부터 ‘2013-10-03’까지 데이터를 조회한다.            추가적으로 client_id와 dirver_id가 Users Table 내 banned가 ‘Yes’인 user_id를 제외한다.            request_at에 대한 날자 별 데이터를 집계하기 위하여 GROUP BY절을 이용한다.            ‘Cancellation Rate’를 구하기 위해 status가 completed가 아닌 데이터의 개수와 전체 개수를 나눈 후, 예제와 동일하게 소수점 2자리까지 반올림 하여 표시한다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/trips-and-users/",
        "teaser": null
      },{
        "title": "Leetcode Java Ugly Number",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isUgly(int n) {     for (int idx = 2; idx &lt; 6 &amp;&amp; n &gt; 0; idx++) {       while (idx != 4 &amp;&amp; n % idx == 0) {         n /= idx;       }     }     return n == 1;   }  }   결과  Link   설명     주어진 정수 n이 못생긴 숫자인지 검증하는 문제이다.            못생긴 숫자는 소인수가 2, 3, 5의 숫자로만 구성된 양의 정수이다.           2 ~ 5까지 숫자로 n이 0보다 클 때 까지 반복한다.            조건이 2, 3, 5이므로 4를 제외하고 n이 idx를 나눈 나머지 값이 0일 때 까지 반복하여 n을 나누어준다.           반복이 완료되면 n이 1인지를 검증한 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/ugly-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Ugly Number II",
        "excerpt":"문제  Link   코드  class Solution {    public int nthUglyNumber(int n) {     int[] nums = new int[n];     nums[0] = 1;     int index2 = 0;     int index3 = 0;     int index5 = 0;     int factor2 = 2;     int factor3 = 3;     int factor5 = 5;     int min = 1;     for (int idx = 1; idx &lt; n; idx++) {       nums[idx] = min = Math.min(Math.min(factor2, factor3), factor5);       if (min == factor2) {         factor2 = nums[++index2] * 2;       }       if (min == factor3) {         factor3 = nums[++index3] * 3;       }       if (min == factor5) {         factor5 = nums[++index5] * 5;       }     }     return min;   }  }   결과  Link   설명     지난 번 Ugly Number와 비슷한 문제로, n번째 못생긴 숫자를 반환하는 문제이다.            못생긴 숫자는 소인수가 2, 3, 5의 숫자로만 구성된 양의 정수이다.       예제를 참고하면, 첫 번째 못생긴 숫자는 1인 것을 알 수 있다.           문제 풀이에 필요한 변수를 정의한다.            nums는 n번째 못생긴 숫자를 임시 저장하기 위한 배열로, n의 크기로 정의하고 예제를 참고하여 첫 값에 1을 넣어준다.       index2, index3, index5는 각 소인수 별 횟수를 저장하는 정수이다.       factor2, factor3, factor5는 각 소인수의 배수를 저장하는 정수이다.       min은 n번째 못생긴 숫자를 임시 저장하기 위한 정수이다.                1부터 n 이전까지 반복하여 nums에 못생긴 숫자를 순서대로 넣어준다.       nums[idx]와 min에 factor2, factor3, factor5 중 가장 작은 값을 넣어준다.            못생긴 숫자인 각 정수들을 순서대로 nums에 넣기 위한 방법이다.           min의 값에 따라 아래를 수행한다.            min이 factor2와 동일한 값이면, index2를 증가시키고 nums의 index2번째 값을 가져와 2를 곱한 값을 factor2에 넣어준다.       min이 factor3과 동일한 값이면, index3를 증가시키고 nums의 index3번째 값을 가져와 3를 곱한 값을 factor3에 넣어준다.       min이 factor5와 동일한 값이면, index5를 증가시키고 nums의 index5번째 값을 가져와 5를 곱한 값을 factor5에 넣어준다.       위 수행이 개별 검증인 이유는, 공배수인 값의 경우 index와 factor를 공통으로 증가시키기 위함이다.           반복이 완료되면 min의 값 혹은 nums[$n - 1$]의 값을 주어진 문제의 결과로 반환한다.            반복은 $n - 1$번까지 반복되므로, min의 값과 nums[$n - 1$]의 값은 동일하다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/ugly-number-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Missing Number",
        "excerpt":"문제  Link   코드  class Solution {    public int missingNumber(int[] nums) {     int total = 0;     int length = nums.length;     for (int num : nums) {       total += num;     }     return ((length * (length + 1)) / 2) - total;   }  }   결과  Link   설명     주어진 배열 nums에 누락된 숫자를 찾는 문제이다.            단, nums에 누락된 숫자가 없을 경우 다음 이어지는 숫자를 반환한다.           문제 풀이에 필요한 변수를 정의한다.            total은 주어진 배열 nums의 숫자를 더하기 위한 변수로, 0으로 초기화한다.       length는 주어진 배열 nums의 길이를 저장하기 위한 변수이다.                nums 배열 내 모든 값을 total에 저장한다.       length를 이용하여 0부터 $length + 1$까지 숫자들의 합한 값에 total의 값을 뺀 숫자를 주어진 문제의 결과로 반환한다.            0부터 $n + 1$까지 합한 값은 $\\frac{(n \\times (n + 1))}{2}$의 공식의 결과로 확인 할 수 있다.       아래에 발생 가능한 두 가지 경우를 예를 든다.                    nums = [0, 1, 3, 4]인 경우, $\\frac{(4 \\times (4 + 1))}{2} - (0 + 1 + 3 + 4) = 10 - 8 = 2$로 누락된 값인 2이 주어진 문제의 결과가 된다.           nums = [0, 1, 2, 3]인 경우, $\\frac{(4 \\times (4 + 1))}{2} - (0 + 1 + 2 + 3) = 10 - 6 = 4$로 다음 이어지는 숫자인 4가 주어진 문제의 결과가 된다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/missing-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Integer to English Words",
        "excerpt":"문제  Link   코드  class Solution {    private static String[] LOWER_THAN_20_WORDS = { \"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\" };   private static String[] TEN_WORDS = { \"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\" };    public String numberToWords(int num) {     if (num == 0) {       return \"Zero\";     }     int hundreds = num % 1000;     num /= 1000;     int thousands = num % 1000;     num /= 1000;     int millions = num % 1000;     num /= 1000;     int billions = num;     StringBuilder sb = new StringBuilder();     if (billions &gt; 0) {       this.hundredsToWord(billions, sb);       this.addSpace(sb);       sb.append(\"Billion \");     }     if (millions &gt; 0) {       this.hundredsToWord(millions, sb);       this.addSpace(sb);       sb.append(\"Million \");     }     if (thousands &gt; 0) {       this.hundredsToWord(thousands, sb);       this.addSpace(sb);       sb.append(\"Thousand \");     }     if (hundreds &gt; 0) {       this.hundredsToWord(hundreds, sb);     }     return sb.toString().trim();   }    private void addSpace(StringBuilder sb) {     if (sb.length() - 1 != sb.lastIndexOf(\" \")) {       sb.append(\" \");     }   }    private void hundredsToWord(int num, StringBuilder sb) {     int tens = num % 100;     num /= 100;     if (num &gt; 0) {       this.tensToWord(num, sb);       sb.append(\" Hundred \");     }     if (tens &gt; 0) {       this.tensToWord(tens, sb);     }   }    private void tensToWord(int num, StringBuilder sb) {     if (num &lt; 20) {       sb.append(LOWER_THAN_20_WORDS[num]);     } else {       int tens = num / 10;       if (tens &gt; 0) {         sb.append(TEN_WORDS[tens]).append(\" \");       }       num %= 10;       if (num &gt; 0) {         sb.append(LOWER_THAN_20_WORDS[num]);       }     }   }  }   결과  Link   설명          주어진 정수 num을 영문자열로 변환하는 문제이다.            주어진 num이 0인 경우, “Zero”를 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 전역 변수를 정의한다.            LOWER_THAN_20_WORDS은 20 미만의 숫자들을 영문자로 변경한 배열이다.       TEN_WORDS는 10단위 숫자들을 영문자로 변경한 배열이다.                    단, 20 미만의 영문자에 10이 포함되기 때문에 10 자리에는 ““으로 두었다.                           문제 풀이에 필요한 10 단위를 영문자열로 변환하기 위한 tensToWord 메서드를 정의한다.            num이 20 미만인 경우, LOWER_THAN_20_WORDS[num]의 영문자를 sb에 이어준다.       num이 20 이상인 경우, 아래의 순서대로 진행한다.                    tens에 nums을 10으로 나눈 몫을 넣어 tens가 0 보다 큰 경우, TEN_WORDS[tens]의 영문자를 sb에 이어준다.           num에 10으로 나눈 나머지 값을 넣고, num이 0 보다 큰 경우, LOWER_THAN_20_WORDS[num]의 영문자를 sb에 이어준다.                           문제 풀이에 필요한 100 단위를 영문자열로 변환하기 위한 hundredsToWord 메서드를 정의한다.            tens에 num을 100으로 나눈 나머지 값을 넣어주고, num에 100으로 나눈 몫을 넣어준다.       num이 0 보다 큰 경우, num의 값으로 tensToWord 메서드를 수행하여 sb에 hundred 단위의 영문자를 이어준 후 “ Hundred “ 문자열을 이어준다.       tens가 0 보다 큰 경우, tensToWord에 tens를 이용하여 sb에 10단위의 영문자를 이어준다.           문제 풀이에 필요한 sb의 앞 문자열에 “ “이 들어간 경우에 대한 예외 처리를 공통화 하기 위한 addSpace 메서드를 정의한다.            만일 sb의 마지막 위치인 $sb.length() - 1$에 공백(“ “)이 위치하지 않은 경우, 영문자열의 띄어쓰기 구분을 위해 sb에 공백(“ “)을 넣어준다.           문제 풀이에 필요한 변수를 정의한다.            hundres, thousands, millions, billions에 차례대로 num을 1000으로 나눈 나머지 값을 넣어주고, num에 1000으로 나눈 몫을 넣어준다.       주어진 정수 num을 영문자열로 저장하기 위해 StringBuilder인 sb를 정의한다.                    동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.                           billions가 0 보다 큰 경우 아래를 수행하여 billion 단위의 영문자를 완성한다.            billions의 값으로 hundredsToWord 메서드를 수행하여 sb에 billion 단위의 영문자를 이어준다.       addSpace 메서드를 수행하여 문자열 간 띄어쓰기 규칙을 유지한다.       sb에 “Billion “ 문자열을 이어주어 billion 단위의 영문자를 완성한다.           millions가 0 보다 큰 경우 아래를 수행하여 million 단위의 영문자를 완성한다.            millions의 값으로 hundredsToWord 메서드를 수행하여 sb에 million 단위의 영문자를 이어준다.       addSpace 메서드를 수행하여 문자열 간 띄어쓰기 규칙을 유지한다.       sb에 “Million “ 문자열을 이어주어 million 단위의 영문자를 완성한다.           thousands가 0 보다 큰 경우 아래를 수행하여 thousand 단위의 영문자를 완성한다.            thousands의 값으로 hundredsToWord 메서드를 수행하여 sb에 thousand 단위의 영문자를 이어준다.       addSpace 메서드를 수행하여 문자열 간 띄어쓰기 규칙을 유지한다.       sb에 “Thousand “ 문자열을 이어주어 thousand 단위의 영문자를 완성한다.           hundreds가 0 보다 큰 경우 아래를 수행하여 hundred 단위의 영문자를 완성한다.            hundreds의 값으로 hundredsToWord 메서드를 수행하여 sb에 hundred 단위의 영문자를 이어준다.       addSpace 메서드를 수행하여 문자열 간 띄어쓰기 규칙을 유지한다.       sb에 “Hundred “ 문자열을 이어주어 hundred 단위의 영문자를 완성한다.           8 ~ 11로 영문자열이 저장된 sb를 문자열로 전환 후 앞,뒤 공백을 제거하고 주어진 문제로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/integer-to-english-words/",
        "teaser": null
      },{
        "title": "Leetcode Java H-Index",
        "excerpt":"문제  Link   코드  class Solution {    public int hIndex(int[] citations) {     Arrays.sort(citations);     int idx = citations.length - 1;     int count = 0;     while (idx &gt;= 0 &amp;&amp; citations[idx] &gt; count) {       count++;       idx--;     }     return count;   }  }   결과  Link   설명     각 논문의 인용 횟수인 주어진 정수 배열인 citations으로 H-Index를 구하는 문제이다.            전문적인 내용으로 해석이 까다로운 문제이므로 간단히 설명하면, citations의 길이보다 작은 크기에서 최대 인용 가능한 횟수를 구하는 문제이다.                citations를 오름차순으로 정렬하여 H-index를 구하기 쉽게 만든다.       문제 풀이에 필요한 변수를 정의한다.            idx는 citations의 길이를 저장하기 위한 변수이다.       count는 H-index를 저장할 변수로, 0으로 초기화 한다.                citations를 탐색하여 idx가 0 이상이며 citations[idx]가 count 초과인 경우, count를 증가시키고 idx를 감소시킨다.       반복이 종료되면 H-index를 구한 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/h-index/",
        "teaser": null
      },{
        "title": "Leetcode Java H-Index II",
        "excerpt":"문제  Link   코드  class Solution {    public int hIndex(int[] citations) {     int length = citations.length;     int left = 0;     int right = length - 1;     while (left &lt;= right) {       int mid = (left + right) / 2;       int diff = length - mid;       if (citations[mid] == diff) {         return diff;       } else if (citations[mid] &lt; diff) {         left = mid + 1;       } else {         right = mid - 1;       }     }     return length - left;   }  }   결과  Link   설명     지난번 H-Index와 비슷한 문제로, 각 논문의 인용 횟수인 주어진 정수 배열인 citations으로 H-Index를 구하는 문제이다.            전문적인 내용으로 해석이 까다로운 문제이므로 간단히 설명하면, citations의 길이보다 작은 크기에서 최대 인용 가능한 횟수를 구하는 문제이다.       단 지난 번 문제와 다른 점은, citations가 오름차순으로 정렬되어 있다는 것이다.           문제 풀이에 필요한 변수를 정의한다.            length는 citations의 길이를 저장하는 변수이다.       left는 binary search에서 좌측에서 시작하는 index로, 0으로 초기화 한다.       right는 binary saerch에서 우측에서 시작하는 index로, $length - 1$로 초기화 한다.           left가 right보다 같거나 작을때 까지 반복을 수행한다.            mid에 $\\frac{left + right}{2}$ 값을 넣어 left와 right 가운데의 index를 정의한다.       diff에 $length - mid$ 값을 넣어 h-index 값을 임의 정의한다.       citations[mid]의 값이 diff와 동일하면 diff의 값이 h-index이므로, diff를 주어진 문제의 결과로 반환한다.       citations[mid]의 값이 diff보다 작으면 left에 $mid + 1$의 값을 넣어 탐색 범위를 축소시킨다.       citations[mid]의 값이 diff보다 크면 right에 $mid - 1$의 값을 넣어 탐색 범위를 축소시킨다.           반복이 완료되면 citations의 값으로 h-index를 탐색하지 못하였으므로, $length - left$의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/h-index-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java First Bad Version",
        "excerpt":"문제  Link   코드  public class Solution extends VersionControl {    public int firstBadVersion(int n) {     int low = 1;     int high = n;     while (low &lt; high) {       int mid = low + ((high - low) / 2);       if (isBadVersion(mid)) {         high = mid;       } else {         low = mid + 1;       }     }     return low;   }  }   결과  Link   설명          주어진 정수인 n은 제품의 버전으로, VersionControl 클래스에서 제공되는 isBadVersion 메서드를 활용하여 최소의 검사를 통해 첫 번째로 잘못된 버전을 찾는 문제이다.       문제의 풀이에 필요한 변수를 정의한다.            low는 binary search를 활용하여 최소 버전부터 탐색하기 위한 변수로, 1로 초기화한다.       high는 binary search를 활용하여 최대 버전부터 탐색하기 위한 변수로, n으로 초기화한다.           low가 high보다 클 때 까지 반복하여 검증을 수행한다.            mid에 low를 보정치로 사용한 $low + \\frac{high - low}{2}$의 결과를 넣어준다.       mid를 이용하여 isBadVersion 메서드를 호출한 결과가 true인 경우, high에 mid를 넣어 최대 버전의 범위를 축소한다.       mid를 이용하여 isBadVersion 메서드를 호출한 결과가 false인 경우, low에 $mid + 1$을 넣어 최소 버전의 범위를 축소한다.           반복이 완료되면 최소 버전인 low를 첫 번째로 잘못된 버전으로 인지하고, 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/first-bad-version/",
        "teaser": null
      },{
        "title": "Leetcode Java Perfect Squares",
        "excerpt":"문제  Link   코드  class Solution {    public int numSquares(int n) {     for (int idx = 1; idx &lt; n; idx++) {       if (this.recursive(n, idx)) {         return idx;       }     }     return n;   }    private boolean recursive(int n, int count) {     if (count == 1) {       return Math.abs(Math.pow((int) Math.sqrt(n), 2) - n) &lt; 1e-5;     } else {       for (int idx = 1; idx * idx &lt;= n; idx++) {         if (this.recursive(n - idx * idx, count - 1)) {           return true;         }       }       return false;     }   }  }   결과  Link   설명          주어진 정수 n을 이용하여 완전 제곱수의 합으로 해당 값을 이루기 위한 최소 개수를 탐색하는 문제이다.            1부터 n까지 반복하여 n과 idx 값으로 재귀 호출을 활용하여 검증을 수행한다.       idx 값이 1인 경우, n의 제곱근의 제곱의 절대 값이 $1 \\times E^(-5)$ 미만인 경우 true를 그 외는 false를 반환한다.            해당 값의 차이가 큰 경우, n의 제곱근의 값을 이용하여 완전 제곱수를 구성할 수 없기 때문이다.           그 외의 경우, 아래를 진행하여 검증을 수행한다.            idx를 1부터 시작하여 idx의 제곱의 값이 n 이하일 때 까지 반복한다.       $n - idx^2$을 n에, count를 감소시켜 재귀 호출을 수행하여 검증한 결과를 확인한다.                    재귀 호출로 완전 제곱수를 구성하는 경우, true를 반환한다.                       반복문이 종료되는 경우 완전 제곱수로 구성이 되지 않는다는 의미이므로, false를 반환한다.                3, 4번의 수행 결과로 true가 반환되면, 완전 제곱수의 최소 개수인 idx를 주어진 문제의 결과로 반환한다.       반복이 모두 완료되면 n은 최소의 완전 제곱수인 1로만 구성된 경우이므로, n을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/perfect-squares/",
        "teaser": null
      },{
        "title": "Leetcode Java Expression Add Operators",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; addOperators(String num, int target) {     List&lt;String&gt; result = new ArrayList&lt;&gt;();     if (Long.valueOf(num) &gt; Integer.MAX_VALUE) {       return result;     }     char[] nums = num.toCharArray();     char[] path = new char[nums.length * 2 - 1];     long val = 0;     for (int idx = 0; idx &lt; nums.length; idx++) {       val = val * 10 + nums[idx] - '0';       path[idx] = nums[idx];       this.recursive(result, target, nums, path, 0, val, idx + 1, idx + 1);       if (val == 0) {         break;       }     }     return result;   }    private void recursive(List&lt;String&gt; result, int target, char[] nums, char[] path, long left, long right, int numsIdx, int pathIdx) {     if (numsIdx == nums.length) {       if (left + right == target) {         result.add(new String(path, 0, pathIdx));       }       return;     }     long val = 0;     int j = pathIdx + 1;     for (int i = numsIdx; i &lt; nums.length; i++) {       val = val * 10 + nums[i] - '0';       path[j++] = nums[i];       path[pathIdx] = '+';       this.recursive(result, target, nums, path, left + right, val, i + 1, j);       path[pathIdx] = '-';       this.recursive(result, target, nums, path, left + right, -val, i + 1, j);       path[pathIdx] = '*';       this.recursive(result, target, nums, path, left, right * val, i + 1, j);       if (nums[numsIdx] == '0') {         return;       }     }   }  }   결과  Link   설명          숫자로 구성된 주어진 문자열 num을 이용하여 각 숫자 간 연산을 이용하여 target을 만들기 위한 모든 연산식을 찾는 문제이다.            주어진 연산식을 넣을 컬렉션인 result를 정의하고, 만일 num을 Long으로 변환한 값이 Integer를 초과하는 경우 result를 반환한다.       문제 풀이에 필요한 변수를 정의한다.            nums는 num을 문자의 배열로 변환하여 저장하기 위한 변수이다.       path는 nums의 길이의 2배보다 1 작은 크기로 문자 배열을 정의한다.       val은 문자열 num을 숫자로 변환하여 저장하기 위한 변수이다.           nums 배열을 처음부터 끝까지 반복하여 result에 연산식을 넣어준다.            val에 $val \\times 10$의 값과 nums[idx]에 ‘0’을 빼서 숫자로 전환한 값을 합쳐서 넣어준다.       path[idx]에 nums[idx] 값을 넣어준다.       아래의 재귀 호출을 활용하여 result를 완성한다.           nums의 index를 나타내는 numsIdx가 nums의 길이와 동일한 경우 아래를 수행한다.            $left + right$ 값이 target이 되는지 확인하여, path를 이용하여 path에 저장된 index인 pathIdx 위치 값까지 문자열로 전환하여 result에 넣어준다.       return을 통해 재귀 호출을 끝내준다.           val에 0을, j에 $pathIdx + 1$ 값을 넣어 numsIdx부터 nums까지 아래를 반복한다.            val에 $val \\times 10$의 값과 nums[idx]에 ‘0’을 빼서 숫자로 전환한 값을 합쳐서 넣어준다.       path[j]에 nums[i] 값을 넣어주고, j를 증가시킨다.       path[pathIdx]에 ‘+’를, left에 $left + right$의 값을, right에 val을, numsIdx를 증가시켜 재귀 호출을 수행한다.       path[pathIdx]에 ‘-‘를, left에 $left + right$의 값을, right에 -val을, numsIdx를 증가시켜 재귀 호출을 수행한다.       path[pathIdx]에 ‘*‘를, right에 $right \\times val$의 값을, numsIdx를 증가시켜 재귀 호출을 수행한다.       nums[numsIdx]의 값이 ‘0’인 경우, 재귀 호출을 종료한다.                val 값이 0인지 확인하여 반복문을 종료시킨다.       반복문이 종료되면 연산식이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/expression-add-operators/",
        "teaser": null
      },{
        "title": "Leetcode Java Move Zeroes",
        "excerpt":"문제  Link   코드  class Solution {    public void moveZeroes(int[] nums) {     int idx = 0;     for (int num : nums) {       if (num != 0) {         nums[idx++] = num;       }     }     while (idx &lt; nums.length) {       nums[idx++] = 0;     }   }  }   결과  Link   설명          주어진 정수 배열 nums 내 0을 해당 배열 내 마지막 위치로 이동시키는 문제이다.            nums 배열 내 0이 아닌 값들을 차례대로 넣기 위해 idx를 0으로 정의한다.            nums를 반복하여 0이 아닐 때 까지 nums[idx]에 넣고 idx를 증가시킨다.            0이 아닌 값들을 차례대로 넣은 nums의 idx 이후 값들을 모두 0으로 채워준다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/move-zeroes/",
        "teaser": null
      },{
        "title": "Leetcode Java Peeking Iterator",
        "excerpt":"문제  Link   코드  //Java Iterator interface reference: //https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html public class PeekingIterator implements Iterator&lt;Integer&gt; {    private Iterator&lt;Integer&gt; iterator;   private Integer peekVal;   private boolean cached;    public PeekingIterator(Iterator&lt;Integer&gt; iterator) {     // initialize any member here.     this.iterator = iterator;   }    // Returns the next element in the iteration without advancing the iterator.   public Integer peek() {     if (!this.cached) {       this.peekVal = this.iterator.next();       this.cached = true;     }     return this.peekVal;   }    // hasNext() and next() should behave the same as in the Iterator interface.   // Override them if needed.   @Override   public Integer next() {     if (this.cached) {       this.cached = false;       return this.peekVal;     }     return this.iterator.next();   }    @Override   public boolean hasNext() {     if (this.cached) {       return true;     }     return this.iterator.hasNext();   }  }   결과  Link   설명     peek, hasNext, next 기능을 수행하는 Iterator인 PeekingIterator 클래스를 완성하는 문제이다.            생성자인 PeekingIterator(Iterator iterator)는 정수의 iterator를 초기화 하는 역할을 수행한다.       메서드인 peek()는 iterator의 다음 값을 반환하고 포인터를 그대로 유지한다.       메서드인 next()는 iterator의 다음 값을 반환하고 포인터를 움직인다.       메서드인 hasNext()는 iterator의 값이 존재하는지 여부를 반환한다.           문제 풀이에 필요한 변수를 정의한다.            iterator는 생성자를 통해 주입된 iterator 객체의 값을 보관하기 위한 변수이다.       peekVal은 iterator의 값을 순차적으로 보관하여 반환하기 위한 임시 변수이다.       cached는 iterator의 값을 peekVal에 임시 보관하였는지 여부를 저장하는 변수이다.           주어진 생성자인 PeekingIterator(Iterator iterator)를 완성한다.            변수를 통해 주입된 iterator를 전역 변수인 iterator에 저장한다.           주어진 메서드인 peek()를 완성한다.            cached가 false인 경우, iterator의 다음 값을 peekVal에 넣어주고 cached를 true로 바꾼다.       peekVal의 값을 반환한다.           주어진 메서드인 next()를 완성한다.            cached가 true인 경우, cached를 false로 바꿔주고 peekVal의 값을 반환한다.       cached가 false인 경우, iterator의 다음 값을 반환한다.           주어진 메서드인 hasNext()를 완성한다.            cached가 true인 경우, true를 반환한다.       cached가 false인 경우, iterator의 값이 존재하는지 여부인 hasNext()의 결과를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/peeking-iterator/",
        "teaser": null
      },{
        "title": "Leetcode Java Find the Duplicate Number",
        "excerpt":"문제  Link   코드  class Solution {    public int findDuplicate(int[] nums) {     int memory[] = new int[nums.length];     for (int num : nums) {       memory[num]++;     }     for (int num : nums) {       if (memory[num] &gt; 1) {         return num;       }     }     return -1;   }  }   결과  Link   설명     주어진 정수 배열 nums 중 중복된 값이 있는지 찾아 반환하는 문제이다.            배열 내 값은 nums의 크기보다 작은 수로 이루어져 있다.       해당 정수 배열 내 무조건 하나의 정수만 2번 혹은 그 이상 발생한다.                memory 배열을 nums의 크기만큼 정의한다.            nums를 반복하여 momory[num] 위치의 값을 증가시킨다.            nums를 반복하여 memory[num]의 값이 1보다 큰 경우, num을 주어진 문제의 결과로 반환한다.       그 외의 경우, 기본 조건에 의해 발생되지 않겠지만 반드시 반환문이 필요하므로 -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-the-duplicate-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Game of Life",
        "excerpt":"문제  Link   코드  class Solution {    public void gameOfLife(int[][] board) {     int rowSize = board.length;     int colSize = board[0].length;     for (int i = 0; i &lt; rowSize; i++) {       for (int j = 0; j &lt; colSize; j++) {         int lives = this.getLiveNeighbors(board, rowSize, colSize, i, j);         if (board[i][j] == 1 &amp;&amp; lives &gt;= 2 &amp;&amp; lives &lt;= 3) {           board[i][j] = 3;         }         if (board[i][j] == 0 &amp;&amp; lives == 3) {           board[i][j] = 2;         }       }     }     for (int i = 0; i &lt; rowSize; i++) {       for (int j = 0; j &lt; colSize; j++) {         board[i][j] &gt;&gt;= 1;       }     }   }    private int getLiveNeighbors(int[][] board, int m, int n, int i, int j) {     int lives = 0;     for (int x = Math.max(i - 1, 0); x &lt;= Math.min(i + 1, m - 1); x++) {       for (int y = Math.max(j - 1, 0); y &lt;= Math.min(j + 1, n - 1); y++) {         lives += board[x][y] &amp; 1;       }     }     lives -= board[i][j] &amp; 1;     return lives;   }  }   결과  Link   설명     주어진 2차원 정수 배열인 board를 이용하여 1970년 영국 수학자 Jone Horton Conway가 고안한 Conway’s Game of Life를 수행하는 문제이다.            살아있는 세포는 1, 죽은 세포는 0으로 표시한다.       상, 하, 좌, 우, 대각의 총 8개 셀은 살아있는 이웃으로 판단한다.       아래 4개의 규칙에 의해 게임이 수행된다.                    살아있는 이웃이 2개 미만인 살아있는 세포는 죽게된다.           2 ~ 3개의 살아있는 이웃이 있는 살아있는 세포는 그대로 살아있는다.           살아있는 이웃이 3개인 죽은 세포는 살아난다.           3개 초과의 살아있는 이웃이 있는 살아있는 세포는 죽게된다.                           문제 풀이에 필요한 변수를 정의한다.            rowSize는 board의 가로 길이인 board.length의 값을 저장하는 변수이다.       colSize는 board의 세로 길이인 board[0].length의 값을 저장하는 변수이다.           board를 순차적으로 반복하기 전에, 살아있는 세포의 수를 검증하기 위한 getLiveNeighbors 메서드를 정의한다.            살아있는 세포의 수를 저장하기 위한 lives 변수를 정의한다.       살아있는 세포의 이웃에 대한 가로 축의 범위인 x는 $i - 1$과 0 중 큰 값부터 시작하여 $i + 1$과 $m - 1$ 중 작은 값까지 점층적으로 증가시키며 반복한다.       살아있는 세포의 이웃에 대한 세로 축의 범위인 y는 $j - 1$과 0 중 큰 값부터 시작하여 $j + 1$과 $n - 1$ 중 작은 값까지 점층적으로 증가시키며 반복한다.                    boards[x][y]와 i의 AND(&amp;) 비트 연산의 결과를 lives에 더하여 lives를 증가시킨다.                       마지막으로 lives에 board[i][j]의 AND(&amp;) 비트 연산의 결과를 lives에 빼서 lives를 감소시킨 값을 반환한다.           3번을 이용하여 살아있는 세포의 수를 저장한 lives를 이용하여 아래를 수행한다.            board[i][j]의 값이 1이고 lives가 2 혹은 3인 경우, board[i][j]에 3을 넣어준다.                    01(1)의 비트 값인 board[i][j] 값을 11(3)으로 만들어 넣는 이유는 3번의 비트 연산 수행에 &amp;연산에 수행되는 값이 1과 같이 처리되기 위함이다.           01(1) &amp; 00(0) == 11(3) &amp; 00(0) == 0와 01(1) &amp; 01(1) == 11(3) &amp; 01(1) == 1으로 이웃을 판단하는 로직에서는 동일 수행 결과를 만들어주고, 이후 살아있는 상태임을 표기하기 위함이다.                       board[i][j]의 값이 0이고 lives가 3인 경우, board[i][j]에 2를 넣어준다.                    00(0)의 비트 값인 board[i][j] 값을 10(2)으로 만들어 넣는 이유는 3번의 비트 연산 수행에 &amp;연산에 수행되는 값이 0과 같이 처리되기 위함이다.           00(0) &amp; 00(0) == 10(2) &amp; 00(0) == 00(0) &amp; 01(1) == 10(2) &amp; 01(1) == 0으로 이웃을 판단하는 로직에서는 동일 수행 결과를 만들어주고, 이후 살아있는 상태임을 표기하기 위함이다.                           4번을 통해서 board에 넣어준 2(11)와 3(10)의 값들의 두 번째 비트 값을 board에 다시 넣어, 2와 3이 들어간 값은 살아있는 세포로 표기해준다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/game-of-life/",
        "teaser": null
      },{
        "title": "Leetcode Java Word Pattern",
        "excerpt":"문제  Link   코드  class Solution {    public boolean wordPattern(String pattern, String s) {     char[] patterns = pattern.toCharArray();     String[] words = s.split(\" \");     if (patterns.length != words.length) {       return false;     }     Map&lt;Object, Integer&gt; map = new HashMap&lt;&gt;();     for (Integer idx = 0; idx &lt; words.length; idx++) {       if (map.put(patterns[idx], idx) != map.put(words[idx], idx)) {         return false;       }     }     return true;   }  }   결과  Link   설명     주어진 문자열 s의 문자 조합이 동일한 문자열 pattern의 형태와 유사한지를 검증하는 문제이다.            예를 들어, pattern이 “abc”이면 s는 “attachement file folder”로 각자 다른 단어로 구성되어야 한다.       예제를 보아, pattern이 “abc”일때 s는 “file folder file”로 a와 c가 동일해서는 안 된다.           문제 풀이에 필요한 변수를 정의한다.            patterns는 pattern을 각 문자 단위로 나누어 저장한 문자 배열이다.       words는 s를 공백(“ “)으로 구분한 단어들의 문자열 배열이다.                patterns와 words의 길이가 같지 않는다면 기본 형태가 다르므로, false를 주어진 문제의 결과로 반환한다.            patterns와 words의 요소들을 각각 임시 저장할 map을 정의한다.       patterns와 words를 모두 탐색한다.            map에 patterns의 idx번째 요소와 words의 idx번째 요소를 각각 idx 값으로 넣어주고 각 값이 idx가 아니면 두 개의 pattern에 word가 동일하게 들어간 경우이므로, false를 주어진 문제의 결과로 반환한다.           반복이 종료되면 patterns의 요소들에 words의 각 요소들이 알맞은 패턴으로 구성되었다는 의미이므로, true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/word-pattern/",
        "teaser": null
      },{
        "title": "Leetcode Java Nim Game",
        "excerpt":"문제  Link   코드  class Solution {    public boolean canWinNim(int n) {     return n % 4 != 0;   }  }   결과  Link   설명     주어진 정수 n을 이용하여 친구와 Nim Game을 하여 승리할 수 있는지 여부를 반환하는 문제이다.            Nim Game이란 탁자 위에 돌들을 올려놓고 먼저 1개에서 3개까지 돌을 제거 하며 순서를 교대하다 마지막 돌을 제거하는 사람이 승자인 게임이다.           주어진 정수 n을 4로 나눈 나머지 값이 0이 아닌 경우 true를, 아니면 false를 주어진 문제의 결과로 반환한다.            n이 4인 경우, 처음 순서로 1 ~ 3 개를 제거하더라도 승리할 수 없다.       n이 5인 경우, 처음에 1개를 제거 후 친구가 1 ~ 3 개 중 임의의 개수를 제거하더라도 1 ~ 3개의 돌이 남으므로 다음에 돌아온 내 순서에서 승리가 가능하다.       이를 동일하게 n이 $4 \\times N$(N &gt;= 1)의 숫자가 아닌 경우, 승리 할 수 있다고 판단한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/num-game/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Median from Data Stream",
        "excerpt":"문제  Link   코드  class MedianFinder {    private Queue&lt;Integer&gt; queue;   private Queue&lt;Integer&gt; reverse;   private boolean isEven;    public MedianFinder() {     this.queue = new PriorityQueue&lt;&gt;();     this.reverse = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);     this.isEven = true;   }    public void addNum(int num) {     if (this.isEven) {       this.queue.add(num);       this.reverse.add(this.queue.poll());     } else {       this.reverse.add(num);       this.queue.add(this.reverse.poll());     }     this.isEven = !this.isEven;   }    public double findMedian() {     if (this.isEven) {       return (this.queue.peek() + this.reverse.peek()) / 2.0;     } else {       return this.reverse.peek();     }   }  }  /**  * Your MedianFinder object will be instantiated and called as such:  * MedianFinder obj = new MedianFinder();  * obj.addNum(num);  * double param_2 = obj.findMedian();  */   결과  Link   설명     addNum을 통해 주입된 숫자를 이용하여 findMedian으로 중앙값을 출력하는 MedianFinder 클래스를 완성하는 문제이다.            생성자인 MedianFinder()는 MedianFinder 클래스를 초기화시킨다.       메서드인 addNum(int num)은 주어진 정수 num을 데이터 구조에 맞는 흐름에 넣어준다.       메서드인 findMedian()은 주어진 정수들을 이용하여 중앙값을 반환한다.           문제 풀이에 필요한 변수를 정의한다.            queue는 주어진 정수를 순차적인 순서로 저장하는 역할로, 주어진 정수들의 초반의 절반 값들을 저장하는 큐이다.       reverse는 주어진 정수를 역순으로 저장하는 역할로, 주어진 정수들의 절반 이후의 값들을 저장하는 큐이다.       isEven은 주어진 정수의 개수가 짝수인지 여부를 저장하는 변수이다.           주어진 생성자인 MedianFinder()를 완성한다.            queue와 reverse를 순서대로 정의하기 위해 PriorityQueue로 초기화 하고, reverse의 경우 순서를 내림차순으로 저장해야 하므로 (a, b) -&gt; (b - a)를 넣어준다.       isEven은 현재 주어진 정수가 없으므로 true로 초기화한다.           주어진 메서드인 addNum(int num)을 완성한다.            isEven이 true인 짝수번째로 입력된 숫자의 경우, queue에 주어진 정수 num을 넣고 reverse에 queue의 가장 큰 값을 꺼내서 넣어준다.       isEven이 false인 홀수번쨰 입력된 숫자인 경우, reverse에 주어진 정수 num을 넣고, queue에 reverse의 가장 작은 값을 꺼내서 넣어준다.       isEven에 isEven의 값의 반대 값을 넣어준다.           주어진 메서드인 findMedian()을 완성한다.            isEven이 true인 주어진 정수가 짝수개라면, queue의 가장 작은 값과 reverse의 가장 큰 값을 꺼내 Double형인 2.0으로 나눈 결과를 반환한다.       isEven이 false인 주어진 정수가 홀수개라면, reverse의 가장 큰 값을 꺼내 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-median-from-data-stream/",
        "teaser": null
      },{
        "title": "Leetcode Java Serialize and Deserialize Binary Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode(int x) { val = x; }  * }  */ class Codec {    // Encodes a tree to a single string.   public String serialize(TreeNode root) {     return this.serialize(root, new StringBuilder()).toString();   }    private StringBuilder serialize(TreeNode root, StringBuilder stringBuilder) {     if (root == null) {       return stringBuilder.append(\".\");     }     stringBuilder.append(root.val).append(\",\");     this.serialize(root.left, stringBuilder);     stringBuilder.append(\",\");     this.serialize(root.right, stringBuilder);     return stringBuilder;   }    // Decodes your encoded data to tree.   public TreeNode deserialize(String data) {     return this.deserialize(new LinkedList&lt;&gt;(Arrays.asList(data.split(\",\"))));   }    private TreeNode deserialize(Queue&lt;String&gt; queue) {     String val = queue.poll();     if (\".\".equals(val)) {       return null;     }     TreeNode root = new TreeNode(Integer.valueOf(val));     root.left = this.deserialize(queue);     root.right = this.deserialize(queue);     return root;   }  }  // Your Codec object will be instantiated and called as such: // Codec ser = new Codec(); // Codec deser = new Codec(); // TreeNode ans = deser.deserialize(ser.serialize(root));   결과  Link   설명     TreeNode를 serialize하고 deserialize하여 원래 TreeNode를 복원하는 Codec 클래스를 완성하는 문제이다.            메서드인 serialize(TreeNode root)는 주어진 TreeNode인 root를 문자열로 변경한다.       메서드인 deserialize(String data)는 주어진 String인 data는 TreeNode를 문자열로 변경한 값으로, 해당 값을 이용하여 TreeNode로 복원한다.           주어진 메서드인 serialize(TreeNode root)를 완성하기 위해 재귀 호출용 메서드 serialize(TreeNode root, StringBuilder stringBuilder)를 완성한다.            root가 null인 경우, stringBuilder에 마침표(“.”)를 넣어준다.       그 외의 경우 root.val과 콤마(“,”)를 순차적으로 넣어준다.       root의 left TreeNode를 재귀 호출을 이용하여 stringBuilder에 순차적으로 값을 넣어준다.       root의 left TreeNode의 재귀 호출이 완료되면 콤마(“,”)를 넣어 값을 구분해준다.       root의 right TreeNode를 재귀 호출을 이용하여 stringBuilder에 순차적으로 값을 넣어준다.       위의 수행 결과로 완성된 stringBuilder를 반환한다.           주어진 메서드인 serialize(TreeNode root)를 완성한다.            2번에서 만든 serialize(TreeNode root, StringBuilder stringBuilder)를 주어진 TreeNode인 root와 새 StringBuilder 클래스를 생성하여 수행한 결과를 문자열로 치환하여 반환한다.       동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.           주어진 메서드인 deserialize(String data)를 완성하기 위해 재귀 호출용 메서드 deserialize(Queue queue)를 완성한다.            queue에서 값을 꺼내 지역 변수 val에 넣어준다.       val 값이 마침표(“.”)인 경우 null인 TreeNode이므로, null을 반환한다.       val 값을 정수형으로 변경하여 새 TreeNode를 root로 정의한다.       root의 left TreeNode에 queue를 이용한 재귀 호출 결과인 TreeNode를 넣어준다.       root의 right TreeNode에 queue를 이용한 재귀 호출 결과인 TreeNode를 넣어준다.       위의 수행 결과로 완성된 TreeNode를 반환한다.           주어진 메서드인 deserialize(String data)를 완성한다.            4번에서 만든 deserialize(Queue queue)를 data를 콤마(\",\")로 분리한 배열을 List형으로 변환하여 새 LinkedList로 만들어 수행한 결과를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/serialize-and-deserialize-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Bulls and Cows",
        "excerpt":"문제  Link   코드  class Solution {    public String getHint(String secret, String guess) {     int bulls = 0;     int cows = 0;     int[] count = new int[10];     for (int idx = 0; idx &lt; secret.length(); idx++) {       char secretChar = secret.charAt(idx);       char guessChar = guess.charAt(idx);       if (secretChar == guessChar) {         bulls++;       } else {         if (count[secretChar - '0']++ &lt; 0) {           cows++;         }         if (count[guessChar - '0']-- &gt; 0) {           cows++;         }       }     }     return new StringBuilder().append(bulls).append(\"A\").append(cows).append(\"B\").toString();   }  }   결과  Link   설명     Bulls And Cows 게임을 하는 문제이다.            비밀 숫자인 secret을 맞추기 위해 추측값 guess를 제시하면 해당 값에 대한 결과를 x개의 “황소”와 y개의 “소”를 xAyB형태로 반환한다.       “황소”란 정확한 위치에 있는 추측의 숫자의 개수를 의미한다.       “소”란 비밀 숫자에 포함되어 있지만, 잘못된 위치에 있는 추측의 숫자의 개수를 의미한다.       단 y의 경우 중복된 숫자를 제외하고 표기한다.                    secret = 1123, guess = 0111인 경우, 소는 3번째와 4번째의 1이지만 1A1B로 표기한다.                           문제 풀이에 필요한 변수를 정의한다.            bulls는 황소의 숫자를 세기 위한 변수로, 0으로 초기화한다.       cows는 소의 숫자를 세기 위한 변수로, 0으로 초기화한다.       count는 각 숫자를 개수를 세기 위한 배열로, 0 ~ 9까지 존재하므로 크기를 10으로 설정하여 초기화한다.           secret의 길이만큼 반복하여 호아소와 소의 개수를 센다.            secret의 idx번째 문자를 secretChar에 넣어준다.       guess의 idx번째 문자를 guessChar에 넣어준다.       secretChar와 guessChar가 동일하다면 bulls를 증가시킨다.       동일하지 않다면, 아래를 수행한다.                    ASCII 값을 활용하여 secretChar의 숫자에 해당하는 count 내 해당 위치의 값이 0보다 작으면 guess에 포함된 숫자이므로 cows를 증가시키고, 해당 여부와 상관없이 cow를 증가시켰으니 count내 해당 위치의 값을 증가시켜준다.           ASCII 값을 활용하여 guessChar의 숫자에 해당하는 count 내 해당 위치의 값이 0보다 크면 secret에 포함된 숫자이므로 cows를 증가시키고, 해당 여부와 상관없이 cow를 증가시켰으니 count내 해당 위치의 값을 증가시켜준다.                           반복을 통해 bulls와 cows를 모두 확인하였으면, 해당 값을 이용하여 xAyB형태의 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/bulls-and-cows/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Increasing Subsequence",
        "excerpt":"문제  Link   코드  class Solution {    public int lengthOfLIS(int[] nums) {     int[] dp = new int[nums.length + 1];     dp[0] = Integer.MIN_VALUE;     int length = 0;     for (int idx = 0; idx &lt; nums.length; idx++) {       int position = length;       while (dp[position] &gt;= nums[idx]) {         position--;       }       if (position == length) {         length++;       }       dp[position + 1] = nums[idx];     }     return length;   }  }   결과  Link   설명          주어진 정수 배열인 nums를 이용하여 오름차순으로 부분 배열을 만들 때 가장 길게 만들 수 있는 길이를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            dp는 오름차순으로 부분 배열을 만들 때 순차적인 값을 저장할 배열로, nums의 길이보다 1 크게 정의하고 처음 값을 정수의 가장 작은 값으로 넣어준다.       length는 오름차순으로 부분 배열을 만들 때 최대 길이를 저장하는 변수로 0으로 초기화한다.           nums를 처음부터 끝까지 반복하여 최대 길이 length를 구한다.            position에 length를 넣어주고 dp[position]의 값보다 nums[idx]가 큰 값일 때 까지 반복하여 position을 감소시킨다.       position이 length와 동일한 경우 dp의 다음 값에 들어갈 값이므로, length를 증가시킨다.       dp[$position + 1$]에 nums[idx] 값을 넣어주고 반복을 계속 수행한다.           반복이 종료되면 nums를 이용하여 오름차순으로 부분 배열을 만들 때 가장 길게 만들 수 있는 length를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-increasing-subsequence/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove Invalid Parentheses",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; removeInvalidParentheses(String s) {     List&lt;String&gt; result = new ArrayList&lt;&gt;();     this.recursive(s, result, new char[] { '(', ')' }, 0, 0);     return result;   }    private void recursive(String s, List&lt;String&gt; result, char[] check, int x, int y) {     int count = 0;     int i = x;     while (i &lt; s.length() &amp;&amp; count &gt;= 0) {       if (s.charAt(i) == check[0]) {         count++;       }       if (s.charAt(i) == check[1]) {         count--;       }       i++;     }     if (count &gt;= 0) {       String reverse = new StringBuilder(s).reverse().toString();       if (check[0] == '(') {         this.recursive(reverse, result, new char[] { ')', '(' }, 0, 0);       } else {         result.add(reverse);       }     } else {       i--;       for (int j = y; j &lt;= i; j++) {         if (s.charAt(j) == check[1] &amp;&amp; (j == y || s.charAt(j - 1) != check[1])) {           this.recursive(s.substring(0, j) + s.substring(j + 1, s.length()), result, check, i, j);         }       }     }   }  }   결과  Link   설명          주어진 문자열 s에 괄호가 유효하지(정상적으로 열고 닫지) 않는 문자열로 구성되어 있으면, 최소의 괄호를 제거하여 괄호가 유효한 문자열을 모두 만들어 반환하는 문제이다.            모든 괄호가 유효한 문자열을 넣을 컬렉션인 result를 정의하고, 배열의 정순인 “(“, “)” 문자열 순서로 재귀 호출을 수행하여 result에 모든 결과를 넣어준다.       문제 풀이에 필요한 변수를 정의한다.            count는 유효하지 않은 괄호의 개수를 파악하기 위한 변수로, 0으로 초기화한다.       i는 문자열 s를 탐색하기 위한 시작 위치인 변수로, 주어진 변수 x로 초기화한다.           문자열 s의 i번째 문자부터 끝까지 반복을 통해 탐색하여 아래를 수행한다.            문자열 s의 i번째 문자가 check의 첫 번째 문자인 경우, count를 증가시킨다.       문자열 s의 i번째 문자가 check의 두 번째 문자인 경우, count를 감소시킨다.       마지막으로 i를 증가시키고 반복을 계속한다.           count가 0 이상인 경우, 유효하지 않은 괄호가 존재하므로 아래를 수행한다.            문자열 s를 거꾸로 반전시켜서 reverse에 저장한다.       check의 첫 번째 문자가 괄호의 시작인 ‘(‘인 경우, check를 반대로 바꾸어 재귀 호출을 수행한다.       check의 첫 번째 문자가 괄호의 종료인 ‘)’인 경우, result에 reverse 문자열을 넣어준다.           count가 0인경우, 문자열의 괄호를 검증하기 위해 아래를 수행한다.            해당 검증을 수행하기 위해 i를 감소시킨다.       y부터 i 이전까지 반복을 수행한다.       s의 j번째 문자가 check의 두 번째 문자이면서, j와 y가 같거나 s의 $j - 1$번째 문자가 check의 두 번째 문자가 아닌 경우에는 j번째 문자만 s에서 제외하고 x에 i를, y에 j를 넣어 재귀 호출을 수행한다.           재귀 호출이 완료되서 모든 가능한 문자열을 result에 넣어지면 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-invalid-parentheses/",
        "teaser": null
      },{
        "title": "Leetcode Java Range Sum Query - Immutable",
        "excerpt":"문제  Link   코드  class NumArray {    private int[] nums;      public NumArray(int[] nums) {     int length = nums.length;     this.nums = new int[length];     for (int idx = 0; idx &lt; length; idx++) {       if (idx == 0) {         this.nums[idx] = nums[idx];       } else {         this.nums[idx] = this.nums[idx - 1] + nums[idx];       }     }   }    public int sumRange(int left, int right) {     if (left == 0) {       return nums[right];     } else {       return nums[right] - nums[left - 1];     }   }  }  /**  * Your NumArray object will be instantiated and called as such:  * NumArray obj = new NumArray(nums);  * int param_1 = obj.sumRange(left,right);  */   결과  Link   설명     배열을 주입하여 구간 값의 합을 구하는 NumArray 클래스를 완성하는 문제이다.            생성자인 NumArray(int[] nums)는 NumsArray 클래스를 초기화하여 nums의 값들을 주입한다.       메서드인 sumRange(int left, int right)는 생성자로 주입된 값들의 left번째 값부터 right번째 값까지 더하여 반환한다.           문제 풀이에 필요한 변수를 정의한다.            nums는 생성자로 부여된 정수들의 값을 누계하여 저장할 변수이다.           생성자인 NumArray(int[] nums)를 완성한다.            주어진 nums의 길이를 length로 정의한다.       전역 변수인 nums를 nums의 길이로 초기화 한다.       반복을 이용하여 주입된 nums의 값의 idx번째 값까지 합을 전역변수 nums의 idx 위치의 값에 넣어준다.           메서드인 sumRange(int left, int right)를 완성한다.            nums에 각 위치 별 누계를 저장하였으므로 left가 0인 경우, nums[right]의 값이 이미 중촉하여 해당 값을 주어진 문제의 결과로 반환한다.       left가 0이 아닌 경우, nums[right]의 값에서 nums[$left - 1$]의 값을 빼면 left번째 값에서 right번째 값들의 합이 되므로 뺀 값을 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/range-sum-query-immutable/",
        "teaser": null
      },{
        "title": "Leetcode Java Range Sum Query 2D - Immutable",
        "excerpt":"문제  Link   코드  class NumMatrix {    private int[][] matrix;    public NumMatrix(int[][] matrix) {     this.matrix = matrix;     int rowLength = matrix.length;     int colLength = matrix[0].length;     for (int i = 0; i &lt; rowLength; i++) {       int sum = matrix[i][0];       for (int j = 1; j &lt; colLength; j++) {         sum += matrix[i][j];         matrix[i][j] = sum;       }     }     for (int j = 0; j &lt; colLength; j++) {       int sum = matrix[0][j];       for (int i = 1; i &lt; rowLength; i++) {         sum += matrix[i][j];         matrix[i][j] = sum;       }     }   }    public int sumRegion(int row1, int col1, int row2, int col2) {     int sum = matrix[row2][col2];     if (row1 &gt; 0) {       sum -= matrix[row1 - 1][col2];     }     if (col1 &gt; 0) {       sum -= matrix[row2][col1 - 1];     }     if (row1 &gt; 0 &amp;&amp; col1 &gt; 0) {       sum += matrix[row1 - 1][col1 - 1];     }     return sum;   }  }  /**  * Your NumMatrix object will be instantiated and called as such:  * NumMatrix obj = new NumMatrix(matrix);  * int param_1 = obj.sumRegion(row1,col1,row2,col2);  */   결과  Link   설명     2차원 배열을 주입하여 부분 배열 값의 합을 구하는 NumArray 클래스를 완성하는 문제이다.            생성자인 NumArray(int[][] matrix)는 NumsArray 클래스를 초기화하여 nums의 값들을 주입한다.       메서드인 sumRegion(int row1, int col1, int row2, int col2)은 생성자로 주입된 배열에서 row1 ~ row2, col1 ~ col2의 부분 배열에 속하는 값들의 합을 반환한다.           문제 풀이에 필요한 변수를 정의한다.            matrix는 생성자로 부여된 배열의 값을 넣을 변수이다.           생성자인 NumArray(int[][] matrix)를 완성한다.            주어진 matrix를 전역 변수인 matrix에 넣어준다.       rowLength와 colLength에 matirx의 행과 열의 길이를 넣어준다.       matrix를 반복하여 첫 행의 값들을 기준으로 아래 행으로 내려가면서 누계하고 해당 값을 위치에 넣어준다.       matrix를 반복하여 첫 열의 값들을 기준으로 우측 열로 이동하면서 누계하고 해당 값을 위치에 넣어준다.           메서드인 sumRegion(int row1, int col1, int row2, int col2)을 완성한다.            sum에 matrix[row2][col2] 값을 넣어준다.       row1이 0보다 큰 경우, sum에서 matrix[$row1 - 1$][col2] 값을 빼준다.       col1이 0보다 큰 경우, sum에서 matrix[row2][$col1 - 1$] 값을 빼준다.       row1과 col1 둘 다 0보다 큰 경우, sum에서 matrix[$row1 - 1$][$col1 - 1$] 값을 빼준다.       위의 경우의 수를 제거한 부분 배열의 합인 sum을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/range-sum-query-2d-immutable/",
        "teaser": null
      },{
        "title": "Leetcode Java Additive Number",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isAdditiveNumber(String num) {     return this.recursive(num, -1, -1, 0, 0);   }    private boolean recursive(String num, long pre, long cur, int idx, int cnt) {     int length = num.length();     if (idx == length) {       if (cur != -1 &amp;&amp; pre != -1 &amp;&amp; cnt &gt; 2) {         return true;       } else {         return false;       }     }     long n = 0;     for (int i = idx; i &lt; length; i++) {       n = n * 10 + (num.charAt(i) - '0');       if (cur != -1 &amp;&amp; pre != -1) {         if (n == cur + pre) {           if (this.recursive(num, cur, n, i + 1, cnt + 1)) {             return true;           }         } else if (n &gt; cur + pre) {           return false;         }       }       if (pre == -1) {         if (this.recursive(num, n, cur, i + 1, cnt + 1)) {           return true;         }       } else if (cur == -1) {         if (this.recursive(num, pre, n, i + 1, cnt + 1)) {           return true;         }       }       if (n == 0) {         break;       }     }     return false;   }  }   결과  Link   설명          숫자로 이루어진 주어진 문자열 num을 이용하여 숫자를 나눌 때, 이전 값과 현재 값의 합이 다음 값이 되는 조합으로 이루어져 있는지 검증하는 문제이다.       문제 풀이에 사용할 재귀 호출 메서드인 recursive를 정의한다.            이전 값을 pre, 현재 값을 cur, 문자열의 위치 값인 idx, 숫자열의 개수를 저장할 cnt 변수로 활용한다.                length에 num의 길이를 저장한다.       idx가 length와 동일한 경우, 아래를 검증한다.            cur과 pre가 -1이 아니고 cnt가 2보다 큰 경우 최소한 세 개 이상의 숫자열이 이전 값과 현재 값의 합이 다음 값이 되므로, true를 반환한다.       그렇지 않은 경우 문제를 충족하지 않으므로, false를 반환한다.           값을 측정할 변수 n을 정의하고, idx부터 length까지 반복을 수행한다.            n에 $n \\times 10$에 num의 i번째 문자열의 숫자 값을 더해준다.       cur과 pre가 -1인 경우, 아래를 검증한다.                    n의 값이 $cur + pre$의 값과 동일한 경우, pre 자리에 cur을, cur 값에 n을, i 값에 $i + 1$을, cnt 값에 $cnt + 1$을 넣어 재귀 호출을 수행한 결과가 true인 경우 true를 반환한다.           n의 값이 $cur + pre$의 값보다 큰 경우, false를 반환한다.                       pre가 -1인 경우, 첫 검증을 수행하므로 아래를 수행한다.                    pre 자리에 n을, cur 값에 cur을, i 값에 $i + 1$을, cnt 값에 $cnt + 1$을 넣어 재귀 호출을 수행한 결과가 true인 경우, true를 반환한다.                       pre가 -1이 아니고 cur이 -1인 경우, 아래를 수행한다.                    pre 자리에 pre를, cur 값에 n을, i 값에 $i + 1$을, cnt 값에 $cnt + 1$을 넣어 재귀 호출을 수행한 결과가 true인 경우, true를 반환한다.                       n이 0인 경우 유효하지 않는 값이므로, 반복을 멈추고 false를 반환한다.                    Note에 추가로 설명한 1, 02, 3 혹은 1, 2, 03 같이 0이 붙는 경우 유효하지 않는 값으로 판단한다.                           위에서 정의한 재귀 호출 메서드인 recursive를 pre와 cur에 -1을, idx와 cnt에 0을 넣어 num을 검증한 결과를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/additive-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Range Sum Query - Mutable",
        "excerpt":"문제  Link   코드  class NumArray {    private int[] nums;   private int sum;    public NumArray(int[] nums) {     this.nums = nums;     this.sum = 0;     for (int num : nums) {       this.sum += num;     }   }    public void update(int index, int val) {     this.sum -= this.nums[index] - val;     this.nums[index] = val;   }    public int sumRange(int left, int right) {     int temp = 0;     if ((right - left) &lt; this.nums.length / 2) {       for (int idx = left; idx &lt;= right; idx++) {         temp += this.nums[idx];       }     } else {       temp = this.sum;       for (int idx = 0; idx &lt; left; idx++) {         temp -= this.nums[idx];       }       for (int idx = right + 1; idx &lt; this.nums.length; idx++) {         temp -= this.nums[idx];       }     }     return temp;   }  }  /**  * Your NumArray object will be instantiated and called as such:  * NumArray obj = new NumArray(nums);  * obj.update(index,val);  * int param_2 = obj.sumRange(left,right);  */   결과  Link   설명     배열을 주입하여 구간 값의 합을 구하거나 특정 위치의 값을 변경하는 NumArray 클래스를 완성하는 문제이다.            생성자인 NumArray(int[] nums)는 NumsArray 클래스를 초기화하여 nums의 값들을 주입한다.       메서드인 update(int index, int val)는 생성자로 주입된 값들의 index번째 값을 val 값으로 치환한다.       메서드인 sumRange(int left, int right)는 생성자로 주입된 값들의 left번째 값부터 right번째 값까지 더하여 반환한다.           문제 풀이에 필요한 변수를 정의한다.            nums는 생성자로 부여된 정수들의 값들을 넣을 변수이다.       sum은 생성자로 부여된 정수들의 합을 넣을 변수이다.           생성자인 NumArray(int[] nums)를 완성한다.            주어진 정수 배열인 nums를 전역 변수 nums에 주입한다.       nums를 반복하여 모든 값들을 sum에 더해준다.           메서드인 update(int index, int val)를 완성한다.            모든 값들의 합을 저장한 sum에 nums의 index번째 값과 val 값의 차이 값을 빼준다.       nums의 index번째 위치에 val 값을 넣어준다.           메서드인 sumRange(int left, int right)를 완성한다.            부분 합을 저장할 temp를 0으로 정의한다.       $right - left$의 값이 nums의 길이 절반 미만인 경우, left 부터 right번째 값까지 순회하여 temp에 값을 더해준다.       $right - left$의 값이 nums의 길이 절반 이상인 경우, 효율적으로 계산하기 위하여 아래를 수행한다.                    모든 값을 더한 sum의 값을 temp에 넣어준다.           nums의 처음부터 left까지, right부터 마지막까지 값을 temp에서 빼준다.                       부분 합을 구한 temp를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/range-sum-query-mutable/",
        "teaser": null
      },{
        "title": "Leetcode Java Best Time to Buy and Sell Stock with Cooldown",
        "excerpt":"문제  Link   코드  class Solution {    public int maxProfit(int[] prices) {     int sold = 0;     int hold = Integer.MIN_VALUE;     int rest = 0;     for (int price : prices) {       hold = Math.max(hold, rest - price);       rest = Math.max(rest, sold);       sold = hold + price;     }     return Math.max(sold, rest);   }  }   결과  Link   설명     주어진 정수 배열 prices를 이용하여 최대 이익을 낼 수 있는 금액을 구하는 문제이다.            단, 판매 이후 하루는 주식 매매가 불가능하다.           문제 풀이에 필요한 변수를 정의한다.            sold는 매매한 이익을 담는 변수로 0으로, 초기화한다.       hold는 매매하지 않았을 경우 차익을 저장할 변수로, Integer의 최소값으로 초기화한다.       rest는 아무것도 하지 않았을 경우 이익을 저장하기 위한 변수로, 0으로 초기화한다.           prices를 반복하여 최대 이익을 구한다.            hold에 hold와 차익이 되는 $rest - price$의 값 중 큰 값을 넣어준다.       rest에 rest와 sold의 값 중 큰 값을 넣어준다.       sold에 매매 이익이 되는 $hold + price$ 값을 넣어준다.           반복이 완료되면 마지막으로 매매를 한 경우인 sold와 매매하지 않았을 경우인 rest중 큰 값이 최대 이익이므로, 해당 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/best-time-to-buy-and-sell-stock-with-cooldown/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Height Trees",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     if (n == 1) {       result.add(0);       return result;     } else if (n == 2) {       result.add(0);       result.add(1);       return result;     }     List&lt;Integer&gt;[] graph = new ArrayList[n];     int[] degree = new int[n];     for (int idx = 0; idx &lt; n; idx++) {       graph[idx] = new ArrayList&lt;&gt;();     }     for (int[] edge : edges) {       int v1 = edge[0];       int v2 = edge[1];       degree[v1]++;       degree[v2]++;       graph[v1].add(v2);       graph[v2].add(v1);     }     Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();     for (int idx = 0; idx &lt; n; idx++) {       if (degree[idx] == 1) {         deque.add(idx);       }     }     while (n &gt; 2) {       int size = deque.size();       n -= size;       while (size &gt; 0) {         int idx = deque.pop();         degree[idx]--;         for (int val : graph[idx]) {           degree[val]--;           if (degree[val] == 1) {             deque.add(val);           }         }         size--;       }     }     result.addAll(deque);     return result;   }  }   결과  Link   설명     주어진 정수 n과 정수 배열 edges를 이용하여 만든 Tree가 최소 높이가 되는 Tree들(Minimum Height Trees - MHTs)의 root의 값을 반환하는 문제이다.            주어진 정수 n은 Tree의 노드의 개수이자 노드의 값의 상한선($n - 1$)을 의미한다.       주어진 정수 배열인 edges는 노드간 연결 정보를 저장한 배열이다.           최소 높이를 저장할 result인 List를 정의하여, 주어진 n이 1과 2인 경우 아래를 수행한다.            주어진 n이 1인 경우, result에 0을 넣어 주어진 문제의 결과로 반환한다.       주어진 n이 2인 경우, result에 0과 1을 넣어 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            graph는 가능한 Tree를 만들어 넣을 List의 배열로, n의 크기와 각 위치에 ArrayList를 초기화하여 넣어준다.       degree는 각 graph의 각 높이를 저장할 배열로, n의 크기로 초기화한다.           edges를 반복하여 degree와 graph를 초기화한다.            지역 변수 v1에 edge[0], v2에 edge[1]을 넣어준다.       degree의 v1번째 값과 v2번째 값을 증가시킨다.       graph의 v1번째 List에 v2를 넣어주고, v2번째 List에 v1을 넣어준다.                deque를 정의하여 degree가 1인 값만 deque에 넣어준다.       n이 2보다 클 때까지 반복하여 deque에 최소 높이가 되는 Tree들(MHTs)의 root 값을 넣어준다.            지역 변수 size에 deque의 크기를 넣어준다.       n에 해당 size 값을 빼준다.       size가 0보다 클 때까지 다시 반복을 수행한다.                    deque에서 값을 하나 꺼내와서 idx에 넣어준다.           graph의 idx번째 값들을 반복하여 degree의 해당 값의 위치 값을 빼주고, 해당 값이 1이 되면 deque에 넣어준다.           size를 감소시키고 반복을 계속 수행한다.                           반복이 완료되면 최소 높이가 되는 Tree들(MHTs)의 root 값들을 넣은 deque의 모든 값들을 result에 넣어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-height-trees/",
        "teaser": null
      },{
        "title": "Leetcode Java Burst Balloons",
        "excerpt":"문제  Link   코드  class Solution {    public int maxCoins(int[] nums) {     int length = nums.length;     int[] numbers = new int[length + 2];     numbers[0] = 1;     numbers[length + 1] = 1;     for (int idx = 0; idx &lt; length; idx++) {       numbers[idx + 1] = nums[idx];     }     int[][] dp = new int[length + 2][length + 2];     for (int j = 2; j &lt; numbers.length; j++) {       for (int i = j - 1; i &gt; 0; i--) {         int max = 0;         for (int k = i; k &lt; j; k++) {           max = Math.max(max, dp[i][k] + dp[k + 1][j] + (numbers[i - 1] * numbers[k] * numbers[j]));         }         dp[i][j] = max;       }     }     return dp[1][length + 1];   }  }   결과  Link   설명     주어진 정수 배열 nums를 이용하여 풍선터트려 받을 수 있는 최대 코인을 반환하는 문제이다.            i번째 풍선을 터트리면 $nums[i - 1] \\times nums[i] \\times nums[i + 1]$ 코인을 받는다.       $i - 1$ 혹은 $i + 1$의 자리가 배열의 범위를 벗어날 경우, 1의 값이 있다고 가정한다.           문제 풀이에 필요한 변수를 정의한다.            length는 주어진 배열 num의 길이를 저장할 배열이다.       numbers는 1번의 두 번째 조건을 만족하기 위해 주어진 nums의 앞 뒤에 1의 값을 추가할 배열로, $length + 2$ 크기로 정의하고 0번째와 $length + 1$번째 값에 1을 넣고 그 가운데는 nums의 값들을 넣어준다.                최대 코인을 산정하기 위해 2차원 배열인 dp를 가로와 세로의 길이가 $length + 2$의 크기로 정의한다.       반복문을 통해 dp에 값을 넣어준다.            2부터 numbers의 길이만큼 j를 증가시키며 반복하고, 다시 $j - 1$부터 i가 0보다 클 때까지 i를 감소시켜 반복한다.                    max에 임시로 0을 넣어주고 i부터 j 이전까지 k를 증가시켜 반복하여 max와 $dp[i][k] + dp[k + 1] + numbers[i - 1] \\times numbers[k] \\times numbers[j]$의 값중 최대 코인을 찾아 max에 넣어준다.           dp[i][j]에 위의 반복을 통해 정해진 max 값을 넣어준다.                           반복이 종료되면 최대 코인을 저장한 dp[1][length + 1]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/burst-balloons/",
        "teaser": null
      },{
        "title": "Leetcode Java Super Ugly Number",
        "excerpt":"문제  Link   코드  class Solution {    public int nthSuperUglyNumber(int n, int[] primes) {     int[] nums = new int[n];     int pre = 1;     int min = 1;     int length = primes.length;     int[] idx = new int[length];     int[] prePrimes = new int[length];     Arrays.fill(prePrimes, 1);     for (int i = 0; i &lt; n; i++) {       nums[i] = min;       min = Integer.MAX_VALUE;       for (int j = 0; j &lt; length; j++) {         if (prePrimes[j] == pre) {           prePrimes[j] = primes[j] * nums[idx[j]];           idx[j]++;         }         min = Math.min(prePrimes[j], min);       }       pre = min;     }     return nums[n - 1];   }  }   결과  Link   설명          주어진 정수 배열 primes의 소인수를 이용한 숫자를 만들 때 n번째가 되는 정수를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            nums는 primes의 소인수를 이용한 숫자를 넣을 배열로, 주어진 정수 n의 크기로 초기화한다.       pre는 이전의 값을 저장하는 변수이다.       min은 pre 다음에 나올 primes의 소인수를 이용한 숫자를 저장할 변수이다.       length는 primes의 길이를 저장할 변수이다.       idx는 primes의 동일 위치의 값을 반복한 횟수를 저장할 배열로, length의 크기로 초기화한다.       prePrimes는 primes를 이용하여 idx의 동일 위치번쨰 반복한 결과를 넣을 배열로, length의 크기로 초기화하고 모든 위치의 값을 1로 초기화한다.           0부터 n 전까지 i를 증가시키면서 반복하여 nums에 값을 넣어준다.            nums의 i번째 위치에 min 값을 넣어준다.       min 값에 Integer의 가장 큰 값을 넣어준다.       0부터 length 전까지 j를 증가시키면서 반복하여 min 값을 구한다.                    prePrimes의 j번쨰 값이 pre와 동일한 경우, prePrimes[j]의 값에 $primes[j] \\times num[idx[j]]$ 결과를 넣어주고 j를 증가시킨다.           min과 prePrimes[j]의 최소 값을 min에 넣어준다.                       pre에 min 값을 넣어준다.           primes의 소인수를 이용한 숫자를 만들 때 n번째 값이 되는 nums의 $n - 1$번째 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/super-ugly-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Count of Smaller Numbers After Self",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; countSmaller(int[] nums) {     int length = nums.length;     Integer[] result = new Integer[length];     int min = Integer.MAX_VALUE;     int max = Integer.MIN_VALUE;     for (int num : nums) {       min = Math.min(min, num);     }     for (int idx = 0; idx &lt; length; idx++) {       nums[idx] = nums[idx] - min + 1;       max = Math.max(max, nums[idx]);     }     int[] tree = new int[max + 1];     for (int idx = length - 1; idx &gt;= 0; idx--) {       result[idx] = this.get(tree, nums[idx] - 1);       this.update(tree, nums[idx]);     }     return Arrays.asList(result);   }    private void update(int[] tree, int index) {     int length = tree.length;     while (index &lt; length) {       tree[index]++;       index += (index &amp; -index);     }   }    private int get(int[] tree, int index) {     int count = 0;     while (index &gt; 0) {       count += tree[index];       index -= (index &amp; -index);     }     return count;   }  }   결과  Link   설명          주어진 정수 배열 nums의 값들을 이용하여 특정 위치의 값은 해당 위치 이후의 값들 중 자신보다 작은 값이 몇 개 존재하는지 각각 세서 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장하기 위한 변수이다.       result는 nums와 동일한 위치에 존재하는 값의 결과를 저장하기 위한 배열로, length의 크기로 초기화한다.       min은 nums 내 가장 작은 값을 저장할 배열로, Integer의 가장 큰 값으로 초기화하고 nums를 순회하며 가장 작은 값을 찾아 넣어준다.       max는 nums 내 가장 큰 값을 저장할 배열로, Integer의 가장 작은 값으로 초기화하고 nums를 순회하며 가장 큰 값을 찾아 넣어준다.                    단, 순회하면서 배열의 크기를 최소한으로 사용하기 위해 nums의 idx번째 값에 $nums[idx] - min + 1$ 값을 넣어 값들을 0 기준으로 평준화 시켜주고, 해당 값을 이용하여 큰 값을 산정한다.                           Binary index tree로 사용할 tree 배열을 $max + 1$ 크기로 정의하고, nums를 역순으로 탐색하여 결과를 세기 위해서 $length - 1$부터 0까지 반복을 수행한다.            reulst[idx]에 tree와 nums의 $idx - 1$ 값을 이용하여 개수를 세서 넣어준다.                    index가 0보다 클 때 까지 반복하여 count에 tree의 index번째 값을 넣어주고, index에 index와 -index 값을 AND(&amp;) 비트 연산하여 더하여 반복을 계속 수행한다.                       tree에 nums의 idx 값을 이용하여 값을 수정해준다.                    index가 tree의 길이보다 작을 떄 까지 반복하여 tree의 index번째 값을 증가시키고, index에 index와 -index 값을 AND(&amp;) 비트 연산하여 더하여 반복을 계속 수행한다.                           3번을 통해 계산된 특정 위치 이후의 값들 중 자신보다 작은 값의 개수를 산정한 result를 List로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-of-smaller-numbers-after-self/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove Duplicate Letters",
        "excerpt":"문제  Link   코드  class Solution {    public String removeDuplicateLetters(String s) {     StringBuilder sb = new StringBuilder();     int[] count = new int[26];     boolean[] chars = new boolean[26];     for (char c : s.toCharArray()) {       count[c - 'a'] += 1;     }     for (int i = 0, j = 0; i &lt; s.length(); i++) {       char curr = s.charAt(i);       if (!chars[curr - 'a']) {         while (j &gt; 0 &amp;&amp; sb.charAt(j - 1) &gt; curr &amp;&amp; count[sb.charAt(j - 1) - 'a'] &gt; 0) {           chars[sb.charAt(j - 1) - 'a'] = false;           sb.deleteCharAt(j - 1);           j--;         }         sb.append(curr);         chars[curr - 'a'] = true;         j++;       }       count[curr - 'a'] -= 1;     }     return sb.toString();   }  }   결과  Link   설명          주어진 문자열 s를 이용하여 각 문자의 중복을 제거하고, 문자열의 오름차순으로 정렬하여 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            sb는 주어진 문자열 s의 중복 제거된 문자열을 동적으로 넣기 위한 변수이다.                    동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.                       count는 주어진 문자열 s를 알파벳 순서로 존재했는지를 지정하기 위한 변수로, 알파벳 개수인 26으로 크기를 초기화한다.       chars는 특정 알파벳 문자가 존재했는지 여부를 저장하기 위한 변수로, 알파벳 개수인 26으로 크기를 초기화한다.                s를 반복하여 0(a)부터 25(z)까지 문자의 발생 빈도를 count에 넣어준다.       반복문을 통해 정의한 sb에 오름차순으로 중복제거된 문자열을 넣어준다.            curr에 s의 i번째 문자열을 넣어준다.       chars의 $curr - a(97)$번째 값이 false이면 아래를 수행한다.                    j가 0보다 크고, sb의 $j - 1$의 ASCII 값이 curr보다 크면서 sb의 $j - 1$번째 문자에 a(97)를 뺀 값이 0보다 큰 경우 count의 $j - 1$번째 문자에 a(97)를 뺀 위치에 false를 넣고, sb에서 $j - 1$번째 값을 제거하고 j를 감소시킨다.           sb에 curr을 넣어주고, chars의 $curr - a(97)$번째 값에 true를 넣어주고, j를 증가시킨다.                       반복이 종료되면 count의 $curr - a(97)$번째 값을 감소시킨다.           반복이 종료되면 중복을 제거한 오름차순 정렬된 문자의 조합을 넣은 sb를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-duplicate-letters/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Product of Word Lengths",
        "excerpt":"문제  Link   코드  class Solution {    public int maxProduct(String[] words) {     int length = words.length;     int[] value = new int[length];     for (int i = 0; i &lt; length; i++) {       for (char c : words[i].toCharArray()) {         value[i] |= 1 &lt;&lt; (c - 'a');       }     }     int result = 0;     for (int i = 0; i &lt; length; i++) {       int iThWordLength = words[i].length();       for (int j = i + 1; j &lt; length; j++) {         if ((value[i] &amp; value[j]) == 0) {           result = Math.max(result, iThWordLength * words[j].length());         }       }     }     return result;   }  }   결과  Link   설명          주어진 문자열 배열인 words를 이용하여 중복되지 않은 문자들로 이루어진 두 문자열의 길이 곱이 가장 큰 값을 찾는 문제이다.       문제 풀이에 필요한 변수를 저으이한다.            length는 words의 길이를 저장하기 위한 변수이다.       value는 각 문자열의 bit를 저장하기 위한 변수로, 모든 문자열을 이용하여 아래를 통해 값을 넣어준다.                    value의 i번째 값과 1을 $c - ‘a’(97)$ 값만큼 비트를 왼쪽으로 이동시킨 값의 OR(|) 비트 연산의 결과를 value의 i번째에 넣어준다.                                결과를 담을 result를 0으로 초기화 하여 선언한다.       0부터 length까지 반복하여 result에 결과를 넣어준다.            i번째 단어의 길이를 저장할 iThWordLegnth에 words의 i번쨰 문자의 길이를 넣어준다.       $i + 1$ 부터 length까지 반복하면서 value의 i번째 값과 value의 j번째 값의 AND(&amp;) 비트 연산 결과가 0인 경우, 아래를 수행한다.                    result에 result와 words의 i번째 문자 길이와 words의 j번쨰 문자 길이의 곱 중 큰 값을 넣어준다.                           반복이 완료되면 중복되지 않은 문자들로 이루어진 두 문자열의 길이 곱이 가장 큰 값을 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-product-of-word-lengths/",
        "teaser": null
      },{
        "title": "Leetcode Java Bulb Switcher",
        "excerpt":"문제  Link   코드  class Solution {    public int bulbSwitch(int n) {     return (int) Math.sqrt(n);   }  }   결과  Link   설명     주어진 정수 n개의 전구를 이용하여 아래의 룰대로 수행하여 켜진 전구의 수를 반환하는 문제이다.            처음 n개의 전구는 모두 꺼져있다.       n 번의 라운드를 수행하며, 매 라운드마다 n 번째의 전구를 스위칭하여 꺼진 전구는 켜고, 켜져있는 전구는 꺼준다.           주어진 n의 제곱근을 구하여 정수형으로 형변환한 값을 주어진 문제의 결과로 반환한다.            n보다 크지 않은 완전 제곱근의 수는 n의 제곱근의 정수부분이므로, Math.sqrt(n)의 결과를 정수형인 int로 형변환하여 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/bulb-switcher/",
        "teaser": null
      },{
        "title": "Leetcode Java Create Maximum Number",
        "excerpt":"문제  Link   코드  class Solution {    public int[] maxNumber(int[] nums1, int[] nums2, int k) {     int[] result = new int[k];     for (int i = Math.max(0, k - nums2.length); i &lt;= Math.min(nums1.length, k); i++) {       int[] maxNums1 = this.findMax(nums1, i);       int[] maxNums2 = this.findMax(nums2, k - i);       int[] merge = this.merge(maxNums1, maxNums2);       if (this.isGreater(merge, result, 0, 0)) {         result = merge;       }     }     return result;   }    private boolean isGreater(int[] nums1, int[] nums2, int i, int j) {     while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) {       if (nums1[i] &gt; nums2[j]) {         return true;       } else if (nums1[i] &lt; nums2[j]) {         return false;       } else {         i++;         j++;       }     }     return i &lt; nums1.length;   }    private int[] merge(int[] nums1, int[] nums2) {     int i = 0;     int j = 0;     int length = nums1.length + nums2.length;     int[] result = new int[length];     for (int k = 0; k &lt; length; k++) {       if (this.isGreater(nums1, nums2, i, j)) {         result[k] = nums1[i++];       } else {         result[k] = nums2[j++];       }     }     return result;   }    private int[] findMax(int[] nums, int k) {     int j = 0;     int length = nums.length;     int[] result = new int[k];     for (int i = 0; i &lt; length; i++) {       while (j &gt; 0 &amp;&amp; result[j - 1] &lt; nums[i] &amp;&amp; j + length - i &gt; k) {         j--;       }       if (j &lt; k) {         result[j++] = nums[i];       }     }     return result;   }  }   결과  Link   설명     주어진 정수 배열 nums1과 nums2를 이용하여 아래의 조건을 만족하는 k 크기의 최대 값을 가진 배열을 만드는 문제이다.            주어진 정수 k는 nums1과 nums2의 길이보다 같거나 작은 숫자로 주어진다.       nums1과 nums2의 각 배열의 상대적 순서를 유지하여 k 크기의 배열에 크기순으로 넣은 배열이 가장 큰 경우의 배열을 찾아 주어진 문제의 결과로 반환한다.                결과를 넣을 result 배열을 k크기로 초기화한다.            0과 $k - nums2.length$의 값중 큰 값부터 nums1.length와 k 중 작은 값 까지 반복하여 result에 문제의 결과를 넣어준다.       maxNums1에 nums1의 값들 중 가장 큰 값을 포함한 일련된 i개의 숫자로 배열을 만들어 넣어주고, maxNums2에 nums2의 값들 중 가장 큰 값을 포함한 일련된 $k - i$개의 숫자로 배열을 만들어 넣어준다.            findMax(int[] nums, int k) 메서드는 nums의 숫자들을 모두 순회하여 일련된 가장 큰 값을 포함한 k개의 숫자로 배열을 만들어 넣어준다.           4번을 통해 큰 값들을 찾은 두 배열인 maxNums1과 maxNums2를 숫자 크기의 내림차순으로 합친 배열을 merge에 넣어준다.            merge(int[] nums1, int[] nums2) 메서드는 nums1과 nums2의 값들이 들어갈 크기의 배열을 선언하여 어느 값이 큰지를 isGreater(int[] nums1, int[] nums2, int i, int j) 메서드를 이용하여 검증하여 해당 배열에 넣어주고, 해당 배열을 반환한다.                isGreater(int[] nums1, int[] nums2, int i, int j) 메서드를 이용하여 merge와 result를 처음 값부터 비교하여 어느 배열이 순차적으로 큰 값으로 존재하는지를 검증하고, merge가 큰 경우 result에 넣고 반복을 계속 수행한다.       반복이 완료되면 nums1과 nums2의 각 배열의 상대적 순서를 유지하여 k 크기의 배열에 크기순으로 넣은 배열이 가장 큰 경우의 배열인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/create-maximum-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Coin Change",
        "excerpt":"문제  Link   코드  class Solution {    public int coinChange(int[] coins, int amount) {     int[] dp = new int[amount + 1];     Arrays.fill(dp, amount + 1);     dp[0] = 0;     for (int idx = 0; idx &lt; amount + 1; idx++) {       for (int coin : coins) {         if (idx &gt;= coin) {           dp[idx] = Math.min(dp[idx], 1 + dp[idx - coin]);         }       }     }     return dp[amount] &gt; amount ? -1 : dp[amount];   }  }   결과  Link   설명     주어진 정수 배열 coins의 값들로 amount를 만들 수 있는 최소한의 코인의 개수를 구하는 문제이다.            단, amount를 만들 수 없는 경우 -1을 주어진 문제의 결과로 반환한다.                dp 배열을 $amount + 1$ 크기로 정의하고, 첫 값에는 0을 그 외에는 amount + 1 값을 넣어준다.       0부터 $amount + 1$까지 idx를 증가시키며 dp에 값을 넣어준다.            coins를 반복하여 idx가 coin의 값보다 큰 경우, dp의 idx번째 값에 dp의 idx번째 값과 dp의 $idx - coin$의 값에 1을 더한 값보다 작은 값을 넣어준다.           반복이 완료되어 dp에 값이 다 채워진 경우, dp의 amount번쨰 값이 amount보다 큰 경우 -1을 작은 경우 dp의 amount번째 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/coin-change/",
        "teaser": null
      },{
        "title": "Leetcode Java Wiggle Sort II",
        "excerpt":"문제  Link   코드  class Solution {    public void wiggleSort(int[] nums) {     int length = nums.length;     if (length == 1) {       return;     }     int[] count = new int[5001];     for (int num : nums) {       count[num]++;     }     int j = 1;     for (int i = 5000; i &gt;= 0; i--) {       while (count[i] &gt; 0) {         nums[j] = i;         count[i]--;         j += 2;         if (j &gt;= length) {           j = 0;         }       }     }   }  }   결과  Link   설명     주어진 배열 nums를 이용하여 아래의 조건을 만족하는 배열로 변환하는 문제이다.            배열 내 값들은 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3] … 와 같이 특정 위치의 값은 좌측의 값보다 커야하고, 우측 값보다 작아야한다.       O(1)의 시간 복잡도 또는 In-Place 알고리즘으로 O(n)의 여분 공간으로 풀이하는 것을 요구한다.                length에 nums의 길이를 넣어주고, length가 1인 경우 정렬이 필요하지 않으므로 반환한다.            숫자를 넣을 count 배열을 정의하고, nums 내 값의 범위인 0 ~ 5000까지 값을 세기 위해 5001 크기로 초기화한다.            nums를 순회하여 count 배열에 num번째 값을 증가시킨다.       j를 1로 정의하고, 5000부터 0까지 i를 감소시키며 nums의 값을 변경시켜준다.            count[i]의 값이 0보다 큰 경우, 아래를 수행한다.                    nums의 j번째 위치에 i를 넣어주고, count의 i번째 값을 감소시킨다.           j를 2 증가시키고, j가 length보다 큰 경우 0으로 초기화한다.                       위의 방식대로 반복을 계속하여 큰 수를 nums의 홀수 위치에 차례대로 넣고, 작은 수를 다시 앞에서부터 nums의 0을 포함한 짝수 위치에 차례대로 넣어준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/wiggle-sort-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Count of Range Sum",
        "excerpt":"문제  Link   코드  class Solution {    public int countRangeSum(int[] nums, int lower, int upper) {     int length = nums.length;     long[] sum = new long[length + 1];     for (int idx = 0; idx &lt; length; idx++) {       sum[idx + 1] = sum[idx] + nums[idx];     }     return this.recursive(sum, new long[length + 1], 0, length, lower, upper);   }    private int recursive(long[] sum, long[] cache, int low, int high, long lower, long upper) {     if (low &gt;= high) {       return 0;     }     int mid = (high + 1 - low) / 2 + low;     int count = this.recursive(sum, cache, low, mid - 1, lower, upper) + this.recursive(sum, cache, mid, high, lower, upper);     int start = mid;     int end = mid;     for (int idx = low; idx &lt; mid; idx++) {       while (start &lt;= high &amp;&amp; sum[start] - sum[idx] &lt; lower) {         start++;       }       while (end &lt;= high &amp;&amp; sum[end] - sum[idx] &lt;= upper) {         end++;       }       count += end - start;     }     this.merge(sum, cache, low, mid, high);     return count;   }    private void merge(long[] sum, long[] cache, int low, int mid, int high) {     int left = low;     int right = mid;     int idx = low;     while (left &lt; mid &amp;&amp; right &lt;= high) {       if (sum[left] &lt;= sum[right]) {         cache[idx++] = sum[left++];       } else {         cache[idx++] = sum[right++];       }     }     while (left &lt; mid) {       cache[idx++] = sum[left++];     }     while (right &lt;= high) {       cache[idx++] = sum[right++];     }     System.arraycopy(cache, low, sum, low, high + 1 - low);   }  }   결과  Link   설명     주어진 정수 배열 nums를 이용하여 주어진 정수 lower에서 upper 범위를 포함한 부분 범위 합의 개수를 반환하는 문제이다.            범위 합 S(i, j)는 i와 j를 포함한 nums 배열 내 값들의 합으로 정의된다. (단, i &lt;= j이다.)           문제 풀이에 필요한 변수를 정의한다.            length는 주어진 정수 배열 nums의 길이를 저장하는 변수이다.       sum은 주어진 nums를 차례대로 합을 저장하는 배열로, nums를 순회하여 sum에 값을 누계하여 넣어준다.           부분 범위 합의 개수를 세기 위한 recursive(long[] sum, long[] cache, int low, int high, long lower, long upper) 메서드를 완성한다.            low가 high보다 크거나 같은 경우, 0을 반환한다.       mid에 $\\frac{high + 1 - low}{2} + low$의 값을 넣어준다.       count는 $mid - 1$로 재귀호출한 값과 mid로 재귀호출한 값을 넣어준다.       start와 end에 mid 값을 넣어준다.       low부터 mid 전까지 idx를 증가시키며 반복시켜 아래를 수행한다.                    high가 start보다 크거나 같고 $sum[start] - sum[idx]$ 값이 lower보다 작을때까지 반복하여 start를 증가시켜준다.           high가 end보다 크거나 같고 $sum[end] - sum[idx]$ 값이 upper보다 작거나 같을때까지 반복하여 end를 증가시켜준다.           위의 반복이 완료되면 count에 $end - start$ 값을 넣어준다.                       위의 반복이 완료되면 아래의 4번에서 정의한 merge(sum, cache, low, mid, high) 메서드를 호출하여 mergeSort를 수행하고 count를 반환한다.           위의 mergeSort를 하기 위한 merge(long[] sum, long[] cache, int low, int mid, int high) 메서드를 완성한다.            left와 idx에 low를, right에 mid 값을 넣어준다.       left가 mid보다 작고 right가 high보다 같거나 작을때까지 반복하여 아래를 수행한다.                    sum[left]의 값이 sum[right]값보다 작거나 같으면, cache[idx]에 sum[left] 값을 넣어주고 idx와 left를 증가시켜준다.           sum[left]의 값이 sum[right]값보다 크면, cache[idx]에 sum[right] 값을 넣어주고 idx와 right를 증가시켜준다.                       left가 mid보다 작을때까지 반복하여 cache[idx]에 sum[left] 값을 넣어주고 idx와 left를 증가시킨다.       right가 high보다 작거나 같을때까지 반복하여 cache[idx]에 sum[right] 값을 넣어주고 idx와 right를 증가시킨다.       cache의 low부터 $high + 1 - low$개의 값들을 sum의 low부터 차례대로 값을 넣어준다.           3, 4번을 수행하여 확인한 부분 배열의 개수인 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-of-range-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Odd Even Linked List",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode oddEvenList(ListNode head) {     if (head != null) {       ListNode odd = head;       ListNode even = head.next;       ListNode temp = head.next;       while (even != null &amp;&amp; even.next != null) {         odd.next = even.next;         even.next = even.next.next;         odd = odd.next;         even = even.next;       }       odd.next = temp;     }     return head;   }  }   결과  Link   설명     주어진 ListNode인 head를 이용하여 짝수번째 값들을 head의 뒤로 이동시키는 문제이다.            반드시 O(1)의 추가 공간 복잡도와 O(n)의 시간 복잡도로 문제를 풀어야 한다.                head가 null이 아닌 경우만 3 ~ 5번을 수행한다.       문제 풀이에 필요한 변수를 정의한다.            odd는 홀수번째 값을 ListNode로 저장할 변수로, head로 초기화한다.       even은 짝수번쨰 값을 ListNode로 저장할 변수로, head.next로 초기화한다.       temp는 even을 이용하여 뒤로 미룰 값들을 ListNode로 저장할 변수로, even과 동일하게 head.next로 초기화한다.           even과 even.next ListNode들이 null이 아닌 경우, 아래를 수행한다.            odd.next에 evne.next를 넣어준다.       even.next에 even.next.next를 넣어준다.       odd에 odd.next를 넣어준다.       even에 evne.next를 넣어준다.                odd.next에 temp를 넣어 짝수번째 위치의 값들을 이어준다.       짝수번째 값들을 뒤로 이동시킨 head를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/odd-even-linked-list/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Increasing Path in a Matrix",
        "excerpt":"문제  Link   코드  class Solution {    public int longestIncreasingPath(int[][] matrix) {     int row = matrix.length;     int col = matrix[0].length;     int[][] memory = new int[row][col];     int result = 0;     for (int i = 0; i &lt; row; i++) {       for (int j = 0; j &lt; col; j++) {         result = Math.max(result, this.recursive(matrix, memory, i, j, row, col));       }     }     return result;   }    private int recursive(int[][] matrix, int[][] memory, int i, int j, int row, int col) {     if (memory[i][j] &gt; 0) {       return memory[i][j];     }     int num = matrix[i][j];     int result = 0;     if (i &gt; 0 &amp;&amp; matrix[i - 1][j] &gt; num) {       result = Math.max(result, this.recursive(matrix, memory, i - 1, j, row, col));     }     if (i + 1 &lt; row &amp;&amp; matrix[i + 1][j] &gt; num) {       result = Math.max(result, this.recursive(matrix, memory, i + 1, j, row, col));     }     if (j &gt; 0 &amp;&amp; matrix[i][j - 1] &gt; num) {       result = Math.max(result, this.recursive(matrix, memory, i, j - 1, row, col));     }     if (j + 1 &lt; col &amp;&amp; matrix[i][j + 1] &gt; num) {       result = Math.max(result, this.recursive(matrix, memory, i, j + 1, row, col));     }     memory[i][j] = ++result;     return result;   }  }   결과  Link   설명     주어진 정수 배열인 matrix를 이용하여 해당 위치의 값보다 이동한 위치의 값이 큰 값으로 이동하는 경우, 가능한 최대 이동 거리를 반환하는 문제이다.            각 셀에서 상, 하, 좌, 우 네 방향으로만 움직일 수 있다.       대각선으로 이동하거나 배열 밖으로 움직일 수 없다.           문제 풀이에 필요한 변수를 정의한다.            row은 matrix의 행의 개수를 저장하기 위한 변수로, matirx.length를 넣어준다.       col은 matrix의 열의 개수를 저장하기 위한 변수로, matrix[0].length를 넣어준다.       memory는 matrix를 이용하여 이동하는 경우, 최대 이동 거리를 기억하기 위한 임시 배열이다.       result는 matrix를 순회하여 최대 이동 거리를 저장하기 위한 변수이다.           matrix를 순회하여 result에 최대 이동 거리를 저장한다.            result에 result와 4번에서 정의한 recursive(matrix, memory, i, j, row, col) 메서드의 수행 결과 중 큰 값을 넣어준다.           DFS(Depth-first search) 알고리즘을 이용하여 최대 이동거리를 구할 recursive(int[][] matrix, int[][] memory, int i, int j, int row, int col) 메서드를 정의한다.            memory[i][j]의 값이 0보다 큰 경우 이미 최대 이동 거리를 계산한 위치이므로, 해당 값을 반환한다.       문제 풀이에 필요한 변수를 정의한다.                    num은 matrix[i][j]의 값 저장할 변수이다.           result는 최대 이동 거리를 계산하기 위한 변수로, 0으로 초기화한다.                       i가 0보다 크고 matrix[$i - 1$][j]의 값이 num보다 큰 경우, result에 result와 좌측의 위치인 $i - 1$로 재귀 호출한 결과 중 큰 값을 넣어준다.       $i + 1$이 row보다 작고 matrix[$i + 1][j]의 값이 num보다 큰 경우, result에 result와 우측의 위치인 $i + 1$로 재귀 호출한 결과 중 큰 값을 넣어준다.       j가 0보다 크고 matrix[i][$j - 1$] 값이 num보다 큰 경우, result에 result와 아래의 위치인 $j - 1$로 재귀 호출한 결과 중 큰 값을 넣어준다.       $j + 1$이 col보다 작고 matrix[i][j + 1]의 값이 num보다 큰 경우, result에 result와 위의 위치인 $j + 1$로 재귀 호출한 결과 중 큰 값을 넣어준다.       result를 증가시키고 memory[i][j]의 위치에 값을 넣고, 반환시킨다.           반복이 완료되어 matrix를 이용하여 값이 증가하며 이동하는 최대 이동 거리가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-increasing-path-in-a-matrix/",
        "teaser": null
      },{
        "title": "Leetcode Java Patching Array",
        "excerpt":"문제  Link   코드  class Solution {    public int minPatches(int[] nums, int n) {     int length = nums.length;     int miss = 1;     int count = 0;     for (int idx = 0; 0 &lt; miss &amp;&amp; miss &lt;= n;) {       if (idx &lt; length &amp;&amp; nums[idx] &lt;= miss) {         miss += nums[idx++];       } else {         miss += miss;         count++;       }     }     return count;   }  }   결과  Link   설명          주어진 배열 nums의 값들을 이용하여 부분 배열의 합이 1 ~ n까지 가능하기 위해, nums에 추가할 숫자의 개수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length 는 주어진 배열 nums의 길이를 저장할 변수로, nums.length를 넣어준다.       miss는 추가할 숫자를 저장할 변수로, 첫 값은 1로 넣어준다.       count는 추가할 숫자의 개수를 저장할 변수로, 0으로 초기화한다.           miss가 0부터 0보다 크고 n보다 작거나 같을 때까지 idx를 증가시키며 반복하여 아래를 수행한다.            idx가 length보다 작고 nums의 idx번째 값이 miss보다 작을 경우, miss에 nums[idx] 값을 추가하고 idx를 증가시킨다.       위의 경우가 아닌 경우, miss에 miss를 더해주고 count를 증가시킨다.           반복이 완료되면 nums의 값들을 이용하여 부분 배열의 합이 1 ~ n까지 가능하기 위해, nums에 추가할 숫자의 개수를 계산한 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/patching-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Verify Preorder Serialization of a Binary Tree",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isValidSerialization(String preorder) {     char[] nodes = preorder.toCharArray();     int slots = 1;     for (int idx = 0; idx &lt; nodes.length; idx++) {       if (nodes[idx] == ',') {         --slots;         if (slots &lt; 0) {           return false;         }         if (nodes[idx - 1] != '#') {           slots += 2;         }       }     }     slots = (nodes[nodes.length - 1] == '#') ? slots - 1 : slots + 1;     return slots == 0;   }  }   결과  Link   설명          주어진 문자열 preorder는 TreeNode의 값들과 Null인 Node는 “#” 문자열을 사용하여 사전 정렬(preorder) 순으로 콤마(,)로 구분하여 넣은 값으로, 해당 문자열이 유효한 TreeNode로 구성되었는지를 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            Nodes는 preorder의 값들을 문자 별 분리하여 저장할 배열이다.       slots는 preorder를 이용하여 유효한 TreeNode인지를 검증하기 위한 변수로, 1로 초기화 한다.           nodes를 순회하여 검증을 수행한다.            nodes의 idx번째 값이 콤마(“,”)인 경우, 아래를 수행한다.                    slots를 감소시켜준다.           만일 slots가 0보다 작아지는 경우 유효한 TreeNode가 될 수 없으므로, false를 주어진 문제의 결과로 반환한다.           nodes의 $idx - 1$번째 값이 “#” 문자가 아닌 경우 노드가 존재한다는 의미이므로, slots를 2 증가 시켜준다.                                반복이 완료되면 nodes의 마지막 값이 #이면 slots를 1 감소시키고, 아닌 경우 1을 증가시킨다.       slots가 0이면 각 값들이 유효한 위치에 존재한다는 의미이므로, 해당 검증 결과를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/verify-preorder-serialization-of-a-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Reconstruct Itinerary",
        "excerpt":"문제  Link   코드  class Solution {    private Map&lt;String, Queue&lt;String&gt;&gt; targets = new HashMap&lt;&gt;();   private List&lt;String&gt; result = new ArrayList&lt;&gt;();    public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) {     for (List&lt;String&gt; ticket : tickets) {       this.targets.putIfAbsent(ticket.get(0), new PriorityQueue&lt;&gt;());       this.targets.get(ticket.get(0)).add(ticket.get(1));     }     this.recursive(\"JFK\");     return this.result;   }    private void recursive(String departure) {     while (this.targets.containsKey(departure) &amp;&amp; !this.targets.get(departure).isEmpty()) {       this.recursive(this.targets.get(departure).poll());     }     this.result.add(0, departure);   }  }   결과  Link   설명     주어진 tickets는 [출발지, 목적지] 순의 티켓 정보를 가진 컬렉션으로, 해당 컬렉션을 이용하여 목적지의 문자열이 어휘 순서가 작은 순서대로 여정을 만드는 문제이다.            단, 여정의 출발은 “JFK”부터 시작한다.       예를 들어, [“JFK”, “LGA”]는 [“JFK”, “LGB”] 보다 어휘 순서가 작다.           문제 풀이에 필요한 전역 변수를 정의한다.            targets는 출발지 별 목적지 정보를 담기 위한 컬렉션이다.       result는 주어진 여정을 넣기 위한 컬렉션이다.           주어진 tickets를 반복하여 targets를 초기화 한다.            targets에 ticket의 첫 번째 값인 출발지가 존재하지 않는 경우, 해당 값으로 targets에 새 PriorityQueue를 넣어준다.       targets 내 ticket의 첫 번째 값인 출발지가 Key인 값에 ticket의 두 번째 값인 목적지를 넣어준다.           targets의 departure 값이 존재하고, targets의 departure의 값이 비어있지 않을 때 까지 아래를 수행한다.            targets의 departure의 값 중 첫 값을 빼서 재귀 호출을 수행한다.                4번의 재귀 호출이 끝나면 result의 첫 값에 departure를 추가한다.       4, 5번을 통해서 목적지의 문자열이 어휘 순서가 작은 순서대로의 여정을 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reconstruct-itinerary/",
        "teaser": null
      },{
        "title": "Leetcode Java Increasing Triplet Subsequence",
        "excerpt":"문제  Link   코드  class Solution {    public boolean increasingTriplet(int[] nums) {     int big = Integer.MAX_VALUE;     int small = Integer.MAX_VALUE;     for (int num : nums) {       if (num &lt;= small) {         small = num;       } else if (num &lt; big) {         big = num;       } else if (num &gt; big) {         return true;       }     }     return false;   }  }   결과  Link   설명     주어진 nums를 이용하여 값이 증가하는 연속된 세 숫자가 존재하는지 검증하는 문제이다.            연속된 각 숫자 i, j, k는 i &lt; j &lt; k이며, nums[i] &lt; nums[j] &lt; nums[k]의 관계를 성립한다.           문제 풀이에 필요한 변수를 정의한다.            big과 small은 위의 i와 k인 큰 값과 작은 값을 넣을 변수로, 각각 int형의 가장 큰 값을 넣어준다.           nums를 순회하여 검증을 수행한다.            num이 small보다 작거나 같으면, small에 num을 넣어준다.       위의 경우가 아니면서 num이 big보다 작을 경우, big에 num을 넣어준다.       위의 경우들이 아니면서 num이 big보다 클 경우, true를 주어진 문제의 결과로 반환한다.           반복이 종료되면 값이 증가하는 연속된 세 숫자가 없다는 의미이므로, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/increasing-triplet-subsequence/",
        "teaser": null
      },{
        "title": "Leetcode Java Self Crossing",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isSelfCrossing(int[] distance) {     int length = distance.length;     if (length &lt;= 3) {       return false;     }     int idx = 2;     while (idx &lt; length &amp;&amp; distance[idx] &gt; distance[idx - 2]) {       idx++;     }     if (idx &gt;= length) {       return false;     }     if ((idx &gt;= 4 &amp;&amp; distance[idx] &gt;= distance[idx - 2] - distance[idx - 4]) ||       (idx == 3 &amp;&amp; distance[idx] == distance[idx - 2])) {       distance[idx - 1] -= distance[idx - 3];     }     idx++;     while (idx &lt; length) {       if (distance[idx] &gt;= distance[idx - 2]) {         return true;       }       idx++;     }     return false;   }  }   결과  Link   설명          주어진 정수 배열 distance를 이용하여 [0, 0]부터 시작하여 상, 좌, 하, 우 순서로 이동하여 교차하는 지점이 있는지 검증하는 문제이다.            length는 distance의 길이를 저장할 변수로, distance.length로 초기화 시켜준다.       length가 3 이하인 경우, 교차하는 구간이 존재하지 않기 때문에, false를 주어진 문제의 결과로 반환한다.            대각선을 제외한 줄을 그어 교차하는 구간을 구하기 위해선, 최소 4번의 이동이 필요하다.                idx에 2를 넣고, idx가 length보다 작고 distance의 idx번째 값이 distance의 $idx - 2$번째 값보다 클 때 까지 idx를 증가시킨다.       idx가 length와 같거나 클 경우 교차하는 구간이 존재하지 않으므로, false를 주어진 문제의 결과로 반환한다.            4번을 통해 선의 이동이 소용돌이처럼 교차하지 않고 커지는 경우이다.           아래의 조건들 중 하나라도 만족하면, distance의 $idx - 1$번째 값에 distance의 $idx - 3$번째 값이 차이를 distance의 $idx - 1$번째 자리에 넣어 바깥쪽으로 나선형 모양이 되는 것을 안쪽으로 전환시킨다.            idx가 4보다 클 때, distance의 idx번째 값이 distance의 $idx - 2$번째 값과 distinct의 $idx - 4$번째 값의 차이보다 크거나 같은 경우.       idx가 3인 경우, distance의 idx번째 값과 distance의 $idx - 2$번째 값이 같은 경우.           idx를 증가시키고, idx가 length보다 작을 때까지 아래를 반복한다.            distance의 idx번째 값이 distance의 $idx - 2$번쨰 값보다 크거나 같으면 교차하는 지점이 생긴다는 의미이므로, true를 주어진 문제의 결과로 반환한다.       idx를 증가시키고 반복을 계속 수행한다.           반복이 종료되면 교차하는 지점이 생기지 않는다는 의미이므로, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/self-crossing/",
        "teaser": null
      },{
        "title": "Leetcode Java Palindrome Pairs",
        "excerpt":"문제  Link   코드  class Solution {    private TrieNode root = new TrieNode();    public List&lt;List&lt;Integer&gt;&gt; palindromePairs(String[] words) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     int length = words.length;     for (int idx = 0; idx &lt; length; idx++) {       this.add(words[idx], idx);     }     for (int idx = 0; idx &lt; length; idx++) {       this.search(result, words[idx], idx);     }     return result;   }    private boolean isPalindrome(char[] charArray, int start, int end) {     while (start &lt; end) {       if (charArray[start++] != charArray[end--]) {         return false;       }     }     return true;   }    private void add(String word, int wordIndex) {     TrieNode temp = root;     char[] charArray = word.toCharArray();     for (int idx = charArray.length - 1; idx &gt;= 0; idx--) {       int num = charArray[idx] - 'a';       if (this.isPalindrome(charArray, 0, idx)) {         temp.palindromeWordIndexes.add(wordIndex);       }       if (temp.children[num] == null) {         temp.children[num] = new TrieNode();       }       temp = temp.children[num];     }     temp.wordIndex = wordIndex;   }    private void search(List&lt;List&lt;Integer&gt;&gt; result, String word, int wordIndex) {     TrieNode temp = root;     char[] charArray = word.toCharArray();     for (int idx = 0; idx &lt; charArray.length; idx++) {       int num = charArray[idx] - 'a';       if (temp.wordIndex != -1 &amp;&amp; this.isPalindrome(charArray, idx, charArray.length - 1)) {         result.add(Arrays.asList(wordIndex, temp.wordIndex));       }       if (temp.children[num] == null) {         return;       }       temp = temp.children[num];     }     if (temp.wordIndex != -1 &amp;&amp; temp.wordIndex != wordIndex) {       result.add(Arrays.asList(wordIndex, temp.wordIndex));     }     for (int palindromeWordIndex : temp.palindromeWordIndexes) {       result.add(Arrays.asList(wordIndex, palindromeWordIndex));     }   }  }  class TrieNode {    public int wordIndex;   public List&lt;Integer&gt; palindromeWordIndexes;   public TrieNode[] children;    public TrieNode() {     this.wordIndex = -1;     this.palindromeWordIndexes = new ArrayList&lt;&gt;();     this.children = new TrieNode[26];   }  }   결과  Link   설명          앞뒤로 읽어도 같은 문자열(이하 회문)을 만들 수 있는 주어진 문자열 배열인 words 내 두 단어의 조합의 인덱스를 반환하는 문제이다.       문제 풀이에 필요한 TrieNode 클래스를 정의한다.            wordIndex는 해당 단어의 words 내 위치인 인덱스를 저장하는 변수이다.       palindromeWordIndexes는 회문이 되는 words 내 위치인 인덱스를 저장할 변수이다.       children은 해당 단어까지의 문자열 이후의 문자열을 이어주기 위한 변수로, 객체 생성 시 다음 문자를 저장하기 위해 알파벳의 개수인 26 크기의 TrieNode 배열로 초기화 한다.           문제 풀이에 필요한 전역 변수를 정의한다.            root는 주어진 words를 이용하여 Trie를 완성하기 위한 변수이다.           문제 풀이에 필요한 isPalindrome(char[] charArray, int start, int end) 메서드를 완성한다.            start가 end보다 작을 때 까지 반복하여 charArray의 start번째 값과 end번째 값이 같지 않으면 회문이 아니므로 false를 반환하고, start를 증가시키고 end를 감소시키고 반복을 계속 진행한다.       반복이 완료되면 charArray가 회문으로 구성되어 있으므로 true를 반환한다.           문제 풀이에 필요한 add(String word, int wordIndex) 메서드를 완성한다.            root를 지역 변수 temp에 넣어주고, word를 charArray에 문자의 배열로 변환하여 넣어준다.       charArray를 역순으로 반복하여 Trie를 완성한다.                    num에 charArray의 idx번째 문자와 ‘a’의 차이인 영소문자의 순서값으로 변환시킨다.           charArray의 0부터 idx번째 값까지 4번의 isPalindrome 메서드를 활용하여 검증하고, 회문이 되면 temp의 palindromeWordIndexes에 wordIndex를 넣어준다.           temp.children의 num번째 TrieNode가 null인 경우, 새 TrieNode를 생성하여 넣어준다.           temp에 temp.children의 num번째 TrieNode를 넣고 반복을 계속 진행한다.                       반복이 완료되면 temp.wordIndex에 wordIndex를 넣어준다.           문제 풀이에 필요한 search(List&lt;List&gt; result, String word, int wordIndex) 메서드를 완성한다.            root를 지역 변수 temp에 넣어주고, word를 charArray에 문자의 배열로 변환하여 넣어준다.       charArray를 처음부터 끝까지 반복하여 검색을 수행한다.                    num에 charArray의 idx번째 문자와 ‘a’의 차이인 영소문자의 순서값으로 변환시킨다.           temp.wordIndex가 -1이 아니면서 charArray의 idx번째 값부터 끝까지 회문이 되는 경우, result에 wordIndex와 temp.wordIndex를 List로 묶어 넣어준다.           temp.children의 num번째 값이 null인 경우, 문자열의 끝이므로 검색을 중단한다.           temp에 temp.children의 num번째 값을 넣어주고 반복을 계속 수행한다.                       temp.wordIndex가 -1이 아니면서 temp.wordIndex가 wordIndex가 아닌 경우 전체가 회문이 되는 경우이므로, result에 wordIndex와 temp.wordIndex를 List로 묶어 넣어준다.       temp의 palindromeWordIndexes를 반복하여 회문이 되는 모든 조합을 result에 wordIndex와 palindromeWordIndex를 List로 묶어 넣어준다.           문제 풀이에 수행되는 palindromePairs(String[] words) 메서드를 완성한다.            문제 풀이에 필요한 변수를 정의한다.                    result는 회문이 되는 조합을 넣을 List로, 새 ArrayList로 초기화 하여 정의한다.           length는 words의 길이를 저장할 변수로, words.length를 넣어 정의한다.                       0부터 length까지 idx를 증가시키며, 5번에서 생성한 add(String word, int wordIndex) 메서드를 이용하여 words의 각 문자들을 TrieNode에 넣어준다.       0부터 length까지 idx를 증가시키며, 6번에서 생성한 search(List&lt;List&gt; result, String word, int wordIndex) 메서드를 이용하여 result에 회문이 되는 모든 조합을 넣어준다.       위의 수행이 완료되면 회문이 되는 모든 두 문자의 조합을 넣은 result를 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/palindrome-pairs/",
        "teaser": null
      },{
        "title": "Leetcode Java House Robber III",
        "excerpt":"문제  Link   코드  class Solution {    public int rob(TreeNode root) {     int[] result = this.recursive(root);     return Math.max(result[0], result[1]);   }    private int[] recursive(TreeNode root) {     int[] result = new int[2];     if (root == null) {       return result;     }     int[] left = this.recursive(root.left);     int[] right = this.recursive(root.right);     result[0] = root.val + left[1] + right[1];     result[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);     return result;   }  }   결과  Link   설명     주어진 TreeNode인 root의 최상위 노드부터 시작해서 도둑질할 수 있는 최대 금액을 구하는 문제이다.            단, 자식 노드가 두 개인 노드의 금액은 도둑질이 불가능하다.           재귀 호출을 사용하여 root를 순회할 recursive(TreeNode root) 메서드를 완성한다.            정수 배열인 result를 최대 자식 노드의 개수인 2의 크기로 초기화 하여 정의한다.       root가 null인 경우 더 이상 탐색이 불가능하므로, result를 그대로 반환한다.       root의 left TreeNode를 재귀 호출한 결과를 left에, right TreeNode를 재귀 호출한 결과를 right에 넣어준다.       result에 재귀 호출로 구해진 left와 right를 이용하여 두 값을 넣어준다.                    첫 번째 값에 $root.val + left[1] + right[1]$을 넣어준다.           두 번째 값에 left[0]과 left[1] 중 큰 값과 right[0]과 right[1] 중 큰 값의 합을 넣어준다.                       result를 반환한다.           root를 2번의 재귀 호출을 수행한 결과를 result에 넣어주고, result[0] 과 result[1] 중 큰 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/house-robber-iii/",
        "teaser": null
      },{
        "title": "Leetcode Java Counting Bits",
        "excerpt":"문제  Link   코드  class Solution {    public int[] countBits(int n) {     int[] result = new int[n + 1];     for (int idx = 1; idx &lt;= n; idx++) {       result[idx] = result[idx &amp; (idx - 1)] + 1;     }     return result;   }  }   결과  Link   설명          주어진 정수 n을 이용하여 0 ~ n까지 bit 형식에 포함된 1의 개수를 배열의 각 위치에 넣어 반환하는 문제이다.            결과를 넣을 result 배열을 0 ~ n까지 넣어야 하므로, $n + 1$ 크기로 정의한다.       1부터 n까지 idx를 증가시켜 각 숫자의 bit 형식에 포함된 1의 개수를 센다.            result의 idx번째 값에 result의 idx와 $idx - 1$의 AND(&amp;) 비트 연산을 수행한 결과의 위치 값에 1을 더하여 넣어주고, 반복을 계속 수행한다.                    idx &amp; $idx - 1$의 비트 연산의 수행은 가장 낮은 세트 비트를 삭제한다.           예를 들어 idx가 14인 경우 비트는 1110로, $idx - 1$은 1101로 AND(&amp;) 비트 연산의 결과는 1100이 되므로 1이 2개여서 추가로 1을 더하면 result[14]는 3이 된다.           위의 내용을 정리하면 $result[idx] = result[idx &amp; (idx - 1)] + 1$이 성립한다.                           0 ~ n까지 bit 형식에 포함된 1의 개수를 넣은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/counting-bits/",
        "teaser": null
      },{
        "title": "Leetcode Java Flatten Nested List Iterator",
        "excerpt":"문제  Link   코드  /**  * // This is the interface that allows for creating nested lists.  * // You should not implement it, or speculate about its implementation  * public interface NestedInteger {  *  *     // @return true if this NestedInteger holds a single integer, rather than a nested list.  *     public boolean isInteger();  *  *     // @return the single integer that this NestedInteger holds, if it holds a single integer  *     // Return null if this NestedInteger holds a nested list  *     public Integer getInteger();  *  *     // @return the nested list that this NestedInteger holds, if it holds a nested list  *     // Return empty list if this NestedInteger holds a single integer  *     public List&lt;NestedInteger&gt; getList();  * }  */ public class NestedIterator implements Iterator&lt;Integer&gt; {    private LinkedList&lt;Iterator&lt;NestedInteger&gt;&gt; linkedList;   private Iterator&lt;NestedInteger&gt; currentIterator;   private Integer next;    public NestedIterator(List&lt;NestedInteger&gt; nestedList) {     this.linkedList = new LinkedList&lt;&gt;();     this.currentIterator = nestedList.iterator();     this.next = this.getNext();   }    @Override   public Integer next() {     Integer temp = next;     this.next = this.getNext();     return temp;   }    @Override   public boolean hasNext() {     return this.next != null;   }    private Integer getNext() {     while (!this.currentIterator.hasNext()) {       if (this.linkedList.isEmpty()) {         return null;       }       this.currentIterator = this.linkedList.removeLast();     }     NestedInteger nextInteger = this.currentIterator.next();     if (nextInteger.isInteger()) {       return nextInteger.getInteger();     }     this.linkedList.addLast(this.currentIterator);     this.currentIterator = nextInteger.getList().iterator();     return this.getNext();   }  }  /**  * Your NestedIterator object will be instantiated and called as such:  * NestedIterator i = new NestedIterator(nestedList);  * while (i.hasNext()) v[f()] = i.next();  */   결과  Link   설명     중첩된 정수 List인 nestedList를 평면화 시키는 NestedIterator 클래스를 완성하는 문제이다.            생성자인 NestedIterator(List nestedList)는 nestedList를 이용하여 NestedIterator를 초기화시킨다.       메서드인 next()는 평면화된 nestedList의 다음 정수를 반환한다.       메서드인 hasNext()는 평면화된 nestedList의 다음 정수가 존재하는지 여부를 반환한다.           문제 풀이에 필요한 변수를 정의한다.            linkedList는 nestedList를 이용하여 순차적인 정수 활용을 위한 LinkedList이다.       currentIterator는 linkedList에서 순차적으로 Iterator를 받아와 사용하기 위한 Iterator이다.       next는 다음 값을 임시 저장하기 위한 정수이다.           순차적으로 정수를 활용하기 위한 getNext() 메서드를 정의한다.            currentIterator의 다음 값이 없을 때 까지 아래의 경우를 반복한다.                    linkedList가 비어있을 경우 더 이상 반환시킬 정수가 없으므로, null을 반환한다.           위의 경우가 아닌 경우, currentIterator에 linkedList의 마지막 Iterator를 꺼내 넣어준다.                       nextInteger에 currentInterator의 다음 차례 NestedInteger를 넣어준다.       만일 nextInteger가 Integer형인 경우, nextInteger의 Integer를 반환한다.       그렇지 않은 경우 아래를 수행한다.                    linkedList에 currentIterator를 마지막으로 넣어준다.           currentIterator에 nextInteger의 List를 Iterator로 변환하여 넣어준다.           재귀 호출을 수행하여 다음 값을 탐색한다.                           생성자인 NestedIterator(List nestedList)를 완성한다.            linkedList에 새 LinkedList를 정의하여 넣어준다.       currentIterator에 nestedList를 Iterator로 변환하여 넣어준다.       next에 3번에서 정의한 getNext() 메서드를 호출한 결과를 넣어준다.           메서드인 next()를 완성한다.            next의 값을 temp에 임시 보관하고, next에 3번에서 정의한 getNext()의 수행 결과를 넣어준다.       임시 저장한 다음 정수인 temp를 반환한다.           메서드인 hasNext()를 완성한다.            다음 정수를 저장한 next의 값이 null이면 다음 값이 존재하므로 true를, null이 아니면 다음 값이 존재하지 않으므로 false를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/flatten-nested-list-iterator/",
        "teaser": null
      },{
        "title": "Leetcode Java Power of Four",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isPowerOfFour(int n) {     if ((n &amp; (n - 1)) == 0) {       while (n &gt; 1) {         n &gt;&gt;= 2;       }     }     return n == 1;   }  }   결과  Link   설명          주어진 정수가 n이 $4^x$인 4의 제곱수인지를 검증하는 문제이다.       n과 $n - 1$의 AND(&amp;) 비트 연산의 결과가 0인 경우, n이 1보다 클때까지 반복하여 n의 비트 숫자열을 우측으로 2칸 이동시킨다.            Power of Two와 유사하게 n과 $n - 1$의 AND(&amp;) 비트 연산의 2의 배수의 결과는 0이 된다.       n의 비트 숫자열을 우측으로 2칸 이동시키면 4를 나눈 상태와 동일하다.           n이 1이면 4의 제곱수이므로 true를, 아니면 4의 제곱수가 아니므로 false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/power-of-four/",
        "teaser": null
      },{
        "title": "Leetcode Java Integer Break",
        "excerpt":"문제  Link   코드  class Solution {    public int integerBreak(int n) {     if (n &lt;= 3) {       return n - 1;     } else {       int product = 1;       while (n &gt; 4) {         product *= 3;         n -= 3;       }       return product * n;     }   }  }   결과  Link   설명          주어진 정수 n을 정수의 합으로 표현 가능한 2개 이상의 정수로 쪼갠 숫자들의 곱이 최대인 결과를 찾는 문제이다.            n이 3 이하인 경우, 최대가 되는 숫자인 $n - 1$를 주어진 문제의 결과로 반환한다.            2개 이상의 정수로 쪼갠 숫자들의 곱이 최대가 되는 결과를 저장할 product를 정의하고 1로 초기화한다.       n이 4보다 클 때까지 반복하여 product에 3을 곱해주고, n에 3을 빼준다.            n을 3단위로 줄여가며 곱하는 가장 큰 이유는, 6의 경우 $3 \\times 3 = 9 &gt; 6 = 2 \\times 2 \\times 2$, 10의 경우 $3 \\times 3 \\times 4 = 36 &gt; 25 = 5 \\times 5 $로 3 위주의 곱이 가장 큰 결과를 도출 할 수 있다.           반복문이 완료되면 product와 남은 값인 n의 곱을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/integer-break/",
        "teaser": null
      },{
        "title": "Leetcode Java Reverse String",
        "excerpt":"문제  Link   코드  class Solution {    public void reverseString(char[] s) {     int left = 0;     int right = s.length - 1;     while (left &lt; right) {       char temp = s[left];       s[left] = s[right];       s[right] = temp;       left++;       right--;     }   }  }   결과  Link   설명          주어진 문자 배열 s를 반전시키는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            left는 좌측의 값을 반전시키기 위한 인덱스로, 0으로 초기화한다.       right는 우측의 값을 반전시키기 위한 인덱스로, $s.length - 1$의 값으로 초기화한다.           left가 right보다 작을 때 까지 반복하여 배열을 반전시킨다.            temp에 s의 left번째 문자를 넣고, s의 left번째 자리에 s의 right번째 문자를 넣어준다.       s의 right번째 문자를 넣어주고, s의 right번째 자리에 temp를 넣어 문자의 위치를 바꾸어 준다.       left를 증가시키고, right를 감소시키며 반복을 계속 수행하여 모든 문자의 위치를 바꾸어준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reverse-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Reverse Vowels of a String",
        "excerpt":"문제  Link   코드  class Solution {    public String reverseVowels(String s) {     char[] charArray = s.toCharArray();     int start = 0;     int end = s.length() - 1;     while (start &lt; end) {       while (this.isConsonant(charArray[start])) {         if (start &gt;= end) {           break;         }         start++;       }       while (this.isConsonant(charArray[end]) &amp;&amp; start &lt; end) {         if (start &gt;= end) {           break;         }         end--;       }       char temp = charArray[start];       charArray[start] = charArray[end];       charArray[end] = temp;       start++;       end--;     }     return new String(charArray);   }    private boolean isConsonant(char c) {     return !(c == 'A' || c == 'a' ||          c == 'E' || c == 'e' ||          c == 'I' || c == 'i' ||          c == 'O' || c == 'o' ||          c == 'U' || c == 'u');   }  }   결과  Link   설명          주어진 문자열 s의 모음 단어(‘a’, ‘e’, ‘i’, ‘o’ , ‘u’)의 순서를 반전시키고 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            charArray는 주어진 문자열 s를 문자 배열로 변환해서 저장할 변수이다.       start는 문자열 s의 좌측부터 탐색할 변수로, 0으로 초기화한다.       end는 문자열 s의 우측부터 탐색할 변수로, $s.length - 1$로 초기화 한다.           start가 end보다 작을 때 까지 반복하여 문자열의 순서를 변경한다.            charArray에서 start번째 문자가 모음 단어일 때 까지 반복을 수행하여 start가 end보다 큰 경우 반복을 그만하고, 그렇지 않으면 start를 증가시킨다.       charArray에서 end번째 문자가 모음 단어이고 start가 end보다 작을 때 까지 반복을 수행하여 start가 end보다 큰 경우 반복을 그만하고, 그렇지 않으면 end를 감소시킨다.       위에서 결정된 start와 end 자리의 문자를 교체해주고, start는 증가시키고 end는 감소시킨 후 반복을 계속 수행한다.           반복이 완료되면 charArray를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reverse-vowels-of-a-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Top K Frequent Elements",
        "excerpt":"문제  Link   코드  class Solution {    public int[] topKFrequent(int[] nums, int k) {     int min = nums[0];     int max = nums[0];     for (int num : nums) {       if (num &lt; min) {         min = num;       } else if (num &gt; max) {         max = num;       }     }     Num[] array = new Num[max - min + 1];     for (int num : nums) {       if (array[num - min] == null) {         array[num - min] = new Num(num);       } else {         array[num - min].count++;       }     }     Arrays.sort(array, new Comparator&lt;Num&gt;() {       @Override       public int compare(Num o1, Num o2) {         if (o1 == null) {           return 1;         } else if (o2 == null) {           return -1;         } else {           return o2.count - o1.count;         }       }     });     int[] result = new int[k];     for (int i = 0; i &lt; k; i++) {       result[i] = array[i].value;     }     return result;   }  }  class Num {    public int value;   public int count;    public Num(int value) {     this.value = value;     this.count = 1;   }  }   결과  Link   설명          주어진 정수 배열 nums의 k번쨰 가장 많이 발생한 값들을 반환하는 문제이다.            min과 max에 nums의 첫 값을 넣어주고, nums를 순회하면서 최소값과 최대값을 각 변수에 넣어준다.       Num을 이용해 배열의 크기를 최소화 하기 위해 $max - min + 1$ 크기로 정의한다.            Num은 특정 값인 value의 발생 빈도인 count를 저장하는 객체이다.                nums를 순회하여 array의 $num - min$번째 Num 객체에 count를 증가시킨다.            array의 값들을 count 수로 내림차순 정렬한다.       result 변수는 k의 크기로 정의하고 array의 k번째 Num의 value를 넣어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/top-k-frequent-elements/",
        "teaser": null
      },{
        "title": "Leetcode Java Intersection of Two Arrays",
        "excerpt":"문제  Link   코드  class Solution {    public int[] intersection(int[] nums1, int[] nums2) {     int[] count = new int[1000];     for (int num : nums1) {       count[num]++;     }     int[] result = new int[nums1.length];     int index = 0;     for (int num : nums2) {       if (count[num] &gt; 0) {         result[index++] = num;         count[num] = 0;       }     }     return Arrays.copyOf(result, index);   }  }   결과  Link   설명          주어진 정수 배열인 nums1과 nums2 내 동일하게 들어있는 값들을 중복 제거하여 반환하는 문제이다.            숫자의 개수를 저장할 배열인 count를 주어진 배열 내 정수가 가질 수 있는 최대값인 1000 크기로 정의하고, nums1을 순회하여 count의 내부 값들의 개수를 증가시켜준다.       결과를 담을 result 배열을 nums1의 크기로, 해당 배열에 값을 순차적으로 넣기 위한 index를 0으로 정의한다.            result의 크기를 nums1 크기로 정의한 이유는, 주어진 두 배열인 nums1과 nums2 내 중복된 값의 개수는 두 배열 중 가장 작은 크기의 배열 크기 이하로만 존재할 수 있다.       임의 배열 크기로 정의하고 index까지 배열을 자를 예정이므로 둘 중 아무 크기로 정의해도 상관없다.                nums2를 반복하여 count의 num번째 값이 0 초과(nums1에 존재하는 값)인 경우, result에 num을 넣고 index를 증가시키고 count의 num번째 값을 0으로 초기화 시킨다.       반복이 완료되면 nums1과 nums2의 중복된 값을 넣은 result 배열의 index개 값들로 신규 배열에 넣어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/intersection-of-two-arrays/",
        "teaser": null
      },{
        "title": "Leetcode Java Intersection of Two Arrays II",
        "excerpt":"문제  Link   코드  class Solution {    public int[] intersect(int[] nums1, int[] nums2) {     int[] count = new int[1001];     for (int num : nums1) {       count[num]++;     }     int[] result = new int[nums1.length];     int index = 0;     for (int num : nums2) {       if (count[num] &gt; 0) {         result[index++] = num;         count[num]--;       }     }     return Arrays.copyOf(result, index);   }  }   결과  Link   설명          이전 Intersection of Two Arrays 문제와 유사한 문제로, 주어진 정수 배열인 nums1과 nums2 내 동일하게 들어있는 값들을 모두 반환하는 문제이다.            숫자의 개수를 저장할 배열인 count를 주어진 배열 내 정수가 가질 수 있는 최대 개수인 1001 크기로 정의하고, nums1을 순회하여 count의 내부 값들의 개수를 증가시켜준다.       결과를 담을 result 배열을 nums1의 크기로, 해당 배열에 값을 순차적으로 넣기 위한 index를 0으로 정의한다.            result의 크기를 nums1 크기로 정의한 이유는, 주어진 두 배열인 nums1과 nums2 내 중복된 값의 개수는 두 배열 중 가장 작은 크기의 배열 크기 이하로만 존재할 수 있다.       임의 배열 크기로 정의하고 index까지 배열을 자를 예정이므로 둘 중 아무 크기로 정의해도 상관없다.                nums2를 반복하여 count의 num번째 값이 0 초과(nums1에 존재하는 값)인 경우, result에 num을 넣고 index를 증가시키고 count의 num번째 값을 감소시킨다.       반복이 완료되면 nums1과 nums2의 중복된 값을 넣은 result 배열의 index개 값들로 신규 배열에 넣어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/intersection-of-two-arrays-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Data Stream as Disjoint Intervals",
        "excerpt":"문제  Link   코드  class SummaryRanges {    private List&lt;int[]&gt; list;    public SummaryRanges() {     this.list = new ArrayList&lt;&gt;();   }    public void addNum(int val) {     int idx = this.binarySearch(val);     if (idx &gt;= 0 &amp;&amp; val &gt;= this.list.get(idx)[0] &amp;&amp; val &lt;= this.list.get(idx)[1]) {       return;     }     int[] cur = new int[] { val, val };     if (idx &gt;= 0) {       int[] pre = this.list.get(idx);       if (pre[1] + 1 == val) {         this.list.remove(idx);         cur[0] = pre[0];         idx--;       }     }     if (idx + 1 &lt; this.list.size()) {       int[] next = this.list.get(idx + 1);       if (val + 1 == next[0]) {         this.list.remove(idx + 1);         cur[1] = next[1];       }     }     this.list.add(idx + 1, cur);   }    public int[][] getIntervals() {     int size = this.list.size();     int[][] intervals = new int[size][];     for (int idx = 0; idx &lt; size; idx++) {       intervals[idx] = this.list.get(idx);     }     return intervals;   }    private int binarySearch(int num) {     int left = 0;     int right = this.list.size() - 1;     while (left &lt;= right) {       int mid = left + (right - left) / 2;       if (num &lt; this.list.get(mid)[0]) {         right = mid - 1;       } else if (num &gt; list.get(mid)[0]) {         left = mid + 1;       } else {         return mid;       }     }     return right;   }  }  /**  * Your SummaryRanges object will be instantiated and called as such:  * SummaryRanges obj = new SummaryRanges();  * obj.addNum(val);  * int[][] param_2 = obj.getIntervals();  */   결과  Link   설명     숫자를 추가하면 기존 숫자들을 이용하여 연속된 숫자들의 부분 범위를 지정하여 데이터 스트림으로 보관하는 SummaryRanges 클래스를 완성하는 문제이다.            생성자인 SummaryRanges()는 빈 스트림 객체를 초기화 하는 역할을 수행한다.       메서드인 addNum(int val)은 연속된 숫자들의 부분 범위를 지정하기 위한 정수인 val를 주입하는 역할을 수행한다.       메서드인 getIntervals()는 연속된 숫자들의 부분 범위를 저장한 데이터 스트림을 반환하는 역할을 수행한다.           문제 풀이에 필요한 변수를 정의한다.            list는 연속된 숫자들의 부분 범위를 저장한 데이터 스트림을 임시 보관할 변수이다.           생성자인 SummaryRanges()를 완성한다.            전역 변수인 list를 새 ArrayList를 생성하여 초기화 시켜준다.           addNum(int val) 메서드를 통해 주입된 val의 값을 넣기 위한 위치를 탐색하기 위한 binarySearch(int num) 메서드를 완성한다.            좌측에서 탐색하기 위한 변수인 left를 0으로, 우측에서 탐색하기 위한 변수인 right를 $list.size() - 1$로 초기화 한다.       left가 right보다 작거나 같을 때 까지 반복하여 위치 탐색을 수행한다.                    mid에 $left + \\frac{right - left}{2}$의 결과를 넣어준다.           list의 mid번째 배열의 첫 값이 num보다 클 경우, right에 $mid - 1$을 넣어 탐색 범위를 좁혀준다.           list의 mid번째 배열의 첫 값이 num보다 작을 경우, left에 $mid + 1$을 넣어 탐색 범위를 좁혀준다.           그 외인 두 값이 같은 경우, mid를 반환한다.                       반복이 완료되면 최대한 좁혀진 right의 값을 위치 값으로 반환한다.           메서드인 addNum(int val)을 완성한다.            idx에 4번에서 정의한 binarySearch() 메서드를 활용하여 구해진 위치 값을 넣어준다.       idx가 0보다 크고, val의 값이 list의 idx번째 배열의 첫 값보다 크고 두번째 값보다 작거나 같은 경우 해당 영역에 포함되는 값이므로 그만 수행한다.       현재 값을 임시 부분 배열로 cur 배열을 선언하고 val 값을 첫 번째와 두 번째 위치에 넣어준다.       idx가 0보다 큰 경우 아래를 수행한다.                    pre에 list의 idx번째 배열을 넣어준다.           pre의 두 번째 값에 1을 더한 값이 val 값과 동일한 경우 해당 부분 영역의 길이에 val 값을 합칠 수 있으므로, list에서 idx번째 객체를 삭제하고 cur의 첫 값에 pre의 첫 값을 넣어 idx를 감소시킨다.                       $idx + 1$이 list의 크기보다 작은 경우 아래를 수행한다.                    next에 list의 $idx + 1$번째 배열을 넣어준다.           $val + 1$이 next의 첫 번째 값과 동일한 경우 next의 값이 조금 더 크므로, list에서 $idx + 1$번째 값을 제거하고 cur의 두 번째 값에 next의 두 번째 값을 넣어준다.                       위의 모든 과정이 완료되면 list의 $idx + 1$번째 위치에 cur 배열을 넣어주어 데이터 스트림을 만들어준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/data-stream-as-disjoint-intervals/",
        "teaser": null
      },{
        "title": "Leetcode Java Russian Doll Envelopes",
        "excerpt":"문제  Link   코드  class Solution {    public int maxEnvelopes(int[][] envelopes) {     int dp[] = new int[envelopes.length];     int count = 0;     Arrays.sort(envelopes, (e1, e2) -&gt; e1[0] == e2[0] ? e2[1] - e1[1] : e1[0] - e2[0]);     for (int[] envelope : envelopes) {       int index = Arrays.binarySearch(dp, 0, count, envelope[1]);       if (index &lt; 0) {         index = -(index + 1);       }       dp[index] = envelope[1];       if (index == count) {         count++;       }     }     return count;   }  }   결과  Link   설명     주어진 배열 envelopes는 봉투의 너비와 높이를 나타내는 정수의 2차원 배열로, 러시아 인형과 같이 작은 봉투를 큰 봉투에 순차적으로 넣을 수 봉투의 최대 개수를 구하는 문제이다.            envelopes[i] = [width, height]       봉투를 회전시킬 수 없다.           문제 풀이에 필요한 변수를 정의한다.            dp는 envelopse를 이용하여 값을 순차적으로 넣어 활용하기 위한 배열로, envelopes.length의 크기로 초기화한다.       count는 봉투를 러시아 인형같이 사용할 수 있는 최대 개수를 저장할 변수로, 0으로 초기화한다.           envelopes를 아래의 조건으로 정렬한다.            e1의 첫 번째 값과 e2의 첫 번째 같이 같으면 $e2[1] - e1[1]$의 결과로 정렬을 수행한다.       위의 경우가 아니면, $e1[0] - e2[0]$의 결과로 정렬을 수행한다.           envelopes를 반복하여 최대 개수를 count에 누적한다.            index는 Arrays의 binarySearch 메소드를 활용하여 envelope의 두 번째 값의 위치를 이진 검색 수행한 위치 값을 넣어준다.       index가 0보다 작은 경우, index에 $index + 1$을 음수로 전환한 값으로 넣어준다.       dp의 index번째 값에 envelope의 두 번째 값을 넣어준다.       index와 count가 동일한 경우, count를 증가시켜주고 반복을 계속 수행한다.           반복이 완료되면 최대 개수를 저장한 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/russian-doll-envelopes/",
        "teaser": null
      },{
        "title": "Leetcode Java Design Twitter",
        "excerpt":"문제  Link   코드  class Twitter {    private List&lt;Integer[]&gt; posts;   private Map&lt;Integer, Set&lt;Integer&gt;&gt; relation;    public Twitter() {     this.posts = new ArrayList&lt;&gt;();     this.relation = new HashMap&lt;&gt;();   }    public void postTweet(int userId, int tweetId) {     this.posts.add(new Integer[] { userId, tweetId });   }    public List&lt;Integer&gt; getNewsFeed(int userId) {     List&lt;Integer&gt; newsFeed = new ArrayList&lt;&gt;();     for (int idx = this.posts.size() - 1; idx &gt;= 0 &amp;&amp; newsFeed.size() &lt; 10; idx--) {       Integer[] post = this.posts.get(idx);       Set&lt;Integer&gt; followees = this.relation.get(userId);       if (post[0] == userId || (followees != null &amp;&amp; followees.contains(post[0]))) {         newsFeed.add(post[1]);       }     }     return newsFeed;   }    public void follow(int followerId, int followeeId) {     Set&lt;Integer&gt; followees = this.relation.get(followerId);     if (followees == null) {       followees = new HashSet&lt;&gt;();     }     followees.add(followeeId);     this.relation.put(followerId, followees);   }    public void unfollow(int followerId, int followeeId) {     Set&lt;Integer&gt; followees = this.relation.get(followerId);     if (followees != null) {       followees.remove(followeeId);     }   }  }  /**  * Your Twitter object will be instantiated and called as such:  * Twitter obj = new Twitter();  * obj.postTweet(userId,tweetId);  * List&lt;Integer&gt; param_2 = obj.getNewsFeed(userId);  * obj.follow(followerId,followeeId);  * obj.unfollow(followerId,followeeId);  */   결과  Link   설명     사용자가 트윗을 게시하고, 다른 사용자를 팔로우 혹은 언팔로우 할 수 있으며, 최근 10개의 사용자의 뉴스 피드를 볼 수 있는 간단한 Twitter를 만드는 문제이다.            생성자인 Twitter()는 Twitter 객체를 초기화 시키는 역할을 한다.       메서드인 postTweet(int userId, int tweetId)은 게시한 user의 id인 userId와 고유한 새 tweet의 id인 tweetId를 엮어주는 역할을 한다.       메서드인 getNewsFeed(int userId)는 news feed를 검색하는 userId를 이용하여 해당 user가 follow한 사용자들의 최근 10개 news feed를 가져오는 역할을 한다.       메서드인 follow(int followerId, int followeeId)는 follow하는 userId와 follow받는 userId를 연결하는 역할이다.       메서드인 unfollow(int followerId, int followeeId)는 위의 follow(int followerId, int followeeId)와 반대로, follow한 연결 관계를 삭제하는 역할이다.           문제 풀이에 필요한 변수를 정의한다.            posts는 userId와 tweetId를 엮어 저장할 post들을 저장할 List이다.       relation은 user가 follow하는 계정들의 userId를 저장하기 위한 Map이다.           생성자인 Twitter()를 완성한다.            posts에 새 ArrayList를 넣어 초기화 시켜준다.       relation에 새 HashMap을 넣어 초기화 시켜준다.           메서드인 postTweet(int userId, int tweetId)을 완성한다.            posts에 userId와 tweetId를 엮어 정수 배열로 넣어준다.           메서드인 getNewsFeed(int userId)를 완성한다.            최근 10개의 newsFeed를 넣을 List인 newsFeed를 정의한다.       posts를 역순으로 newsFeed가 10개가 되거나 idx가 0 이하가 될 때 까지 탐색하며 newsFeed를 넣어준다.                    posts의 idx번째 배열을 꺼내 post로 정의한다.           relation에서 userId의 follower 목록을 가져와 followees에 넣어준다.           post의 첫 번째 값이 userId이거나 followees가 존재하며 followees에 post의 첫 번째 값이 포함하는 경우 자기 자신의 newsFeed거나 follower의 newsFeed이므로, newsFeed에 post의 두 번째 값인 tweetId를 넣어주고 반복을 계속 수행한다.                       반복이 완료되면 newsFeed를 반환한다.           메서드인 follow(int followerId, int followeeId)를 완성한다.            relation의 followerId에 해당하는 값을 가져와 followees로 정의한다.       followees가 null인 경우 기존 follow하는 유저들이 없었다는 의미이므로, followees에 새 HashSet을 넣어준다.       followees에 followeeId를 넣어주고, relation의 followerId에 해당 하는 값에 followees를 넣어준다.           메서드인 unfollow(int followerId, int followeeId)를 완성한다.            relation의 followerId에 해당하는 값을 가져와 followees로 정의한다.       followees가 null이 아닌 경우 기존 follow하는 유저들이 있다는 의미이므로, folloewees에 followeeId를 삭제한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/design-twitter/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Numbers with Unique Digits",
        "excerpt":"문제  Link   코드  class Solution {    public int countNumbersWithUniqueDigits(int n) {     if (n == 0) {       return 1;     } else {       int count = 10;       int unit = 9;       for (int idx = 2; idx &lt;= n &amp;&amp; idx &lt;= 10; idx++) {         unit *= 9 - idx + 2;         count += unit;       }       return count;     }   }  }   결과  Link   설명          주어진 정수 n을 이용하여 0 이상 $10^{n}$미만의 고유한 숫자로 이루어진 숫자열의 개수를 찾는 문제이다.            n이 0인 경우 0밖에 없으므로, 1을 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            count는 n이 1인 경우 0 ~ 9 까지 10개의 고유 숫자가 존재하므로, 10으로 초기화 한다.       unit은 유일한 숫자의 개수를 산정하기 위한 초기 단위이다.           2부터 idx가 n과 10 이하일 때까지 증가시키며 숫자를 센다.            unit에 $9 - idx + 2$와 자기 자신을 곱한 후, count에 더하여 반복을 계속 수행한다.                    n이 2인 경우, $10 + (9 \\times 9) = 10 + 81 = 91$이 고유한 숫자들로 이루어진 숫자열의 개수이다.           n이 3인 경우, $10 + (9 \\times 9) + (9 \\times 9 \\times 8) = 10 + 81 + 648 = 739$이 고유한 숫자들로 이루어진 숫자열의 개수이다.           이런 식으로 0이상 $10^{n}$ 미만의 고유한 숫자들로 이루어진 숫자열의 개수를 구할 수 있다.                           총 개수를 계산한 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-numbers-with-unique-digits/",
        "teaser": null
      },{
        "title": "Leetcode Java Max Sum of Rectangle No Larger Than K",
        "excerpt":"문제  Link   코드  class Solution {    public int maxSumSubmatrix(int[][] matrix, int k) {     int row = matrix.length;     int col = matrix[0].length;     int max = Integer.MIN_VALUE;     for (int i = 0; i &lt; col; i++) {       int[] nums = new int[row];       for (int j = i; j &lt; col; j++) {         for (int l = 0; l &lt; row; l++) {           nums[l] += matrix[l][j];         }         max = Math.max(max, this.getMaxSubSum(nums, row, k));         if (max == k) {           return k;         }       }     }     return max;   }    private int getMaxSubSum(int[] nums, int row, int k) {     int curr = nums[0];     int max = curr;     for (int idx = 1; idx &lt; row; idx++) {       curr = Math.max(curr + nums[idx], nums[idx]);       if (curr &gt; max) {         max = curr;       }     }     if (max &lt;= k) {       return max;     }     max = Integer.MIN_VALUE;     for (int i = 0; i &lt; row; i++) {       curr = 0;       for (int j = i; j &lt; row; j++) {         curr += nums[j];         if (curr &gt; max &amp;&amp; curr &lt;= k) {           max = curr;         }         if (max == k) {           return k;         }       }     }     return max;   }  }   결과  Link   설명          주어진 2차원 배열 matrix를 이용하여 k보다 크지 않은 사각형 모양의 부분 영역 값들의 최대 합을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            row는 matrix 행의 개수를 저장하는 변수로, matrix.length로 초기화 한다.       col은 matrix 열의 개수를 저장하는 변수로, matrix[0].length로 초기화 한다.       max는 k보다 크지 않은 부분 합을 저장할 변수로, 정수의 가장 작은 값으로 초기화 한다.           0부터 col까지 i를 증가시키며 반복을 수행한다.            nums는 각 부분 영역 값들의 합을 계산하기 위한 배열로, row 크기만큼의 배열로 정의한다.                    i부터 col 미만까지 j를 증가시키며 nums를 초기화한다.           0부터 row 미만까지 l을 증가시키며, nums의 l번째 값에 matrix[l][j]의 값을 더해준다.           max에 max와 4번에 정의한 getMaxSubSum(int[] nums, int row, int k)의 수행 결과 중 큰 값을 넣어준다.           max가 k와 동일한 경우 발생 가능한 최대의 크기이므로, k를 주어진 문제의 결과로 반환한다.           위의 결과를 수행하여 순차적으로 반복을 계속 수행한다.                       반복이 완료되면 k를 초과하지 않은 부분 영역 값들의 최대 합을 저장한 max를 주어진 문제의 결과로 반환한다.           부분 영역 값들의 최대 값을 찾기 위한 getMaxSubSum(int[] nums, int row, int k) 메서드를 정의한다.            문제 풀이에 필요한 변수를 정의한다.                    curr은 현재 값을 임시 저장하기 위한 변수로, nums의 첫 값으로 초기화한다.           max는 최대 값을 저장하기 위한 변수로, curr의 값으로 초기화한다.                       1부터 row 미만까지 반복하면서 최대 값을 max에 넣어준다.                    curr에 $curr + nums[idx]$의 값과 nums[idx] 값 중 큰 값을 넣어준다.           curr이 max보다 큰 경우, max에 curr 값을 넣어준다.                       max가 k보다 작거나 같은 경우 해당 값이 가장 큰 값이므로, max를 반환한다.       max에 정수의 가장 작은 값을 넣어 초기화 시켜준다.       0부터 row 미만까지 i를 증가시키며 반복을 수행한다.                    curr을 0으로 초기화 한다.           i부터 row 미만까지 j를 증가시키며 max를 탐색한다.           curr에 nums[j] 값을 누적시킨다.           curr이 max보다 크고 k보다 같거나 작은 경우 가능한 최대 값이므로, max에 curr 값을 넣어준다.           max가 k와 동일한 경우 발생 가능한 최대의 크기이므로, k를 반환한다.                       반복이 완료되면 nums에서 발생 가능한 최대 값인 max를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/max-sum-of-rectangle-no-larger-than-k/",
        "teaser": null
      },{
        "title": "Leetcode Java Water and Jug Problem",
        "excerpt":"문제  Link   코드  class Solution {    public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {     if (jug1Capacity + jug2Capacity &lt; targetCapacity) {       return false;     } else if (jug1Capacity == targetCapacity         || jug2Capacity == targetCapacity         || jug1Capacity + jug2Capacity == targetCapacity) {       return true;     } else {       return targetCapacity % this.getGcd(jug1Capacity, jug2Capacity) == 0;     }   }    private int getGcd(int num1, int num2) {     if (num1 % num2 == 0) {       return num2;     } else {       return this.getGcd(num2, num1 % num2);     }   }  }   결과  Link   설명          주어진 정수 jug1Capacity와 jug2Capacity의 용기를 이용하여 정확한 targetCapacity 용량을 측정할 수 있는지를 검증하는 문제이다.            jug1Capacity와 jug2Capacity의 합이 targetCapacity보다 작은 경우 두 용기에 물을 채워도 targetCapacity만큼 채울 수 없으므로, 주어진 문제의 결과로 false를 반환한다.            jug1Capacity 혹은 jug2Capacity, 두 합이 targetCapacity과 같은 경우는 단번에 targetCapacity만큼 채울 수 있으므로, 주어진 문제의 결과로 true를 반환한다.            targetCapacity과 5번에서 정의한 getGcd(jug1Capacity, jug2Capacity) 메서드의 나눈 나머지 값이 0인지 여부를 주어진 문제의 결과로 반환한다.            유클리드 호제법1을 이용한 getGcd(jug1Capacity, jug2Capacity) 메서드를 정의한다.             num1과 num2의 나눈 나머지 값이 0인 경우, num2를 반환한다.       그렇지 않은 경우, num2와 num1과 num2의 나눈 나머지 값을 재귀 호출을 수행한 결과를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.   Reference                 Wiki-Euclidean_Algorithm &#8617;           ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/water-and-jug-problem/",
        "teaser": null
      },{
        "title": "Leetcode Java Valid Perfect Square",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isPerfectSquare(int num) {     int left = 1;     int right = num;     while (left &lt;= right) {       int mid = left + ((right - left) / 2);       int result = num / mid;       if (result == mid &amp;&amp; num % mid == 0) {         return true;       } else if (result &lt; mid) {         right = mid - 1;       } else {         left = mid + 1;       }     }     return false;   }  }   결과  Link   설명     주어진 정수 num이 완전 제곱수인지를 검증하는 문제이다.            단, 내장 함수를 사용할 수 없다.           문제 풀이에 필요한 변수를 정의한다.            left는 제곱수인지 검증하기 위한 제곱근을 가능한 가장 작은 수인 1 부터 찾기 위한 변수로, 1로 초기화 한다.       right도 제곱수인지 검증하기 위한 제곱근을 가능한 가장 큰 수인 num부터 찾기 위한 변수로, num으로 초기화 한다.           left가 right보다 작거나 같을 때까지 반복한다.            mid에 $left + \\frac{right - left}{2}$의 값을 넣어준다.       result에 $\\frac{num}{mid}$를 넣고 아래를 검증한다.                    result가 mid와 같고 num에 mid를 나눈 나머지 값이 0인 경우 mid의 제곱이 num이 되므로, true를 주어진 문제의 결과로 반환한다.           result가 mid보다 작은 경우 예측 가능한 숫자를 작게 좁히기 위해, right에 $mid - 1$을 넣어준다.           그 외의 경우 예측 가능한 숫자를 크게 좁히기 위해, left에 $mid + 1$를 넣어준다.                           반복이 완료되면 완전 제곱수가 아니므로, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/valid-perfect-square/",
        "teaser": null
      },{
        "title": "Leetcode Java Largest Divisible Subset",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; largestDivisibleSubset(int[] nums) {     int length = nums.length;     int[][] dp = new int[length][2];     Arrays.sort(nums);     int max = 0;     int index = -1;     for (int i = 0; i &lt; length; i++) {       dp[i][0] = 1;       dp[i][1] = -1;       for (int j = 0; j &lt; i; j++) {         if (nums[i] % nums[j] == 0 &amp;&amp; dp[j][0] + 1 &gt; dp[i][0]) {           dp[i][0] = dp[j][0] + 1;           dp[i][1] = j;         }       }       if (dp[i][0] &gt; max) {         max = dp[i][0];         index = i;       }     }     List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();     while (index != -1) {       result.add(nums[index]);       index = dp[index][1];     }     return result;   }  }   결과  Link   설명     주어진 정수 배열인 nums를 이용하여 아래의 조건을 만족하는 배열을 만드는 문제이다.            주어진 문제의 결과로 반환하는 answer에 들어가는 값들은 answer[i] % answer[j] == 0 혹은 answer[j] % answer[i] == 0을 만족해야 한다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장하기 위한 변수로, nums.length로 초기화한다.       dp는 주어진 문제의 조건에 해당하는 값을 찾기 위한 임시 배열로, 그 전의 위치를 순차적으로 담기 위해 dp[length][2]로 초기화한다.       max는 최대 값을 저장하기 위한 임시 변수로, 0으로 초기화한다.       index는 nums의 위치 값을 임시 저장하기 위한 임시 변수로, -1로 초기화 한다.           nums를 오름차순으로 정렬하고, nums의 모든 값을 앞에서부터 반복한다.            dp[i][0]은 1로, dp[i][1]은 -1로 초기화 한다.       0부터 i까지 j를 증가시키며 반복하여, 아래를 검증하여 값을 설정한다.                    nums[i]의 값과 nums[j]의 값의 나눈 나머지 값이 0이고 $dp[j][0] + 1$의 값이 dp[i][0]의 값보다 큰 경우, dp[i][0]에 dp[j][0] + 1 값을 dp[i][1]에 j를 넣어준다.                       dp[i][0]의 값이 max보다 큰 경우, max에 dp[i][0]의 값을 index에 i를 넣어주고 반복을 계속 수행한다.           결과를 넣을 List인 result를 정의하고, index가 -1이 아닐 때 까지 반복한다.            result에 조건을 만족하는 값인 nums의 index번째 값을 넣어주고, index에 이전의 값이 존재하는 위치인 dp[index][1] 값을 넣어준다.       최초 정의한 index인 -1이 되기 전까지 반복을 수행하여 조건에 만족하는 값들을 result에 모두 넣어준다.           반복이 완료되면 문제의 조건을 만족하는 결과를 넣은 List인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/largest-divisible-subset/",
        "teaser": null
      },{
        "title": "Leetcode Java Sum of Two Integers",
        "excerpt":"문제  Link   코드  class Solution {    public int getSum(int a, int b) {     while (a != 0) {       int carry = (a &amp; b) &lt;&lt; 1;       b = a ^ b;       a = carry;     }     return b;   }  }   결과  Link   설명          주어진 정수 a와 b의 합을 “+” 혹은 “-“ 연산자를 사용하지 않고 두 수의 합을 구하는 문제이다.       a가 0이 아닐때 까지 반복한다.            carry에 a와 b의 AND(&amp;) 비트 연산을 수행하고, 해당 비트를 좌측으로 한 칸 이동시킨다.       b에 a와 b의 XOR(^) 비트 연산을 수행한 결과를 넣어준다.       a에 carry를 넣어주고 반복을 계속 한다.           반복이 종료되면 b를 주어진 문제의 결과로 반환한다.   예제     a가 0이고 b가 1인 경우 아래와 같다.            a와 b의 AND(&amp;) 비트 연산의 결과는 00 &amp; 01 = 00이다.       00을 좌측으로 1칸 이동시키면, 00 비트는 그대로 carry에 0이 주입된다.       a와 b의 XOR(^) 비트 연산의 결과는 00 ^ 01 = 01 = 1으로 b에 주입된다.       a에 carry가 들어가 0이므로, 반복이 종료되고 b의 값인 1이 반환된다.           a가 1이고 b가 2인 경우 아래와 같다.            a와 b의 AND(&amp;) 비트 연산의 결과는 01 &amp; 10 = 00이다.       00을 좌측으로 1칸 이동시키면, 00 비트는 그대로 carry에 0이 주입된다.       a와 b의 XOR(^) 비트 연산의 결과는 01 ^ 10 = 11 = 3으로 b에 주입된다.       a에 carry가 들어가 0이므로, 반복이 종료되고 b의 값인 3이 반환된다.           이렇게 AND(&amp;) 비트 연산의 결과를 carry에 넣고, XOR(^) 비트 연산을 이용하여 값을 b에 임시 저장하고, a에 carry를 넣어 반복을 수행하면 “+” 연산과 동일한 결과를 산출한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sum-of-two-integers/",
        "teaser": null
      },{
        "title": "Leetcode Java Find K Pairs with Smallest Sums",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; kSmallestPairs(int[] nums1, int[] nums2, int k) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     Queue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;((a, b) -&gt; (a[0] + a[1] - b[0] - b[1]));     for (int idx = 0; idx &lt; nums1.length &amp;&amp; idx &lt; k; idx++) {       queue.offer(new int[] { nums1[idx], nums2[0], 0 });     }     while (k-- &gt; 0 &amp;&amp; !queue.isEmpty()) {       int[] curr = queue.poll();       List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();       temp.add(curr[0]);       temp.add(curr[1]);       result.add(temp);       if (curr[2] == nums2.length - 1) {         continue;       }       queue.add(new int[] { curr[0], nums2[curr[2] + 1], curr[2] + 1 });     }     return result;   }  }   결과  Link   설명          주어진 배열 nums1과 nums2는 오름차순 정렬되어 있으며, 해당 값들을 이용하여 k개의 작은 부분 배열들을 만드는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 부분 배열을 저장할 List이다.       queue는 num1을 이용한 임의 부분 배열을 저장할 Queue로, $a[0] + a[1] - b[0] - b[1]$의 순서로 PriorityQueue를 이용하여 정의한다.           nums1을 반복하여 k개까지 조합을 queue에 넣어준다.            필요한 nums1의 값과 nums2의 첫 값, 0을 차례대로 queue에 넣어준다.           k를 감소시키며 0보다 크고 queue가 비어있지 않을 때 까지 반복하여 result에 부분 배열들을 넣어준다.            curr에 queue의 배열을 꺼내 넣어준다.       temp List를 새로 정의해서 curr의 앞의 두 값을 넣고 result에 넣어준다.       curr의 세 번째 값이 $nums2.length - 1$인 경우, 반복을 계속 반복한다.       queue에 curr의 첫 값과, nums2에서 curr의 세 번째 값에 1을 더한 값의 위치 값, curr의 세 번째 값에 1을 더한 값을 queue에 다시 넣어준다.           반복이 완료되면 부분 배열을 넣은 reulst를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-k-pairs-with-smallest-sums/",
        "teaser": null
      },{
        "title": "Leetcode Java Guess Number Higher or Lower",
        "excerpt":"문제  Link   코드  /**   * Forward declaration of guess API.  * @param  num   your guess  * @return        -1 if num is lower than the guess number  *            1 if num is higher than the guess number  *               otherwise return 0  * int guess(int num);  */  public class Solution extends GuessGame {    public int guessNumber(int n) {     int low = 1;     int high = n;     while (low &lt; high) {       int mid = low + ((high - low) / 2);       switch (super.guess(mid)) {         case -1: high = mid; break;         case 1: low = mid + 1; break;         case 0: return mid;       }     }     return low;   }  }   결과  Link   설명     GuessGame의 guess(int num) 메서드 호출 결과로 1과 주어진 정수 n 사이의 임의 숫자 pick을 유추하는 문제이다.            guess 메서드 호출 결과가 -1인 경우, num &gt; pick 이다.       guess 메서드 호출 결과가 1인 경우, num &lt; pick 이다.       guess 메서드 호출 결과가 0인 경우, num == pick 이다.           주어진 문제 풀이에 필요한 변수를 정의한다.            low는 가능한 가장 작은 수인 1로 초기화한다.       high는 가능한 가장 큰 수인 n으로 초기화한다.           low가 high보다 작을 때 까지 반복한다.            mid에 $low + \\frac{high - low}{2}$의 결과를 넣고, mid를 이용하여 guess 메서드를 호출한다.                    guess 메서드 호출 결과가 -1인 경우, high에 mid 값을 넣어준다.           guess 메서드 호출 결과가 1인 경우, low에 $mid + 1$ 값을 넣어준다.           guess 메서드 호출 결과가 0인 경우, mid를 주어진 문제의 결과로 반환한다.                           반복이 완료되면 low를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/guess-number-higher-or-lower/",
        "teaser": null
      },{
        "title": "Leetcode Java Guess Number Higher or Lower II",
        "excerpt":"문제  Link   코드  class Solution {    public int getMoneyAmount(int n) {     return this.recursive(new int[n + 1][n + 1], 1, n);   }    private int recursive(int[][] dp, int low, int high) {     if (low &gt;= high) {       return 0;     } else if (dp[low][high] &gt; 0) {       return dp[low][high];     } else {       dp[low][high] = Integer.MAX_VALUE;       int mid = (low + high) / 2;       for (int idx = mid; idx &lt; high; idx++) {         int left = this.recursive(dp, low, idx - 1);         int right = this.recursive(dp, idx + 1, high);         dp[low][high] = Math.min(dp[low][high], idx + Math.max(left, right));         if (left &gt;= right) {           break;         }       }     }     return dp[low][high];   }  }   결과  Link   설명     1과 주어진 정수 n 사이의 올바른 숫자를 맞추는 과정 속에 아래의 조건을 통해 선택한 숫자에 관계 없이 승리할 수 있는 최소 금액을 반환하는 문제이다.            올바른 숫자를 맞추면 게임에서 승리한다.       잘못된 숫자를 맞추면 고른 숫자가 더 높거나 낮은지를 알려주고, 해당 숫자만큼의 달러를 지불하게 된다.                dp를 [$n + 1$][$n + 1$] 크기로 재귀 호출을 사용하여 1부터 n까지 숫자로 최소 금액을 탐색한다.            low가 high보다 크거나 같을 경우 탐색 범위를 벗어났으므로, 0을 반환한다.            dp[low][high]의 값이 0보다 큰 경우 해당 위치의 값은 이미 탐색이 되었으므로, 해당 값을 반환한다.       3번과 4번의 경우가 아닌 경우, 아래를 수행한다.            dp[low][high]에 정수의 가장 큰 값을 넣어주고, mid에 $\\frac{low + high}{2}$의 값을 넣어준다.       mid부터 high까지 idx를 증가시키며 반복을 수행한다.                    left에 low와 high에 $idx - 1$를 넣어 재귀 호출을 수행한 결과를 넣어준다.           right에 low에 $idx + 1$과 high를 넣어 재귀 호출을 수행한 결과를 넣어준다.           dp[low][high]에 dp[low][high]의 값과 left와 right 중 큰 값에 idx를 더한 값 중 작은 값을 넣어준다.           left가 right보다 크거나 같은 경우 반복을 중단한다.                           반복이 완료되면 dp[low][high] 값을 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/guess-number-higher-or-lower-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Wiggle Subsequence",
        "excerpt":"문제  Link   코드  class Solution {    public int wiggleMaxLength(int[] nums) {     int up = 1;     int down = 1;     for (int idx = 1; idx &lt; nums.length; idx++) {       if (nums[idx] &gt; nums[idx - 1]) {         up = down + 1;       } else if (nums[idx] &lt; nums[idx - 1]) {         down = up + 1;       }     }     return Math.max(up, down);   }   }   결과  Link   설명          주어진 정수 배열 nums의 값들이 파동과 같이 높은 값 -&gt; 낮은 값 -&gt; 높은 값 형태로 구성된 최대 길이를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            up은 현재의 값이 이전의 값보다 커지는 경우 증가시키기 위한 변수로, 1로 초기화한다.       down은 현재의 값이 이전의 값보다 작아지는 경우 증가시키기 위한 변수로, 1로 초기화한다.           nums를 두 번째 값부터 끝까지 탐색하여 up과 down에 횟수를 증가시킨다.            up의 경우, 이전의 값과 비교하기 때문에 첫 값부터 탐색하는 것이 아니라 두 번째 값부터 탐색한다.       nums의 idx번째 값이 nums의 $idx - 1$번째 값보다 큰 경우, up에 $down + 1$을 넣어준다.       nums의 idx번째 값이 nums의 $idx - 1$번째 값보다 작은 경우, down에 $up + 1$을 넣어준다.       up과 down에 반대 값의 1을 더한 값을 넣은 이유는, 점층적으로 증가 혹은 감소하는 값들의 횟수를 배제하기 위함이다.           반복이 완료되면 up과 down 중 큰 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/wiggle-subsequence/",
        "teaser": null
      },{
        "title": "Leetcode Java Combination Sum IV",
        "excerpt":"문제  Link   코드  class Solution {    public int combinationSum4(int[] nums, int target) {     int[] dp = new int[target + 1];     Arrays.fill(dp, -1);     return this.resursive(nums, dp, target);   }    private int resursive(int[] nums, int[] dp, int target) {     if (target == 0) {       return 1;     } else if (target &lt; 0) {       return 0;     } else if (dp[target] == -1) {       int result = 0;       for (int num : nums) {         result += this.resursive(nums, dp, target - num);       }       dp[target] = result;     }     return dp[target];   }  }   결과  Link   설명          주어진 정수 배열인 nums가 주어지면 같은 위치의 값을 반복 사용하더라도 목표 target을 만들기 위한 고유 조합의 개수를 구하는 문제이다.            문제 풀이에 필요한 dp를 $target + 1$ 크기로 정의하고, 모든 값을 -1로 초기화한다.            4번에서 정의한 재귀 호출 메서드인 resursive(int[] nums, int[] dp, int target)를 호출한 결과를 주어진 문제의 결과로 반환한다.            재귀 호출을 통해 목표된 값을 탐색하기 위한 resursive(int[] nums, int[] dp, int target) 메서드를 정의한다.             target이 0인 경우 목표 값을 완성한 경우이므로, 1을 반환한다.       target이 0보다 작은 경우 목표값을 초과한 경우이므로, 0을 반환한다.       dp의 target번째 값이 -1인 경우 해당 위치의 dp가 초기화되지 않았다는 의미이므로, 아래를 수행하여 값을 넣어준다.                    result에 0을 넣어준다.           nums를 순회하여 result에 target에 num을 감소시키며 재귀 호출을 수행하여 개수를 넣어준다.           dp의 target번째 위치에 result를 넣어준다.                       dp의 target번째 값을 반환하여 해당 target번째 값의 고유 조합의 개수를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/combination-sum-iv/",
        "teaser": null
      },{
        "title": "Leetcode Java Kth Smallest Element in a Sorted Matrix",
        "excerpt":"문제  Link   코드  class Solution {    public int kthSmallest(int[][] matrix, int k) {     int row = matrix.length;     int col = matrix[0].length;     int low = matrix[0][0];     int high = matrix[row - 1][col - 1];     while (low &lt; high) {       int mid = low + ((high - low) / 2);       if (this.getCount(matrix, row, col, mid) &lt; k) {         low = mid + 1;       } else {         high = mid;       }     }     return low;   }    private int getCount(int[][] matrix, int row, int col, int mid) {     int count = 0;     int j = col - 1;     for (int i = 0; i &lt; row; i++) {       while (j &gt;= 0 &amp;&amp; matrix[i][j] &gt; mid) {         j--;       }       count += j + 1;     }     return count;   }  }   결과  Link   설명          주어진 2차원 정수 배열인 matrix 내부 값들은 행 기준으로 오름차순 정렬되어 있으며, 해당 배열 내 값들 중 k번째로 작은 값을 찾는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            row는 matrix의 행 개수를 저장할 변수로, matrix의 길이로 초기화한다.       col는 matrix의 열 개수를 저장할 변수로, matrix의 첫 행의 길이로 초기화한다.       low는 작은 값을 저장할 변수로, matrix의 가장 작은 값인 첫 위치의 정수를 넣어준다.       high는 큰 값을 저장할 변수로, matrix의 가장 큰 값인 마지막 위치의 정수를 넣어준다.           low가 high보다 작을 때 까지 반복한다.            mid의 $low + \\frac{high - low}{2}$ 값을 넣어준다.       4번에서 정의한 getCount(int[][] matrix, int row, int col, int mid)를 수행한 결과에 따라 아래를 수행하고 반복을 계속 수행한다.                    k보다 위의 값이 작은 경우 더 낮은 위치에 존재하므로, low에 $mid + 1$을 넣어 범위를 좁혀준다.           그 외의 경우 더 높은 위치에 존재하므로, high에 mid를 넣어 범위를 좁혀준다.                           현재 위치에서 작은 값의 개수를 세기 위한 getCount(int[][] matrix, int row, int col, int mid) 메서드를 정의한다.            문제 풀이에 필요한 변수를 정의한다.                    count는 현재 값보다 작은 값의 개수를 저장할 변수로, 0으로 초기화한다.           j는 컬럼의 위치 값을 저장할 변수로, $col - 1$으로 초기화한다.                       0부터 row까지 i를 증가시키며 반복을 수행한다.                    j가 0보다 크거나 같고 matrix[i][j]의 값이 mid보다 큰 경우 해당 값 이전의 작은 값을 탐색하기 위해, j를 감소시키고 반복을 계속 수행한다.           위의 반복이 완료되면 $j + 1$개의 작은 값들을 count에 넣어 준다.                       반복이 완료되면 작은 값들의 개수인 count를 반환한다.           3번의 반복이 완료되면 k번째로 작은 값인 low를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/kth-smallest-element-in-a-sorted-matrix/",
        "teaser": null
      },{
        "title": "Leetcode Java Insert Delete GetRandom O(1)",
        "excerpt":"문제  Link   코드  class RandomizedSet {    private Map&lt;Integer, Integer&gt; map;   private List&lt;Integer&gt; list;   private Random random;    public RandomizedSet() {     this.map = new HashMap&lt;&gt;();     this.list = new ArrayList&lt;&gt;();     this.random = new Random();   }    public boolean insert(int val) {     if (this.map.containsKey(val)) {       return false;     } else {       this.map.put(val, this.list.size());       this.list.add(val);       return true;     }   }    public boolean remove(int val) {     if (this.map.containsKey(val)) {       int index = this.map.get(val);       int lastIndex = this.list.size() - 1;       int num = this.list.get(lastIndex);       this.list.set(index, num);       this.map.put(num, index);       this.map.remove(val);       this.list.remove(lastIndex);       return true;     } else {       return false;     }   }    public int getRandom() {     return this.list.get(this.random.nextInt(this.list.size()));   }  }  /**  * Your RandomizedSet object will be instantiated and called as such:  * RandomizedSet obj = new RandomizedSet();  * boolean param_1 = obj.insert(val);  * boolean param_2 = obj.remove(val);  * int param_3 = obj.getRandom();  */   결과  Link   설명     주어진 RandomizedSet 클래스를 완성하는 문제이다.            생성자인 RandomizedSet()는 RandomizedSet 객체를 초기화하는 역할을 수행한다.       메서드인 insert(int val)는 val 값이 RandomizedSet 객체 내 존재하지 않았으면 val 값을 저장한 후 false를 반환하고, 존재하였다면 true만 반환한다.       메서드인 remove(int val)는 val 값이 RandomizedSet 객체 내 존재하면 val 값을 제거한 후 true를 반환하고, 존재하지 않았으면 false만 반환한다.       메서드인 getRandom()는 RandomizedSet 객체 내 존재하는 값들을 동일한 확률로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            map은 입력된 값을 저장해서 존재하는지 여부를 판단하기 위한 Map이다.       list는 입력된 값들을 중복되지 않게 저장하기 위한 List이다.       random은 객체 내 존재하는 값을 임의 확률로 반환하기 위한 객체이다.           생성자인 RandomizedSet()를 완성한다.            map에 HashMap, list에 ArrayList로 초기화 시켜준다.           메서드인 insert(int val)를 완성한다.            map에 val 값이 존재하는 경우, false를 반환한다.       map에 val 값이 존재하지 않는 경우, 아래를 수행한다.                    map의 val이 키인 값에 list의 크기를 넣어준다.           list에 val 값을 넣어주고, true를 반환한다.                           메서드인 remove(int val)를 완성한다.            map에 val 값이 존재하는 경우, 아래를 수행한다.                    index에 map의 val이 키인 값인 list 내 존재하는 위치로 초기화한다.           lastIndex에 list의 크기의 1 작은 값인 list에 존재하는 마지막 값의 위치로 초기화한다.           num에 list의 lastIndex번째 위치인 마지막 값을 꺼내 초기화한다.           list의 index번째 위치에 num을 넣어준다.           map의 num이 키인 값에 index를 넣어 list 내 존재하는 위치를 갱신한다.           map에서 val인 키와 값을 제거한다.           list의 latIndex에 해당하는 값을 제거한다.                       map에 val 값이 존재하지 않는 경우, false를 반환한다.           메서드인 getRandom()를 완성한다.            list에서 list의 크기 만큼의 임의의 위치 값을 꺼내 반환한다.                    Random 객체의 nextInt(int bound) 메서드는 0부터 bound 미만까지의 임의 정수 숫자열을 반환한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/insert-delete-getrandom-o1/",
        "teaser": null
      },{
        "title": "Leetcode Java Insert Delete GetRandom O(1) - Duplicates allowed",
        "excerpt":"문제  Link   코드  class RandomizedCollection {    private Map&lt;Integer, Set&lt;Integer&gt;&gt; map;   private List&lt;Integer&gt; list;   private Random random;    public RandomizedCollection() {     this.map = new HashMap&lt;&gt;();     this.list = new ArrayList&lt;&gt;();     this.random = new Random();   }    public boolean insert(int val) {     boolean isContains = this.map.containsKey(val);     if (!isContains) {       this.map.put(val, new HashSet&lt;Integer&gt;());     }     this.map.get(val).add(this.list.size());     this.list.add(val);     return !isContains;   }    public boolean remove(int val) {     boolean isContains = this.map.containsKey(val);     if (isContains) {       int index = this.map.get(val).iterator().next();       int lastIndex = this.list.size() - 1;       int num = this.list.get(lastIndex);       this.list.set(index, num);       this.map.get(val).remove(index);       this.map.get(num).add(index);       this.map.get(num).remove(lastIndex);       this.list.remove(lastIndex);       if (this.map.get(val).isEmpty()) {         this.map.remove(val);       }     }     return isContains;   }    public int getRandom() {     return this.list.get(this.random.nextInt(this.list.size()));   }  }  /**  * Your RandomizedCollection object will be instantiated and called as such:  * RandomizedCollection obj = new RandomizedCollection();  * boolean param_1 = obj.insert(val);  * boolean param_2 = obj.remove(val);  * int param_3 = obj.getRandom();  */   결과  Link   설명     지난번 Insert Delete GetRandom O(1)와 유사한 문제로, 주어진 RandomizedCollection 클래스를 완성하는 문제이다.            앞의 문제와 차이점은 중복이 허용된 객체라는 점이다.       생성자인 RandomizedCollection()는 RandomizedCollection 객체를 초기화하는 역할을 수행한다.       메서드인 insert(int val)는 val 값이 RandomizedCollection 객체 내 존재하지 않았으면  false를, 존재하였다면 true를 반환하면서 val 값을 저장한다.       메서드인 remove(int val)는 val 값이 RandomizedCollection 객체 내 존재하면 true를, 존재하지 않았으면 false를 반환하면서 val 값을 제거한다.       메서드인 getRandom()는 RandomizedCollection 객체 내 존재하는 값들을 동일한 확률로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            map은 입력된 값을 저장해서 존재하는지 여부를 판단하기 위한 Map이다.       list는 입력된 값들을 중복되지 않게 저장하기 위한 List이다.       random은 객체 내 존재하는 값을 임의 확률로 반환하기 위한 객체이다.           생성자인 RandomizedSet()를 완성한다.            map에 HashMap, list에 ArrayList, random에 Random 객체로 초기화 시켜준다.           메서드인 insert(int val)를 완성한다.            isContains에 map에 val 값이 존재하는지 여부를 저장한다.       isContains가 false인 경우 기존에 입력된 값이 존재하지 않았으므로, map의 val 키에 새 HashMap을 넣어준다.       map의 val이 키로 가진 Set을 꺼내와 list의 크기를 넣어준다.       list에 val 값을 넣어 값을 계속 이어준다.       isContains의 반대가 존재 여부이므로 반대 값을 반환한다.           메서드인 remove(int val)를 완성한다.            isContains에 map에 val 값이 존재하는지 여부를 저장한다.       isContains가 true인 경우 아래를 수행한다.                    index에 map의 val이 키인 Set 내 다음 값을 꺼내 넣어준다..           lastIndex에 list의 크기의 1 작은 값인 list에 존재하는 마지막 값의 위치로 초기화한다.           num에 list의 lastIndex번째 위치인 마지막 값을 꺼내 초기화한다.           list의 index번째 위치에 num을 넣어준다.           map의 val이 키인 Set에 index를 제거해 list 내 존재하는 위치를 삭제해준다.           map의 num이 키인 Set에 index를 넣어 list 내 존재하는 위치를 갱신한다.           map의 num이 키인 Set에서 lastIndex번째 값을 제거한다.           list의 latIndex에 해당하는 값을 제거한다.           map에서 val이 키인 Set이 비어있는 경우, 해당 키를 제거한다.                       isContains의 여부에 따라 삭제를 수행하였으므로, 해당 값을 반환한다..           메서드인 getRandom()를 완성한다.            list에서 list의 크기 만큼의 임의의 위치 값을 꺼내 반환한다.                    Random 객체의 nextInt(int bound) 메서드는 0부터 bound 미만까지의 임의 정수 숫자열을 반환한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/insert-delete-getrandom-o1-duplicates-allowed/",
        "teaser": null
      },{
        "title": "Leetcode Java Linked List Random Node",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    private ListNode listNode;   private int size;   private Random random;    public Solution(ListNode head) {     this.listNode = head;     this.size = 0;     ListNode curr = head;     while (curr != null) {       this.size++;       curr = curr.next;     }     this.random = new Random();   }    public int getRandom() {     int num = this.random.nextInt(this.size);     ListNode curr = this.listNode;     while (num &gt; 0) {       curr = curr.next;       num--;     }     return curr.val;   }  }  /**  * Your Solution object will be instantiated and called as such:  * Solution obj = new Solution(head);  * int param_1 = obj.getRandom();  */   결과  Link   설명     단일 ListNode가 주어지면, 임의의 노드 값을 동일 확률로 반환하는 Solution 클래스를 완성하는 문제이다.            생성자인 Solution(ListNode head)은 Solution 객체에 head 넣어 초기화하는 역할을 수행한다.       메서드인 getRandom()는 Solution 객체에 주입된 ListNode 내 존재하는 값들을 동일한 확률로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            listNode는 생성자를 통해 주입된 ListNode를 저장하기 위한 변수이다.       size는 listNode의 개수를 저장할 변수이다.       random은 객체 내 존재하는 값을 임의 확률로 반환하기 위한 객체이다.           생성자인 Solution(ListNode head)을 완성한다.            주입된 head를 listNoad에 넣어준다.       size를 0으로 초기화 한다.       curr에 head을 임시로 넣어주고 curr이 null이 아닐 때까지 반복을 수행하여 size에 node의 개수를 넣어준다.       random에 Random 객체로 초기화 시켜준다.           메서드인 getRandom()을 완성한다.            num에 size 미만의 임의 숫자를 넣어준다.                    Random 객체의 nextInt(int bound) 메서드는 0부터 bound 미만까지의 임의 정수 숫자열을 반환한다.                       curr에 listNode를 넣고 num이 0 이상일 때 까지 이동하며 num번째 노드를 찾아준다.       num번째 노드인 curr의 val 값을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/linked-list-random-node/",
        "teaser": null
      },{
        "title": "Leetcode Java Ransom Note",
        "excerpt":"문제  Link   코드  class Solution {    public boolean canConstruct(String ransomNote, String magazine) {     int[] count = new int[26];     for (char ransomNoteChar : ransomNote.toCharArray()) {       int num = ransomNoteChar - 'a';       int preIndex = count[num];       int index = magazine.indexOf(ransomNoteChar, preIndex);       if (index == -1) {         return false;       }       count[num] = index + 1;     }     return true;   }  }   결과  Link   설명     주어진 문자열 magazine이 주어지면 해당 문자들로 ransomNote를 만들 수 있는지 검증하는 문제이다.            단, magazine의 문자는 한 번만 사용할 수 있다.                count 정수 배열을 영문자의 개수인 26의 크기로 정의한다.       ransomNote의 문자들을 반복하여 검증을 수행한다.            num에 ransomNoteChar에 ‘a’(26)을 뺀 영문자 순서를 넣어준다.       preIndex에 count에서 num번째 값인 기존에 위치했던 ransomNoteChar의 위치 값을 넣어준다.       index에 magazine에서 preIndex 이후의 자리 중 ransomNoteChar의 값을 넣어준다.       index가 -1인 경우 magazine에 ransomNoteChar가 더 이상 존재하지 않는다는 의미이므로, false를 주어진 문제의 결과로 반환한다.       count의 num번째 위치에 $index + 1$을 넣어 다음 검색에 그 위치 이후에서 검색할 수 있게하고, 반복을 계속 수행한다.           반복이 완료되면 ransomNote의 문자들이 magazine에 모두 포함되므로, true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/ransom-note/",
        "teaser": null
      },{
        "title": "Leetcode Java Shuffle an Array",
        "excerpt":"문제  Link   코드  class Solution {    private int[] nums;   private int[] copy;   private Random random;    public Solution(int[] nums) {     this.nums = nums;     this.copy = Arrays.copyOf(nums, nums.length);     this.random = new Random();   }    public int[] reset() {     this.copy = Arrays.copyOf(nums, nums.length);     return this.copy;   }    public int[] shuffle() {     for (int idx = this.copy.length - 1; idx &gt;= 0; idx--) {       int num = this.random.nextInt(idx + 1);       int temp = this.copy[num];       this.copy[num] = this.copy[idx];       this.copy[idx] = temp;     }     return this.copy;   }  }  /**  * Your Solution object will be instantiated and called as such:  * Solution obj = new Solution(nums);  * int[] param_1 = obj.reset();  * int[] param_2 = obj.shuffle();  */   결과  Link   설명     정수 배열 nums가 주어지면, 무작위로 섞고 초기화가 가능한 Solution 객체를 만드는 문제이다.            생성자인 Solution(int[] nums)는 주어진 정수 배열 nums로 Solution 객체를 초기화한다.       메서드인 int[] reset()은 Solution 내 배열을 재 설정하여 반환한다.       메서드인 int[] suffle()은 Solution 내 배열을 무작위로 섞어 반환한다.           문제 풀이에 필요한 변수를 정의한다.            nums는 주어진 정수 배열을 원본으로 저장하기 위한 변수이다.       copy는 nums를 복사해서 무작위로 섞어 보관할 변수이다.       random은 객체 내 존재하는 값을 임의 확률로 반환하기 위한 객체이다.           생성자인 Solution(int[] nums)을 완성한다.            nums에 주어진 정수 배열인 nums를 넣어준다.       copy에 nums를 깊은 복사하여 넣어준다.       random에 Random 객체로 초기화 시켜준다.           메서드인 int[] reset()을 완성한다.            생성자와 동일하게 copy에 nums를 깊은 복사하여 넣어준다.       nums로 복사된 copy를 반환한다.           메서드인 int[] suffle()을 완성한다            copy 객체를 반복하여 내부 값들을 섞어준다.                    num에 0에서 $idx + 1$번째 값 사이의 임의 값을 넣어준다.           num번째 값과 idx번째 값을 바꿔준다.                       반복이 완료되면 값을 섞은 copy를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/shuffle-an-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Mini Parser",
        "excerpt":"문제  Link   코드  /**  * // This is the interface that allows for creating nested lists.  * // You should not implement it, or speculate about its implementation  * public interface NestedInteger {  *     // Constructor initializes an empty nested list.  *     public NestedInteger();  *  *     // Constructor initializes a single integer.  *     public NestedInteger(int value);  *  *     // @return true if this NestedInteger holds a single integer, rather than a nested list.  *     public boolean isInteger();  *  *     // @return the single integer that this NestedInteger holds, if it holds a single integer  *     // Return null if this NestedInteger holds a nested list  *     public Integer getInteger();  *  *     // Set this NestedInteger to hold a single integer.  *     public void setInteger(int value);  *  *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.  *     public void add(NestedInteger ni);  *  *     // @return the nested list that this NestedInteger holds, if it holds a nested list  *     // Return empty list if this NestedInteger holds a single integer  *     public List&lt;NestedInteger&gt; getList();  * }  */ class Solution {    private int start;   private char[] charArray;    public NestedInteger deserialize(String s) {     this.start = 0;     this.charArray = s.toCharArray();     return this.recursive();   }    private NestedInteger recursive() {     NestedInteger result = new NestedInteger();     if (this.charArray[this.start] == '[') {       this.start++;       this.dfs(result);     } else {       int num = 0;       int posistion = 1;       if (charArray[this.start] == '-') {         posistion = -1;         this.start++;       }       while (this.start &lt; this.charArray.length &amp;&amp; this.charArray[this.start] &lt;= '9' &amp;&amp; this.charArray[this.start] &gt;= '0') {         num = (num * 10) + (this.charArray[this.start++] - '0');       }       result.setInteger(num * posistion);     }     return result;   }    private void dfs(NestedInteger parent) {     while (this.charArray[this.start] != ']') {       parent.add(this.recursive());       if (this.charArray[this.start] == ',') {         this.start++;       }     }     this.start++;   }  }   결과  Link   설명     주어진 문자열 s를 읽어 NestedInteger로 역직렬화 하는 문제이다.            각 요소는 정수이거나 List형태로 구성된다.           문제 풀이에 필요한 변수를 정의한다.            start는 파싱을 시작하기 위한 위치값을 넣기 위한 변수이다.       charArray는 주어진 문자열 s를 문자 배열로 저장하여 활용하기 위한 변수이다.                start를 0으로 charArray를 주어진 문자열 s의 문자 배열로 전환하여 넣어주고, 4번에 정의한 recursive() 메서드를 수행한 결과를 주어진 문제의 결과로 반환한다.       재귀 호출을 이용하여 정수를 파싱하기 위한 recursive() 메서드를 정의한다.            result 변수에 새 NestedInteger를 생성한다.                    소스에서는 해당 interface를 임시 구현한 SimpleNestedInteger로 사용하였다.                       charArray의 start번째 문자가 대괄호 시작 문자(‘[‘)인 경우 start를 증가시키고 5번에서 정의한 dfs(NestedInteger parent) 메서드를 호출한다.       위의 경우가 아니면 아래를 수행한다.                    정수열을 만들기 위한 변수인 num을 0으로, 음수/양수를 구분하기 위한 변수인 position을 1로 초기화 한다.           charArray의 start번째 값이 ‘-‘인 경우, position에 -1을 넣고 start를 증가시킨다.           start가 charArray의 길이 미만이고, 0과 9 사이의 숫자일 때 까지 반복하여 num에 정수 값을 넣어준다.           반복이 완료되면 result에 특정 정수 값인 num을 position을 곱해서 넣어준다.                       위로 초기화된 result를 반환한다.           DFS 알고리즘로 문자열 탐색을 수행하는 dfs(NestedInteger parent) 메서드를 완성한다.            charArray의 start번째 문자가 대괄호 종료 문자(‘]’)가 아닐 때 까지 반복하여 아래를 수행한다.                    parent에 4번에서 정의한 recursive() 메서드를 수행한 결과를 내부 List에 넣어준다.           charArray의 start번째 문자가 콤마(‘,’)인 경우 무시하고 넘어가기 위해 start를 증가시킨다.                       반복이 종료되면 다음 위치로 이동하기 위해 start를 증가시킨다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/mini-parser/",
        "teaser": null
      },{
        "title": "Leetcode Java Lexicographical Numbers",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; lexicalOrder(int n) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     for (int idx = 1; idx &lt; 10; idx++) {       this.dfs(result, n, idx);     }     return result;   }    private void dfs(List&lt;Integer&gt; result, int n, int curr) {     if (curr &gt; n) {       return;     }     result.add(curr);     for (int idx = 0; idx &lt; 10; idx++) {       if ((10 * curr) + idx &gt; n) {         return;       }       this.dfs(result, n, (10 * curr) + idx);     }   }  }   결과  Link   설명     1부터 주어진 정수 n까지 사전 순으로 정렬하여 반환하는 문제이다.            O(n) 시간 복잡도와, O(1) 공간 복잡도를 사용하는 알고리즘을 작성해야 한다.                결과를 저장할 result를 ArrayList로 초기화하고 1부터 10 미만까지 idx를 증가시키며 반복하여, 3번에서 정의한 dfs(List result, int n, int curr) 메서드를 수행한다.       DFS 알고리즘로 문자열 탐색을 수행하는 dfs(List result, int n, int curr) 메서드를 완성한다.            curr이 n보다 큰 경우 기준을 초과되었으므로, 그만 수행한다.       result에 curr을 넣어준다.       0부터 10 미만까지 idx를 증가시키며 반복을 수행한다.                    $(10 \\times curr) + idx$이 n보다 큰 경우 기준을 초과하였으므로, 그만 수행한다.           재귀 호출을 통해 curr에 $(10 \\times curr) + idx$을 넣어 사전 순으로 정수를 result에 넣어준다.                           2번의 반복이 완료되면 결과를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/lexicographical-numbers/",
        "teaser": null
      },{
        "title": "Leetcode Java First Unique Character in a String",
        "excerpt":"문제  Link   코드  class Solution {    public int firstUniqChar(String s) {     int index = Integer.MAX_VALUE;     for (char c = 'a'; c &lt;= 'z'; c++) {       int first = s.indexOf(c);       if (first != -1 &amp;&amp; first == s.lastIndexOf(c)) {         index = Math.min(index, first);       }     }     return index == Integer.MAX_VALUE ? -1 : index;   }  }   결과  Link   설명          주어진 문자열 s 내 단 한번만 사용된 최초 문자를 찾아 해당 위치를 반환하는 문제이다.            문자열 s 내 유일한 문자의 위치를 index에 정수의 가장 큰 값을 넣어 초기화 한다.       ‘a’ 문자부터 ‘z’까지 c를 반복하며 문자열 s를 탐색한다.            해당 문자의 위치가 -1이 아니면서 처음과 마지막의 위치가 동일한 경우 문자열 s 내 유일한 문자이므로, index에 index와 해당 문자의 위치인 first 중 작은(앞의 위치에 해당하는) 값을 넣어준다.           index가 초기 값인 정수의 최대 값인지를 확인하여 경우에 따라 주어진 문제의 결과를 반환한다.            index가 초기 값 그대로인 경우 유일한 문자가 존재하지 않는다는 의미이므로, -1을 주어진 문제의 결과로 반환한다.       위의 경우가 아닌 경우 유일한 문자가 최소 1개 이상 존재하므로, 가장 먼저 존재하는 문자의 위치를 저장한 index를 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/first-unique-character-in-a-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Absolute File Path",
        "excerpt":"문제  Link   코드  class Solution {    public int lengthLongestPath(String input) {     String[] paths = input.split(\"\\n\");     int[] stack = new int[paths.length + 1];     int result = 0;     for (String path : paths) {       int level = path.lastIndexOf(\"\\t\") + 1;       int curr = stack[level + 1] = stack[level] + path.length() - level + 1;       if (path.contains(\".\")) {         result = Math.max(result, curr - 1);       }     }     return result;   }  }   결과  Link   설명          Directory Path인 input을 이용하여 dir부터 가장 긴 디렉토리 구조의 길이를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            paths에 input의 폴더 구분인 “\\n”로 분리하여 문자열의 배열로 넣어준다.       stack에는 이전까지 디렉토리 구조의 길이를 넣어줄 정수 배열로, $paths.legnth + 1$ 크기로 정의한다.       result는 가장 긴 디렉토리 구조의 길이를 넣을 변수로, 0으로 초기화한다.           paths를 반복하여 result에 결과를 넣어준다.            level에 폴더 혹은 파일 이름의 시작이되는 path의 마지막 “\\t”의 위치 값을 넣어준다.       curr과 stack[$level + 1$]에 path에 해당하는 디렉토리 구조의 길이인 $stack[level] + path.length - level + 1$를 넣어준다.       path에 파일 확장자의 구분이 되는 콤마(“.”)가 존재한다면, result에 result와 $curr - 1$ 중 큰 값을 넣어준다.           반복이 완료되면 가장 긴 디렉토리 구조의 길이를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-absolute-file-path/",
        "teaser": null
      },{
        "title": "Leetcode Java Find the Difference",
        "excerpt":"문제  Link   코드  class Solution {    public char findTheDifference(String s, String t) {     char[] sCharArray = s.toCharArray();     char[] tCharArray = t.toCharArray();     int diff = 0;     for (int idx = 0; idx &lt; sCharArray.length; idx++) {       diff += tCharArray[idx] - sCharArray[idx];     }     return (char) (diff + tCharArray[sCharArray.length]);   }  }   결과  Link   설명          주어진 문자열 t에서 s에서 누락된 문자를 찾는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            sCharArray는 주어진 문자열 s를 문자 배열로 변환하여 사용할 변수이다.       tCharArray는 주어진 문자열 t를 문자 배열로 변환하여 사용할 변수이다.       diff는 주어진 문자열 s와 t의 차이를 담을 변수이다.           주어진 문자열 t는 s보다 한 글자 많기 때문에 0부터 sCharArray의 길이만큼 idx를 증가시키며 반복시킨다.            diff에 tCharArray 배열 내 idx번째 문자의 정수형과 sCharArray 배열 내 idx번째 문자의 정수형의 차이를 넣어주고 반복을 계속 수행한다.           diff에 tCharArray의 마지막 문자를 더해서 문자로 변환한 값을 주어진 문자로 반환한다.            tCharArray 배열 내 문자들의 ASCII Code 값의 합에 sCharArray 배열 내 문자들의 ASCII Code의 합을 뺀 경우, sCharArray에 누락된 문자의 ASCII 코드 값이 나와 문자로 변환하면 해당 영문자로 반환이 된다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-the-difference/",
        "teaser": null
      },{
        "title": "Leetcode Java Elimination Game",
        "excerpt":"문제  Link   코드  class Solution {    public int lastRemaining(int n) {     if (n == 1) {       return n;     } else {       return 2 * ((n / 2) + 1 - this.lastRemaining(n / 2));     }   }  }   결과  Link   설명     1부터 주어진 숫자 n까지 숫자를 나열하여 아래의 법칙으로 숫자들을 제거하여 남은 하나의 정수를 반환하는 문제이다.            처음은 왼쪽에서 오른쪽으로, 다음은 오른쪽에서 왼쪽으로 번갈아가며 한 자리 씩 넘어가며 제거한다.       예를 들어 n이 5인 경우, 1, 2, 3, 4, 5 -&gt; 2, 4 -&gt; 2가 결과가 된다.       해당 문제는 Josephus Problem과 유사한 문제이다.           n의 경우에 따라 재귀 호출을 수행하여 결과를 반환한다.            n이 1인 경우, n을 반환한다.       n이 1이 아닌 경우, $\\frac{2 + n}{2}$에 $\\frac{n}{2}$로 재귀 호출 수행한 결과를 빼서 해당 결과의 2배를 반환한다.                    위는 $2 \\times (\\frac{n}{2} + 1 - this.lastRemaining(\\frac{n}{2}))$로 표현한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/elimination-game/",
        "teaser": null
      },{
        "title": "Leetcode Java Perfect Rectangle",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isRectangleCover(int[][] rectangles) {     Set&lt;int[]&gt; rectangleSet = new TreeSet&lt;&gt;((r1, r2) -&gt; {       if (r1[1] &gt;= r2[3] || r1[0] &gt;= r2[2]) {         return 1;       } else if (r1[3] &lt;= r2[1] || r1[2] &lt;= r2[0]) {         return -1;       } else {         return 0;       }     });     int top = Integer.MIN_VALUE;     int bottom = Integer.MAX_VALUE;     int left = Integer.MAX_VALUE;     int right = Integer.MIN_VALUE;     int area = 0;     for (int[] rectangle : rectangles) {       if (!rectangleSet.add(rectangle)) {         return false;       }       area += (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1]);       top = Math.max(top, rectangle[3]);       bottom = Math.min(bottom, rectangle[1]);       left = Math.min(left, rectangle[0]);       right = Math.max(right, rectangle[2]);     }     return (right - left) * (top - bottom) == area;   }  }   결과  Link   설명          주어진 2차원 정수 배열 rectangles는 직사각형들의 좌표 값으로, 해당 직사각형들을 이용하여 겹치지 않은 정사각형을 만들 수 있는지를 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            rectangleSet은 중복을 배제하고 정렬된 이진 탐색 트리 형태로 저장하기 위해 TreeSet으로 정의한다.       top과 right는 가장 작은 값을 넣기 위해 정수의 최솟값으로 넣어 정의한다.       bottom과 left는 가장 큰 값을 넣기 위해 정수의 최댓값으로 넣어 정의한다.       area는 각 사각형의 부피를 넣기 위한 변수로, 0으로 정의한다.           주어진 rectangles를 반복하여 부피와 좌표를 정의한다.            rectangleSet에 rectangle이 겹치는 경우, false를 반환한다.       area에 x축의 차이와 y축의 차이를 곱한 rectangle의 부피를 더해준다.       top과 right에 자신의 값과 각 좌표의 크기 중 큰 값을 넣어준다.       bottom과 left에 자신의 값과 각 좌표의 큰기 중 작은 값을 넣어준다.           각 좌표값을 이용한 부피의 크기와 area의 크기가 동일한지 여부를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/perfect-rectangle/",
        "teaser": null
      },{
        "title": "Leetcode Java Is Subsequence",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isSubsequence(String s, String t) {     int index = -1;     for (int idx = 0; idx &lt; s.length(); idx++) {       index = t.indexOf(s.charAt(idx), index + 1);       if (index == -1) {         return false;       }     }     return true;   }  }   결과  Link   설명     주어진 문자열 s가 t의 부분 문자들로 이루어졌는지를 검증하는 문제이다.            단 s와 t의 문자들의 순서는 차례대로 유지되어야 한다.       예를 들어, t가 “asbdc”이면 s가 “abc”이면 true이고 “acb”이면 false가 된다.                문자의 위치를 저장하기 위한 index를 -1로 정의한다.       0부터 s의 길이만큼 idx를 증가시키며 반복하여 검증을 수행한다.            index에 t에서 $index + 1$번째 이후 문자들 중 s의 idx번째 문자의 위치 값을 넣어준다.       위의 검증에서 해당 문자가 없어 index가 -1인 경우, false를 주어진 문제의 결과로 반환한다.       그렇지 않은 경우, 반복을 계속 수행한다.           반복이 완료되면 s가 t의 부분 문자들로 이루어져 있으므로, true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/is-subsequence/",
        "teaser": null
      },{
        "title": "Leetcode Java UTF-8 Validation",
        "excerpt":"문제  Link   코드  class Solution {    public boolean validUtf8(int[] data) {     int bytes = 0;     for (int num : data) {       int mask = 128;       if (bytes == 0) {         while ((mask &amp; num) != 0) {           bytes++;           mask &gt;&gt;= 1;         }         if (bytes &gt; 4 || bytes == 1) {           return false;         }       } else {         if ((num &amp; mask) == 0 || (num &amp; (mask &gt;&gt; 1)) != 0) {           return false;         }       }       if (bytes != 0) {         bytes -= 1;       }     }     return bytes == 0;   }  }   결과  Link   설명     주어진 정수 배열 data가 UTF-8 인코딩인지 검증하는 문제이다.            올바른 UTF-8는 아래와 같다.                                                       Char. number range               UTF-8 octet sequence                                         (hexadecimal)               (binary)                                                               0000 0000-0000 007F               0xxxxxxx                                         0000 0080-0000 07FF               110xxxxx 10xxxxxx                                         0000 0800-0000 FFFF               1110xxxx 10xxxxxx 10xxxxxx                                         0001 0000-0010 FFFF               11110xxx 10xxxxxx 10xxxxxx 10xxxxxx                                                        문자열의 shift 횟수를 저장할 bytes를 0으로 정의한다.       data를 반복하여 검증을 수행한다.            검증을 수행할 mask를 128로 정의한다.       bytes가 0인 경우, 아래를 수행한다.                    mask와 num의 AND(&amp;) 비트 연산의 결과가 0이 아닌 경우, bytes를 증가시키고 mask의 bit를 우측으로 한 칸 이동시킨다.           bytes가 4보다 크거나 1인 경우 UTF-8 인코딩이 아니므로, false를 주어진 문제의 결과로 반환한다.                       bytes가 0이 아닌 경우, 아래를 수행한다.                    num과 mask의 AND(&amp;) 비트 연산의 결과가 0이거나 num과 mask의 bit를 우측으로 한 칸 이동시킨 값의 AND(&amp;) 비트 연산의 결과가 0이 아닌 경우, false를 주어진 문제의 결과로 반환한다.                       bytes가 0이 아닌 경우, bytes를 감소시킨다.           반복이 완료되면 bytes가 0인지 여부를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/utf-8-validation/",
        "teaser": null
      },{
        "title": "Leetcode Java Decode String",
        "excerpt":"문제  Link   코드  class Solution {    private int index = 0;    public String decodeString(String s) {     StringBuilder result = new StringBuilder();     while (index &lt; s.length() &amp;&amp; s.charAt(index) != ']') {       if (Character.isDigit(s.charAt(index))) {         int repeat = 0;         while (Character.isDigit(s.charAt(index))) {           repeat = (repeat * 10) + (s.charAt(index++) - '0');         }         index++;         String word = this.decodeString(s);         for (int idx = 0; idx &lt; repeat; idx++) {           result.append(word);         }         index++;       } else {         result.append(s.charAt(index++));       }     }     return result.toString();   }   }   결과  Link   설명     주어진 문자열 s를 이용하여 아래의 규칙대로 수행한 결과를 반환하는 문제이다.            k[encoded_string]로 표기된 문자열은 encoded_string을 k번 반복하면 된다.       encoded_string 내 k[encoded_string]로 표기된 문자열은 안쪽부터 먼저 변환 후 바깥쪽에서 변환한다.           index는 주어진 문자열의 위치를 나타내며, 0으로 초기화한다.            decodeString(String s)를 재귀 호출하여 전역 변수를 정의한다.           result는 결과를 저장할 StringBuilder 객체이다.            동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.           index가 s의 길이보다 작고, index번째 문자가 ‘]’가 아닐 때 까지 반복을 수행한다.            s의 index번째 문자가 숫자인 경우, 아래를 수행한다.                    반복 횟수를 넣을 repeat를 0으로 초기화하고, 숫자인 값을 repeat에 넣어준다.           숫자를 넣은 다음 값은 ‘[’ 문자이므로, index를 증가시킨다.           word는 재귀 호출을 이용하여 다음 ‘]’문자까지 값을 받아 초기화한다.           0부터 repeat 전까지 반복하여 result에 word를 repeat번 넣어준다.           값을 다 넣은 다음 값은 ‘]’이므로, index를 증가시킨다.                       s의 index번째 문자가 숫자가 아닌 경우 단순 문자열이므로, result에 s의 index번째 문자를 넣고 index를 증가시킨다.           반복이 완료되면 result를 문자열로 변환시켜 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/decode-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Substring with At Least K Repeating Characters",
        "excerpt":"문제  Link   코드  class Solution {    public int longestSubstring(String s, int k) {     return this.recursive(s, k, 0, s.length());   }    private int recursive(String s, int k, int start, int end) {     if (end &lt; k) {       return 0;     }     int[] count = new int[26];     char[] charArray = s.toCharArray();     for (int i = start; i &lt; end; i++) {       count[charArray[i] - 'a']++;     }     for (int mid = start; mid &lt; end; mid++) {       if (count[charArray[mid] - 'a'] &gt;= k) {         continue;       }       int next = mid + 1;       while (next &lt; end &amp;&amp; count[charArray[next] - 'a'] &lt; k) {         next++;       }       return Math.max(this.recursive(s, k, start, mid), this.recursive(s, k, next, end));     }     return end - start;   }  }   결과  Link   설명          주어진 문자열 s 중 k번 이상 반복된 문자열이 들어간 가장 긴 부분 문자열의 길이를 구하는 문제이다.            재귀 호출을 위한 recursive(String s, int k, int start, int end) 메서드를 이용하여 0부터 s의 길이까지 가장 긴 부분 문자열의 길이를 주어진 문제의 결과로 반환한다.             end가 k보다 작은 경우 k번 이상 반복할 문자가 존재하지 않으므로, 0을 반환한다.       문제 풀이에 필요한 변수를 정의한다.                    count는 각 문자 별 발생 횟수를 저장하기 위한 배열로, 알파벳의 개수인 26 크기로 정의한다.           charArray는 s를 문자의 배열로 변환하여 저장한다.                       start부터 end까지 count 배열 내 영문자의 순서인 ‘a’(0) ~ ‘z’(25)에 발생 횟수를 저장한다.       start부터 end까지 mid를 증가시키며 반복을 수행한다.                    charArray의 mid번째 문자가 k 이상인 경우 조건을 만족하므로, 반복을 계속 수행한다.           next에 $mid + 1$을 넣어준다.           next가 end 미만이고 charArray의 next번째 문자의 개수가 k개 미만인 경우, next를 증가시킨다.           start에서 mid, next에서 end까지 각각 재귀 호출을 수행하여 가장 큰 값을 반환한다.                       반복이 정상적으로 끝나면 가장 큰 길이가 되는, $end - start$를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-substring-with-at-least-k-repeating-characters/",
        "teaser": null
      },{
        "title": "Leetcode Java Rotate Function",
        "excerpt":"문제  Link   코드  class Solution {    public int maxRotateFunction(int[] nums) {     int sum = 0;     int cal = 0;     int length = nums.length;     for (int idx = 0; idx &lt; length; idx++) {       cal += idx * nums[idx];       sum += nums[idx];     }     int max = cal;     for (int idx = length - 1; idx &gt;= 1; idx--) {       cal += sum - (length * nums[idx]);       max = Math.max(max, cal);     }     return max;   }  }   결과  Link   설명     주어진 nums를 이용하여 가장 큰 회전 함수의 값을 찾는 문제이다.            회전 함수는, $F(k) = (0 \\times nums[0]) + … + ((n - 1) \\times nums[n - 1])$으로 구해진다.       단, 숫자의 이동은 시계 방향(우측)으로만 가능하다.           문제 풀이에 필요한 변수를 정의한다.            sum은 nums의 숫자 합계를 구하기 위한 변수로, 0으로 초기화한다.       cal은 회전 함수의 값을 구한 값을 저장하기 위한 변수로, 0으로 초기화한다.       length는 정수 배열 nums의 크기를 담아 저장한다.                nums를 처음부터 끝까지 반복하여 값의 위치와 값의 곱을 cal에, 값을 sum에 더해준다.            임시로 최대 값인 max에 초기 회전 함수의 결과인 cal 값을 넣어준다.       값의 위치를 마지막 값부터 두 번째 값까지 idx를 감소시키며 반복을 수행한다.            sum과 $length \\times nums[idx]$의 결과를 뺀 후 cal에 더해준다.       max에 max와 cal 중 큰 값을 넣어준다.                    1번에서 설명한 회전 함수는 예제를 통해 아래의 공식으로 구성된다.             F(k) = (0 × nums[length - k]) + (1 × num[length - k + 1]) + ... + ((length - 1) × nums[length - (k + 1)])$ F(k - 1) = (0 × nums[length - k + 1]) + (1 × num[length - k + 2]) + ... + ((length - 1) × nums[length - k])                                   그러므로, 아래의 공식이 성립한다.             F(k) - F(k - 1) = nums[length - k + 1] + nums[length - k + 2] + ... + nums[length - (k + 1)] - ((length - 1) × nums[length - k]) = (nums[length - k] + nums[length - k + 1] + ...) - (length × nums[length - k]) = sum - (length × nums[length - k])                                   즉, $F(k) = F(k - 1) + sum - (length \\times nums[length - k])$의 공식이 성립하게 된다.           $F(1) = F(0) + sum - (length \\times nums[length - 1])$이므로, $length - 1$부터 1까지 감소시키며 가장 큰 회전 함수의 값을 구한다.                           반복이 완료되면 가장 큰 회전 함수의 값을 저장한 max를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/rotate-function/",
        "teaser": null
      },{
        "title": "Leetcode Java Integer Replacement",
        "excerpt":"문제  Link   코드  class Solution {    public int integerReplacement(int n) {     int count = 0;     while (n &gt; 1) {       if ((n &amp; 1) != 0) {         n += (n == 3 || ((n &gt;&gt; 1) &amp; 1) == 0) ? -1 : 1;         count++;       }       n &gt;&gt;&gt;= 1;       count++;     }     return count;   }  }   결과  Link   설명     주어진 정수 n을 이용하여 아래의 규칙을 이용하여 1로 변환하는 가장 작은 횟수를 구하는 문제이다.            n이 짝수인 경우, n을 2로 나누어준다.       n이 홀수인 경우, n에 1을 빼거나 더하여 짝수로 변환한다.                변환 횟수를 저장할 count를 정의하고, 0으로 초기화한다.       n이 1보다 클 때 까지 반복하여 아래를 수행한다.            n 과 1의 AND(&amp;) 비트 연산의 결과가 0이 아닌 경우 홀수이므로, 아래를 수행한다.                    n의 비트를 우측으로 한 칸 이동한 결과와 1의 AND(&amp;) 비트 연산을 수행한 결과가 0인 경우와 특이 케이스인 n이 3인 경우는 n을 감소시키는 것이 횟수를 줄이는 방법이므로, n에 1을 빼준다.           위의 경우가 아닌 경우, n에 1을 증가시킨다.           예를 들어 n이 5(101)인 경우, 1을 더하면 6 -&gt; 3 -&gt; 2 -&gt; 1로 3번, 1을 빼면 4 -&gt; 2 -&gt; 1로 2번이 된다.           다른 예로 n이 3(11)인 경우 1의 AND(&amp;) 비트 연산의 결과가 1이지만, 1을 더하면 4 -&gt; 2 -&gt; 1로 2번, 1을 빼면 2 -&gt; 1로 1번이 되므로 예외 처리를 수행한다.           마지막으로 홀수를 짝수로 변경했으므로, count를 증가시킨다.                       n의 비트를 우측으로 두 칸 이동을 시킨다.                    n /= 2와 기능은 동일하지만, overflow를 방지할 수 있다.                       짝수를 2로 나누었으므로, count를 증가시킨다.           반복이 완료되면 n을 1로 변환하는 가장 작은 횟수를 저장한 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/integer-replacement/",
        "teaser": null
      },{
        "title": "Leetcode Java Random Pick Index",
        "excerpt":"문제  Link   코드  class Solution {    int[] nums;   Random random;    public Solution(int[] nums) {     this.nums = nums;     this.random = new Random();   }    public int pick(int target) {     int index = -1;     int max = 1;     for (int idx = 0; idx &lt; nums.length; idx++) {       if (nums[idx] == target &amp;&amp; random.nextInt(max++) == 0) {         index = idx;       }     }     return index;   }  }  /**  * Your Solution object will be instantiated and called as such:  * Solution obj = new Solution(nums);  * int param_1 = obj.pick(target);  */   결과  Link   설명     주어진 정수 배열 nums를 이용하여 임의의 정수를 추출하는 Solution 객체를 만드는 문제이다.            생성자인 Solution(int[] nums)은 Solution 객체를 초기화 하는 역할을 수행한다.       메서드인 pick(int target)은 target에 해당하는 값들 중 임의의 index를 반환한다.           문제 풀이에 필요한 변수를 정의한다.            nums는 생성자를 통해 주입된 정수 배열을 임시 보관하기 위한 배열이다.       random은 반복된 값들 중 임의 위치를 반환하기 위한 변수이다.           생성자인 Solution(int[] nums)를 정의한다.            주어진 변수 nums를 전역 변수 nums에 넣어준다.       random 전역 변수를 Random 객체로 초기화 한다.           메서드인 pick(int target)을 정의한다.            위치 값을 넣기 위한 변수 result를 -1로, random의 임의 값을 구한기 위한 값을 max로 정의한다.       nums의 위치를 idx로 처음부터 끝까지 반복을 수행한다.                    nums의 idx번째 값이 target과 동일하고, random을 이용한 결과가 만족할 경우 index에 idx 값을 넣어준다.                       반복이 종료되면 target의 임의 위치 값을 넣은 result를 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/random-pick-index/",
        "teaser": null
      },{
        "title": "Leetcode Java Evaluate Division",
        "excerpt":"문제  Link   코드  class Solution {    public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) {     Map&lt;String, Map&lt;String, Double&gt;&gt; map = new HashMap&lt;&gt;();     for (int idx = 0; idx &lt; values.length; idx++) {       List&lt;String&gt; equation = equations.get(idx);       map.putIfAbsent(equation.get(0), new HashMap&lt;&gt;());       map.putIfAbsent(equation.get(1), new HashMap&lt;&gt;());       map.get(equation.get(0)).put(equation.get(1), values[idx]);       map.get(equation.get(1)).put(equation.get(0), 1 / values[idx]);     }     double[] result = new double[queries.size()];     for (int idx = 0; idx &lt; queries.size(); idx++) {       List&lt;String&gt; query = queries.get(idx);       result[idx] = this.dfs(query.get(0), query.get(1), 1, map, new HashSet&lt;&gt;());     }     return result;   }    private double dfs(String s, String t, double num, Map&lt;String, Map&lt;String, Double&gt;&gt; map, Set&lt;String&gt; set) {     if (!map.containsKey(s) || !set.add(s)) {       return -1;     } else if (s.equals(t)) {       return num;     } else {       Map&lt;String, Double&gt; next = map.get(s);       for (String str : next.keySet()) {         double result = this.dfs(str, t, num * next.get(str), map, set);         if (result != -1) {           return result;         }       }       return -1;     }   }  }  /**  * Your Solution object will be instantiated and called as such:  * Solution obj = new Solution(nums);  * int param_1 = obj.pick(target);  */   결과  Link   설명     쌍으로 이루어진 문자열 List인 equations과 숫자 List인 values가 주어지면, query의 계산 결과를 구하는 문제이다.            $equations[i] = [Ai, Bi]$일 때, $Ai / Bi = values[i]$를 만족한다.       $queries[j] = [Cj, Dj]$일 때, $Cj / Dj = result[i]$를 만족하는 값들을 구한다.       단, 값을 유추할 수 없는 경우 -1.0을 반환한다.                equations와 values를 엮어 저장 할 map을 HashMap으로 초기화한다.       0부터 values의 개수 이전까지 idx를 증가시키며 map에 값을 넣어준다.            equations의 idx번째 List를 equation에 임시로 넣어준다.       equations의 각 값들이 key가되는 value가 map에 존재하지 않을 경우, 새 HashMap을 넣어준다.       map에서 equation의 첫 번째 값이 key인 Map을 꺼내와서, equation의 두 번째 값과 values의 idx번째 값을 key와 value로 엮어 넣어준다.       map에서 equation의 두 번째 값이 key인 Map을 꺼내와서, equation의 첫 번째 값과 values의 idx번째 값을 1로 나눈 결과를 key와 value로 엮어 넣어준다.                결과를 저장할 result 배열을 queries의 개수의 크기로 초기화한다.       0부터 queries의 개수 이전까지 idx를 증가시키며 result에 값을 넣어준다.            queries의 idx번째 List를 query에 넣어준다.       result의 idx번째 값에 6번에서 정의한 dfs(Map&lt;String, Map&lt;String, Double» map, Set set, String q1, String q2, double num) 메서드의 수행 결과를 넣어준다.           result에 값을 넣기 위한 dfs(Map&lt;String, Map&lt;String, Double» map, Set set, String q1, String q2, double num) 메서드를 정의한다.            map에 q1이 존재하지 않거나 set에 q1이 존재하지 않는 경우 결과를 판단할 수 없으므로, -1을 반환한다.       q1과 q2가 동일한 경우 두 값의 나눈 값은 1이므로, num을 그대로 반환한다.       map에서 q1에 해당하는 Map을 next에 넣어주고 아래를 수행한다.                    next의 keySet을 str로 반복을 수행하여 str과 q2, num에 next의 str이 key인 값의 값을 가져와 곱하여 재귀 호출을 수행하여 -1이 아닌 경우, 해당 값을 반환한다.           반복이 정상적으로 완료되면 유추 가능한 값이 존재하지 않는다는 의미이므로, -1을 반환한다.                           5번의 반복이 완료되면 결과를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/evaluate-division/",
        "teaser": null
      },{
        "title": "Leetcode Java Nth Digit",
        "excerpt":"문제  Link   코드  class Solution {    public int findNthDigit(int n) {     int length = 1;     int base = 1;     while (n &gt; 9L * base * length) {       n -= 9 * base * length;       length++;       base *= 10;     }     int result = 0;     int num = (n - 1) / length + base;     for (int idx = (n - 1) % length; idx &lt; length; idx++) {       result = num % 10;       num /= 10;     }     return result;   }  }   결과  Link   설명     무한 정수 시퀀스에서 주어진 정수인 n번째 값을 반환한다.            n이 11인 경우, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, … 중 0을 반환한다.                길이를 저장하는 length와 배수를 결정하는 base에 1을 넣어 초기화한다.       n이 $9 \\times base \\times length$ 초과일 때 까지 반복하여 length와 base를 계산한다.            n에 $9 \\times base \\times length$을 빼주고, length를 1 더하고 base를 10 곱해준다.                    해당 무한 정수 시퀀스는 아래와 같은 규칙이 성립한다.           1 ~ 9 = $9 \\times 1 = 9$ 자리           10 ~ 99 = $90 \\times 2 = 180$ 자리           100 ~ 999 = $900 \\times 3 = 2700$ 자리           위 규칙을 이용하여 숫자 범위를 추정하기 위해 $9 \\times base \\times length$를 정의하고, base는 10단위, length는 1 단위로 계속 증가시킨다.                           결과를 넣을 result에 0을, 계산에 필요한 num에 $\\frac{n - 1}{length} + base$을 넣어준다.            num의 초기 값의 설정을 통해 무한 정수 시퀀스에서 n번째 위치에 포함되는 숫자를 유추한다.           $(n - 1) % length$의 결과부터 length 까지 idx를 증가시키며 result를 유추한다.            result에 num을 10으로 나눈 나머지 값을 넣어주고, num을 10으로 나누어준다.           반복이 완료되면 무한 정수 시퀀스에서 n번째 값이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/nth-digit/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Watch",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; readBinaryWatch(int turnedOn) {     List&lt;String&gt; times = new ArrayList&lt;String&gt;();     for (int hour = 0; hour &lt; 12; hour++) {       for (int minute = 0; minute &lt; 60; minute++) {         int bits = Integer.bitCount(hour) + Integer.bitCount(minute);         if (bits == turnedOn) {           times.add(this.getTime(hour, minute));         }       }     }     return times;   }    private String getTime(int hour, int minute) {     return new StringBuilder().append(hour).append(\":\").append(minute / 10).append(minute % 10).toString();   }  }   결과  Link   설명     1부터 10까지 임의의 숫자인 turnedOn이 주어지면, 바이너리 워치에서 표현 가능한 시간을 반환하는 문제이다.            바이너리 워치는 상단에 시간을 나타내는 4개(8, 4, 2, 1)의 숫자와 하단에 분을 나타내는 6개(32, 16, 8, 4, 2 , 1)의 숫자가 존재한다.       시간은 앞 자리에 0을 넣지 않고, 분은 앞 자리에 0을 넣어 시간 표현식을 만들어 준다.       예를 들어, “01:00”와 “10:2”는 유효하지 않고, “1:00”와 “10:02”는 유효하다.                결과를 넣을 times를 ArrayList로 초기화 한다.       0부터 11까지 hour를 증가시키며 반복한다.            0부터 59까지 minute를 증가시키며 반복을 수행한다.                    hour와 minute의 이진 표현에 있는 비트 수의 합이 turnedOn과 동일한 경우, hour와 minute를 주어진 시간 표현식에 맞춰 변환하여 times에 넣어준다.                           반복이 완료되면 표현 가능한 시간을 저장한 times를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-watch/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove K Digits",
        "excerpt":"문제  Link   코드  class Solution {    public String removeKdigits(String num, int k) {     char[] numCharArray = num.toCharArray();     int start = 0;     int end = 0;     for (int idx = 0; idx &lt; numCharArray.length; idx++) {       if (end &gt; 0 &amp;&amp; k &gt; 0 &amp;&amp; numCharArray[end - 1] &gt; numCharArray[idx]) {         k--;         idx--;         end--;       } else {         numCharArray[end++] = numCharArray[idx];       }     }     if (k &gt; 0) {       end -= k;     }     while (end &gt; start &amp;&amp; numCharArray[start] == '0') {       start++;     }     return start == end ? \"0\" : new String(numCharArray, start, end - start);   }  }   결과  Link   설명          숫자로 구성된 주어진 문자열 num 중 k개의 숫자를 제거하여 가장 작은 숫자를 문자열로 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            numCharArray는 num의 각 문자들을 활용하기 위한 배열로, num을 문자 배열로 변환하여 저장한다.       start는 문자열로 변환하기 위한 시작 인덱스로, 0으로 초기화한다.       end는 문자열로 변환하기 위한 종료 인덱스로, 0으로 초기화한다.           0부터 numCharArray의 길이만큼 idx를 증가시키며 반복하여 순서대로 만들 수 있는 작은 값 순으로 정렬을 수행한다.            end와 k가 0보다 크고 numCharArray의 $end - 1$번째 값이 idx번째 값보다 큰 경우, k와 idx와 end를 감소시킨다.       위의 경우가 아닌 경우, numCharArray의 end번째 자리에 idx번째 문자를 넣고 end를 증가시킨다.                k가 0보다 큰 경우 뒤의 k개는 무시해도 되는 큰 수이므로, end를 k만큼 빼준다.            end가 start보다 크고 numCharArray의 start번째 문자가 0인 경우, 숫자의 시작을 0이 아닌 숫자로 하기 위해 start를 계속 증가시킨다.       start가 end와 동일한 경우 문자열에서 포함된 숫자열이 없으므로 “0”을, 그렇지 않은 경우 numCharArray의 start부터 $end - start$까지 문자열로 변화하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-k-digits/",
        "teaser": null
      },{
        "title": "Leetcode Java Frog Jump",
        "excerpt":"문제  Link   코드  class Solution {    public boolean canCross(int[] stones) {     if (stones[1] != 1) {       return false;     }     int length = stones.length;     return this.bfs(stones, new boolean[length][length], length, 0, 1);   }    private boolean bfs(int[] stones, boolean[][] dp, int length, int last, int current) {     if (current == length - 1) {       return true;     } else if (dp[last][current]) {       return false;     } else {       int lastJump = stones[current] - stones[last];       int next = current + 1;       while (next &lt; length &amp;&amp; stones[next] &lt;= stones[current] + lastJump + 1) {         int increment = stones[next] - stones[current] - lastJump;         if (increment &gt;= -1 &amp;&amp; increment &lt;= 1 &amp;&amp; this.bfs(stones, dp, length, current, next)) {           return true;         }         next++;       }       dp[last][current] = true;       return false;     }   }  }   결과  Link   설명     주어진 정수 배열 stones는 강 위에 돌의 위치로, 해당 돌의 위치를 이용하여 강을 건널 수 있는지 검증하는 문제이다.            단, 점프는 1부터 위치에 해당하는 숫자의 위치와 해당 위치에 -1 혹은 +1 한 값으로만 이동이 가능하다.                stones의 두 번째 값이 1이 아닌 경우 처음부터 이동이 불가능하므로, false를 주어진 문제의 결과로 반환한다.            length를 stones의 길이로 저장하고, 4번에서 정의한 bfs(int[] stones, boolean[][] dp, int length, int last, int current)메서드의 결과를 주어진 문제의 결과로 반환한다.       BFS 방식으로 검증할 bfs(int[] stones, boolean[][] dp, int length, int last, int current) 메서드를 정의한다.            current와 $length - 1$이 동일한 경우 강을 건넜으므로, true를 반환한다.       dp[last][current]의 값이 true인 경우 이미 검증이 수행되어 강을 건너는데 실패한 값이므로, false를 반환한다.       그 외의 경우 아래를 통해 dp를 초기화한다.                    이전 점프 거리인 lastJump에 stones의 current번째 값과 last번째 값의 차이를 넣어준다.           다음 위치 값인 next에 $current + 1$을 넣어준다.           next가 length 미만이고, 다음 돌의 위치인 stones[next]가 최대 점프 가능한 위치인 $stones[current] + lastJump + 1$인 경우까지 반복을 계속 수행한다.                                 다음 점프의 증가분인 increment에 stones의 next번째 값과 current번째 값을 뺀 거리와 lastJum를 빼서 넣어준다.       increment가 -1 이상 1 이하의 값이고 current와 next로 재귀 호출한 결과가 true인 경우 정상적으로 점프가 되므로, true를 반환한다.       next를 증가시키고 계속 반복을 수행한다.       - 반복이 완료되면 dp[last][current]에 true를 넣어주고, false를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/frog-jump/",
        "teaser": null
      },{
        "title": "Leetcode Java Sum of Left Leaves",
        "excerpt":"문제  Link   코드  class Solution {    public int sumOfLeftLeaves(TreeNode root) {     return this.recursive(root, false);   }    private int recursive(TreeNode root, boolean isLeft) {     if (root == null) {       return 0;     } else {       if (root.left == null &amp;&amp; root.right == null) {         return isLeft ? root.val : 0;       } else {         return this.recursive(root.left, true) + this.recursive(root.right, false);       }     }   }  }   결과  Link   설명          주어진 이진 트리인 root의 좌측 노드의 합을 계산하는 문제이다.            3번에서 정의한 recursive(TreeNode root, boolean isLeft) 메서드의 결과를 주어진 문제의 결과로 반환한다.            재귀 호출을 이용하여 root의 좌측 노드의 합만 계산하기 위한 recursive(TreeNode root, boolean isLeft) 메서드를 정의한다.             root가 null인 경우 좌측 노드가 없으므로, 0을 반환한다.       root가 null이 아닌 경우, 아래를 수행한다.                    root의 left와 right 노드가 없을 경우, 해당 노드가 left 노드인 경우 root의 val 값을 아니면 0을 반환한다.           root의 left 혹은 right 노드가 있을 경우, root의 left와 right 노드를 각각 재귀 호출 수행하여 합한 값을 반환한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sum-of-left-leaves/",
        "teaser": null
      },{
        "title": "Leetcode Java Convert a Number to Hexadecimal",
        "excerpt":"문제  Link   코드  class Solution {    public String toHex(int num) {     if (num == 0) {       return \"0\";     } else {       StringBuilder sb = new StringBuilder();       while (num != 0) {         int n = num &amp; 0xf;         n += n &lt; 0xa ? '0' : 'a' - 10;         sb.append((char) n);         num &gt;&gt;&gt;= 4;       }       return sb.reverse().toString();     }   }  }   결과  Link   설명     주어진 정수 num을 이용하여 16진수 표현 문자열을 반환하는 문제이다.            답변 문자열의 모든 문자는 소문자이고, num이 0인 경우를 제외하고 문자열 내 0을 제외하고 작성한다.                num이 0인 경우, “0”을 주어진 문제의 결과로 반환한다.       num이 0이 아닌 경우, 아래를 수행한다.            16진수 표현을 저장할 sb를 StringBuilder로 초기화한다.                    동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.                       num이 0이 아닐 때 까지 아래를 반복하여 sb에 값을 넣어준다.                    n에 num과 0xf(15)의 AND(&amp;) 비트 연산 수행 결과를 넣어준다.           n에 n이 0xa(10)보다 작은 경우 0, 같거나 큰 경우 $’a’ - 10$을 더해준다.           sb에 n을 문자열로 변환한 값을 넣아주고, num의 비트를 우측으로 4칸 이동시킨다.                       16진수 표현 문자열을 역순으로 저장한 sb를 다시 반대로 전환하여 문자열로 변환 후 주어진 문제의 결과로 반환한다.                    StringBuilder의 insert(int offset, char c) 메서드는 offset까지 포인터를 이동하여 c를 삽입하고 해당 위치 값들을 뒤로 이동시키기 때문에, append(char c) 메서드와 reverse()을 활용하는 것이 시간 복잡도가 더 낮아진다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/convert-a-number-to-hexadecimal/",
        "teaser": null
      },{
        "title": "Leetcode Java Queue Reconstruction by Height",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] reconstructQueue(int[][] people) {     Arrays.sort(people, (p1, p2) -&gt; {       int val = p2[0] - p1[0];       if (val == 0) {         val = p1[1] - p2[1];       }       return val;     });     List&lt;int[]&gt; result = new ArrayList&lt;&gt;();     for (int[] p : people) {       result.add(p[1], p);     }     return result.toArray(new int[0][]);   }  }   결과  Link   설명     주어진 2차원 정수 배열인 people을 이용하여 아래의 조건을 활용하여 큐에 정렬하는 문제이다.            people[i] = [hi, ki]이며, h는 키를 k는 자신 앞에 존재하는 인원들 중 자신보다 키가 큰 인원의 수를 의미한다.       queue[j] = [hj, kj]이며, people이 j번째 큐에 존재하는 값을 의미한다.           주어진 조건에 맞게 정렬하기 위해 임의 두 값을 p1과 p2라고 정의하고 people을 정렬한다.            val에 p2의 첫 번째 값과 p1의 첫 번째 값의 차이를 넣어준다.       val이 0인 경우 동일한 키를 의미하므로, val에 p1의 두 번째 값과 p2의 두 번째 값을 뺀 값인 자신의 앞에 키가 큰 인원의 수의 차이를 넣어준다.       val이 반환된 값의 크기로 오름차순 정렬을 수행한다.                정렬된 값들을 저장할 result를 ArrayList로 초기화하고, 정렬된 people을 result의 p[1] 값 위치에 p를 넣어준다.       반복이 완료되면 reuslt를 2차원 정수 배열로 변경하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/queue-reconstruction-by-height/",
        "teaser": null
      },{
        "title": "Leetcode Java Trapping Rain Water II",
        "excerpt":"문제  Link   코드  class Solution {    public int trapRainWater(int[][] heightMap) {     int row = heightMap.length;     int col = heightMap[0].length;     int[][] volume = new int[row][col];     for (int i = 0; i &lt; row; i++) {       for (int j = 0; j &lt; col; j++) {         volume[i][j] = heightMap[i][j];       }     }     boolean update = true;     boolean init = true;     while (update) {       update = false;       for (int i = 1; i &lt; row - 1; i++) {         for (int j = 1; j &lt; col - 1; j++) {           int val = Math.max(heightMap[i][j], Math.min(volume[i - 1][j], volume[i][j - 1]));           if (init || val &lt; volume[i][j]) {             volume[i][j] = val;             update = true;           }         }       }       init = false;       for (int i = row - 2; i &gt;= 1; i--) {         for (int j = col - 2; j &gt;= 1; j--) {           int val = Math.max(heightMap[i][j], Math.min(volume[i + 1][j], volume[i][j + 1]));           if (val &lt; volume[i][j]) {             volume[i][j] = val;             update = true;           }         }       }     }     int sum = 0;     for (int i = 0; i &lt; row; i++) {       for (int j = 0; j &lt; col; j++) {         if (volume[i][j] - heightMap[i][j] &gt; 0) {           sum += (volume[i][j] - heightMap[i][j]);         }       }     }     return sum;   }  }   결과  Link   설명          주어진 2차원 정수 배열 heightMap을 이용하여 빗물을 가둘 수 있는 물의 양을 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            row는 heightMap의 행의 개수를 저장하는 변수로, heightMap.length로 초기화한다.       col은 heightMap의 열의 개수를 저장하는 변수로, heightMap[0].length로 초기화한다.       volume은 주어진 heightMap의 빗물을 가둔 후 최대 높이를 저장할 배열로, heightMap의 값으로 초기화한다.       update는 값의 수정 유무를 저장할 변수로, true로 초기화한다.       init은 첫 수행 여부를 저장할 변수로, true로 초기화한다.           update가 true일 때 까지 반복하여 아래를 수행한다.            update를 false로 수정하여 수정 내역이 없는 상태로 초기화한다.       heightMap을 행과 열을 1부터 row와 col의 값보다 1 작게 반복하여 아래를 수행한다.                    val에 volume[i - 1][j]의 값과 volume[i][j - 1]의 값 중 작은 값하고 heightMap[i][j]의 값 중 큰 값을 넣어준다.           첫 수행이거나 val이 volume[i][j]보다 작아 물을 담을 높이보다 큰 경우, volume[i][j]에 val 값을 넣어 평준화 시키고 update를 true로 바꾸어 수정한 상태로 바꾸어준다.                       첫 수행이 완료되었으므로, init을 false로 바꾸어준다.       heightMap을 행과 열을 row와 col의 값보다 2 작은 값에서 1까지 반복하여 아래를 수행한다.                    val에 volume[i + 1][j]의 값과 volume[i][j + 1]의 값 중 작은 값하고 heightMap[i][j]의 값 중 큰 값을 넣어준다.           val이 volume[i][j]의 값보다 작아 물을 담을 높이보다 큰 경우, volume[i][j]에 val 값을 넣어 평준화 시키고 update를 true로 바꾸어 수정한 상태로 바꾸어준다.                                반복이 완료되면 빗물을 가둘 수 있는 물의 양을 저장할 sum을 0으로 초기화시킨다.            volume을 반복하여 heightMap과 각 위치의 차이 값이 volume이 더 큰 경우, sum에 volume의 값과 heightMap의 값의 차이를 더해준다.       위의 반복이 완료되면 빗물을 가둘 수 있는 물의 양을 저장한 sum을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/trapping-rain-water-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Palindrome",
        "excerpt":"문제  Link   코드  class Solution {    public int longestPalindrome(String s) {     int[] count = new int[58];     for (char c : s.toCharArray()) {       count[c - 'A']++;     }     int length = 0;     boolean isOdd = false;     for (int idx = 0; idx &lt; 58; idx++) {       length += count[idx];       if (count[idx] % 2 == 1) {         length--;         isOdd = true;       }     }     return length + (isOdd ? 1 : 0);   }  }   결과  Link   설명     주어진 문자열 s를 이용하여 만들 수 있는 가장 긴 회문을 만드는 문제이다.            단, 대소문자를 구분하므로 “Aa”는 회문이 되지 않는다.                count를 대문자 A부터 소문자 z까지 ASCII 코드의 길이인 58 크기로 초기화 하고, s의 각 문자의 발생 개수를 count에 넣어준다.            가장 킨 회문의 길이를 저장할 length를 0으로, 해당 회문의 길이가 홀수인지 저장할 isOdd를 false로 초기화한다.       0부터 58까지 idx를 증가시키며 가장 긴 회문의 길이를 저장한다.            length에 count의 idx번째 값을 더해준다.       count의 idx번째 값이 홀수인 경우, length를 감소시키고 isOdd를 true로 변경한다.                    회문의 길이가 짝수인 경우, 모든 문자의 발생 횟수는 짝수로 존재하여야 한다.                           반복이 완료되면 isOdd가 true로 홀수인 경우 length에 1을 더해서, 짝수인 경우 length를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-palindrome/",
        "teaser": null
      },{
        "title": "Leetcode Java Split Array Largest Sum",
        "excerpt":"문제  Link   코드  class Solution {    public int splitArray(int[] nums, int m) {     int max = 0;     int sum = 0;     for (int num : nums) {       max = Math.max(max, num);       sum += num;     }     while (max &lt; sum) {       int mid = max + (sum - max) / 2;       if (this.isValid(nums, m, mid)) {         sum = mid;       } else {         max = mid + 1;       }     }     return max;   }    private boolean isValid(int[] nums, int m, int mid) {     int sum = 0;     int count = 1;     for (int num : nums) {       sum += num;       if (sum &gt; mid) {         count++;         sum = num;         if (count &gt; m) {           return false;         }       }     }     return true;   }  }   결과  Link   설명     주어진 정수 배열 nums를 이용하여 아래의 조건을 만족하는 부분 배열 내 가장 큰 값을 구하는 문제이다.            nums를 m개의 부분 배열로 분리하는 여러 경우 중 부분 배열의 합이 최대인 값이 최소가 되는 경우를 구한다.       모든 부분 배열은 비어있지 않아야 한다.                nums 배열의 가장 큰 값을 max에, 모든 값의 합을 sum에 정의한다.       max가 sum보다 작을 때 까지 반복한다.            최댓값의 상한을 정하는 mid에 $max + \\frac{sum - max}{2}$의 값을 넣어준다.       4번에서 정의한 isValid(int[] nums, int m, int mid) 메서드의 수행 결과에 따라 아래를 수행한다.                    결과가 true인 경우 부분 배열로 분리할 수 있으므로, sum에 mid 값을 넣어 최댓값의 상한 축소시킨다.           결과가 false인 경우 부분 배열로 분리할 수 없으므로, max에 $mid + 1$의 값을 최댓값의 상한을 확장시킨다.                           부분 배열롤 분리할 수 있는지 여부를 판단하기 위한 isValid(int[] nums, int m, int mid) 메서드를 완성한다.            문제 풀이에 필요한 변수를 정의한다.                    sum은 부분 배열의 합계를 계산하기 위한 변수로, 0으로 초기화한다.           count는 부분 배열의 개수를 계산하기 위한 변수로, 1로 초기화한다.                       nums를 처음부터 끝까지 반복한다.                    sum에 num을 더해주고, sum이 mid보다 큰 경우 부분 배열 분리가 가능하므로 아래를 수행한다.                                 count를 증가시켜 부분 배열의 개수를 추가한다.       sum에 num을 넣어 부분 배열의 값을 초기화 시킨다.       만일 count가 m보다 큰 경우 목표하고자 하는 부분 배열의 크기를 초과하였으므로, false를 반환한다.     - 반복이 완료되면 목표하고자 하는 부분 배열의 크기를 만족하는 분리가 가능하므로, true를 반환한다.           3번의 반복이 완료되면 요구 조건을 만족하는 부분 배열 내 가장 큰 값을 저장한 max를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/split-array-largest-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Fizz Buzz",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; fizzBuzz(int n) {     List&lt;String&gt; result = new ArrayList&lt;&gt;();     for (int idx = 1; idx &lt;= n; idx++) {       if (idx % 15 == 0) {         result.add(\"FizzBuzz\");       } else if (idx % 3 == 0) {         result.add(\"Fizz\");       } else if (idx % 5 == 0) {         result.add(\"Buzz\");       } else {         result.add(String.valueOf(idx));       }     }     return result;   }  }   결과  Link   설명     1부터 주어진 정수 n까지 아래의 규칙대로 결과를 만들어 반환하는 문제이다.            3과 5의 배수인 경우, answer[i]에 “FizzBuzz”를 넣어준다.       3의 배수인 경우, answer[i]에 “Fizz”를 넣어준다.       5의 배수인 경우, answer[i]에 “Buzz”를 넣어준다.       그 외의 경우, answer[i]에 위치 값인 i를 문자열로 넣어준다.                결과를 넣을 result를 ArrayList로 초기화 한다.       1부터 n까지 반복하여 result에 문자열을 넣어준다.            3과 5의 배수인 15의 배수인 경우 “FizzBuzz”를 넣어준다.       3의 배수는 “Fizz”를, 5의 배수는 “Buzz”를 넣어준다.       그 외는 위치 값인 idx를 문자열로 변환하여 넣어준다.           반보이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/fizz-buzz/",
        "teaser": null
      },{
        "title": "Leetcode Java Arithmetic Slices",
        "excerpt":"문제  Link   코드  class Solution {    public int numberOfArithmeticSlices(int[] nums) {     int number = 0;     int count = 0;     for (int idx = 2; idx &lt; nums.length; idx++) {       if (nums[idx] - nums[idx - 1] == nums[idx - 1] - nums[idx - 2]) {         count++;         number += count;       } else {         count = 0;       }     }     return number;   }  }   결과  Link   설명          주어진 정수 배열인 num을 이용하여 최소 3개 이상의 연속된 숫자의 차이가 동일한 부분 배열을 만들 수 있는 최대 부분 배열의 개수를 산정하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            number는 최소 3개 이상의 연속된 숫자의 차이가 동일한 부분 배열의 개수를 저장하는 변수로, 0으로 초기화한다.                    간단히 [1, 2, 3, 4]의 경우 아래의 예제이다.                                 첫 번째 수행에 부분 배열인 [1, 2, 3]을 만들 수 있으므로 1개이다.       두 번쨰 수행에 부분 배열인 [2, 3, 4]를 만들 수 있고, 첫 번째 수행에 이어지므로 [1, 2, 3, 4]의 부분 배열도 생성이 가능하므로 2개가 된다.       위의 수행으로 총 3개의 부분 배열을 생성 할 수 있다.     - count는 연속된 숫자의 차이가 동일한 경우 만들 수 있는 부분 배열의 개수를 임시 산정하는 변수로, 0으로 초기화한다.           2부터 nums의 길이만큼 idx를 증가시키며 아래를 수행한다.            nums의 현재 위치와 그 전 위치의 값의 차이가 그 전 위치와 그 전의 전 위치의 값의 차이가 동일한 경우 최소 3개 이상의 연속된 숫자의 차이가 동일하므로, count를 증가시키고 number에 count를 더해준다.       그렇지 않은 경우, 연속되지 않으므로 count를 초기화 시킨다.           반복이 완료되면 최소 3개 이상의 연속된 숫자의 차이가 동일한 부분 배열을 만들 수 있는 최대 부분 배열의 개수인 number를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/arithmetic-slices/",
        "teaser": null
      },{
        "title": "Leetcode Java Third Maximum Number",
        "excerpt":"문제  Link   코드  class Solution {    public int thirdMax(int[] nums) {     long[] memory = new long[] { Long.MIN_VALUE, Long.MIN_VALUE, Long.MIN_VALUE };     for (int num : nums) {       if (num &gt; memory[0]) {         memory[2] = memory[1];         memory[1] = memory[0];         memory[0] = num;       } else if (num &lt; memory[0] &amp;&amp; num &gt; memory[1]) {         memory[2] = memory[1];         memory[1] = num;       } else if (num &lt; memory[1] &amp;&amp; num &gt; memory[2]) {         memory[2] = num;       }     }     return (int) (memory[2] == Long.MIN_VALUE ? memory[0] : memory[2]);   }  }   결과  Link   설명     주어진 정수 배열 nums가 주어지면 중복되지 않은 세 번째 최댓값을 반환하는 문제이다.            세 번째 최댓값이 없는 경우, 최댓값을 반환한다.                가장 큰 세 값을 저장하기 위한 memory를 overflow를 방지하기 위해 long 형의 배열로 정의하고, 각 자리에 Long의 가장 작은 값을 넣어준다.       nums의 모든 값을 반복하여 memory에 값을 넣어준다.            num이 memory의 첫 번째 값보다 큰 경우, memory의 모든 값을 다음 위치로 이동시키고 첫 번째 자리에 num을 넣어준다.       num이 memory의 첫 번째 값보다 작고 두 번째 값보다 큰 경우, memory의 두 번째 값부다 다음 위치로 이동시키고 두 번째 자리에 num을 넣어준다.       num이 memory의 두 번째 값보다 작고 세 번째 값보다 큰 경우, memory의 세 번째 값에 num을 넣어준다.           memory의 세 번째 값이 초기값인지를 검증하여 아래를 수행한다.            위의 경우가 초기값인 경우, memory의 첫 값인 최댓 값을 int형으로 변환하여 주어진 문제의 결과로 반환한다.       위의 경우가 초기값이 아닌 경우, memory의 세 번째 값인 세 번째로 가장 큰 값을 int형으로 변환하여 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/third-maximum-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Add Strings",
        "excerpt":"문제  Link   코드  class Solution {    public String addStrings(String num1, String num2) {     StringBuilder sb = new StringBuilder();     int num1Length = num1.length() - 1;     int num2Length = num2.length() - 1;     int carry = 0;     while (num1Length &gt;= 0 || num2Length &gt;= 0) {       int n1 = num1Length &gt;= 0 ? num1.charAt(num1Length--) - '0' : 0;       int n2 = num2Length &gt;= 0 ? num2.charAt(num2Length--) - '0' : 0;       sb.append((n1 + n2 + carry) % 10);       carry = (n1 + n2 + carry) / 10;     }     if (carry &gt; 0) {       sb.append(carry);     }     return sb.reverse().toString();   }  }   결과  Link   설명          주어진 두 문자열 num1과 num2은 숫자를 문자로 저장한 변수들로, 두 값의 합을 문자열로 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            sb는 두 값의 합을 넣기 위한 변수로, StringBuilder로 정의한다.                    동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.                       num1Length와 num2Length는 num1과 num2의 마지막 위치를 커서처럼 사용하기 위한 변수로, 각 길이의 1을 뺀 값으로 넣어준다.       carry는 두 값의 합이 10을 넘길 경우 다음 위치 값의 합에 더해줄 변수로, 0으로 초기화한다.           num1Length와 num2Length 둘 중 하나라도 0보다 큰 경우 아래를 반복한다.            num1Length가 0보다 큰 경우, n1에 num1의 num1Length번째 값을 넣고 아니면 0을 넣어준 후 num1Length를 감소시킨다.       num2Length가 0보다 큰 경우, n2에 num2의 num2Length번째 값을 넣고 아니면 0을 넣어준 후 num2Length를 감소시킨다.       sb에 $n1 + n2 + carry$의 1자리 값을 넣어준다.       carry에 $n1 + n2 + carry$의 10자리 값을 넣어준다.                반복이 완료되면 carry가 0보다 큰 경우, sb에 carry를 넣어준다.       역순으로 합을 계산하였으므로, sb를 reverse() 메소드를 사용하여 반전시킨 후 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/add-strings/",
        "teaser": null
      },{
        "title": "Leetcode Java Partition Equal Subset Sum",
        "excerpt":"문제  Link   코드  class Solution {    public boolean canPartition(int[] nums) {     int sum = 0;     for (int num : nums) {       sum += num;     }     if ((sum &amp; 1) &gt; 0) {       return false;     }     int target = sum / 2;     return this.dfs(nums, new boolean[target + 1], 0, target);   }    private boolean dfs(int[] nums, boolean[] dp, int index, int target) {     if (index &gt;= nums.length) {       return false;     } else if (nums[index] == target) {       return true;     } else {       int num = target - nums[index];       if (num &gt; 0 &amp;&amp; !dp[num]) {         dp[num] = true;         return this.dfs(nums, dp, index + 1, num) || this.dfs(nums, dp, index + 1, target);       } else {         return this.dfs(nums, dp, index + 1, target);       }     }   }  }   결과  Link   설명          비어있지 않은 주어진 양의 정수 배열 nums를 이용하여 합이 동일한 두 부분 배열로 나눌 수 있는지 검증하는 문제이다.            sum에 nums의 모든 값을 더해 넣어준다.            sum과 1의 AND(&amp;) 비트 연산 수행 결과가 0 이상인 sum이 홀수인 경우 두 값을 균일하게 나눌 수 없으므로, false를 반환한다.            target에 $\\frac{sum}{2}$의 결과를 넣어주고, 5번에서 정의한 dfs(int[] nums, boolean[] dp, int index, int target) 함수를 dp에 $target + 1$ 크기의 부울 배열과 index는 0, target에 target을 이용하여 수행한 결과를 주어진 문제의 결과로 반환한다.            DFS 방식으로 결과를 탐색할 dfs(int[] nums, boolean[] dp, int index, int target) 메서드를 정의한다.             index가 nums의 길이보다 크거나 같은 경우 균일한 두 값으로 나눌 수 없으므로, false를 반환한다.       nums[index] 값이 target과 동일한 경우, true를 반환한다.       그 외의 경우 아래를 수행한다.                    num에 target과 nums의 index번째 값의 차이를 넣어준다.           num이 0보다 크고 dp의 num번째 자리가 false인 경우, dp의 num번째 값을 true로 바꾸고 index를 1 증가시키고 target에 num을 넣은 재귀 호출 결과와 index를 1 증가시킨 재귀 호출 결과의 OR 조건 결과를 반환한다.           위의 경우가 아니면, index를 1 증가시킨 재귀 호출 결과를 반환한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/partition-equal-subset-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Pacific Atlantic Water Flow",
        "excerpt":"문제  Link   코드  class Solution {    private List&lt;List&lt;Integer&gt;&gt; result;   private boolean[][] pacific;   private boolean[][] atlantic;    public List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(int[][] heights) {     int row = heights.length;     int col = heights[0].length;     this.result = new ArrayList&lt;&gt;();     this.pacific = new boolean[row][col];     this.atlantic = new boolean[row][col];     for (int idx = 0; idx &lt; row; idx++) {       this.dfs(heights, this.pacific, idx, 0, row, col);       this.dfs(heights, this.atlantic, idx, col - 1, row, col);     }     for (int idx = 0; idx &lt; col; idx++) {       this.dfs(heights, this.pacific, 0, idx, row, col);       this.dfs(heights, this.atlantic, row - 1, idx, row, col);     }     return this.result;   }    private void dfs(int[][] heights, boolean[][] visit, int i, int j, int row, int col) {     if (visit[i][j]) {       return;     }     visit[i][j] = true;     if (this.pacific[i][j] &amp;&amp; this.atlantic[i][j]) {       List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();       temp.add(i);       temp.add(j);       this.result.add(temp);     }     if (i + 1 &lt; row &amp;&amp; heights[i + 1][j] &gt;= heights[i][j]) {       this.dfs(heights, visit, i + 1, j, row, col);     }     if (i - 1 &gt;= 0 &amp;&amp; heights[i - 1][j] &gt;= heights[i][j]) {       this.dfs(heights, visit, i - 1, j, row, col);     }     if (j + 1 &lt; col &amp;&amp; heights[i][j + 1] &gt;= heights[i][j]) {       this.dfs(heights, visit, i, j + 1, row, col);     }     if (j - 1 &gt;= 0 &amp;&amp; heights[i][j - 1] &gt;= heights[i][j]) {       this.dfs(heights, visit, i, j - 1, row, col);     }     return;   }  }   결과  Link   설명          Pacific과 Atlantic 해안을 인접하고 있는 섬의 높이를 나타내는 heights가 주어지면, 빗물이 올 경우 두 해안으로 흐를 수 있는 경계가 되는 구간을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            row는 heights 배열 내 행의 개수를 저장할 변수로, heights의 행의 개수로 초기화한다.       col은 heights 배열 내 열의 개수를 저장할 변수로, heights의 첫 행의 열 개수로 초기화한다.       result는 결과를 저장할 List로, 새 ArrayList로 정의한다.       pacific은 Pacific 해안으로 빗물이 흐를 가능성이 있는지 저장할 배열로, heights와 동일한 크기로 초기화한다.       atlantic은 Atlantic 해안으로 빗물이 흐를 가능성이 있는지 저장할 배열로, heights와 동일한 크기로 초기화한다.                0부터 row의 크기 전까지 증가시키며 5번에서 정의한 dfs(int[][] heights, boolean[][] visit, int i, int j, int row, int col) 메서드를 pacific은 (idx, j)로 atlantic은 (idx, $col - 1$)로 수행한다.            0부터 col의 크기 전까지 증가시키며 5번에서 정의한 dfs(int[][] heights, boolean[][] visit, int i, int j, int row, int col) 메서드를 pacific은 (0, idx)로 atlantic은 ($row - 1$, idx)로 수행한다.       DFS 방식으로 문제를 해결할 dfs(int[][] heights, boolean[][] visit, int i, int j, int row, int col) 메서드를 정의한다.            visit[i][j]가 true인 경우 이전에 수행된 위치이므로, 수행을 그만한다.       visit[i][j]에 true를 넣어 수행 여부를 체크해둔다.       pacific[i][j]의 값이 true이고 atlantic[i][j]의 값이 true인 경우 양 해안가로 빗물이 흐를 수 있으므로, i와 j를 새 ArrayList에 넣어 result에 추가한다.       $i + 1$이 row보다 작고 heights[$i + 1$][j]의 값이 heights[i][j]의 값보다 크거나 같은 경우, i를 증가시키고 dfs 메서드를 수행하여 배열의 위에서 아래로 가장 높은 지역을 탐색한다.       $i - 1$이 0보다 크고 heights[$i - 1$][j]의 값이 heights[i][j]의 값보다 크거나 같은 경우, i를 감소시키고 dfs 메서드를 수행하여 배열의 아래에서 위로 가장 높은 지역을 탐색한다.       $j + 1$이 col보다 작고 heights[i][$j + 1$]의 값이 heights[i][j]의 값보다 크거나 같은 경우, j를 증가시키고 dfs 메서드를 수행하여 배열의 좌측에서 우측으로 가장 높은 지역을 탐색한다.       $j - 1$이 0보다 크고 heights[i][$j - 1$]의 값이 heights[i][j]의 값보다 크거나 같은 경우, j를 감소시키고 dfs 메서드를 수행하여 배열의 우측에서 좌측으로 가장 높은 지역을 탐색한다.           반복이 완료하여 result에 경계의 위치 값을 다 넣었으면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/pacific-atlantic-water-flow/",
        "teaser": null
      },{
        "title": "Leetcode Java Battleships in a Board",
        "excerpt":"문제  Link   코드  class Solution {    public int countBattleships(char[][] board) {     int row = board.length;     int col = board[0].length;     int count = 0;     for (int i = 0; i &lt; row; i++) {       for (int j = 0; j &lt; col; j++) {         if (board[i][j] == '.' || (i &gt; 0 &amp;&amp; board[i - 1][j] == 'X') || (j &gt; 0 &amp;&amp; board[i][j - 1] == 'X')) {           continue;         }         count++;       }     }     return count;   }  }   결과  Link   설명     주어진 2차원 배열인 board는 해양 위의 전함의 위치를 ‘X’로 표시되어 있어, 해당 전함의 수를 계산하는 문제이다.            단, 전함은 $1 \\times k$ 혹은 $k \\times 1$ 크기로 존재하며 인접한 전함은 없다고 가정한다.           문제 풀이에 필요한 변수를 정의한다.            row는 board 행의 수를 저장하기 위한 변수로, board의 길이로 초기화한다.       col은 board 열의 수를 저장하기 위한 변수로, board[0]의 길이로 초기화한다.       count는 전함의 수를 저장하기 위한 변수로, 0으로 초기화한다.           board 배열을 첫 셀에서 마지막 셀까지 반복하여 아래를 수행한다.            아래의 경우 개수 산정에 의미가 없으므로 무시하고 계속 수행한다.                    board[i][j]가 ‘.’이면 비어있으므로 개수 산정에서 제외한다.           i가 0보다 큰 상황에서 좌측 셀의 값이 ‘X’인 경우 $k \\times 1$ 크기의 전함이므로 개수 산정에서 제외한다.           j가 0보다 큰 상황에서 아래 셀의 값이 ‘x’인 경우 $1 \\times k$ 크기의 전함이므로 개수 산정에서 제외한다.                       위의 경우를 제외하면 전함이 새로 발견되었으므로 count를 증가시킨다.           반복이 완료되면 전함의 개수인 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/battleships-in-a-board/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum XOR of Two Numbers in an Array",
        "excerpt":"문제  Link   코드  class Solution {    public int findMaximumXOR(int[] nums) {     int result = 0;     int mask = 0;     int max = 0;     for (int num : nums) {       max = Math.max(max, num);     }     Set&lt;Integer&gt; set = new HashSet&lt;&gt;();     for (int idx = 31 - Integer.numberOfLeadingZeros(max); idx &gt;= 0; idx--) {       set.clear();       int bit = 1 &lt;&lt; idx;       mask |= bit;       int maxBit = result | bit;       for (int num : nums) {         int temp = num &amp; mask;         if (set.contains(temp ^ maxBit)) {           result = maxBit;           break;         }         set.add(temp);       }     }     return result;   }  }   결과  Link   설명          주어진 nums를 이용하여 nums 내 임의 두 값의 XOR 연산의 결과가 가장 큰 값을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 XOR 연산의 결과가 가장 큰 값을 넣을 변수로, 0으로 초기화한다.       mask는 비트를 마스킹하기 위한 변수로, 0으로 초기화한다.       max는 nums 배열 내 최댓값을 넣기 위한 변수로, nums 배열을 순회하여 최댓값을 넣어준다.       set은 XOR의 최댓값이 되는 값을 구하기 위해 임시로 값을 넣을 변수로, HashSet으로 정의한다.           31에서 max의 비트 값에서 맨 처음 1이 나온 위치 앞의 0의 개수를 빼준 값부터 0 이상까지 idx를 감소시키며 반복한다.            해당 최댓값을 이용하여 비트 연산을 수행할 결우 overflow되는 부분을 배제하고 탐색하기 위해서 해당 자릿수 만큼 제거하고 수행한다.       set을 초기화하고, bit에 1을 좌측으로 idx번 이동시킨 값을 넣어준다.       mask에 mask와 bit의 OR(|) 비트 연산의 수행 결과를 넣어준다.       maxBit에 result와 bit의 OR(|) 비트 연산의 수행 결과를 넣어준다.       nums를 반복하여 아래를 수행한다.                    temp에 num과 mask의 AND(&amp;) 비트 연산의 수행 결과를 넣어준다.           temp와 maxBit의 XOR(^) 비트 연산의 수행결과가 set에 존재하면, 최댓값인 maxBit를 result에 넣어 반복을 종료한다.           위를 수행하고 set에 temp를 넣어주고 반복을 계속 수행한다.                           반복을 수행하여 nums 내 임의 두 값의 XOR 연산의 결과가 가장 큰 값을 넣은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-xor-of-two-numbers-in-an-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Reconstruct Original Digits from English",
        "excerpt":"문제  Link   코드  class Solution {    public String originalDigits(String s) {     char[] charCount = new char['a' + 26];     for (char c : s.toCharArray()) {       charCount[c]++;     }     int[] count = new int[10];     count[0] = charCount['z'];     count[2] = charCount['w'];     count[4] = charCount['u'];     count[6] = charCount['x'];     count[8] = charCount['g'];     count[3] = charCount['h'] - count[8];     count[5] = charCount['f'] - count[4];     count[7] = charCount['s'] - count[6];     count[9] = charCount['i'] - count[6] - count[5] - count[8];     count[1] = charCount['n'] - count[7] - (2 * count[9]);     StringBuilder sb = new StringBuilder();     for (int i = 0; i &lt; 10; i++) {       for (int j = 0; j &lt; count[i]; j++) {         sb.append(i);       }     }     return sb.toString();   }  }   결과  Link   설명          주어진 문자열 s가 주어지면 해당 문자열 기반으로 영문 숫자를 만들 수 있는 숫자들을 오름차순으로 변환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            charCount는 문자열 s에 포함된 영문자의 개수를 저장할 변수로, ‘a’의 ASCII 코드 값에 ‘z’까지 넣기 위해 26을 더해서 정의하고 문자열 s를 반복하여 영문자의 개수를 넣어준다.       count는 생성 가능한 0부터 9까지의 숫자 개수를 저장하기 위한 변수로, 숫자의 개수인 10 크기로 초기화한다.           생성 가능한 숫자를 count 배열에 추가한다.            0 ~ 9 까지 영문자 중 고유하게 생성 가능한 영문자들의 개수를 먼저 센다.       간단히 0 ~ 9 까지 숫자를 영문자로 변환해보면 아래와 같다.                                                       0               zero                                         1               one                                         2               two                                         3               three                                         4               four                                         5               five                                         6               six                                         7               seven                                         8               eight                                         9               nine                                               zero, two, four, six, eight는 다른 숫자의 영문자 내 포함되지 않으므로 count의 각 숫자 위치에 charCount에서 굵은 영문자에 해당하는 ASCII 코드 값의 위치 값을 넣어준다.       그 다음 계산이 필요한 항목들을 아래와 같이 계산한다.                    three의 경우, eight가 존재하기 때문에 count[3]에 charCount에서 ‘h’의 ASCII 코드 값의 위치 값인 charCount[‘h’]에 count[8]을 뺀 값을 넣어준다.           five의 경우, four가 존재하기 때문에 count[5]에 charCount에서 ‘f’의 ASCII 코드 값의 위치 값인 charCount[‘f’]에 count[4]을 뺀 값을 넣어준다.           seven의 경우, six가 존재하기 때문에 count[7]에 charCount에서 ‘s’의 ASCII 코드 값의 위치 값인 charCount[’s’]에 count[6]을 뺀 값을 넣어준다.           nine의 경우, five와 six, eight가 존재하기 때문에 count[9]에 charCount에서 ‘i’의 ASCII 코드 값의 위치 값인 charCount[‘i’]에 count[5], count[6], count[8]의 값들을 빼준다.           one의 경우, seven과 nine이 존재하기 때문에 count[1]에 charCount에서 ‘n’의 ASCII 코드 값의 위치 값인 charCount[‘n’]에 count[7]의 값을 빼고 9에는 n이 2개 들어가므로 count[9]는 2배로 빼준다.                           숫자를 오름차순 문자열로 만들어 생성하기위한 sb를 StringBuilder로 초기화한다.            동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.           0부터 9까지 i를 증가시키며 반복한다.            0부터 count[i]의 값까지 j를 증가시키며, sb에 j의 수만큼 반복하여 i를 넣어준다.           반복이 완료되면 문자열 s를 오름차순의 숫자를 이어준 sb를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reconstruct-original-digits-from-english/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Repeating Character Replacement",
        "excerpt":"문제  Link   코드  class Solution {    public int characterReplacement(String s, int k) {     int[] chars = new int[26];     int max = 0;     int maxLength = 0;     int start = 0;     int length = s.length();     char[] charArray = s.toCharArray();     for (int idx = 0; idx &lt; length; idx++) {       int num = charArray[idx] - 'A';       chars[num]++;       if (chars[num] &gt; max) {         max = chars[num];       }       while (idx - start + 1 &gt; max + k) {         chars[charArray[start] - 'A']--;         start++;       }       maxLength = Math.max(maxLength, idx - start + 1);     }     return maxLength;   }  }   결과  Link   설명     문자열 s가 주어지면 k개의 문자를 변환하여 동일한 알파벳을 최대 몇 개까지 연속해서 구성할 수 있는지 탐색하는 문제이다.            단, 모든 문자는 영 대문자로 이루어져있다.           문제 풀이에 필요한 변수를 정의한다.            chars는 알파벳을 임시 저장하기 위한 변수로, 영문자의 개수인 26의 크기로 초기화한다.       max는 해당 영문자의 개수를 저장할 변수로, 0으로 초기화한다.       maxLength는 동일한 영문자로 구성한 최대 길이를 저장할 변수로, 0으로 초기화한다.       start는 동일 영문자로 구성하기 위한 시작 위치를 저장할 변수로, 0으로 초기화한다.       length는 문자열 s의 길이를 저장할 변수로, s의 길이로 초기화한다.       charArray는 문자열 s를 문자 배열로 변환하여 저장할 변수로, s를 문자의 배열로 변환하여 초기화한다.           0부터 length까지 idx를 증가시키며 아래를 수행한다.            num에 idx번째 문자를 0(‘A’) ~ 25(‘Z’)까지 변환하여 넣어준다.       chars의 num번째 값을 증가시킨다.       chars의 num번째 값이 max보다 큰 경우, max에 chars의 num번째 값을 넣어준다.       연속된 문자열의 길이인 $idx - start + 1$의 값이 $max + k$보다 큰 경우, charArray의 start번째 문자를 0(‘A’) ~ 25(‘Z’)까지 변환한 값을 이용하여 chars의 해당 위치의 값을 감소시키고 시작 위치인 start를 증가시킨다.       maxLength에 maxLength와 $idx - start + 1$의 값 중 큰 값을 넣어준다.           반복이 완료되면 최대 길이를 저장한 maxLength를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-repeating-character-replacement/",
        "teaser": null
      },{
        "title": "Leetcode Java Construct Quad Tree",
        "excerpt":"문제  Link   코드  /* // Definition for a QuadTree node. class Node {     public boolean val;     public boolean isLeaf;     public Node topLeft;     public Node topRight;     public Node bottomLeft;     public Node bottomRight;           public Node() {         this.val = false;         this.isLeaf = false;         this.topLeft = null;         this.topRight = null;         this.bottomLeft = null;         this.bottomRight = null;     }          public Node(boolean val, boolean isLeaf) {         this.val = val;         this.isLeaf = isLeaf;         this.topLeft = null;         this.topRight = null;         this.bottomLeft = null;         this.bottomRight = null;     }          public Node(boolean val, boolean isLeaf, Node topLeft, Node topRight, Node bottomLeft, Node bottomRight) {         this.val = val;         this.isLeaf = isLeaf;         this.topLeft = topLeft;         this.topRight = topRight;         this.bottomLeft = bottomLeft;         this.bottomRight = bottomRight;     } }; */  class Solution {    public Node construct(int[][] grid) {     return this.recursive(grid, 0, grid.length - 1, 0, grid[0].length - 1);   }    private Node recursive(int[][] grid, int left, int right, int top, int bottom) {     if ((left == right &amp;&amp; top == bottom) || this.areSameValues(grid, left, right, top, bottom)) {       return new Node(grid[left][top] == 0 ? false : true, true);     }     int rowMid = (left + right) / 2;     int colMid = (top + bottom) / 2;     return new Node(false, false,         this.recursive(grid, left, rowMid, top, colMid),         this.recursive(grid, left, rowMid, colMid + 1, bottom),         this.recursive(grid, rowMid + 1, right, top, colMid),         this.recursive(grid, rowMid + 1, right, colMid + 1, bottom));   }    private boolean areSameValues(int[][] grid, int left, int right, int top, int bottom) {     int value = grid[left][top];     for (int i = left; i &lt;= right; i++) {       for (int j = top; j &lt;= bottom; j++) {         if (grid[i][j] != value) {           return false;         }       }     }     return true;   }  }   결과  Link   설명     2차원 정수 배열 grid가 주어지면 해당 배열의 값을 쿼드 트리로 표현할 경우의 루트 노드를 반환하는 문제이다.            쿼드 트리는 내부에 4개의 하위 트리가 있는 데이터 구조이다.       val은 노드가 1의 그리드를 나타내면 true이고, 0의 그리드를 나타내면 false로 표현한다.       isLeaf는 루트 노드인 경우 false이고, 자식 노드인 경우 true로 표현한다.       쿼드 트리를 만드는 방법은 간단히 아래와 같다.                    전체 영역을 2차원 배열을 4등분 한다.           영역이 동일한 값으로 구성되어 있으면 자식 노드가 없는 노드로 구성한다.           영역이 동일한 값으로 구성되어 있지 않으면 맨 위로 돌아가 해당 영역으로 축소하고 쿼드 트리를 구성한다.                                3번에서 정의한 recursive(int[][] grid, int left, int right, int top, int bottom) 메서드를 첫 셀부터 끝 셀까지 위치 값을 넣어 수행한 결과의 노드를 주어진 문제의 결과로 반환한다.       재귀 호출을 활용하여 루트 노드를 만들 recursive(int[][] grid, int left, int right, int top, int bottom) 메서드를 정의한다.            left와 right가 동일하고 top과 bottom이 동일하거나 4번에서 정의한 areSameValues(int[][] grid, int left, int right, int top, int bottom) 메서드의 결과가 true인 경우 자식 노드이므로, grid[left][top]이 0인지 여부를 val에 isLeaf는 true로 새 Node를 정의하여 반환한다.       rowMid에 left와 right의 중앙값인 $\\frac{left + right}{2}$를, colMid에 top과 bottom의 중앙값인 $\\frac{top + bottom}{2}$를 넣어준다.       새 노드를 value와 isLeaf를 false로 하고 아래의 각 자식 노드를 넣어 반환한다.                    topLeft에 right에 rowMid를, bottom에 colMid를 넣어 재귀 호출을 수행한 결과를 넣어준다.           topRight에 right에 rowMid를, top에 $colMid + 1$을 넣어 재귀 호출을 수행한 결과를 넣어준다.           bottomLeft left에 $rowMid + 1$을, bottom에 colMid를 넣어 재귀 호출을 수행한 결과를 넣어준다.           bottomRight left에 $rowMid + 1$을, top에 $colMid + 1$을 넣어 재귀 호출을 수행한 결과를 넣어준다.                           특정 구간의 값들이 동일한지를 검증하기 위해 areSameValues(int[][] grid, int left, int right, int top, int bottom) 메서드를 정의한다.            value에 gird[left][top] 값을 임의 저장하고, 모든 값이 동일하면 ture를 동일하지 않으면 false를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/construct-quad-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java N-ary Tree Level Order Traversal",
        "excerpt":"문제  Link   코드  /* // Definition for a Node. class Node {     public int val;     public List&lt;Node&gt; children;      public Node() {}      public Node(int _val) {         val = _val;     }      public Node(int _val, List&lt;Node&gt; _children) {         val = _val;         children = _children;     } }; */  class Solution {   public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) {     List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();     if (root != null) {       this.recursive(root, list, 0);     }     return list;   }    private void recursive(Node root, List&lt;List&lt;Integer&gt;&gt; list, int level) {     if (list.size() &lt;= level) {       list.add(new ArrayList&lt;&gt;());     }     list.get(level).add(root.val);     for (Node node : root.children) {       this.recursive(node, list, level + 1);     }   } }   결과  Link   설명          주어진 Node가 주어지면 level 별 val 값을 묶어서 반환하는 문제이다.            결과를 담을 List인 list를 ArrayList로 초기화한다.            root가 null이 아닌 경우 4번에서 정의한 recursive(Node root, List&lt;List&gt; list, int level) 메서드를 level 0으로 수행한다.       재귀 호출을 이용하여 list에 level 별 노드의 val 값을 넣을 recursive(Node root, List&lt;List&gt; list, int level) 메서드를 정의한다.            list의 크기가 level 이하인 경우, list에 새 ArrayList를 넣어준다.       list의 level번째 List를 가져와 root의 val 값을 넣어준다.       root의 children을 반복하여 재귀 호출을 $level + 1$로 수행한다.           결과를 넣은 list를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/n-ary-tree-level-order-traversal/",
        "teaser": null
      },{
        "title": "Leetcode Java Flatten a Multilevel Doubly Linked List",
        "excerpt":"문제  Link   코드  /* // Definition for a Node. class Node {     public int val;     public Node prev;     public Node next;     public Node child; }; */  class Solution {    public Node flatten(Node head) {     if (head == null) {       return null;     } else if (head.child == null) {       Node node = this.flatten(head.next);       head.next = node;       if (node != null) {         node.prev = head;       }     } else {       Node node = head.next;       Node child = this.flatten(head.child);       head.next = child;       child.prev = head;       Node temp = child;       while (temp.next != null) {         temp = temp.next;       }       Node next = this.flatten(node);       temp.next = next;       if (next != null) {         next.prev = temp;       }       head.child = null;     }     return head;   }  }   결과  Link   설명     주어진 이전, 다음, 자식 노드 정보를 가지고 있는 head Node를 직렬화 시키는 문제이다.            직렬화 시킬 때, 자식 노드 -&gt; 다음 노드 순의 순서로 진행한다.                head가 null인 경우 직렬화가 불가능하기 때문에, null을 반환한다.       head의 child 노드가 null인 경우, 아래를 수행하여 다음 노드로 직렬화를 수행한다.            node에 head의 next 노드를 이용하여 재귀 호출한 결과를 넣어준다.       head의 next 노드에 node를 넣어준다.       node가 null이 아닌 경우, node의 이전 값에 head를 넣어 이어준다.           그 외의 head의 child 노드가 존재하는 경우, 아래를 수행하여 순차적으로 직렬화를 수행한다.            node에 head의 next 노드를 임시로 넣어준다.       child에 head의 child 노드를 이용하여 재귀 호출한 결과를 넣어준다.                    child -&gt; next 순으로 직렬화 하기 때문에, child를 먼저 직렬화 한다.                       head의 next에 child 노드를, child의 prev 노드에 head를 넣어 각 노드를 이어준다.       temp에 child를 넣어주고, temp의 next 노드가 null이 아닐 때 까지 반복하여 temp에 temp의 next 노드를 넣어 마지막 노드로 이동시킨다.       next에 node의 재귀 호출을 수행한 결과를 넣어준다.       temp의 next 노드에 next를 넣어준다.       next가 null이 아닌 경우, next의 prev 노드에 temp를 넣어 위의 child를 직렬화 한 노드에 이어준다.       head의 child 노드에 null을 넣어 자식 노드를 제거한다.           수행이 완료되면 부분 직렬화를 수행한 head를 반환하고, 최종 직렬화가 완료되면 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/flatten-a-multilevel-doubly-linked-list/",
        "teaser": null
      },{
        "title": "Leetcode Java All O`one Data Structure",
        "excerpt":"문제  Link   코드  class AllOne {    private Node head;   private Node tail;   private Map&lt;String, Node&gt; map;    public AllOne() {     this.map = new HashMap&lt;&gt;();   }    public void inc(String key) {     Node node = this.map.get(key);     if (node == null) {       node = new Node(key);       this.map.put(key, node);       if (this.head == null) {         this.head = node;         this.tail = node;       } else {         this.head.left = node;         node.right = this.head;         this.head = node;       }     } else {       node.count++;       while (this.tail != node &amp;&amp; node.count &gt; node.right.count) {         this.swap(node, node.right);       }     }   }    public void dec(String key) {     Node node = this.map.get(key);     node.count--;     if (node.count == 0) {       this.map.remove(key);       if (node.right != null) {         node.right.left = node.left;       }       if (node.left != null) {         node.left.right = node.right;       }       if (node == head) {         this.head = node.right;       }       if (node == tail) {         this.tail = node.left;       }     } else {       while (this.head != node &amp;&amp; node.count &lt; node.left.count) {         this.swap(node.left, node);       }     }   }    public String getMinKey() {     return this.head == null ? \"\" : this.head.val;    }    public String getMaxKey() {     return this.tail == null ? \"\" : this.tail.val;   }    private void swap(Node node1, Node node2) {     Node left = node1.left;     Node right = node2.right;     if (left == null) {       this.head = node2;     } else {       left.right = node2;     }     node2.left = left;     if (right == null) {       this.tail = node1;     } else {       right.left = node1;     }     node1.right = right;     node1.left = node2;     node2.right = node1;   }  }  class Node {    public String val;   public int count;   public Node left;   public Node right;    public Node() {   }    public Node(String val) {     this.val = val;     this.count = 1;   }  }  /**  * Your AllOne object will be instantiated and called as such:  * AllOne obj = new AllOne();  * obj.inc(key);  * obj.dec(key);  * String param_3 = obj.getMaxKey();  * String param_4 = obj.getMinKey();  */   결과  Link   설명     문자열의 개수를 저장하고, 최소 및 최대 개수의 문자열을 반환하는 기능을 가진 데이터 구조를 설계한다.            생성자인 AllOne()는 객체를 초기화한다.       메서드인 inc(String key)는 key에 해당하는 개수를 증가시키고, 데이터 구조에 key가 존재하지 않는다면 key를 추가하고 개수를 1로 설정한다.       메서드인 dec(String key)는 key에 해당하는 개수를 감소시키고, 개수가 0인 경우 데이터 구조에서 제거한다.                    단, key가 감소하기 전에 데이터 구조에 존재한다는 가정을 전제로 둔다.                       메서드인 getMaxKey()는 최대 개수의 key들 중 하나를 반환하고, key가 존재하지 않는 경우 공백(““)을 반환한다.       메서드인 getMinKey()는 최소 개수의 key들 중 하나를 반환하고, key가 존재하지 않는 경우 공백(““)을 반환한다.           문자열과 저장된 횟수를 활용하기 위한 Node 객체를 정의한다.            val은 문자열을 저장하기 위한 변수이다.       count는 저장 횟수를 남길 변수이다.       left는 count가 큰 val에 해당하는 Node를 이어줄 변수이다.       right는 count가 작은 val에 해당하는 Node를 이어줄 변수이다.           문제 풀이에 필요한 변수를 정의한다.            head는 최대 개수의 문자열을 가진 Node를 보관할 변수이다.       tail은 최소 개수의 문자열을 가진 Node를 보관할 변수이다.       map은 key에 대한 Node를 저장하여 Node에서 탐색하는 것보다 빠르게 횟수를 찾기 위한 변수이다.           생성자인 AllOne()를 정의한다.            Node를 임시 저장할 map을 HashMap으로 초기화한다.           메서드인 inc(String key)와 dec(String key)를 수행하며 node의 순서를 바꾸어줄 swap(Node node1, Node node2) 메서드를 정의한다.            left에 node1의 left 노드를, right에 node2의 right 노드를 넣어준다.       left가 null인지 확인하여 아래를 수행한다.                    null인 경우 node1이 최소 횟수의 문자열을 가진 Node이므로, head에 node2를 넣어준다.           null이 아닌 경우, left의 right 노드에 node2를 넣어 이어준다.                       node2의 left 노드에 left를 넣어준다.       right가 null인지 확인하여 아래를 수행한다.                    null인 경우 node2가 최대 횟수의 문자열을 가진 Node이므로, tail에 node1을 넣어준다.           null이 아닌 경우, left의 right 노드에 node1을 넣어 이어준다.                       node2 -&gt; node1 순으로 정렬시키기 위해 순서를 바꾸어 이어준다.           메서드인 inc(String key)를 정의한다.            map에서 key에 해당하는 Node를 찾아 node에 넣어준다.       node가 없을 경우 key가 처음 입력된 문자열이므로, 아래를 수행한다.                    node에 key가 val이고 count가 1인 Node를 만들어 넣어준다.           map에 key를 이용하여 node를 넣어준다.           head가 null인 경우 객체 초기화 후 처음 입력된 값이므로, head와 tail에 node를 넣어준다.           head가 null이 아니면 기존 입력된 값들이 있으므로, Node의 순서를 node 다음 head가 되도록 순서를 바꾸어 head에 node를 넣어준다.                       node가 존재하는 경우, 아래를 수행하여 순서를 바꿔준다.                    node의 count를 증가하고 node가 tail이 아니고 node의 count가 right 노드의 count보다 클 때 까지 반복하여, 5번의 swap(Node node1, Node node2) 메서드로 node와 node의 right 노드의 순서를 계속 바꾸어준다.                           메서드인 dec(String key)를 정의한다.            map에서 key에 해당하는 Node를 찾아 node에 넣어준다.       node의 count를 감소시킨다.                    기존 전제 하에 dec(String key) 메서드를 호출하는 경우, key에 해당하는 node가 존재하므로 node가 null이 될 수 없어 null 여부를 확인하지 않는다.                       node의 count가 0인 경우 해당 노드를 제거해야 하므로, 아래를 수행한다.                    map에서 key에 해당하는 노드를 제거한다.           node의 right 노드가 존재하는 경우, node의 right 노드의 left 노드에 node의 left 노드를 넣어 node를 배제하고 이어준다.           node의 left 노드가 존재하는 경우, node의 left 노드의 right 노드에 node의 right 노드를 넣어 node를 배제하고 이어준다.           node가 head인 경우, head에 node의 right 노드를 넣어 node 다음의 작은 횟수의 문자열을 가진 노드를 head에 설정한다.           node가 tail인 경우, tail에 node의 left 노드를 넣어 node 다음의 큰 횟수의 문자열을 가진 노드를 tail에 설정한다.                       node의 count가 1 이상인 경우, 아래를 수행하여 순서를 바꿔준다.                    head가 node가 아니고 node의 count가 node의 left 노드의 count보다 작을 때 까지 반복하여, 5번의 swap(Node node1, Node node2) 메서드로 node의 left 노드와 node를 계속 바꾸어준다.                           메서드인 getMinKey()를 정의한다.            head가 null인 경우 ““를, 아니면 head의 val 값을 반환한다.           메서드인 getMaxKey()를 정의한다.            tail이 null인 경우 ““를, 아니면 tail의 val 값을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/all-oone-data-structure/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Segments in a String",
        "excerpt":"문제  Link   코드  class Solution {    public int countSegments(String s) {     s = s.trim();     int length = s.length();     char[] charArray = s.toCharArray();     int count = 0;     if (length == 0) {       return count;     } else {       for (int idx = 0; idx &lt; length; idx++) {         if (charArray[idx] == ' ' &amp;&amp; charArray[idx + 1] != ' ') {           count++;         }       }       return count + 1;     }   }  }   결과  Link   설명     문자열 s가 주어지면 해당 문자열의 세그먼트의 수를 반환하는 문제이다.            단, 세그먼트는 공백이 아닌 문자로 이루어진 문자열이다.                우선 문자열 s의 불필요한 좌우 공백을 제거해준다.       문제 풀이에 필요한 변수를 정의한다.            length는 좌우 공백을 제거한 s의 길이를 저장할 변수로, s의 길이로 초기화한다.       charArray는 자우 공백을 제거한 s를 문자 배열로 변환하여 사용할 변수로, s를 문자 배열로 변환하여 넣어준다.       count는 세그먼트 수를 계산할 변수로, 0으로 초기화한다.                length가 0인 경우 세그먼트 또한 없으므로, 0을 주어진 문제의 결과로 반환한다.       length가 0이 아닌 경우, 아래를 수행하여 세그먼트 수를 계산하여 $count + 1$을 주어진 문제의 결과로 반환한다.            0부터 length 미만까지 idx를 증가시키며 idx번째 문자가 공백이고, $idx + 1$ 번쨰 문자가 공백이 아닌 세그먼트 시작 부분을 확인하면 count를 증가시킨다.       count가 아니라 $count + 1$을 반환하는 이유는, 처음 세그먼트를 count에 반영하지 않았기 때문이다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-segments-in-a-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Non-overlapping Intervals",
        "excerpt":"문제  Link   코드  class Solution {    public int eraseOverlapIntervals(int[][] intervals) {     Arrays.sort(intervals, (interval1, interval2) -&gt; {       return interval1[1] - interval2[1];     });     int end = intervals[0][1];     int count = 1;     for (int[] interval : intervals) {       if (interval[0] &gt;= end) {         end = interval[1];         count++;       }     }     return intervals.length - count;   }  }   결과  Link   설명     배열 intervals가 주어지면 겹치지 않은 구간을 만들기 위해 제거해야 하는 값들의 개수를 구하는 문제이다.            intervals[i] = [starti, endi]                intervals를 end 값 기준으로 오름차순 정렬을 수행한다.       문제 풀이에 필요한 변수를 정의한다.            end는 중복되지 않은 구간을 구하기 위한 값을 임시 저장할 변수로, intervals의 첫 값의 두 번째 값인 end 값으로 초기화한다.       count는 중복되지 않은 구간을 세기 위한 변수로, 1로 초기화한다.           intervals를 반복하여 count를 계산한다.            interval의 첫 값이 end보다 크거나 같은 경우, end에 interval의 두 번째 값을 넣어주고 count를 증가시킨다.           intervals의 크기에 중복되지 않은 구간의 개수인 count를 빼서 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/non-overlapping-intervals/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Right Interval",
        "excerpt":"문제  Link   코드  class Solution {    public int[] findRightInterval(int[][] intervals) {     int min = Integer.MAX_VALUE;     int max = Integer.MIN_VALUE;     for (int[] interval : intervals) {       min = Math.min(min, interval[0]);       max = Math.max(max, interval[1]);     }     int[] map = new int[max - min + 1];     for (int idx = 0; idx &lt; map.length; idx++) {       map[idx] = Integer.MIN_VALUE;     }     for (int idx = 0; idx &lt; intervals.length; idx++) {       map[intervals[idx][0] - min] = idx;     }     for (int idx = map.length - 2; idx &gt;= 0; idx--) {       if (map[idx] == Integer.MIN_VALUE) {         map[idx] = map[idx + 1];       }     }     int[] result = new int[intervals.length];     for (int idx = 0; idx &lt; intervals.length; idx++) {       int val = map[intervals[idx][1] - min];       if (val == Integer.MIN_VALUE) {         result[idx] = -1;               } else {         result[idx] = val;       }     }     return result;   }  }   결과  Link   설명     배열 intervals가 주어지면 각각 우측에 위치하는 interval을 찾아 위치를 넣어 반환하는 문제이다.            intervals[i] = [starti, endi]       단, starti는 배열 내 고유한 값이다.       intervals[i]에 대한 오측에 위치하는 interval은 startj &gt;= endi이고 startj가 최소화되는 intervals[j]이며, i와 j가 같을 수 있다.       intervals[i]에 대한 우측에 위치하는 interval이 없을 경우, -1을 해당 자리에 넣는다.           문제 풀이에 필요한 변수를 정의한다.            min은 시작 값이 가장 작은 값을 저장하기 위한 변수로, interval의 첫 번째 값들 중 가장 작은 값을 찾아 넣어준다.       max는 끝 값이 가장 큰 값을 저장하기 위한 변수로, interval의 두 번째 값들 중 가장 큰 값을 찾아 넣어준다.       map은 해당 구간내 위치를 지정하기 위한 배열로, 최소 크기가 되는 $max - min + 1$ 크기로 정의하고 모든 위치에 정수의 가장 작은 값을 넣어준다.           0부터 intervals 길이 미만까지 반복하여 아래를 수행한다.            map의 $intervals[idx][0] - min$ 위치에 순서인 idx를 넣어준다.           map을 뒤에서부터 idx를 감소시키며 아래를 수행한다.            map의 idx번째 값이 정수의 가장 작은 값인 경우, $idx + 1$번째에 있는 값을 넣어준다.           결과를 넣어줄 result 배열을 intervals의 크기로 정의하고, 0부터 해당 크기 미만까지 idx를 증가시키며 반복하여 아래를 수행한다.            map의 $intervals[idx][1] - min$번째 값을 val에 넣어준다.       val이 정수의 가장 작은 값인 경우 우측에 존재하는 값이 없으므로, result의 idx번째 위치에 -1을 넣어준다.       위의 경우가 아니면, result의 idx번째 위치에 val을 넣어준다.           반복이 완료되면 각각 우측에 위치하는 interval의 위치 값을 넣은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-right-interval/",
        "teaser": null
      },{
        "title": "Leetcode Java Path Sum III",
        "excerpt":"문제  Link   코드  class Solution {    public int pathSum(TreeNode root, int targetSum) {     if (root == null) {       return 0;     } else {       Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();       map.put(0, 1);       return this.dfs(root, targetSum, map, 0);     }   }    private int dfs(TreeNode node, int targetSum, Map&lt;Integer, Integer&gt; map, int sum) {     int result = 0;     sum += node.val;     if (map.containsKey(sum - targetSum)) {       result += map.get(sum - targetSum);     }     map.put(sum, map.getOrDefault(sum, 0) + 1);     if (node.left != null) {       result += this.dfs(node.left, targetSum, map, sum);     }     if (node.right != null) {       result += this.dfs(node.right, targetSum, map, sum);     }     map.put(sum, map.get(sum) - 1);     return result;   }  }   결과  Link   설명          TreeNode인 root를 이용하여 val의 합이 targetSum이 되는 구간의 개수를 구하는 문제이다.       root가 null인지 여부에 따라 아래를 수행한다.            root가 null인 경우 val의 합이 targetSum이 되는 구간의 개수를 셀 수 없으므로, 0을 주어진 문제의 결과로 반환한다.       root가 null이 아닌 경우 아래를 수행한다.                    map에 새 HashMap을 정의하고 키가 1인 값에 1을 넣어 초기화한다.           3번에서 정의한 dfs(TreeNode node, int targetSum, Map&lt;Integer, Integer&gt; map, int sum) 메서드를 sum에 0을 넣어 수행한다.                           DFS 방식으로 구간의 개수를 세기 위한 dfs(TreeNode node, int targetSum, Map&lt;Integer, Integer&gt; map, int sum) 메서드를 정의한다.            개수를 세기 위한 result를 0으로 초기화한다.       sum에 node의 val 값을 더하여 구간 합을 계산한다.       map에 $sum - targetSum$의 값이 존재하는 경우, result에 해당 값을 더해준다.       map에 sum이 키인 값에 기존 값이 있으면 sum 아니면 0에 1을 더해서 넣어 map에 구간 개수를 추가해준다.       node의 left TreeNode가 null이 아닌 경우, left TreeNode로 재귀 호출하여 좌측으로 탐색한 결과를 result에 더해준다.       node의 right TreeNode가 null이 아닌 경우, right TreeNode로 재귀 호출하여 우측으로 탐색한 결과를 result에 더해준다.       map에 sum이 키인 값에 기존 값의 1을 뺀 값을 넣어 앞에서 구간 개수를 추가한 것을 초기화 시켜준다.       result를 반환하여 node 기준으로 탐색한 targetSum이 되는 구간의 개수를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/path-sum-iii/",
        "teaser": null
      },{
        "title": "Leetcode Java Find All Anagrams in a String",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; findAnagrams(String s, String p) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     if (p.length() &gt; s.length()) {       return result;     }     int[] countP = new int[26];     for (int idx = 0; idx &lt; p.length(); idx++) {       countP[p.charAt(idx) - 97]++;     }     int[] countS = new int[26];     int idx = 0;     int i = 0;     while (idx &lt; p.length() &amp;&amp; idx &lt; s.length()) {       countS[s.charAt(idx++) - 97]++;     }     while (idx &lt;= s.length()) {       int j = 0;       while (j &lt; 26 &amp;&amp; countP[j] == countS[j]) {         j++;       }       if (j == 26) {         result.add(i);       }       countS[s.charAt(i) - 97]--;       i++;       if (idx != s.length()) {         countS[s.charAt(idx) - 97]++;       }       idx++;     }     return result;   }  }   결과  Link   설명     문자열 s와 p가 주어지면, p를 이용한 아나그램이 가능한 위치를 모두 반환하는 문제이다.            아나그램이란 문자의 재 배열로 특정 문자열을 만들 수 있는 단어 또는 어구이다.                결과를 저장할 result를 ArrayList로 초기화 하고 p의 길이가 s의 길이보다 길 경우 아나그램으로 재 배열해서 만들 수 없으므로, 아무것도 들어있지 않은 result를 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            countP는 p에 들어간 문자의 발생 횟수를 저장할 배열로, 영문자의 개수인 26 크기로 정의하고 p를 반복하여 각 문자 별 a(97)을 뺀 위치 값을 증가시켜준다.       countS는 s에 들어간 문자의 발생 횟수를 저장할 배열로, 영문자의 개수인 26 크기로 정의한다.       idx는 s를 순회하기 위한 위치 변수로, 0으로 초기화한다.       i는 아나그램이 성립하는 위치 변수로, 0으로 초기화한다.                idx가 p와 s의 길이 미만까지 반복하여 countS에 해당 문자의 위치 값을 넣고 idx를 증가시킨다.       idx가 s의 길이 이하일 때까지 아래를 반복한다.            j를 0으로 초기화 시키고, j가 26 미만이고 countP와 countS의 값이 동일한지 검증하여 j를 증가시킨다.       j가 26이면 문자열이 동일하다는 의미이므로, result에 i를 넣어준다.       countS에 문자열 s의 i번째 문자에 해당하는 위치의 값을 감소시켜 검증에 해당 문자를 배제하고 i를 증가시킨다.       idx가 s의 길이가 아닌 경우, countS에 문자열 s의 idx번째 문자에 해당하는 위치 값을 증가시켜 count를 추가한다.       idx를 증가시키고 반복을 계속 수행한다.           반복이 완료되면 아나그램이 성립하는 모든 위치 값을 넣은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-all-anagrams-in-a-string/",
        "teaser": null
      },{
        "title": "Leetcode Java K-th Smallest in Lexicographical Order",
        "excerpt":"문제  Link   코드  class Solution {    public int findKthNumber(int n, int k) {     long cur = 1;     while (k &gt; 1) {       long step = this.getStep(n, cur, cur + 1);       if (step &lt;= k - 1) {         cur++;         k -= step;       } else {         cur *= 10;         k--;       }     }     return (int) cur;   }    private long getStep(int n, long num1, long num2) {     long count = 0;     while (num1 &lt;= n) {       count += Math.min(n + 1, num2) - num1;       num1 *= 10;       num2 *= 10;     }     return count;   }  }   결과  Link   설명          정수 n과 k가 주어지면 1 ~ n까지 숫자를 사전순 정렬을 수행했을 경우, k번째 값을 찾는 문제이다.            k번째 값을 담을 cur을 overflow를 방지하기 위해 long으로 정의하여, 1로 초기화한다.       k가 1 초과일 때까지 반복하여 탐색을 수행한다.            step에 4번에서 정의한 getStep(int n, long num1, long num2) 메서드를 호출한 결과를 넣어준다.       step이 $k - 1$ 이하인 경우, cur을 증가시키고 k에서 step만큼 빼준다.       step이 $k - 1$ 초과인 경우, cur을 10배 증가시키고, k를 감소시킨다.           n에 근접한 값이 되기 위한 횟수를 계산하기 위한 getStep(int n, long num1, long num2) 메서드를 정의한다.            횟수를 계산할 step을 overflow를 방지하기 위해 long으로 정의하여, 0으로 초기화한다.       num1이 n 이하일 때 까지 반복을 수행한다.                    step에 $n + 1$과 num2 중 작은 값에서 num1을 뺀 값을 더해준다.           num1과 num2를 10배 증가시킨다.                       반복이 완료되면 횟수를 저장한 step을 반환한다.           반복이 완료되면 k번째 값인 cur을 int형으로 형 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/k-th-smallest-in-lexicographical-order/",
        "teaser": null
      },{
        "title": "Leetcode Java Arranging Coins",
        "excerpt":"문제  Link   코드  class Solution {    public int arrangeCoins(int n) {     long left = 0;     long right = n;     while (left &lt;= right) {       long mid = left + (right - left) / 2;       long curr = mid * (mid + 1) / 2;       if (n &lt; curr) {         right = mid - 1;       } else {         left = mid + 1;       }     }     return (int) right;   }  }   결과  Link   설명     정수 n이 주어지면 동전으로 계단을 만들 경우, 만들어진 완전한 계단의 층수를 반환하는 문제이다.            계단은 우측에서 좌측으로 올라가는 형태로 구성이 된다.           문제 풀이에 필요한 변수를 정의한다.            left는 좌측 포인터 역할을 수행할 변수로 overflow를 방지하기 위해서 long으로 정의하고, 0으로 초기화한다.       right는 우측 포인터 역할을 수행할 변수로 overflow를 방지하기 위해서 long으로 정의하고, n으로 초기화한다.           left가 right보다 작거나 같을 때 까지 아래를 반복한다.            중간 값을 지정할 mid를 $left + \\frac{right - left}{2}$로 정의한다.       현재 포인터 역할을 수행할 curr을 $\\frac{mid \\times (mid + 1)}{2}$로 정의한다.       n이 curr보다 작은 경우, right에 $mid - 1$을 넣어 탐색 범위를 축소시킨다.       n이 curr보다 크거나 같은 경우, left에 $mid + 1$을 넣어 탐색 범위를 축소시킨다.           반복이 완료되면 최종 포인터의 위치인 right를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/arranging-coins/",
        "teaser": null
      },{
        "title": "Leetcode Java Find All Duplicates in an Array",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; findDuplicates(int[] nums) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     int[] count = new int[nums.length];     for (int num : nums) {       count[num - 1]++;     }     for (int idx = 0; idx &lt; count.length; idx++) {       if (count[idx] == 2) {         result.add(idx + 1);       }     }     return result;   }  }   결과  Link   설명          정수 배열 nums 내 중복된 값을 찾는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 중복된 정수를 저장하기 위한 변수로, ArrayList로 정의한다.       count는 중복된 값을 찾기 위한 변수로, nums의 길이만큼의 크기로 초기화한다.                nums를 반복하여 count의 $num - 1$ 위치의 값을 증가시킨다.            count를 반복하여, count가 2인 값들을 result에 넣어준다.       중복된 값들을 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-all-duplicates-in-an-array/",
        "teaser": null
      },{
        "title": "Leetcode Java String Compression",
        "excerpt":"문제  Link   코드  class Solution {    public int compress(char[] chars) {     int i = 0;     int j = 0;     int index = 0;     int length = chars.length;     while (j &lt; length) {       int count = 0;       char curr = chars[i];       while (j &lt; length &amp;&amp; chars[j] == curr) {         j++;         count++;       }       chars[index++] = curr;       if (count &gt; 1) {         if (count &lt; 10) {           chars[index++] = (char) (count + '0');         } else {           for (char c : String.valueOf(count).toCharArray()) {             chars[index++] = c;           }         }       }       i = j;     }     return index;   }  }   결과  Link   설명     문자 배열인 chars가 주어지면 아래의 규칙대로 문자 배열을 생성할 때, 길이를 구하는 문제이다.            동일한 문자 그룹의 길이가 1개일 경우, 해당 문자만 문자 배열에 넣어준다.       2개 이상인 경우, 문자 뒤에 개수를 문자 배열에 넣어준다.       문자열의 개수가 10개를 넘어가면, 한 자리씩 잘라서 문자 배열에 넣어준다.       주어진 배열을 그대로 사용하여, 새 길이를 구한다.           문제 풀이에 필요한 변수를 정의한다.            i와 j는 chars를 탐색하여 문자의 개수를 탐색하기 위한 변수로, 둘 다 0으로 초기화한다.       index는 조건에 만족하는 배열 내 위치를 저장할 변수로, 0으로 초기화한다.       length는 chars의 길이를 저장할 변수로, chars의 길이로 초기화한다.           j가 length 미만일 때 까지 반복하여 아래를 수행한다.            문제 풀이에 필요한 변수를 정의한다.                    count는 동일한 문자의 개수를 계산할 변수로, 0으로 초기화한다.           curr은 현재 위치의 문자를 저장할 변수로, chars의 i번째 문자를 넣어준다.                       j가 length 미만이고 char[j]가 curr과 동일할 때 까지 반복하여 j와 count를 증가시켜준다.       chars의 index번째 위치에 curr을 넣어주고, index를 증가시킨다.       count가 1 초과이고 count가 10 미만인 경우, chars의 index번째 위치에 count를 ASCII 코드값으로 증가시키고 문자로 변환하여 넣어주고 index를 증가시킨다.       count가 1 초과이고 count가 10 초과인 경우, count를 문자열로 변환하여 chars의 index번째 위치에 차례대로 넣어주면서 index를 증가시킨다.       j번째 문자까지 처리하였으므로, i에 j를 넣어 다음 반복의 위치를 j로 지정해준다.           반복이 완료되면 조건을 만족하는 새 문자 배열의 길이인 index를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/string-compression/",
        "teaser": null
      },{
        "title": "Leetcode Java Add Two Numbers II",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {     l1 = this.reverseList(l1);     l2 = this.reverseList(l2);     ListNode result = null;     ListNode temp = result;     int carry = 0;     while (l1 != null &amp;&amp; l2 != null) {       int sum = carry + l1.val + l2.val;       carry = sum / 10;       ListNode listNode = new ListNode(sum % 10);       if (result == null) {         result = listNode;         temp = result;       } else {         temp.next = listNode;         temp = temp.next;       }       l1 = l1.next;       l2 = l2.next;     }     while (l1 != null) {       int sum = carry + l1.val;       carry = sum / 10;       temp.next = new ListNode(sum % 10);       l1 = l1.next;       temp = temp.next;     }     while (l2 != null) {       int sum = carry + l2.val;       carry = sum / 10;       temp.next = new ListNode(sum % 10);       l2 = l2.next;       temp = temp.next;     }     while (carry != 0) {       temp.next = new ListNode(carry % 10);       carry /= 10;       temp = temp.next;     }     return this.reverseList(result);   }    private ListNode reverseList(ListNode ls) {     ListNode reverse = new ListNode(ls.val);     while (ls.next != null) {       ls = ls.next;       reverse = new ListNode(ls.val, reverse);     }     return reverse;   }  }   결과  Link   설명          숫자를 ListNode로 만든 l1과 l2를 이용하여 합친 값으로 새 ListNode를 만들어 반환하는 문제이다.       ListNode의 값들을 역순으로 전환하기 위한 reverseList(ListNode ls) 메서드를 정의한다.            ls의 val 값으로 ListNode를 만들어서 reverse에 정의하고, ls의 next가 null이 아닐 때 까지 반복하여 reverse에 ls 내 val 값들을 역순으로 만들어준다.       반복이 완료되면 reverse를 반환한다.           문제 풀이에 필요한 변수를 정의한다.            l1과 l2에 2번에서 정의한 reverseList(ListNode ls) 메서드를 이용하여 값들을 역순으로 만들어준다.       result는 결과를 넣을 변수로, null로 초기화한다.       temp는 결과를 엮어줄 임시 변수로, result로 초기화한다.       carry는 숫자의 합이 10 이상일 경우, 10 자릿수를 넣어줄 변수이다.           l1과 l2가 null이 아닐 때 까지 반복하여 아래를 수행한다.            sum에 l1과 l2의 val 값과 carry의 합을 넣어준다.       carry에 10을 나눈 값을 carry에 다시 넣어준다.       listNode에 sum의 1 자릿수를 이용하여 새 ListNode를 만들어 넣어준다.       result가 null인 경우 첫 값이므로, result에 listNode와 temp에 result를 넣어준다.       result가 null이 아니면, temp의 next에 ListNode를 temp에 temp의 next ListNode를 넣어준다.       l1에 l1의 next ListNode를 l2에 l2의 next ListNode를 넣어준다.           l1, l2 순으로 각 ListNode가 null이 아닐 때 까지 반복하여 아래를 수행한다.            sum에 carry와 val 값을 더해준다.       carry에 10을 나눈 값을 carry에 다시 넣어준다.       temp의 next에 sum의 1 자릿수를 이용하여 새 ListNode를 만들어 넣어준다.       l1에 l1의 next ListNode를, temp에 temp의 next ListNode를 넣어준다.           carry에 값이 남아있는 경우, 아래를 수행한다.            temp의 next ListNode에 carry의 1 자릿수를 이용하여 새 ListNode를 만들어 넣어준다.       carry에 10을 나눈 값을 carry에 다시 넣어준다.       temp에 temp의 next ListNode를 넣어준다.           역순의 값을 더해 이어준 result를 2번의 reverseList(ListNode ls) 메서드를 이용하여 다시 원래대로 돌려서 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/add-two-numbers-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Arithmetic Slices II - Subsequence",
        "excerpt":"문제  Link   코드  class Solution {    public int numberOfArithmeticSlices(int[] nums) {     int result = 0;     int length = nums.length;     int[][] dp = new int[length][length];     Map&lt;Long, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();     for (int i = 0; i &lt; length; i++) {       for (int j = i + 1; j &lt; length; j++) {         List&lt;Integer&gt; list = map.get(nums[i] - (nums[j] - (long) nums[i]));         if (list == null) {           continue;         }         for (int num : list) {           dp[i][j] += dp[num][i] + 1;         }         result += dp[i][j];       }       map.computeIfAbsent((long) nums[i], k -&gt; new ArrayList&lt;&gt;()).add(i);     }     return result;   }  }   결과  Link   설명     정수 배열 nums의 최소 3개 이상의 요소가 포함된 부분 배열이 산술적 수열이 되는 조합의 수를 반환하는 문제이다.            각 요소 간 값의 차이가 동일한 값들을 모은 부분 배열은 산술적 수열이다.       테스트 케이스는 결과가 32 비트 정수가 되도록 제공된다.           문제 풀이에 필요한 변수를 정의한다.            result는 산술적 수열이 되는 조합의 수를 저장하기 위한 변수로, 0으로 초기화한다.       length는 nums의 길이를 저장할 변수로, nums의 길이로 초기화한다.       dp는 각 부분 수열의 개수를 계산하기 위한 변수로, $length \\times length$ 크기의 2차원 정수 배열로 초기화한다.       map은 nums 내 각 요소의 위치 값을 저장하기 위한 변수로, HashMap으로 초기화한다.           0부터 length 미만까지 i를 증가시키며 반복하여 아래를 수행한다.            $i + 1$ 부터 length 미만까지 j를 증가시키며 반복하여 아래를 수행한다.                    map에서 nums의 j번째 값과 i번째 값의 차이만큼 발생하는 i번째 값 이하 값에 해당하는 List를 가져온다.           list가 null인 경우 동일한 차이가 발생하는 값이 존재하지 않으므로, 무시하고 j를 증가시켜 반복을 계속 수행한다.           list의 값들을 반복하여 dp[i][j]의 값에 $dp[num][i] + 1$을 계속 더해준다.           result에 dp[i][j] 값을 더해 가능한 부분 배열의 수를 증가시킨다.                       map에 nums의 i번째 값이 있는지 확인하여 없으면 새 ArrayList를 넣고, 해당 List에 해당 값의 위치인 i를 넣어준다.           반복이 완료되면 nums 내 3개 이상의 요소를 이용한 부분 배열이 산술적 수열이 되는 개수를 계산한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/arithmetic-slices-ii-subsequence/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Boomerangs",
        "excerpt":"문제  Link   코드  class Solution {    public int numberOfBoomerangs(int[][] points) {     int number = 0;     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();     for (int i = 0; i &lt; points.length; i++) {       for (int j = 0; j &lt; points.length; j++) {         if (i == j) {           continue;         }         int distance = this.calculateDistance(points[i], points[j]);         int point = map.getOrDefault(distance, 0);         if (point &gt; 0) {           number += point * 2;         }         map.put(distance, point + 1);       }       map.clear();     }     return number;   }    private int calculateDistance(int[] pointA, int[] pointB) {     int x = pointB[0] - pointA[0];     int y = pointB[1] - pointA[1];     return (x * x) + (y * y);   }  }   결과  Link   설명     평면 위에 존재하는 points를 이용하여 point(i, j, k)에서 i와 j 사이의 거리가 i와 k 사이의 거리와 동일하게 지나가는 부메랑의 수를 구하는 문제이다.            points 내 i번째 존재하는 점인 point[i]는 [xi, yi]로 표현한다.           문제 풀이에 필요한 변수를 정의한다.            number는 각 점을 지나는 부메랑의 개수를 세기 위한 변수로, 0으로 초기화한다.       map은 동일한 거리의 점의 수를 저장할 변수로, HashMap으로 초기화한다.           0부터 point의 길이 전까지 i를 증가시키며 아래의 반복을 수행한다.            0부터 point의 길이 전까지 j를 증가시키며 아래의 반복을 다시 수행한다.                    i와 j가 동일한 경우, 다음 반복을 계속 수행한다.           distance에 4번에서 정의한 calculateDistance(int[] pointA, int[] pointB) 메서드를 수행하여 a와 b 사이의 거리를 넣어준다.           map에서 distance가 같은 점이 존재하는지 여부를 확인하여 point에 넣고, 없으면 0을 넣어준다.           point가 1개 이상인 경우, 부메랑은 곡선으로 순하여 다시 돌아오므로, 돌아오는 쪽에서 던져서 던지는 쪽에서 받는 경우를 포함하여 number에 point의 2배를 넣어준다.           map에 dsitance에 해당하는 값에 $point + 1$로 넣어준다.                       map을 초기화 시켜주고 반복을 계속 수행한다.           두 점 사이의 거리를 계산하기 위한 calculateDistance(int[] pointA, int[] pointB) 메서드를 정의한다.            pointA와 pointB 사이의 x축 거리를 변수 x에 넣고, y에 축 거리를 변수 y에 넣어준다.       거리를 구하기 위한 기본 공식에서 제곱근을 수행하기 전인 x의 제곱과 y의 제곱의 합을 반환한다.                    $x = y$이면 $x^2 = y^2$이고, $\\sqrt{x} = \\sqrt{y}$가 성립하므로 제곱근을 수행하지 않은 값이 동일하지 않은 경우, 거리 또한 동일하지 않는다.                           반복이 완료되면 부메랑의 수인 number를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-boomerangs/",
        "teaser": null
      },{
        "title": "Leetcode Java Find All Numbers Disappeared in an Array",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     int[] count = new int[nums.length + 1];     for (int num : nums) {       count[num]++;     }     for (int idx = 1; idx &lt; count.length; idx++) {       if (count[idx] == 0) {         result.add(idx);       }     }     return result;   }  }   결과  Link   설명          정수 배열 nums에서 1부터 해당 배열의 길이까지 숫자 중 누락된 숫자들을 찾아 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 누락된 숫자를 넣을 변수로, ArrayList로 초기화한다.       count는 nums 내 포함된 숫자의 개수를 세기 위한 변수로, nums의 길이보다 하나 크게 정의한다.                nums를 반복하여 count의 num번째 위치의 값을 증가시킨다.       1부터 count의 길이 미만까지 idx를 증가시키며 반복하여 아래를 수행한다.            count의 idx번째 값이 0인 경우, nums에 미 포함된 값이므로 result에 포함시킨다.           반복을 통해 누락된 숫자들을 추가한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-all-numbers-disappeared-in-an-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Serialize and Deserialize BST",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode(int x) { val = x; }  * }  */ public class Codec {    // Encodes a tree to a single string.   public String serialize(TreeNode root) {     StringBuilder sb = new StringBuilder();     this.serialize(sb, root);     return sb.toString();   }    private void serialize(StringBuilder sb, TreeNode root) {     if (root != null) {       sb.append((char) (root.val + '0'));       this.serialize(sb, root.left);       this.serialize(sb, root.right);     }   }    // Decodes your encoded data to tree.   public TreeNode deserialize(String data) {     TreeNode root = null;     for (char c : data.toCharArray()) {       root = this.add(root, c - '0');     }     return root;   }    private TreeNode add(TreeNode root, int val) {     if (root == null) {       return new TreeNode(val);     } else {       if (val &lt; root.val) {         root.left = this.add(root.left, val);       } else {         root.right = this.add(root.right, val);       }       return root;     }   }  }  // Your Codec object will be instantiated and called as such: // Codec ser = new Codec(); // Codec deser = new Codec(); // String tree = ser.serialize(root); // TreeNode ans = deser.deserialize(tree); // return ans;   결과  Link   설명     이진 검색 트리(BST)를 직렬화, 역직렬화를 수행하는 Codec 클래스를 완성하는 문제이다.            메서드인 serialize(TreeNode root)는 주어진 root를 문자열로 직렬화하는 기능을 수행한다.       메서드인 deserialize(String data)는 주어진 data를 TreeNode로 역직렬화하는 기능을 수행한다.           serialize(TreeNode root) 메서드를 완성한다.            root를 직렬화 하여 저장할 변수 sb를 정의하고, StringBuilder로 초기화한다.       3번에서 정의한 serialize(StringBuilder sb, TreeNode root) 메서드를 이용하여 root를 직렬화한 값을 sb에 넣어준다.       직렬화된 값이 저장된 sb를 문자열로 변환하여 반환한다.           root를 재귀 호출을 이용하여 직렬화 하는 serialize(StringBuilder sb, TreeNode root) 메서드를 완성한다.            root가 null이 아닐 경우 아래를 수행한다.                    sb에 root의 val 값을 문자로 치환하여 넣어준다.           left를 이용하여 재귀 호출을 수행하여 sb에 좌측 TreeNode들의 val 값을 직렬화 하여 넣어준다.           right를 이용하여 재귀 호출을 수행하여 sb에 우측 TreeNode들의 val 값을 직렬화 하여 넣어준다.                           deserialize(String data) 메서드를 완성한다.            data를 TreeNode로 변환하기 위한 root를 정의한다.       data의 각 문자를 반복하여 5번에서 정의한 add(TreeNode root, int val) 메서드로 역직렬화를 수행하여 root에 넣어준다.       반복이 완료되면 역직렬화된 root를 반환한다.           root에 val 값을 이용하여 TreeNode를 완성하기 위한 add(TreeNode root, int val) 메서드를 완성한다.            root가 null인 경우 최상위 노드이므로, val을 이용하여 새 TreeNode를 만들어 반환한다.       root가 null이 아닌 경우 아래를 수행한다.                    val 값이 root의 val 미만인 경우 해당 노드 좌측에 위치한 노드이므로, root의 left에 root의 left와 val을 이용한 값을 재귀 호출한 결과를 넣어준다.           val 값이 root의 val 이상인 경우 해당 노드 우측에 위치한 노드이므로, root의 right에 root의 right와 val을 이용한 값을 재귀 호출한 결과를 넣어준다.           위의 수행이 완료되면 root를 반환한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/serialize-and-deserialize-bst/",
        "teaser": null
      },{
        "title": "Leetcode Java Delete Node in a BST",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public TreeNode deleteNode(TreeNode root, int key) {     if (root == null) {       return null;     } else if (key &lt; root.val) {       root.left = this.deleteNode(root.left, key);     } else if (key &gt; root.val) {       root.right = this.deleteNode(root.right, key);     } else if (root.left == null) {       return root.right;     } else if (root.right == null) {       return root.left;     } else {       root.val = this.findMinValue(root.right);       root.right = this.deleteNode(root.right, root.val);     }     return root;   }    private int findMinValue(TreeNode root) {     while (root.left != null) {       root = root.left;     }     return root.val;   }  }   결과  Link   설명          TreeNode인 root 내 val 값이 key와 동일한 노드를 제거하는 문제이다.       root를 각 경우 별 검증을 통해 절차를 수행한다.            root가 null인 경우 노드가 없으므로, null을 반환한다.       key가 root의 val 값보다 작은 경우 해당 root 기준으로 key는 좌측 TreeNode에 존재하므로, root의 left TreeNode로 재귀 호출을 수행한다.       key가 root의 val 값보다 큰 경우 해당 root 기준으로 key는 우측 TreeNode에 존재하므로, root의 right TreeNode로 재귀 호출을 수행한다.       root의 left TreeNode가 null인 경우, root의 right TreeNode를 반환하여 검증하도록 한다.       root의 right TreeNode가 null인 경우, root의 left TreeNode를 반환하여 검증하도록 한다.       그 외의 경우 root의 val 값이 key이므로, 아래를 수행하여 노드를 삭제하고 다음 노드를 이어준다.                    root의 val 값에 3번에서 정의한 findMinValue(TreeNode root) 메서드를 수행한 결과를 넣어준다.           root의 right TreeNode에 root의 right TreeNode를 재귀 호출을 수행한 결과를 넣어준다.                           root 기준으로 가장 작은 값을 찾는 findMinValue(TreeNode root) 메서드를 정의한다.            root의 left TreeNode가 null이 아닐 때 까지 반복하여, root에 root의 left TreeNode를 넣어준다.       root 기준의 가장 작은 값을 찾은 root의 val 값을 반환한다.           수행이 완료되면 root를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/delete-node-in-a-bst/",
        "teaser": null
      },{
        "title": "Leetcode Java Sort Characters By Frequency",
        "excerpt":"문제  Link   코드  class Solution {    public String frequencySort(String s) {     int[][] count = new int[128][2];     for (char c : s.toCharArray()) {       count[c][0] = c;       count[c][1]++;     }     Arrays.sort(count, (a, b) -&gt; (b[1] - a[1]));     StringBuilder sb = new StringBuilder();     for (int idx = 0; idx &lt; count.length; idx++) {       while (count[idx][1] &gt; 0) {         sb.append((char) count[idx][0]);         count[idx][1]--;       }     }     return sb.toString();   }  }   결과  Link   설명          문자열 s에서 가장 많이 존재하는 문자의 내림차순으로 재 배열한 결과를 반환하는 문제이다.       문자열의 발생 빈도를 계산하기 위한 count 배열을 정의하고, 2차원 정수 배열의 [128][2] 크기로 초기화한다.            문자열은 영어 대소문자, 숫자로 구성되어 배열의 행 크기를 ASCII 코드의 최대 크기인 128 크기로 정의한다.       문자의 발생 빈도로 정렬을 수행해야 하므로 문자와 빈도를 저장하기 위해서 배열의 열 크기를 2로 정의한다.                문자열 s를 반복하여 count에 문자와 발생 빈도를 넣어주고, 발생 빈도를 이용하여 내림차순 정렬을 수행한다.       내림차순으로 정렬된 문자열을 생성하기 위해 sb를 StringBuilder로 정의한다.            동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.           0부터 count의 길이까지 idx를 증가시키며 반복하여 아래를 수행한다.            count[idx][1]인 발생 빈도가 0 초과인 경우, sb에 count[idx][0] 값인 발생 문자의 ASCII Code 값을 문자로 변환하여 넣어주고 count[idx][1]인 발생 빈도를 감소시켜준다.           반복이 완료되면 발생 빈도를 내림차순으로 정렬해서 넣은 sb를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sort-characters-by-frequency/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Number of Arrows to Burst Balloons",
        "excerpt":"문제  Link   코드  class Solution {    public int findMinArrowShots(int[][] points) {     Arrays.sort(points, (a, b) -&gt; Integer.compare(a[1], b[1]));     int point = points[0][1];     int count = 1;     for (int idx = 1; idx &lt; points.length; idx++) {       if (points[idx][0] &gt; point) {         point = points[idx][1];         count++;       }     }     return count;   }  }   결과  Link   설명     풍선의 x축 너비를 나타내는 points 내 풍선들을 y축으로 수직 발사하는 화살로 터트릴 경우 필요한 화살의 개수를 구하는 문제이다.            point[i] = [xstart, xend]                points를 풍선 너비의 끝(우측) 지점을 기준으로 오름차순 정렬을 수행한다.       문제 풀이에 필요한 변수를 정의한다.            point는 이전 풍선의 너비 중 마지막 값을 저장하기 위한 변수로, 정렬된 points 내 첫 풍선의 끝 지점의 값을 넣어준다.       count는 화살의 개수를 구하기 위한 변수로, 첫 풍선을 터트리기 위한 1개로 초기화한다.           1부터 points의 길이 전까지 idx를 증가시키며 아래를 반복한다.            points의 idx번째 풍선의 시작(좌측) 지점이 point보다 큰 경우 기존 화살로 같이 터트릴 수 없으므로, point에 해당 풍선의 끝(우측) 지점의 값을 넣어주고 count를 증가시킨다.           반복이 완료되면 화살의 개수인 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-number-of-arrows-to-burst-balloons/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Moves to Equal Array Elements",
        "excerpt":"문제  Link   코드  class Solution {    public int minMoves(int[] nums) {     int result = 0;     int min = Integer.MAX_VALUE;     for (int num : nums) {       min = Math.min(min, num);     }     for (int num : nums) {       result += num - min;     }     return result;   }  }   결과  Link   설명     nums의 요소들을 동일한 값으로 만들기 위한 최소 횟수를 계산하는 문제이다.            한 번에 $n - 1$개의 요소의 값을 1씩 증가시킬 수 있다.           주어진 문제 풀이에 필요한 변수를 정의한다.            result는 최소 횟수를 저장하기 위한 변수로, 0으로 초기화한다.       min은 nums 내 최솟값을 저장하기 위한 변수로, 정수의 가장 큰 값으로 초기화하고 nums를 반복하여 최솟값을 넣어준다.           nums를 반복하여 result에 $num - min$ 값을 더해준다.            $n - 1$개의 요소를 1씩 증가시킬 수 있으므로, 현재 값에서 최솟값을 뺀 횟수만큼 증가하면 동일한 요소의 값으로 만들 수 있다.           반복이 완료되면 최소 횟수인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-moves-to-equal-array-elements/",
        "teaser": null
      },{
        "title": "Leetcode Java 4Sum II",
        "excerpt":"문제  Link   코드  class Solution {    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {     int length = nums1.length;     Arrays.sort(nums1);     Arrays.sort(nums2);     Arrays.sort(nums3);     Arrays.sort(nums4);     int min = Math.min(nums1[0] + nums2[0], -(nums3[length - 1] + nums4[length - 1]));     int max = Math.max(nums1[length - 1] + nums2[length - 1], -(nums3[0] + nums4[0]));     int[] map = new int[max - min + 1];     for (int num1 : nums1) {       for (int num2 : nums2) {         map[num1 + num2 - min]++;       }     }     int result = 0;     for (int num3 : nums3) {       for (int num4 : nums4) {         result += map[-num3 - num4 - min];       }     }     return result;   }  }   결과  Link   설명          네 정수 배열 nums1, nums2, nums3, nums4의 요소들의 합이 0이 되는 조합의 수를 구하는 문제이다.            num1, num2, nums3, nums4 모두 오름차순으로 정렬한다.       문제 풀이에 필요한 변수를 정의한다.            num1부터 nums4의 길이가 동일하므로, length에 nums1의 길이만 넣어준다.       min에 nums1[0]과 nums2[0]의 합과 nums3[$length - 1$]과 nums4[$length - 1$]의 합을 음수로 전환한 값 중 작은 값을 넣어준다.       max에 nums1[$length - 1$]과 nums2[$length - 1$]의 합과 nums3[0]과 nums4[0]의 합을 음수로 전환한 값 중 큰 값을 넣어준다.                    min과 max는 각 배열 내 값을 이용하여 배열의 범위를 좁히기 위한 임의 변수이다.                       각 경우의 수를 계산하기 위한 map을 $max - min + 1$ 크기의 정수 배열로 초기화한다.           nums1과 nums2를 순차적으로 모든 요소들을 사용하여 반복을 수행한다.            각 반복 간 map의 $num1 + num2 - min$ 위치의 값을 증가시킨다.           result를 0으로 초기화 하고, nums3와 nums4를 순차적으로 모든 요소들을 사용하여 반복을 수행한다.            각 반복 간 result에 map의 $-num3 - num4 - min$의 값을 더해준다.                    map의 범위를 좁히기 위해 사용된 min을 제외하고 $num1 + num2$의 값과 $-num3 - num4$의 값을 더한 값이 동일한 경우, 목표가 되는 네 값의 합이 0이 되는 경우가 되므로 result를 증가시키는 것이다.                           반복이 완료되면 조합의 수를 넣은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/4sum-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Assign Cookies",
        "excerpt":"문제  Link   코드  class Solution {    public int findContentChildren(int[] g, int[] s) {     Arrays.sort(g);     Arrays.sort(s);     int i = 0;     for (int j = 0; i &lt; g.length &amp;&amp; j &lt; s.length; j++) {       if (g[i] &lt;= s[j]) {         i++;       }     }     return i;   }  }   결과  Link   설명          아이들이 만족할 쿠키의 최소 크기인 g 배열과 각 크기 별 쿠키를 담은 j 배열을 이용하여 만족한 아이의 수를 구하는 문제이다.            주어진 정수 배열 g와 s를 오름차순으로 정렬한다.       g 배열을 탐색할 인덱스인 i를 0으로 초기화 하여 정의하고, 0부터 i가 g의 길이 미만이고 j가 s의 길이 미만일 때 까지 j를 증가시키며 반복을 수행한다.            g의 i번째 값이 s의 j번째 값보다 작거나 같으면 i를 증가시키고, 반복을 계속 수행한다.           반복이 완료되면 만족할 쿠키를 받은 아이들의 수를 저장한 i를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/assign-cookies/",
        "teaser": null
      },{
        "title": "Leetcode Java 132 Pattern",
        "excerpt":"문제  Link   코드  class Solution {    public boolean find132pattern(int[] nums) {     int length = nums.length;     int index = length;     int max = Integer.MIN_VALUE;     for (int idx = length - 1; idx &gt;= 0; idx--) {       if (nums[idx] &lt; max) {         return true;       }       while (index &lt; length &amp;&amp; nums[idx] &gt; nums[index]) {         max = nums[index++];       }       nums[--index] = nums[idx];     }     return false;   }  }   결과  Link   설명     배열 nums 내 132 패턴을 찾는 문제이다.            132 패턴은, i &lt; j &lt; k의 관계에서 nuns[i] &lt; nums[k] &lt; nums[j]의 관계가 성립하는 패턴이다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장하기 위한 변수로, nums의 길이로 초기화한다.       index는 nums를 역순으로 탐색하기 위한 변수로, length로 초기화한다.       max는 가장 큰 수를 저장하기 위한 변수로, 정수의 가장 작은 값으로 초기화한다.           $length - 1$부터 0까지 반복하여 아래를 수행한다.            nums의 idx 번째 값이 max보다 작으면 132 패턴을 만족하므로, true를 주어진 문제의 결과로 반환한다.       index가 length보다 작고 nums의 idx번째 값이 nums의 index번째 값보다 클 경우 max에 nums의 index번째 값을 넣고, index를 증가시킨다.       nums의 $index - 1$ 위치에 nums의 idx 번째 값을 넣고 반복을 계속 수행한다.           반복이 완료되면 132 패턴을 만족하는 수가 없으므로, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/132-pattern/",
        "teaser": null
      },{
        "title": "Leetcode Java Circular Array Loop",
        "excerpt":"문제  Link   코드  class Solution {    public boolean circularArrayLoop(int[] nums) {     int[] visited = new int[nums.length];     for (int idx = 0; idx &lt; nums.length; idx++) {       if (visited[idx] == 0 &amp;&amp; this.dfs(nums, visited, idx)) {         return true;       }     }     return false;   }    private boolean dfs(int[] nums, int[] visited, int start) {     if (visited[start] == 2) {       return false;     }     visited[start] = 1;     int next = (start + nums[start]) % nums.length;     if (next &lt; 0) {       next += nums.length;     }     if (next == start || nums[next] * nums[start] &lt; 0) {       visited[start] = 2;       return false;     } else if (visited[next] == 1) {       visited[start] = 2;       return true;     } else if (this.dfs(nums, visited, next)) {       return true;     } else {       visited[start] = 2;       return false;     }   }  }   결과  Link   설명     정수 배열인 nums를 이용하여 아래의 규칙으로 배열 내 값들을 계속 순회할 수 있는지 검증하는 문제이다.            nums[i]가 양수이면 nums[i] 값 만큼 앞으로 이동한다.       nums[i]가 음수이면 nums[i] 값 만큼 뒤로 이동한다.       위의 규칙대로 수행하여 시퀀스는 seq[0] -&gt; seq[1] -&gt; … -&gt; seq[k - 1] -&gt; seq[0] -&gt; … 형태로 반복이 되어야 한다.                visited 배열을 nums의 길이만큼의 정수 배열로 초기화한다.            0부터 nums의 길이 미만까지 idx를 증가시키며 visited의 idx번째 값이 0이고, 4번에서 정의한 dfs(int[] nums, int[] visited, int start) 메서드의 결과가 true이면 주어진 문제의 결과로 true를 반환한다.       nums 내 요소들을 이용하여 검증을 수행할 dfs(int[] nums, int[] visited, int start) 메서드를 정의한다.            visited의 start번째 값이 2인 경우, 이미 검증한 단계이므로 false를 반환한다.       visited의 start번째 값에 검증을 진행하고 있다는 의미로 1을 넣어준다.       next에 $start + nums[start]$의 값에서 nums의 길이만큼 나눈 나머지 값을 넣어주고, next가 0 미만인 경우 nums.length를 추가해준다.       next가 start와 동일하거나 nums의 next번째 값과 nums의 start번째 값의 곱이 0 미만인 경우, visited의 start번째 값을 2로 넣어주고 false를 반환한다.                    nums의 next번째 값과 nums의 start번째 값의 곱이 0 미만인 음수인 경우는 next번째 위치와 start번째 위치를 번갈아 이동하므로 순회한다고 볼 수 없다.                       visited의 next번째 값이 1인 경우 visited의 start번째 값을 2로 넣어주고 true를 반환한다.                    위의 경우가 아니면 정상적으로 순회하는 경우이다.                       next의 값을 이용해 재귀 호출한 결과가 true인 경우, true를 반환한다.                    현재 위치까지는 순회하지 않지만, next의 값에서 순회하는 경우이다.                       그 외의 경우 visited의 start번째 값을 2로 바꿔주고 false를 반환한다.                    그 외의 경우 순회하는 경우가 아니다.                           반복이 완료되면 각 요소를 이용하여 사이클이 이루어지지 않으므로, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/circular-array-loop/",
        "teaser": null
      },{
        "title": "Leetcode Java Poor Pigs",
        "excerpt":"문제  Link   코드  class Solution {    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {     int pigs = 0;     while (Math.pow((minutesToTest / minutesToDie) + 1, pigs) &lt; buckets) {       pigs++;     }     return pigs;   }  }   결과  Link   설명     minutesToTest 시간(분) 동안 테스트를 수행하여 어떤 양동이가 독성이 있는지 확인하기 위한 최소한의 돼지의 수를 구하는 문제이다.            buckets 개수의 양동이 내 독성이 있는 양동이가 하나 포함되어 있는데 이 독성은 minutesToDie 시간(분)이 지나면 효과가 발생하여 돼지가 죽는다.       minutesToTest 시간(분)까지 아래 과정을 반복한다.                    돼지를 골라 먹이를 줄 양동이를 선택하여 모두 소비하고, 다른 돼지들에게 먹이를 주지 않는다.           먹이를 먹은 후 minutesToDie 시간(분)까지 기다려 죽는지 확인한다.                                돼지의 수를 저장할 pigs를 0으로 초기화한다.       $\\frac{minutesToTest}{minutesToDie} + 1$를 pigs번 거듭 제곱한 결과가 buckets 미만일 때 까지 반복하여 pigs를 증가시킨다.            양동이가 $5 \\times 5$ 개의 경우, 두 마리의 돼지로 행, 열을 유추하여 독이 있는 양동이를 찾을 수 있다.       양동이가 $5 \\times 5 \\times 5$ 개의 경우, 세 마리의 돼지로 행, 열, 높이를 유추하여 독이 있는 양동이를 찾을 수 있다.       이런 방식으로 pigs를 증가시키고 이를 이용하여 거듭 제곱한 결과를 이용하여 $(\\frac{minutesToTest}{minutesToDie} + 1)^{pigs}$개의 양동이를 처리할 수 있다.           반복이 완료되면 돼지의 수인 pigs를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/poor-pigs/",
        "teaser": null
      },{
        "title": "Leetcode Java Repeated Substring Pattern",
        "excerpt":"문제  Link   코드  class Solution {    public boolean repeatedSubstringPattern(String s) {     int length = s.length();     for (int index = 1; index &lt;= length / 2; index++) {       if (length % index == 0) {         String pattern = s.substring(0, index);         boolean isRepeated = true;         for (int curr = length - index; curr &gt; 0; curr -= index) {           if (!pattern.equals(s.substring(curr, curr + index))) {             isRepeated = false;             break;           }         }         if (isRepeated) {           return true;         }       }     }     return false;   }  }   결과  Link   설명          문자열 s가 반복된 문자열로 이루어져 있는지 검증하는 문제이다.            length s의 길이를 에 저장할 변수로, s의 길이로 초기화한다.       반복되는 문자열의 최대 길이는 해당 문자열의 절반이므로, 1부터 $\\frac{length}{2}$ 이하까지 index를 증가시키며 아래를 반복한다.            length를 index로 나눈 나머지가 0이 아니면 다음 반복을 진행한다.       pattern에 s의 처음부터 index번째 자리 이전까지 잘라 반복이 되는 패턴으로 저장한다.       isRepeated를 true로 초기화한다.       curr를 $length - index$부터 0초과까지 curr를 index만큼 감소시키며 아래의 반복을 수행한다.                    pattern이 s의 curr번째 자리부터 $curr + index$ 번째 자리 이전까지 잘라 동일한지 검증하여, 동일하지 않은 경우 isRepeated를 false로 변경하고 반복을 종료한다.                       반복이 완료되고 isRepeated가 true인 경우 반복이 성립되므로, true를 주어진 문제의 결과로 반환한다.           반복이 완료되면 false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/repeated-substring-pattern/",
        "teaser": null
      },{
        "title": "Leetcode Java LFU Cache",
        "excerpt":"문제  Link   코드  class LFUCache {    private Node head;   private Node tail;    private Map&lt;Integer, Node&gt; map;   private Map&lt;Integer, Node&gt; frequency;   private int capacity;    public LFUCache(int capacity) {     this.head = new Node(-1, -1, -1);     this.tail = new Node(-1, -1, -1);     this.head.next = this.tail;     this.tail.prev = this.head;     this.map = new HashMap&lt;&gt;();     this.frequency = new HashMap&lt;&gt;();     this.capacity = capacity;   }    public int get(int key) {     if (this.map.containsKey(key)) {       Node node = this.map.get(key);       this.update(node);       return node.val;     } else {       return -1;     }   }    public void put(int key, int value) {     if (this.capacity == 0) {       return;     } else if (this.map.containsKey(key)) {       Node node = this.map.get(key);       node.val = value;       this.update(node);     } else {       Node node = new Node(key, value);       if (this.map.size() == this.capacity) {         Node temp = this.head.next;         this.remove(temp);         this.map.remove(temp.key);       }       this.map.put(key, node);       this.insert(this.frequency.getOrDefault(1, this.head), node);     }   }    private void update(Node node) {     Node temp;     if (this.frequency.containsKey(node.count + 1)) {       temp = this.frequency.get(node.count + 1);     } else {       temp = this.frequency.get(node.count);       if (temp == node) {         temp = temp.prev;       }     }     this.remove(node);     node.count++;     this.insert(temp, node);   }    private void remove(Node node) {     if (node.prev.count != node.count &amp;&amp; node.count != node.next.count) {       this.frequency.remove(node.count);     } else if (node == frequency.get(node.count)) {       this.frequency.put(node.count, node.prev);     }     Node next = node.next;     Node prev = node.prev;     prev.next = next;     next.prev = prev;     node.next = null;     node.prev = null;   }    private void insert(Node prev, Node curr) {     Node next = prev.next;     next.prev = curr;     curr.next = next;     curr.prev = prev;     prev.next = curr;     this.frequency.put(curr.count, curr);   }  }  class Node {    public Node prev;   public Node next;    public int val;   public int key;   public int count;    public Node(int key, int val) {     this.key = key;     this.val = val;     this.count = 1;   }    public Node(int key, int val, int count) {     this.key = key;     this.val = val;     this.count = count;   }  }  /**  * Your LFUCache object will be instantiated and called as such:  * LFUCache obj = new LFUCache(capacity);  * int param_1 = obj.get(key);  * obj.put(key,value);  */   결과  Link   설명     LFU(Least Frequently Used) 캐시의 데이터 구조를 설계하고 구현하는 문제이다.            생성자인 LFUCache(int capacity)는 데이터를 담을 한계인 capacity를 이용하여 LFUCache 객체를 초기화한다.       메서드인 get(int key)은 key에 해당하는 캐시를 반환한다. 존재하지 않는 경우 -1을 반환한다.       메서드인 put(int key, int value)은 key에 해당하는 캐시가 존재하면 value로 수정하고, 존재하지 않는 경우 추가한다.                    캐시를 추가할 경우, 캐시의 수가 capacity에 도달하면 자주 사용하지 않은 캐시를 제거하고 추가한다.           위의 경우 동일한 빈도를 가진 노드가 존재하면 자주 사용하지 않은 캐시를 제거한다.                           데이터 연결에 필요한 Node 클래스의 전역 변수를 정의한다.            prev는 이전 노드를 연결하기 위한 변수이다.       next는 다음 노드를 연결하기 위한 변수이다.       val은 캐시에 해당하는 값을 저장하기 위한 변수이다.       key는 캐시에 해당하는 키를 저장하기 위한 변수이다.       count는 해당 캐시가 발생한 횟수를 저장하기 위한 변수이다.           데이터 연결에 필요한 Node 클래스의 생성자를 정의한다.            key와 val로 Node를 생성하는 경우, count를 1로 초기화한다.       key와 val, count로 Node를 생성하는 경우, 각 값을 객체에 넣어 초기화한다.           문제 풀이에 필요한 변수를 정의한다.            head와 tail은 노드를 이어줄 경우, 가장 앞과 뒤의 캐시를 노드로 만들어 저장할 변수이다.       map은 key에 해당하는 캐시를 노드로 저장하기 위한 변수이다.       frequency는 노드의 발생 빈도 별 캐시를 노드로 저장하기 위한 변수이다.           생성자인 LFUCache(int capacity)를 완성한다.            head와 tail를 key, value, count를 -1로 생성한 Node를 넣어준다.       head의 next에 tail을, tail의 prev에 head를 넣어 이어준다.       map과 frequency를 HashMap으로 초기화한다.       capacity에 주입된 capacity를 넣어준다.           캐시의 변경을 위해 update(Node node) 메서드를 정의한다.            temp 노드를 아래 경우에 따라 넣어준다.                    node의 $count + 1$ 번 발생한 노드가 frequency에 존재하는 경우, temp에 해당 노드를 넣어준다.           node의 $count + 1$ 번 발생한 노드가 frequency에 존재하지 않는 경우, temp에 node의 count번 발생한 노드를 frequency에서 찾아 넣어주고 temp와 node가 같으면 temp의 prev 노드를 temp에 넣어준다.                       7번에서 정의한 remove(Node node) 메서드를 이용하여 node를 제거해준다.       node의 count를 증가시키고, 8번에서 정의한 insert(Node prev, Node curr) 메서드를 temp와 node순으로 넣어 수행한다.           캐시의 삭제를 위해 remove(Node node) 메서드를 정의한다.            node와 node의 prev와 next count가 모두 다른 경우, frequency에서 node의 count에 해당하는 노드를 삭제한다.       위의 경우가 아니고 node가 frequency의 node의 count가 key인 노드와 동일한 경우, frequency 내 node의 count가 key인 값을 node의 prev 노드로 넣어 해당 노드를 끊어준다.       node의 next 노드와 prev 노드를 각각 정의하여 현재 node를 배제하여 연결시켜준다.           캐시의 삽입을 위해 insert(Node prev, Node curr) 메서드를 정의한다.            prev 자리에 curr 노드를 넣어주고, prev와 curr을 이어준다.       frequency 내 curr의 count가 키인 노드에 curr을 넣어준다.           메서드인 get(int key)을 완성한다.            map에 key가 키인 노드가 존재하는 경우, 아래를 수행한다.                    map에서 key가 키인 노드를 가져와 해당 노드로 6번에서 정의한 update(Node node) 메서드를 수행하여 캐시 발생 빈도를 증가하여 갱신해준다.           위에서 가져온 node의 val 값을 반환한다.                       위의 경우가 아니면 문제에서 요구한 -1을 반환한다.           메서드인 put(int key, int value)을 완성한다.            capacity가 0인 경우 캐시 저장이 불가능하므로, 아무것도 수행하지 않는다.       map에 key가 키인 노드가 존재하는 경우, 아래를 수행한다.                    map에서 key가 키인 노드를 가져와 val 값에 value를 넣어준다.           위에서 가져온 노드로 6번에서 정의한 update(Node node) 메서드를 수행하여 캐시 발생 빈도와 값을 갱신해준다.                       그 외의 경우 아래를 수행한다.                    node에 key와 value를 이용한 새 노드를 정의해 넣어준다.           map의 크기가 capacity와 동일한 경우, head의 next 노드를 7번에서 정의한 remove(Node node) 메서드로 삭제하고 map에서도 해당 key에 해당하는 캐시를 삭제한다.           map에 key에 해당 하는 키에 node를 넣어준다.           8번에서 정의한 insert(Node prev, Node curr) 메서드를 이용하여 frequency에 1번 발생한 캐시의 노드가 있으면 해당 노드를, 없으면 head를 prev자리에 node를 curr 자리에 넣어 수행하여 새 캐시를 이어준다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/lfu-cache/",
        "teaser": null
      },{
        "title": "Leetcode Java Hamming Distance",
        "excerpt":"문제  Link   코드  class Solution {    public int hammingDistance(int x, int y) {     int bit = x ^ y;     int count = 0;     while (bit != 0) {       bit ^= bit &amp; -bit;       count++;     }     return count;   }  }   결과  Link   설명          두 정수 x와 y의 해밍 거리(Hamming distance)를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            bit는 해밍 거리를 구하기 위한 두 수의 비트의 차이를 넣을 변수로, x와 y의 XOR(^) 비트 연산 결과로 초기화한다.       count는 해밍 거리를 세기 위한 변수로, 0으로 초기화한다.           bit가 0이 아닐 때까지 반복하여 아래를 수행한다.            bit와 -bit의 AND(&amp;) 비트 연산의 결과와 bit의 XOR(^) 비트 연산의 결과를 bit에 다시 넣어준다.       해밍 거리를 저장하는 count를 증가시킨다.           반복이 완료되면 해밍 거리를 저장한 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/hamming-distance/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Moves to Equal Array Elements II",
        "excerpt":"문제  Link   코드  class Solution {    public int minMoves2(int[] nums) {     Arrays.sort(nums);     int left = 0;     int right = nums.length - 1;     int move = 0;     while (left &lt; right) {       move += nums[right--] - nums[left++];     }     return move;   }  }   결과  Link   설명     nums 배열내 모든 요소의 값을 동일하게 만들기 위한 횟수를 구하는 문제이다.            한 번에 배열의 한 요소를 1씩 증가 혹은 감소시킬 수 있다.                문제 풀이 전 nums 배열 내 값들을 오름차순으로 정렬해준다.       문제 풀이에 필요한 변수를 정의한다.            left는 정렬된 nums의 작은 값부터 탐색하기 위한 변수로, 0으로 초기화한다.       right는 정렬된 nums의 큰 값부터 탐색하기 위한 변수로, nums의 길이보다 1 작게 초기화한다.       move는 nums 배열 내 모든 요소의 값을 동일하게 만들기 위한 횟수를 저장하기 위한 변수로, 0으로 초기화한다.           left가 right보다 작을 때 까지 반복하여 아래를 수행한다.            move에 nums의 right번째 값과 left번째 값의 차이를 더해서 배열 내 값을 동일하게 만들기 위한 증감 폭을 계산한다.       right를 감소시키고, left를 증가시킨 후 반복을 계속 수행한다.           반복이 완료되면 계산된 횟수인 move를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-moves-to-equal-array-elements-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Island Perimeter",
        "excerpt":"문제  Link   코드  class Solution {    public int islandPerimeter(int[][] grid) {     int border = 0;     for (int i = 0; i &lt; grid.length; i++) {       for (int j = 0; j &lt; grid[0].length; j++) {         if (grid[i][j] == 1) {           border += 4;           if (i &gt; 0 &amp;&amp; grid[i - 1][j] == 1) {             border -= 2;           }           if (j &gt; 0 &amp;&amp; grid[i][j - 1] == 1) {             border -= 2;           }         }       }     }     return border;   }  }   결과  Link   설명     섬의 지도 역할을 하는 grid의 섬 둘레를 구하는 문제이다.            육지는 $grid[i][j] = 1$, 해상은 $grid[i][j] = 0$으로 표현한다.                섬의 둘레를 계산할 border를 0으로 정의한다.       0부터 grid의 행 개수 전까지 i를 증가시키며, 0부터 grid의 열 개수 전까지 j를 증가시키며 아래를 반복한다.            grid[i][j]의 값이 육지인 1인 경우 아래를 수행한다.                    해당 위치가 육지이므로, 둘레를 4 증가시킨다.           i가 0 초과이며 해당 위치의 좌측 칸인 grid[$i - 1$][j]의 값이 1이면 두 육지가 연결되는 지점을 두 육지에서 제거해야 하므로, border를 2 감소시킨다. (예를 들어, 육지 한 칸의 둘레는 4이고, 육지 두 칸의 둘레는 6이다.)           j가 0 초과이며 해당 위치의 위 칸인 grid[i][$j - 1$]의 값이 1이면 위와 동일한 이유로, border를 2 감소시킨다.                           반복이 완료되면 계산된 섬의 둘레를 저장한 border를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/island-perimeter/",
        "teaser": null
      },{
        "title": "Leetcode Java Can I Win",
        "excerpt":"문제  Link   코드  class Solution {    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {     if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 &lt; desiredTotal) {       return false;     } else if (maxChoosableInteger &gt;= desiredTotal) {       return true;     } else {        return this.dfs(maxChoosableInteger, desiredTotal, new boolean[1 &lt;&lt; maxChoosableInteger], 0);     }   }    private boolean dfs(int maxChoosableInteger, int desiredTotal, boolean[] dp, int curr) {     if (dp[curr]) {       return dp[curr];     }     for (int idx = 0; idx &lt; maxChoosableInteger; idx++) {       if ((curr &amp; 1 &lt;&lt; idx) != 0) {         continue;       } else if (idx + 1 &gt;= desiredTotal || !this.dfs(maxChoosableInteger, desiredTotal - idx - 1, dp, curr | 1 &lt;&lt; idx)) {         dp[curr] = true;         return true;       }     }     return false;   }  }   결과  Link   설명     두 사람이 아래의 규칙대로 게임을 하여 처음 시작한 사람이 무조건 이기는 게임인지를 검증하는 문제이다.            첫 번째 사람부터 1에서부터 maxChoosableInteger까지 숫자를 골라 번갈아 숫자를 선택한다.       번갈아 고른 수의 합이 desiredTotal 이상 되는 사람이 이긴다.       단, 고른 숫자는 다시 선택할 수 없다.                $maxChoosableInteger \\times \\frac{maxChoosableInteger + 1}{2}$의 결과가 desiredTotal보다 작은 경우 선택 할 수 있는 숫자의 합이 desiredTotal에 미치지 못하므로 둘 다 이길 수 없어, false를 주어진 문제의 결과로 반환한다.            maxChoosableInteger이 desiredTotal보다 크거나 같은 경우 처음 시작한 사람이 무조건 이기므로, true를 주어진 문제의 결과로 반환한다.            2, 3번의 경우가 아닌 경우 5번에서 정의한 dfs(int maxChoosableInteger, int desiredTotal, boolean[] dp, int curr) 메서드를 dp에 1의 비트를 좌측으로 maxChoosableInteger번 이동 시킨 크기의 부울 배열을 넣어 수행하여 처음 시작하는 사람이 무조건 이기는지 검증한 결과를 주어진 문제의 결과로 반환한다.       DFS 방식으로 처음 시작하는 사람이 이기는지 검증할 dfs(int maxChoosableInteger, int desiredTotal, boolean[] dp, int curr)메서드를 정의한다.            dp의 curr번째 값이 true인 경우 처음 시작하는 사람이 이기는지 검증이 되었으므로, true를 반환한다.       0부터 maxChoosableInteger 미만까지 idx를 증가시키며 아래를 반복한다.                    curr과 1의 AND(&amp;) 비트 연산의 결과를 idx번 좌측으로 이동시킨 결과가 0이 아닌 경우, 무시하고 다음 반복을 수행한다.           $idx + 1$이 desiredTotal 이상이거나 desiredTotal 자리에 $desiredTotal - idx - 1$을, curr 자리에 curr과 1의 OR(|) 비트 연산의 결과를 idx번 좌측으로 이동시킨 결과를 넣어 재귀호출을 수행한 결과가 true이면, dp의 curr번째 값을 true로 변경하고 true를 반환한다.                       반복이 정상적으로 완료되는 경우 첫 번째 사람이 무조건 이기는 경우가 아니므로, false를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/can-i-win/",
        "teaser": null
      },{
        "title": "Leetcode Java Unique Substrings in Wraparound String",
        "excerpt":"문제  Link   코드  class Solution {    public int findSubstringInWraproundString(String p) {     char[] charArray = p.toCharArray();     int[] max = new int[26];     max[charArray[0] - 'a'] = 1;     int sum = 1;     int length = 1;     for (int idx = 1; idx &lt; p.length(); idx++) {       int diff = charArray[idx] - charArray[idx - 1];       if (diff == 1 || diff == -25) {         length++;       } else {         length = 1;       }       int index = charArray[idx] - 'a';       if (length &gt; max[index]) {         sum += length - max[index];         max[index] = length;       }     }     return sum;   }  }   결과  Link   설명     문자열 s에 존재하는 문자열 p의 고유한 하위 부분 문자열의 수를 구하는 문제이다.            문자열 s는 “…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd…“처럼 알파벳 소문자인 “abcdefghijklmnopqrstuvwxyz”가 이어져 있는 문자열이다.           문제 풀이에 필요한 변수를 정의한다.            charArray는 p를 문자의 배열로 보관할 변수로, p를 문자의 배열로 변환하여 넣어준다.       max는 charArray의 문자 별 최대 고유 하위 문자열의 길이를 저장할 변수로, 영문자의 개수인 26 크기로 초기화하고 charArray의 첫 번째 문자에 ‘a’를 뺀 위치에 1을 넣어준다.       sum은 고유한 하위 문자열의 수를 계산할 변수로, 첫 번째 문자가 위에서 포함되었으므로 1로 초기화한다.       length는 고유한 하위 문자열의 길이를 저장할 변수로, sum과 동일한 이유로 1로 초기화한다.           1부터 p의 길이 전까지 idx를 증가시키며 아래를 반복 수행한다.            charArray의 idx번째 값과 $idx -1$번째 값의 차이가 1이거나 -25인 경우, length를 증가시킨다.       위의 경우가 아니라면 length를 1로 초기화 시킨다.       index에 charArray의 idx번째 값에 ‘a’를 뺀 값을 넣어준다.       length가 max의 index번째 값보다 큰 경우, sum에 $length - max[index]$ 값을 더해주고 max의 index번째 위치에 length를 넣어준다.           반복이 완료되면 고유한 하위 부분 문자열의 수인 sum을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/unique-substrings-in-wraparound-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Validate IP Address",
        "excerpt":"문제  Link   코드  class Solution {    public String validIPAddress(String queryIP) {     if (this.isIPv4(queryIP)) {       return \"IPv4\";     } else if (this.isIPv6(queryIP)) {       return \"IPv6\";     } else {       return \"Neither\";     }   }    private boolean isIPv4(String queryIP) {     String[] octets = queryIP.split(\"\\\\.\", -1);     if (octets.length != 4) {       return false;     }     for (String octet : octets) {       if (octet.length() == 0 || octet.length() &gt; 3 || (octet.charAt(0) == '0' &amp;&amp; octet.length() != 1)) {         return false;       }       int num = 0;       for (int c : octet.toCharArray()) {         if (c &gt;= '0' &amp;&amp; c &lt;= '9') {           num = (num * 10) + (c - '0');         } else {           return false;         }       }       if (num &gt; 255) {         return false;       }     }     return true;   }    private boolean isIPv6(String queryIP) {     String[] octets = queryIP.split(\":\", -1);     if (octets.length != 8) {       return false;     }     for (String octet : octets) {       if (octet.length() &gt; 4 || octet.length() == 0) {         return false;       }       for (int c : octet.toCharArray()) {         if (!((c &gt;= '0' &amp;&amp; c &lt;= '9') || (c &gt;= 'a' &amp;&amp; c &lt;= 'f') || (c &gt;= 'A' &amp;&amp; c &lt;= 'F'))) {           return false;         }       }     }     return true;   }  }   결과  Link   설명     문자열 queryIP가 유효한 IP인지를 검증하는 문제이다.            IP는 “IPv4”와 “IPv6” 두 버전의 경우 해당 문자열을 반환하고, 그 외의 경우 “Neither” 문자열을 반환한다.           queryIP가 IPv4인지 검증하기 위한 isIPv4(String queryIP) 메서드를 정의한다.            queryIP를 마침표(“.”) 기준으로 분리해서 octets에 넣어준다.       octets의 길이가 4가 아닌 경우 유효한 IPv4 구조가 아니므로, false를 반환한다.       octets의 모든 값들을 아래를 통해 검증한다.                    octet의 길이가 0이거나 3을 초과하거나 첫 값이 0으로 시작하지만 한 글자가 아닌 경우 IPv4의 유효한 octet이 아니므로, false를 반환한다.           num을 0으로 정의하여 octet의 모든 값들을 정수로 치환한 값을 넣어주고, 정수가 아닌 값이 존재하면 false를 반환한다.           num이 255를 초과하는 경우도 유효한 IPv4 구조가 아니므로, false를 반환한다.                       반복이 완료되면 queryIP가 유효한 IPv4이므로, true를 반환한다.           queryIP가 IPv6인지 검증하기 위한 isIPv6(String queryIP) 메서드를 정의한다.            queryIP를 콜론(“:”) 기준으로 분리해서 octets에 넣어준다.       octets의 길이가 8이 아닌 경우 유효한 IPv6 구조가 아니므로, false를 반환한다.                    octets의 모든 값을 아래를 통해 검증한다.           octet의 길이가 0이거나 4초과인 경우 IPv6의 유효한 octet이 아니므로, false를 반환한다.           octet의 모든 문자들이 0 ~ 9, a ~ z, A ~ F외 문자가 들어가는 경우, IPv6의 유효한 octet이 아니므로 false를 반환한다.                       반복이 완료되면 queryIP가 유효한 IPv6이므로, true를 반환한다.           아래의 각 경우에 따라 문자열을 주어진 문제의 결과로 반환한다.            2번에서 정의한 isIPv4(String queryIP) 메서드의 수행 결과가 true이면, “IPv4”를 주어진 문제의 결과로 반환한다.       3번에서 정의한 isIPv6(String queryIP) 메서드의 수행 결과가 true이면, “IPv6”를 주어진 문제의 결과로 반환한다.       그 외의 경우 유효한 IP 구조가 아니므로, “Neither”를 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/validate-ip-address/",
        "teaser": null
      },{
        "title": "Leetcode Java Implement Rand10() Using Rand7()",
        "excerpt":"문제  Link   코드  /**  * The rand7() API is already defined in the parent class SolBase.  * public int rand7();  * @return a random integer in the range 1 to 7  */ class Solution extends SolBase {    public int rand10() {     while (true) {       int num = (7 * (super.rand7() - 1)) + super.rand7();       if (num &lt;= 40) {         return (num % 10) + 1;       }     }   }  }   결과  Link   설명          1 ~ 7까지 균등한 임의 정수를 반환하는 rand7() API가 주어지면, 해당 API만 활용하여 1 ~ 10까지 균등한 임의 정수를 반환하는 rand10() 메서드를 완성하는 문제이다.            아래를 만족하여 결과를 반환하기 전까지 계속 반복을 수행한다.             num에 $7 \\times (super.rand7() - 1) + super.rand7()$의 결과를 넣어준다.                    $rand7() - 1$은 0 ~ 6까지의 정수가 가능하며, 7을 곱해주면 0 ~ 42까지 정수가 가능하다.           위의 값에 rand7()의 결과를 더하면 0 ~ 49까지 정수로 이루어질 수 있다.                       num의 결과가 40 이하인 경우, $\\frac{num}{10} + 1$ 결과를 반환한다.                    0 ~ 49까지 정수를 10으로 나눈 나머지는 0 ~ 9로 이루어지며, 1을 더해주면 균등한 확률의 1 ~ 10까지 정수로 생성된다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/implement-rand10-using-rand7/",
        "teaser": null
      },{
        "title": "Leetcode Java Concatenated Words",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; findAllConcatenatedWordsInADict(String[] words) {     Arrays.sort(words, (a, b) -&gt; a.length() - b.length());     TrieNode root = new TrieNode();     List&lt;String&gt; result = new ArrayList&lt;&gt;();     for (String word : words) {       if (this.isAddable(root, word)) {         result.add(word);       }     }     return result;   }    private boolean isAddable(TrieNode root, String word) {     TrieNode curr = root;     for (int idx = 0; idx &lt; word.length(); idx++) {       int num = word.charAt(idx) - 'a';       if (curr.children[num] == null) {         curr.children[num] = new TrieNode();       }       curr = curr.children[num];       if (curr.isWord &amp;&amp; idx &lt; word.length() - 1 &amp;&amp; this.isContains(root, word.substring(idx + 1))) {         return true;       }     }     curr.isWord = true;     return false;   }    private boolean isContains(TrieNode root, String word) {     TrieNode curr = root;     for (int idx = 0; idx &lt; word.length(); idx++) {       int num = word.charAt(idx) - 'a';       if (curr.children[num] == null) {         return false;       }       curr = curr.children[num];       if (curr.isWord &amp;&amp; idx &lt; word.length() - 1 &amp;&amp; this.isContains(root, word.substring(idx + 1))) {         return true;       }     }     return curr.isWord;   }  }  class TrieNode {    public boolean isWord;   public TrieNode[] children;    public TrieNode() {     this.children = new TrieNode[26];   }  }   결과  Link   설명          words 내 문자들을 2개 이상 조합해서 나올 수 있는 모든 문자열을 구하는 문제이다.       문제 풀이에 필요한 TrieNode 클래스를 정의한다.            isWord는 해당 단어까지의 문자열이 단어로 존재하는지 여부를 저장하는 변수이다.       children은 해당 단어까지의 문자열 이후의 문자열을 이어주기 위한 변수로, 객체 생성 시 다음 문자를 저장하기 위해 알파벳의 개수인 26 크기의 TrieNode 배열로 초기화 한다.                words 내 단어들을 길이 별로 정렬을 수행한다.       문제 풀이에 필요한 변수를 정의한다.            root는 문자를 Trie로 구성하기 위해 TrieNode를 새로 생성해서 넣어준다.       reulst는 조합한 문자열을 넣어주기 위한 변수로, ArrayList로 정의한다.           words내 단어들을 모두 반복한다.            6번에서 정의한 isAddable(TrieNode root, String word)가 true인 경우, reulst에 word를 넣어준다.           결과에 포함할 수 있는지를 검증하기 위한 isAddable(TrieNode root, String word) 메서드를 정의한다.            root를 curr에 넣어준다.       0부터 word의 길이 전까지 idx를 증가시키며 아래를 수행한다.                    num에 word의 idx번째 문자를 ‘a’를 뺀 영소문자 인덱스를 넣어준다.           curr 내 children의 num번째 값이 null인 경우, 새 TrieNode를 넣어 초기화한다.           curr에 children의 num번째 TrieNode를 넣어 단어를 넣을 준비를 한다.           curr의 isWord가 true이고 마지막 단어가 아니며 7번에서 정의한 isContains(TrieNode root, String word)에 word를 $idx + 1$번째 글자부터 끝까지의 단어로 수행한 결과가 true이면 결과에 추가할 단어가 되므로, true를 반환한다.                       반복이 완료되면 curr의 isWord를 true로 바꾸고, false를 반환한다.           6번과 유사하지만 해당 단어가 포함되어있는지 검증하기 위한 isContains(TrieNode root, String word) 메서드를 정의한다.            root를 curr에 넣어준다.       0부터 word의 길이 전까지 idx를 증가시키며 아래를 수행한다.                    num에 word의 idx번째 문자를 ‘a’를 뺀 영소문자 인덱스를 넣어준다.           curr 내 children의 num번째 값이 null인 경우 존재하지 않으므로, false를 반환한다.           curr에 children의 num번째 TrieNode를 넣어 검증을 수행할 준비를 한다.           curr의 isWord가 true이고 마지막 단어가 아니며 7번에서 정의한 isContains(TrieNode root, String word)에 word를 $idx + 1$번째 글자부터 끝까지의 단어로 수행한 결과가 true이면 포함된 단어이므로, true를 반환한다.                       반복이 완료되면 curr의 isWord를 반환한다.           반복이 완료되면 부분 문자열을 넣은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/concatenated-words/",
        "teaser": null
      },{
        "title": "Leetcode Java Matchsticks to Square",
        "excerpt":"문제  Link   코드  class Solution {    public boolean makesquare(int[] nums) {     int sum = 0;     for (int num : nums) {       sum += num;     }     if (sum % 4 != 0) {       return false;     }     Arrays.sort(nums);     return this.dfs(nums, new boolean[nums.length], 0, sum / 4, 0, 1);   }    private boolean dfs(int[] nums, boolean[] dp, int curr, int target, int sum, int group) {     if (group == 4) {       return true;     } else if (sum == target) {       return this.dfs(nums, dp, 0, target, 0, group + 1);     } else if (sum &gt; target) {       return false;     } else {       for (int idx = curr; idx &lt; nums.length; idx++) {         if (dp[idx] || (idx &gt; 0 &amp;&amp; nums[idx - 1] == nums[idx] &amp;&amp; !dp[idx - 1])) {           continue;         }         dp[idx] = true;         if (this.dfs(nums, dp, idx + 1, target, sum + nums[idx], group)) {           return true;         }         dp[idx] = false;       }       return false;     }   }  }   결과  Link   설명          성냥개비의 길이가 담긴 nums를 이용하여 정사각형을 만들 수 있는지 검증하는 문제이다.            nums 내 모든 값들을 sum에 더해서 넣어준다.            sum을 4로 나눈 나머지가 0이 아니면 정사각형을 만들 수 없으므로, false를 주어진 문제의 결과로 반환한다.            nums를 오름차순으로 정렬하고, 5번에서 정의한 dfs(int[] nums, boolean[] dp, int curr, int target, int sum, int group) 메서드로 정사각형을 만들 수 있는지 여부를 확인하여 해당 결과를 주어진 문제의 결과로 반환한다.            정사각형을 만들 수 있는지 여부를 검증하기 위한 dfs(int[] nums, boolean[] dp, int curr, int target, int sum, int group) 메서드를 정의한다.             group이 4인 경우 정사각형의 네 번째 변까지 완성 가능하므로, true를 반환한다.       sum이 target인 경우 target 번째 변을 완성했으므로, group을 1 증가시켜서 재귀 호출을 수행한 결과를 반환한다.       sum이 target보다 큰 경우 target번째 변이 다른 변보다 길어서 정사각형을 만들 수 없으므로, false를 반환한다.       그 외의 경우 curr부터 nums의 길이 미만까지 idx를 증가시키며 반복을 수행한다.                    dp의 idx번째 값이 true이면 이미 검증된 항목이고, idx가 0 초과이며 nums의 $idx - 1$번째 값과 idx번째 값이 같으면서 dp의 $idx - 1$번째 값이 false인 경우 동일 값이 이어지므로 다음 반복을 수행한다.           해당 위치를 다녀왔다는 의미로 dp의 idx번째 값을 true로 변경한다.           curr에 $idx + 1$ 값을 넣고, sum에 sum과 nums의 idx번째 값의 합을 넣고 재귀 호출을 수행한 결과가 true인 경우 정사각형을 만들 수 있으므로, true를 반환한다.           dp의 idx번째 값을 false로 다시 변경하여 다음 반복을 수행한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/matchsticks-to-square/",
        "teaser": null
      },{
        "title": "Leetcode Java Ones and Zeroes",
        "excerpt":"문제  Link   코드  class Solution {    public int findMaxForm(String[] strs, int m, int n) {     int[][] dp = new int[m + 1][n + 1];     for (String s : strs) {       int[] count = new int[2];       for (char c : s.toCharArray()) {         if (c == '0') {           count[0]++;         } else {           count[1]++;         }       }       for (int i = m; i &gt;= count[0]; i--) {         for (int j = n; j &gt;= count[1]; j--) {           dp[i][j] = Math.max(dp[i][j], 1 + dp[i - count[0]][j - count[1]]);         }       }     }     return dp[m][n];   }  }   결과  Link   설명          이진수로 이루어진 문자열의 배열인 strs 내 m개의 0과 n개의 1로 구성할 수 있는 부분 집합의 최대 개수를 구하는 문제이다.            dp를 $m + 1$과 $n + 1$ 크기로 정의한다.       strs의 모든 값들을 반복하여 아래를 수행한다.            count 배열을 2 크기로 정의하여 0과 1의 개수를 각각 넣어준다.       m부터 count[0]까지 i를 감소시키고, n부터 count[1]까지 j를 감소시키며 반복을 수행한다.                    dp[i][j]의 값에 dp[i][j]와 dp[$i - count[0]$][$j - count[1]$]에 1을 더한 값 중 큰 값을 넣어준다.                           반복이 완료되면 부분 집합의 최대 개수인 dp[m][n]를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/ones-and-zeroes/",
        "teaser": null
      },{
        "title": "Leetcode Java Heaters",
        "excerpt":"문제  Link   코드  class Solution {    public int findRadius(int[] houses, int[] heaters) {     Arrays.sort(houses);     Arrays.sort(heaters);     int result = 0;     int index = 0;     for (int house : houses) {       while (index + 1 &lt; heaters.length &amp;&amp; house - heaters[index] &gt; heaters[index + 1] - house) {         index++;       }       result = Math.max(result, Math.abs(heaters[index] - house));     }     return result;   }  }   결과  Link   설명          주택위 위치인 houses와 히터의 위치인 heaters를 이용하여 히터가 주택을 따뜻하게 할 온기의 최소 반지름을 구하는 문제이다.            houses와 heaters 내 값들을 모두 오름차순으로 정렬한다.       문제 풀이에 필요한 변수를 정의한다.            result는 반지름의 길이를 담기 위한 변수로, 0으로 초기화한다.       index는 heaters의 위치를 저장할 변수로, 0으로 초기화한다.           houses의 모든 값들을 반복하여 아래를 수행한다.            $index + 1$이 heaters의 크기보다 작고 $house - heaters[index]$의 값이 $heaters[index + 1] - house$ 값보다 큰 경우, index를 증가시킨다.                    두 heater 사이에 house가 존재하는 첫 값이 최소한의 반지름이므로, 해당 위치를 찾는 것이다.                       result에 result와 $heaters[index] - house$의 절대 값 중 큰 값을 넣어준다.           반복이 완료되면 온기의 최소 반지름이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/heaters/",
        "teaser": null
      },{
        "title": "Leetcode Java Number Complement",
        "excerpt":"문제  Link   코드  class Solution {    public int findComplement(int num) {     int sum = 1;     while (sum &lt; num) {       sum = (sum &lt;&lt; 1) | 1;     }     return sum - num;   }  }   결과  Link   설명     num을 이진수로 변환하여 해당 보수로 변환된 정수를 반환하는 문제이다.            예를 들어, 5는 이진수로 101로 표현하며 해당 값의 보수는 010으로 2를 주어진 문제의 결과로 반환하면 된다.           num의 이진수를 모두 1로 변환한 값을 저장할 sum을 1로 저장한다.            num의 최솟값은 1이므로, 해당 값부터 시작한다.           sum이 num보다 작을 때 까지 아래를 반복한다.            sum에 sum의 비트를 좌측으로 1칸 이동시킨 값과 1의 OR(|) 비트 연산의 결과를 넣어준다.           num의 이진수를 모두 1로 변환한 값에 num을 뺀 값이 보수가 되므로, 해당 값을 주어진 문제의 결과로 반환한다.            간단한 예로, $1010 = 1111 - 0101$ 이므로 1010(10)의 보수는 0101(5)이다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-complement/",
        "teaser": null
      },{
        "title": "Leetcode Java Total Hamming Distance",
        "excerpt":"문제  Link   코드  class Solution {    public int totalHammingDistance(int[] nums) {     int count = 0;     int length = nums.length;     for (int j = 0; j &lt; 32; j++) {       int bitCount = 0;       for (int num : nums) {         bitCount += (num &gt;&gt; j) &amp; 1;       }       count += bitCount * (length - bitCount);     }     return count;   }  }   결과  Link   설명          지난번 Hamming Distance 문제와 유사한 문제로, 배열 내 정수들간 해밍 거리의 합을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            count는 해밍 거리의 합을 저장할 변수로, 0으로 초기화한다.       length는 num의 길이를 저장할 변수로, length의 길이로 초기화한다.           0부터 int의 최대 비트의 수인 32 미만까지 j를 증가시키며 반복을 수행한다.            비트의 개수를 저장할 bitCount를 0으로 초기화한다.       nums의 모든 숫자들을 반복하여 num의 비트를 j번 우측으로 이동시킨 값과 1을 AND(&amp;) 비트 연산을 수행한 결과를 bitCount에 더해준다.                    nums 내 모든 숫자의 비트 중 우측에서 j번째가 1이 되는 숫자의 개수를 bitCount에 넣어주는 것이다.                       count에 bitCount와 $length - bitCount$ 값의 곱을 더해준다.                    우측에서 j번째가 모두 동일한 경우 $length - bitCount = 0$으로, 해밍 거리의 합에서 제외된다.           우측에서 j번째가 모두 동일하지 않은 경우, x개에 특정 비트가 있고 (length - x)개에 특정 비트가 없는 경우 $x \\times (length - x)$개의 해밍 거리의 합이 계산된다.                           반복이 완료되면 해밍 거리의 합인 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/total-hamming-distance/",
        "teaser": null
      },{
        "title": "Leetcode Java Generate Random Point in a Circle",
        "excerpt":"문제  Link   코드  class Solution {    private double radius;   private double x_center;   private double y_center;   private Random random;    public Solution(double radius, double x_center, double y_center) {     this.radius = radius;     this.x_center = x_center;     this.y_center = y_center;     this.random = new Random();   }    public double[] randPoint() {     double x = this.getCoordinate(this.x_center);     double y = this.getCoordinate(this.y_center);     while (this.getDistanceAboutCenter(x, y) &gt; this.radius * this.radius) {       x = this.getCoordinate(this.x_center);       y = this.getCoordinate(this.y_center);     }     return new double[] { x, y };   }    private double getDistanceAboutCenter(double x, double y) {     double x_distance = this.x_center - x;     double y_distance = this.y_center - y;     return (x_distance * x_distance) + (y_distance * y_distance);   }    private double getCoordinate(double center) {     return center - this.radius + (this.random.nextDouble() * 2 * this.radius);   }  }  /**  * Your Solution object will be instantiated and called as such:  * Solution obj = new Solution(radius, x_center, y_center);  * double[] param_1 = obj.randPoint();  */   결과  Link   설명     [x_center, y_center]의 위치에서 반지름이 radius인 원 내 임의 점을 생성하는 Solution 클래스를 완성하는 문제이다.            생성자인 Solution(double radius, double x_center, double y_center)은 객체를 초기화하는 역할을 수행한다.       메서드인 randPoint()는 [x_center, y_center]의 위치에서 반지름이 radius인 원 안과 둘레를 포함한 위치 내 임의 점의 위치를 [x, y] 형태의 배열로 반환한다.           문제 풀이에 필요한 전역 변수를 정의한다.            radius는 생성자를 통해 주입된 반지름의 길이를 저장하기 위한 변수이다.       x_center는 생성자를 통해 주입된 원의 중심인 x축을 저장하기 위한 변수이다.       y_center는 생성자를 통해 주입된 원의 중심인 y축을 저장하기 위한 변수이다.       random은 임의 값을 반환하기 위한 변수이다.           생성자인 Solution(double radius, double x_center, double y_center)을 완성한다.            생성자를 통해 주입된 radius, x_center, y_center를 각 전역 변수에 넣어준다.       random은 java에서 임의 수를 반환하는 Random 객체를 초기화하여 넣어준다.           메서드인 randPoint()를 정의한다.            x와 y에 각 축의 중심인 x_center와 y_center를 5번에서 정의한 getCoordinate(double center) 메서드를 수행한 결과를 넣어준다.       x와 y를 이용하여 원 밖을 벗어나는 경우, 다시 윗 단계를 수행하여 원 내에 존재할 때까지 반복을 수행한다.       원 내 존재하는 점의 위치인 x와 y를 배열로 생성하여 반환한다.           x축과 y축의 중심부 기준으로 임의 점을 생성하여 반환할 getCoordinate(double center) 메서드를 정의한다.            center에서 radius를 뺀 값에 임의 0에서 1 사이의 수를 생성하여 radius의 2배 값을 곱해 더해준다.                    x축인 경우, x축의 가장 좌측인 낮은 값의 위치에서 가장 우측인 높은 값 위치까지 임의 수를 생성하게 한다.           y축인 경우, y축의 가장 아래인 낮은 값의 위치에서 가장 위인 높은 값 위치까지 임의 수를 생성하게 한다.                           원 내 임의 점과 원 중심의 거리를 계산하는 getDistanceAboutCenter(double x, double y) 메서드를 정의한다.            x_distance에 x_center와 x의 차이를, y_distance에 y_center와 y의 차이를 저장한다.       x_distance와 y_distance의 각 제곱의 합을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/generate-random-point-in-a-circle/",
        "teaser": null
      },{
        "title": "Leetcode Java Largest Palindrome Product",
        "excerpt":"문제  Link   코드  class Solution {    public int largestPalindrome(int n) {     if (n &gt; 1) {       int num = (int) Math.pow(10, n);       for (long idx = 2; idx &lt; num; idx += 2) {         long high = num - idx;         long low = Long.parseLong(new StringBuilder(Long.toString(high)).reverse().toString());         long temp = (idx * idx) - (4 * low);         if (temp &lt; 0) {           continue;         }         long sqrt = (long) Math.sqrt(temp);         if (sqrt * sqrt == temp) {           return (int) (((high * num) + low) % 1337);         }       }     }     return 9;   }  }   결과  Link   설명          n자리의 두 숫자의 곱이 회문이 되는 가장 큰 값을 찾아 1337을 나눈 나머지를 반환하는 문제이다.            n이 1인 경우, 한 자리의 숫자 중 가장 큰 숫자인 9를 주어진 문제의 결과로 반환한다.            num에 10의 n승한 결과를 넣고, 2부터 num 미만까지 idx를 2씩 증가시키며 반복을 수행한다.             high에 $num - idx$를, low에는 high를 거꾸로 뒤집어 넣어준다.                    회문이 되는 결과를 절반으로 나누면 첫 번째 값의 거꾸로 된 값이 두 번째 값이 되므로, 이 값을 만들어 검증을 수행하는 것이다.                       temp에 idx의 제곱에 $4 \\times low$를 뺀 값을 넣고, temp가 0 미만인 경우 검증을 수행 할 수 없으므로 다음 반복을 수행한다.       temp가 정상적인 제곱수인 경우, $(high \\times num) + low$ 값이 두 값의 곱으로 완성 가능한 수이므로 1337을 나눈 나머지 값을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/largest-palindrome-product/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove Digit From Number to Maximize Result",
        "excerpt":"문제  Link   코드  class Solution {    public String removeDigit(String number, char digit) {     char[] nums = number.toCharArray();     int index = 0;     for (int idx = 0; idx &lt; number.length(); idx++) {       if (nums[idx] == digit) {         index = idx;         if (idx &lt; number.length() - 1 &amp;&amp; nums[idx] &lt; nums[idx + 1]) {           break;         }       }     }     return number.substring(0, index).concat(number.substring(index + 1));   }  }   결과  Link   설명          숫자로 이루어진 문자열 number 내 digit인 문자가 최소 한 번 이상 들어가 있는데, 해당 digit을 제거한 결과가 가장 큰 값을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            nums는 number를 문자 배열로 변환해서 저장하는 변수이다.       index는 제거할 문자의 위치를 저장할 변수로, 0으로 초기화한다.           0부터 number의 길이 미만까지 idx를 증가시키며 아래를 수행한다.            nums의 idx번 문자가 digit인 경우, index에 idx를 넣어준다.       idx가 number의 마지막 문자가 아니고 다음 위치의 값인 $idx + 1$번째 값이 더 큰 경우, 해당 문자를 제거해야 하므로 반복을 중단한다.           반복이 완료되어 제거할 문자의 위치를 탐색하였으면, number를 해당 문자 이전과 이후로 분리해서 하나의 문자열로 만들어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-digit-from-number-to-maximize-result/",
        "teaser": null
      },{
        "title": "Leetcode Java Sliding Window Median",
        "excerpt":"문제  Link   코드  class Solution {    public double[] medianSlidingWindow(int[] nums, int k) {     int[] part = new int[k];     double[] result = new double[nums.length - k + 1];     for (int i = 0; i &lt; k; i++) {       part[i] = nums[i];     }     Arrays.sort(part);     result[0] = this.getMedian(part, k);     for (int i = k, j = 1; i &lt; nums.length; i++, j++) {       this.delete(part, k, nums[i - k]);       this.insert(part, k, nums[i]);       result[j] = this.getMedian(part, k);     }     return result;   }    private double getMedian(int[] part, int k) {     if (k % 2 == 1) {       return (double) part[k / 2];     } else {       return (part[(k / 2) - 1] / 2.0) + (part[k / 2] / 2.0);     }   }    private void delete(int[] part, int k, int value) {     int left = 0;     int right = k;     while (left &lt; right) {       int mid = left + (right - left) / 2;       if (part[mid] == value) {         System.arraycopy(part, mid + 1, part, mid, k - (mid + 1));         part[k - 1] = value;         return;       }       if (part[mid] &lt; value) {         left = mid + 1;       } else {         right = mid;       }     }   }    private void insert(int[] part, int k, int value) {     int left = 0;     int right = k - 1;     while (left &lt; right) {       int mid = left + (right - left) / 2;       if (part[mid] &lt; value) {         left = mid + 1;       } else {         right = mid;       }     }     System.arraycopy(part, left, part, left + 1, (k - 1) - left);     part[left] = value;   }  }   결과  Link   설명          정수의 배열인 nums를 이용하여 앞에서 부터 k개 씩 묶어 각각의 중앙값들을 찾아 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            part는 k개의 정수를 넣어 중앙값을 탐색하기 위한 배열로, k 크기로 정의하여 nums의 0 번째 값부터 k 번째 값까지 넣어준다.       result는 각 중앙값을 넣을 배열로, $nums.length - k + 1$ 크기로 정의한다.                    k개를 묶어 하나의 중앙값이 나오므로, 배열의 크기에서 $k - 1$을 뺀 값만큼 수의 중앙값이 나오게된다.                       part를 오름차순 정렬하고 result의 첫 값에 3번에서 정의한 getMedian(int[] part, int k) 메서드의 결과를 넣어준다.       i는 k, j는 1부터 i가 nums의 길이 미만까지 i와 j를 증가시키며 아래를 수행한다.                    4번에서 정의한 delete(int[] part, int k, int value) 메서드를 수행하여 part에 nums의 $i - k$번째 값을 제거해준다.           5번에서 정의한 insert(int[] part, int k, int value) 메서드를 수행하여 part에 nums의 i번째 값을 넣어준다.           result의 j번째 위치에 3번에서 정의한 getMedian(int[] part, int k) 메서드를 수행한 결과를 넣어준다.                       반복이 완료되면 중앙값들을 넣은 result를 주어진 문제의 결과로 반환한다.           중앙값을 계산하기 위한 getMedian(int[] part, int k) 메서드를 정의한다.            k가 홀수인 경우, part의 $\\frac{size}{2}$번째 값을 double 형으로 변환 후 반환한다.       k가 짝수인 경우, part의 $\\frac{size}{2} - 1$번째 값을 2.0으로 나눈 값과 part의 $\\frac{size}{2}$번째 값을 2.0으로 나눈 값을 더해서 반환한다.           part 내 value에 대한 값을 제거하기 위한 delete(int[] part, int k, int value) 메서드를 정의한다.            left를 0으로, right를 k로 넣어 초기화한다.       left가 right보다 작을 때 까지 반복하여 아래를 수행한다.                    mid에 $left + \\frac{right - left}{2}$의 결과를 넣어 탐색 위치를 설정한다.           part의 mid번째 값이 value인 경우, part의 $mid + 1$번째 값부터 $k - (mid + 1)$개의 값들을 part의 mid번째 값 위치부터 넣어주고 part의 $k - 1$번째 값에 value를 넣어주고 수행을 멈춘다.           part의 mid번째 값이 value보다 작은 경우, left에 $mid + 1$을 넣고 아니면 right에 mid를 넣어 범위를 좁혀준다.                           part 내 value를 넣기 위한 insert(int[] part, int k, int value) 메서드를 정의한다.            left를 0으로, right를 $k - 1$로 넣어 초기화한다.       left가 right보다 작을 때 까지 반복하여 아래를 수행한다.                    mid에 $left + \\frac{right - left}{2}$의 결과를 넣어 탐색 위치를 설정한다.           part의 mid번째 값이 value보다 작은 경우, left에 $mid + 1$을 넣고 아니면 right에 mid를 넣어 범위를 좁혀준다.                       반복이 완료되면 part의 left 번째 값부터 $(k - 1) - left$번째 값까지 part의 $left + 1$번쨰 위치부터 넣어주고 part의 left번째 자리에 value를 넣어준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sliding-window-median/",
        "teaser": null
      },{
        "title": "Leetcode Java Magical String",
        "excerpt":"문제  Link   코드  class Solution {    public int magicalString(int n) {     int fast = 1;     int slow = 1;     int num = 1;     int[] nums = new int[n + 2];     while (fast &lt;= n) {       nums[fast++] = num;       if (nums[slow++] == 2) {         nums[fast++] = num;       }       num = 3 - num;     }     int count = 0;     for (int idx = 1; idx &lt;= n; idx++) {       if (nums[idx] == 1) {         count++;       }     }     return count;   }  }   결과  Link   설명     1과 2로 이루어진 아래의 규칙에 의해 생성된 문자열 s의 n 번째 자리까지 존재하는 1의 개수를 구하는 문제이다.            문자열 s는 “1221121221221121122…” 형태로 이루어지며, 그룹화하면 “1 22 11 2 1 22 1 22 11 2 11 22 …“으로 표현이 된다.       각 그룹의 1 또는 2의 발생 순서는 “1 2 2 1 1 2 1 2 2 1 2 2 …“으로 볼 수 있다.       이는 각 숫자가 반전이 될 때 $num = 3 - num$로 뒤집어 줄 수 있다.           문제 풀이에 필요한 변수를 정의한다.            fast와 slow는 문자열 s를 구성하기 위한 인덱스로, 1로 초기화한다.                    fast는 현재 커서의 인덱스로 nums 내 값을 넣기 위한 변수이다.           slow는 검증을 위한 인덱스로 nums 의 slow번째 값이 2인 경우, fast의 다음 자리에 num을 한 번 더 넣어주는 역할을 수행하여 위의 규칙을 만족하는 문자열 s를 만들 수 있다.                       num은 문자열 s의 각 위치에 들어갈 숫자로, 첫 값인 1로 초기화한다.       nums는 문자열 s를 구성하기 위한 배열로, $n + 2$ 크기로 초기화한다.           fast가 n 이하일 때 까지 아래를 수행하여 문자열 s의 각 자리 숫자를 nums에 차례대로 넣어준다.            nums의 fast번째 자리에 num을 넣고 fast를 증가시킨다.       nums의 slow번째 값이 2인지 검증하고 slow를 증가시키고, 2가 맞는 경우 nums의 fast번째 값에 num을 넣어주고 fast를 증가시킨다.       num에 $3 - num$을 넣어 숫자를 뒤집어준다.           count를 0으로 초기화 시키고, nums를 반복하여 1의 개수를 count에 넣어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/magical-string/",
        "teaser": null
      },{
        "title": "Leetcode Java License Key Formatting",
        "excerpt":"문제  Link   코드  class Solution {    public String licenseKeyFormatting(String s, int k) {     char[] chars = new char[s.length() * 2];     int count = 0;     int index = chars.length;     for (int idx = s.length() - 1; idx &gt;= 0; idx--) {       char c = s.charAt(idx);       if (c == '-') {         continue;       }       if (count == k) {         chars[--index] = '-';         count = 0;       }       chars[--index] = Character.toUpperCase(c);       count++;     }     return String.valueOf(chars, index, chars.length - index);   }  }   결과  Link   설명     문자열 s를 이용하여 k개 단위로 이어진 숫자와 영대문자로 구성된 문자열과 해당 문자열 사이에 구분 기호인 “-“ 문자를 이용하여 라이센스 키를 만드는 문제이다.            정확히 k 배수로 이루어진 문장이 아닌 경우, 앞의 문자열은 k개 이하로 구성한다.           문제 풀이에 필요한 변수를 정의한다.            chars는 라이센스 키를 만들기 위한 문자를 넣을 배열로, k가 1인 경우 s 길이의 2배보다 1 작은 값이 되기 때문에 s의 2배의 크기로 초기화 한다.       count는 k개의 숫자로 묶기 위해 사용하는 변수로, 0으로 초기화한다.       index는 s를 거꾸로 탐색하기 위한 위치값을 넣을 변수로, chars의 길이로 초기화한다.           k배수로 이루어진 경우가 아니면 앞에 남은 문자로 이어야 하므로, s의 마지막 문자부터 거꾸로 idx를 감소시키며 반복을 수행한다.            c에 s의 idx번째 문자를 넣어준다.       c가 문자열 사이 구분 기호인 “-“인 경우, 다음 반복을 수행한다.       count가 k인 경우, chars에 구분 기호인 “-“를 넣고 count를 0으로 초기화시켜준다.       index를 감소시키고 chars의 index번째 자리에 c를 대문자로 변환하여 넣어준다.       문자를 넣었으므로 count를 증가시키고 반복을 계속 수행한다.           chars의 index번째 문자부터 $chars.length - index$ 문자까지 문자열로 만들어서 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/license-key-formatting/",
        "teaser": null
      },{
        "title": "Leetcode Java Max Consecutive Ones",
        "excerpt":"문제  Link   코드  class Solution {    public int findMaxConsecutiveOnes(int[] nums) {     int max = 0;     int curr = 0;     for (int num : nums) {       if (num == 0) {         max = Math.max(max, curr);         curr = 0;       } else {         curr++;       }     }     return Math.max(max, curr);   }  }   결과  Link   설명          nums 내 연속된 1의 개수가 가장 긴 결과를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            max는 연속된 1의 개수가 가장 긴 결과를 저장할 변수로, 0으로 초기화한다.       curr은 현재 1의 개수가 몇 개 연속되었는지 저장할 변수로, 0으로 초기화한다.           nums 내 모든 값들을 반복하여 아래를 수행한다.            num이 0인 경우, max와 curr 중 가장 큰 값을 max에 넣어주고 curr을 0으로 초기화한다.       num이 0이 아닌 경우, curr을 증가시킨다.           마지막 전 까지 연속된 1의 개수가 가장 긴 max와 마지막으로 연속된 1의 개수인 curr 중 가장 큰 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/max-consecutive-ones/",
        "teaser": null
      },{
        "title": "Leetcode Java Predict the Winner",
        "excerpt":"문제  Link   코드  class Solution {    public boolean PredictTheWinner(int[] nums) {     int length = nums.length;     int[] dp = new int[length];     for (int i = length - 1; i &gt;= 0; i--) {       for (int j = i; j &lt; length; j++) {         if (i == j) {           dp[i] = nums[i];         } else {           dp[j] = Math.max(nums[i] - dp[j], nums[j] - dp[j - 1]);         }       }     }     return dp[length - 1] &gt;= 0;   }  }   결과  Link   설명          두 사용자가 nums의 첫 값 혹은 마지막 값을 번갈아가며 자신의 점수에 더하고 선택한 값을 배열에서 제거하는 게임을 진행하는데, 첫 번째 사용자가 이길 수 있는지 여부를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 넣어 보관할 변수이다.       dp는 nums의 값을 더해서 보관할 배열로, length의 크기로 정의한다.           $length - 1$부터 0까지 i를 감소시키고, i부터 length 미만까지 j를 증가시키며 반복을 수행한다.            i와 j가 동일한 값인 경우, dp의 i번째 위치에 nums의 i번째 값을 넣어 값을 초기화시켜준다.                    i를 역순으로 수행하는 이유는 이를 위해서이며, 별도 반복문으로 dp의 값을 초기화 하지 않도록 하는 것이다.                       i와 j가 동일하지 않은 경우, nums의 i번째 값에 dp의 j번째 값을 뺀 값과 nums의 j번째 값에 dp의 $j - 1$번째 값을 뺀 값 중 큰 값을 dp의 j번째 위치에 넣어준다.                    dp[j]는 첫 번쨰 플레이어가 두 번째 플레이어보다 j번째 값 까지 얼마나 많은 점수를 얻을 수 있는지를 나타내므로, i에서 j까지 숫자로 선택하는 경우에 대한 예를 보자.           첫 번째 플레이어가 i번째 값을 선택했을 경우, 두 번째 플레이어보다 $nums[i] - dp[j]$ 의 결과만큼 점수가 높을 수 있다.           첫 번째 플레이어가 j번째 값을 선택했을 경우, 두 번째 플레이어보다 $nums[j] - dp[j - 1]$ 의 결과만큼 점수가 높을 수 있다.           첫 번째 플레이어는 두 경우를 고려하여 더 점수가 높은 값을 선택해야 이길 수 있으므로, 가장 큰 값을 dp의 j번째 위치에 넣어주는 것이다.                           반복이 완료되면 dp의 $length - 1$번째 값이 0 이상인지를 검증하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/predict-the-winner/",
        "teaser": null
      },{
        "title": "Leetcode Java Increasing Subsequences",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     this.dfs(nums, result, new ArrayList&lt;&gt;(), 0, Integer.MIN_VALUE);     return result;   }    private void dfs(int[] nums, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; temp, int index, int value) {     if (index == nums.length) {       if (temp.size() &gt;= 2) {         result.add(new ArrayList&lt;Integer&gt;(temp));       }       return;     }     if (nums[index] &gt;= value) {       temp.add(nums[index]);       this.dfs(nums, result, temp, index + 1, nums[index]);       temp.remove(temp.size() - 1);     }     if (nums[index] != value) {       this.dfs(nums, result, temp, index + 1, value);     }   }  }   결과  Link   설명          nums 내 최소 두 숫자 이상을 활용하여 모든 부분 배열을 구하는 문제이다.            모든 부분 배열을 넣을 result를 ArrayList로 초기화 한다.            4번에서 정의한 dfs(int[] nums, List&lt;List&gt; result, List temp, int index, int value) 메서드를 temp에 새 ArrayList, index에 0, value에 int의 가장 작은 숫자를 이용하여 수행한다.       DFS 방식으로 결과를 탐색할 dfs(int[] nums, List&lt;List&gt; result, List temp, int index, int value) 메서드를 정의한다.            index가 nums의 길이와 동일한 경우, temp의 길이가 2 이상이면 result에 temp를 새 ArrayList 객체로 넣어주고 수행을 중단한다.       nums의 index번째 값이 value보다 큰 경우 아래를 수행하여 부분 배열을 찾아준다.                    temp에 해당 값을 넣어주고 index를 증가시키고 nums의 index번째 값을 value에 넣어 재귀 호출을 수행한다.           재귀 호출이 완료되면 temp에 위에서 넣은 값인 마지막 값을 제거해준다.                       nums의 index번째 값이 value와 같지 않은 경우, index를 증가시키고 value로 재귀 호출을 다시 수행하여 또 다른 부분 배열을 완성해준다.           모든 부분 배열을 넣은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/increasing-subsequences/",
        "teaser": null
      },{
        "title": "Leetcode Java Construct the Rectangle",
        "excerpt":"문제  Link   코드  class Solution {    public int[] constructRectangle(int area) {     int width = (int) Math.sqrt(area);     while (area % width &gt; 0) {       width--;     }     return new int[] { area / width, width };   }  }   결과  Link   설명     사각형의 면적이 area인 사각형의 길이 L과 너비 W를 배열인 [L, W] 형태로 반환하는 문제이다.            너비 W는 길이 L보다 크지않아야 한다.       길이 L과 너비 W의 차이는 가능한 작아야 한다.           width에 area의 제곱근의 결과를 넣어준다.            사각형의 면적은 $L \\times W$이므로, 면적의 제곱근이 제곱수인 경우 정사각형이며 그렇지 않으면 직사각형으로 구성이 된다.                area를 width로 나눈 나머지가 0이 될 때까지, width를 감소시킨다.       3번을 통해 구해진 width를 이용하여 area를 width로 나눈 length와 width를 정수 배열로 만들어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/construct-the-rectangle/",
        "teaser": null
      },{
        "title": "Leetcode Java Reverse Pairs",
        "excerpt":"문제  Link   코드  class Solution {    public int reversePairs(int[] nums) {     return this.mergeSort(nums, 0, nums.length - 1);   }    private int mergeSort(int[] nums, int start, int end) {     if (start &gt;= end) {       return 0;     }     int mid = (start + end) / 2;     int result = this.mergeSort(nums, start, mid) + this.mergeSort(nums, mid + 1, end);     for (int i = start, j = mid + 1; i &lt;= mid; i++) {       while (j &lt;= end &amp;&amp; nums[i] / 2.0 &gt; nums[j]) {         j++;       }       result += j - (mid + 1);     }     Arrays.sort(nums, start, end + 1);     return result;   }  }   결과  Link   설명     nums 내 아래의 조건을 만족하는 역방향 숫자 쌍의 수를 반환하는 문제이다.            역 방향 쌍인 [i, j]는 $0 &lt;= i &lt; j &lt; nums.length$을 만족한다.       역 방향 쌍인 [i, j]는 $nums[i] &gt; 2 \\times nums[j]$을 만족한다.                3번에서 정의한 mergeSort(int[] nums, int start, int end) 메서드에 start는 0, end는 nums의 길이보다 1 작게 수행한 결과를 주어진 문제의 결과로 반환한다.       병합 정렬을 이용해 역방향 숫자 쌍의 수를 계산할 mergeSort(int[] nums, int start, int end) 메서드를 정의한다.            start가 end에 도달한 경우 정렬할 숫자가 없으므로, 0을 반환한다.       문제 풀이에 필요한 변수를 정의한다.                    mid는 start와 end의 중간 값을 넣기 위한 변수로, $\\frac{start + end}{2}$의 결과를 넣어준다.           result는 병합 정렬에 수행된 숫자의 개수를 넣을 변수로, mid를 end에 넣어 재귀 호출을 수행한 결과와 $mid + 1$을 start에 넣어 재귀 호출을 수행한 결과의 합을 넣어 초기화한다.                       start부터 mid까지 i를 증가시키고, j는 $mid + 1$로 초기화 하여 반복을 수행한다.                    주어진 조건인 j가 end 이하이고 nums의 i번째 값을 2.0으로 나눈 값이 nums의 j번째 값보다 큰 경우, j를 증가시켜 j의 위치를 증가시킨다. (위의 조건 중 $nums[i] &gt; 2 \\times nums[j]$는 overflow가 발생 가능하므로, $\\frac{nums[i]}{2} &gt; nums[j]$로 로직을 변경해서 수행한다.)           j에 $mid + 1$의 값을 뺀 결과인 이동 횟수를 넣어준다.                       nums를 start 위치부터 $end + 1$ 위치까지 정렬하고, 정렬이 수행된 숫자의 개수인 result를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reverse-pairs/",
        "teaser": null
      },{
        "title": "Leetcode Java Target Sum",
        "excerpt":"문제  Link   코드  class Solution {    public int findTargetSumWays(int[] nums, int target) {     int sum = 0;     for (int num : nums) {       sum += num;     }     return sum &lt; target || (sum + target) % 2 == 1 ? 0 : this.subset(nums, (target + sum) &gt;&gt; 1);   }    private int subset(int[] nums, int target) {     if (target &lt; 0) {       return 0;     }     int[] dp = new int[target + 1];     dp[0] = 1;     for (int num : nums) {       for (int idx = target; idx &gt;= num; idx--) {         dp[idx] += dp[idx - num];       }     }     return dp[target];   }  }   결과  Link   설명          nums의 각 숫자 사이에 ‘+’와 ‘-‘를 넣어 해당 수식의 결과가 target이 되는 경우의 수를 구하는 문제이다.            sum은 nums의 모든 숫자들의 합을 저장할 변수로, nums를 반복하여 모든 값을 더해준다.       target이 sum보다 크거나 sum과 target을 합한 결과가 홀수인지를 이용하여 아래의 각 경우 별 수행을 한다.            위의 결과들 중 하나라도 만족하는 경우 수식을 만들 수 없으므로, 0을 주어진 문제의 결과로 반환한다.       위의 결과들 중 하나라도 만족하지 않는 경우, 4번에서 정의한 subset(int[] nums, int target) 메서드를 수행한 값을 주어진 문제의 결과로 반환한다.           dp를 활용한 subset으로 경우의 수를 구하기 위한 subset(int[] nums, int target) 메서드를 정의한다.            target이 0보다 작은 경우 수식을 만들 수 있는 경우의 수가 없으므로, 0을 반환한다.       dp는 경우의 수를 구하기 위해 사용될 배열로, $target + 1$ 크기로 정의하고 첫 값을 1로 초기화한다.       nums의 모든 값을 반복하고, target 부터 num 보다 클 때 까지 idx를 감소시키며 반복하여 아래를 수행한다.                    dp의 idx번째 위치의 값에 dp의 $idx - num$의 결과를 더해 경우의 수를 계산한다.           idx를 감소시키며 dp의 $idx - num$의 결과를 더하는 이유는, 해당 결과는 현재의 num을 아직 고려하지 않은 부분 집합의 결과이기 때문에 동일한 num을 반복 사용하지 않는다.                       반복이 완료되면 경우의 수인 dp의 target번째 값을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/target-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Teemo Attacking",
        "excerpt":"문제  Link   코드  class Solution {    public int findPoisonedDuration(int[] timeSeries, int duration) {     int result = 0;     int start = 0;     int end = -1;     for (int time : timeSeries) {       if (end &lt; time) {         result += end - start + 1;         start = time;       }       end = time + duration - 1;     }     return result + end - start + 1;   }  }   결과  Link   설명          duration 동안 중독되는 독 공격 횟수 별 시간인 timeSeries가 주어지면 겹치지 않은 중독된 시간을 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 총 중독된 시간을 계산할 변수로, 0으로 초기화한다.       start는 중독된 시간을 계산하기 위한 시작 시간을 저장할 변수로, 0으로 초기화한다.       end는 중독된 시간을 계산하기 위한 종료 시간을 저장할 변수로, start보다 작게 -1로 초기화한다.           timeSeries의 모든 값을 반복하여 중독된 시간을 계산한다.            end가 time보다 작으면 겹치지 않은 시간의 중독이므로, result에 중독된 시간인 $end - start + 1$를 더해주고 start에 time을 넣어준다.       end에 time에 중독이 발생하면 끝나는 시간인 $time + duration - 1$을 넣어주고 반복을 계속 한다.           반복이 종료되면 중복되지 않은 중독된 시간으로 계산된 result와 마지막으로 중독된 시간인 $end - start + 1$을 더한 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/teemo-attacking/",
        "teaser": null
      },{
        "title": "Leetcode Java Next Greater Element I",
        "excerpt":"문제  Link   코드  class Solution {    public int[] nextGreaterElement(int[] nums1, int[] nums2) {     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();     for (int idx = 0; idx &lt; nums2.length; idx++) {       map.put(nums2[idx], idx);     }     for (int idx = 0; idx &lt; nums1.length; idx++) {       nums1[idx] = this.findNextGreaterElement(nums2, map.get(nums1[idx]));     }     return nums1;   }    private int findNextGreaterElement(int[] nums2, int index) {     int num = nums2[index];     for (int idx = index + 1; idx &lt; nums2.length; idx++) {       if (nums2[idx] &gt; num) {         return nums2[idx];       }     }     return -1;   }  }   결과  Link   설명     nums1 내 각 요소들의 값을 nums2에서 찾아 해당 값의 우측에서 가장 가까우면서 현재 값보다 큰 값을 검색하고, 검색한 값들을 nums1의 순서대로 반환하는 문제이다.            단, 요소의 값보다 큰 값이 우측에 존재하지 않는 경우 -1을 해당 자리에 넣는다.                nums2 내 각 값의 위치를 저장하기 위한 map을 HashMap으로 초기화하고, nums를 반복하여 값을 key에 위치 값은 value로 넣어준다.       nums1의 모든 요소를 반복하여 아래를 수행한다.            nums1의 idx번째 자리에 4번에서 정의한 findNextGreaterElement(int[] nums2, int index) 메서드를 nums1의 idx번째 값을 map에서 nums2 내 위치 값을 찾은 후 index에 넣어 수행한 결과를 넣어 값을 교환해준다.           nums2 배열 내 index번째 값보다 큰 index 이후의 값을 찾는 findNextGreaterElement(int[] nums2, int index) 메서드를 정의한다.            num에 nums2의 index번째 값을 넣어준다.       $index + 1$부터 nums2의 길이 미만까지 idx를 증가시키며 탐색을 수행한다.                    nums2의 idx번째 값이 num보다 큰 경우, nums2의 idx번째 값을 반환한다.                       반복이 종료되면 num보다 큰 값이 우측에 없으므로, -1을 반환한다.           3번의 반복이 완료되면 문제 풀이대로 변환된 값을 가진 nums1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/next-greater-element-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Random Point in Non-overlapping Rectangles",
        "excerpt":"문제  Link   코드  class Solution {    private TreeMap&lt;Integer, Integer&gt; map;   private int sum;   private int[][] rectangles;   private Random random;    public Solution(int[][] rects) {     this.sum = 0;     this.map = new TreeMap&lt;&gt;();     this.rectangles = rects;     this.random = new Random();     for (int idx = 0; idx &lt; rects.length; idx++) {       this.sum += (rects[idx][2] - rects[idx][0] + 1) * (rects[idx][3] - rects[idx][1] + 1);       this.map.put(this.sum, idx);     }   }    public int[] pick() {     int index = this.map.ceilingEntry(1 + this.random.nextInt(this.sum)).getValue();     int x = this.random.nextInt(this.rectangles[index][2] - this.rectangles[index][0] + 1);     int y = this.random.nextInt(this.rectangles[index][3] - this.rectangles[index][1] + 1);     return new int[] { this.rectangles[index][0] + x, this.rectangles[index][1] + y };   }  }  /**  * Your Solution object will be instantiated and called as such:  * Solution obj = new Solution(rects);  * int[] param_1 = obj.pick();  */   결과  Link   설명     겹치지 않은 사각형의 위치인 rects 내 임의의 점의 위치를 반환하는 문제이다.            생성자인 Solution(int[][] rects)은 사각형의 좌표인 rects를 이용하여 객체를 초기화하는 역할을 수행한다.       메서드인 pick()은 생성자를 통해 주입된 rects 내 임의 점을 생성하여 해당 좌표를 [x, y] 배열로 반환하는 역할을 수행한다.           문제 풀이에 필요한 전역 변수를 정의한다.            map은 사각형의 면적 별 rects 내 사각형의 위치 값을 저장하여 보관할 변수로, 키에 대한 메서드 활용을 위해서 TreeMap으로 정의한다.       sum은 사각형의 면적의 합을 저장할 변수이다.       rectangles는 생성자를 통해 주입된 rects를 보관할 변수이다.       random은 임의 좌표를 생성하기 위해 활용될 변수이다.           생성자인 Solution(int[][] rects)을 정의한다.            sum을 0으로, map을 새 TreeMap 객체를 생성하여 초기화한다.       rectangles에 주어진 rects 배열을 넣어준다.       random 객체를 임의 숫자 생성을 위한 Random 객체를 생성하여 초기화한다.       0부터 rects 배열의 길이 미만까지 idx를 증가시키며 아래를 수행한다.                    sum에 rects의 idx번째 사각형의 면적을 계산하여 넣어주고, map에 key가 sum이고 value는 idx로 넣어준다.                           메서드인 메서드인 pick()을 정의한다.            map에서 1부터 sum 이하의 숫자를 생성하여 해당 값보다 작은 key 중 가장 인접한 key의 value를 꺼내 index에 넣어준다.       rectangles 내 index번째 값을 가져와 rectangle로 정의한다.       x에 rectangle의 0에서 x축 길이 내 임의의 값을 넣어준다.       y에 rectangle의 0에서 y축 길이 내 임의의 값을 넣어준다.       rectangle의 x축 위치에 x를 더하고, y축 위치에 y를 더한 값들을 정수 배열로 만들어 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/random-point-in-non-overlapping-rectangles/",
        "teaser": null
      },{
        "title": "Leetcode Java Diagonal Traverse",
        "excerpt":"문제  Link   코드  class Solution {    public int[] findDiagonalOrder(int[][] mat) {     int row = 0;     int col = 0;     int rowLength = mat.length;     int colLength = mat[0].length;     int[] result = new int[rowLength * colLength];     for (int idx = 0; idx &lt; result.length; idx++) {       result[idx] = mat[row][col];       if ((row + col) % 2 == 0) {         if (col == colLength - 1) {           row++;         } else if (row == 0) {           col++;         } else {           row--;           col++;         }       } else {         if (row == rowLength - 1) {           col++;         } else if (col == 0) {           row++;         } else {           row++;           col--;         }       }     }     return result;   }  }   결과  Link   설명     mat의 모든 값들을 아래의 규칙을 만족하는 하나의 배열로 반환하는 문제이다.            첫 값의 위치부터 우측 위로 시작하여 다음 값이 없을 경우, 우측 혹은 아래 칸으로 이동해서 좌측 아래로 숫자들을 차례대로 나열한다.       좌측 아래로 이동하다가 다음 값이 없을 경우, 아래 혹은 우측 칸으로 이동해서 우측 위로 숫자들을 나열한다.       위의 두 규칙을 반복하여 모든 값을 하나의 배열에 넣어준다.           문제 풀이에 필요한 변수를 정의한다.            row와 col은 mat의 행과 열을 탐색할 위지 변수로, 모두 0으로 초기화한다.       rowLength와 colLength는 mat의 행과 열의 길이를 저장할 변수로, 각 길이로 초기화한다.       result는 모든 값을 순차적으로 이어줄 배열로, rowLength와 colLength를 곱한 값의 크기로 초기화한다.       0부터 result의 길이 미만까지 idx를 증가시키며 아래를 수행한다.                    result의 idx번째 위치에 mat[row][col] 값을 넣어준다.           row와 col을 더한 값이 짝수인 경우, col이 마지막 열이면 row를 증가시키고 row가 첫 행이면 col을 증가시키고 그 외의 경우 row를 감소시키고 col을 증가시켜 우측 위 방향으로 위치를 이동시킨다.           row와 col을 더한 값이 홀수인 경우, row가 마지막 행이면 col을 증가시키고 col이 첫 열이면 row를 증가시키고 그 외의 경우 row를 증가시키고 col을 감소시켜 좌측 아래 방향으로 위치를 이동시킨다.                           반복이 완료되면 위의 규칙대로 대각선으로 이동하여 값을 이어준 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/diagonal-traverse/",
        "teaser": null
      },{
        "title": "Leetcode Java Keyboard Row",
        "excerpt":"문제  Link   코드  class Solution {    private static final String[] KEYBOARD_ROWS = { \"qwertyuiop\", \"asdfghjkl\", \"zxcvbnm\" };    public String[] findWords(String[] words) {     int[] positions = new int[26];     for (int idx = 0; idx &lt; KEYBOARD_ROWS.length; idx++) {       for (char c : KEYBOARD_ROWS[idx].toCharArray()) {         positions[c - 'a'] = idx + 1;       }       }     List&lt;String&gt; result = new ArrayList&lt;&gt;();     for (String word : words) {       int row = 0;       int idx = 0;       for (; idx &lt; word.length(); idx++) {         char c = word.charAt(idx);         int num = c - (c &gt;= 'a' ? 'a' : 'A');         if (row == 0) {           row = positions[num];         } else if (row != positions[num]) {           break;         }       }       if (idx == word.length()) {         result.add(word);       }     }     return result.toArray(new String[result.size()]);   }  }   결과  Link   설명     words 내 키보드의 한 줄로 구성이 가능한 문자열을 반환하는 문제이다.            키보드 영문의 경우 첫 번째 행은 “qwertyuiop”, 두 번째 행은 “asdfghjkl”, 세 번째 행은 “zxcvbnm”로 구성이 된다.                기본 판단의 기준이 되는 KEYBOARD_ROWS 배열을 정의하여, “qwertyuiop”, “asdfghjkl”, “zxcvbnm” 세 값을 넣어 전역 변수로 정의한다.            positions를 문자열의 크기인 26으로 정의하여, 모든 영문자 자리에 키보드 행의 위치를 넣어준다.            결과를 넣을 result를 ArrayList로 초기화한다.       words를 반복하여 아래를 수행한다.            키보드의 행을 저장할 row와, word의 커서 역할을 할 idx를 0으로 초기화한다.       idx를 word의 길이 미만까지 증가시키며 아래를 반복한다.                    word의 idx번째 문자를 c에 넣어준다.           num에 c의 대소문자를 무시한 알파벳 순서를 넣어준다.           row가 0인 경우 첫 문자열이기 때문에 positions의 num번째 값을 넣어준다.           위가 아니면서 row가 positions의 num번째 값과 다른 경우 키보드의 한 행을 이용하여 문자를 구상할 수 없으므로 반복을 종료한다.                       반복이 종료되고 idx가 word의 length와 동일하면 한 행으로 단어를 구성 가능하므로, result에 word를 넣어준다.           반복이 완료되면 result를 문자열의 배열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/keyboard-row/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Mode in Binary Search Tree",
        "excerpt":"문제  Link   코드  class Solution {    private int max = 0;   private int count = 1;   private TreeNode prev = null;    public int[] findMode(TreeNode root) {     List&lt;Integer&gt; list = new ArrayList&lt;&gt;();     this.dfs(root, list);     int[] result = new int[list.size()];     for (int idx = 0; idx &lt; list.size(); idx++) {       result[idx] = list.get(idx);     }     return result;   }    public void dfs(TreeNode node, List&lt;Integer&gt; list) {     if (node == null) {       return;     }     this.dfs(node.left, list);     if (this.prev != null) {       if (node.val == this.prev.val) {         this.count++;       } else {         this.count = 1;       }     }     if (this.count &gt; this.max) {       list.clear();       list.add(node.val);       this.max = this.count;     } else if (this.count == this.max) {       list.add(node.val);     }     this.prev = node;     this.dfs(node.right, list);   }  }   결과  Link   설명          중복된 값이 있는 root를 이용하여 가장 많이 반복된 숫자를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            max는 최대 반복 횟수를 저장할 변수로, 0으로 초기화한다.       count는 현재 숫자의 반복 횟수를 계산할 변수로, 1로 초기화한다.       prev는 현재 노드를 저장하고 다음 탐색을 진행하기 위한 변수로, null로 초기화한다.                결과를 저장할 list를 ArrayList로 초기화하여 4번에서 정의한 dfs(TreeNode node, List list) 메서드를 수행한다.       DFS 방식으로 가장 많이 반복된 숫자를 구할 dfs(TreeNode node, List list) 메서드를 정의한다.            node가 null인 경우, 수행을 중지한다.       node의 left TreeNode를 이용하여 재귀 호출을 수행한다.       prev가 null이 아닌 경우, node의 val과 prev의 val이 동일하면 count를 증가시키고 아니면 count를 1로 초기화한다.       count가 max보다 크면 현재 숫자의 반복 횟수가 더 크므로, list를 초기화 후 list에 node의 val 값을 넣어주고 max에 count를 넣어준다.       count가 max와 동일한 경우 반복 횟수가 동일한 값이므로, list에 node의 val 값을 넣어준다.       prev에 node를 넣어주고 node의 right TreeNode로 재귀 호출을 수행한다.           위의 수행이 완료되면 list의 값들을 정수 배열에 넣어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-mode-in-binary-search-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java IPO",
        "excerpt":"문제  Link   코드  class Solution {    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {     Queue&lt;int[]&gt; profitsQueue = new PriorityQueue&lt;&gt;((a, b) -&gt; b[0] - a[0]);     Queue&lt;int[]&gt; capitalQueue = new PriorityQueue&lt;&gt;((a, b) -&gt; a[0] - b[0]);     for (int idx = 0; idx &lt; profits.length; idx++) {       if (capital[idx] &lt;= w) {         profitsQueue.add(new int[] { profits[idx], idx });       } else {         capitalQueue.add(new int[] { capital[idx], idx });       }     }     while (k-- &gt; 0 &amp;&amp; !profitsQueue.isEmpty()) {       w += profitsQueue.poll()[0];       while (!capitalQueue.isEmpty() &amp;&amp; capitalQueue.peek()[0] &lt;= w) {         profitsQueue.add(new int[] { profits[capitalQueue.poll()[1]], 0 });       }     }     return w;   }  }   결과  Link   설명          w의 초기 자본으로 k개의 개별 프로젝트의 순수 이익인 profits과 최소 자본인 capital을 이용하여 각 최대화된 최종 자본을 반환하는 문제이다.       이익과 자본을 정렬화된 Queue에 넣어 사용하기 위한 profitsQueue와 capitalQueue를 정의한다.            profitsQueue는 내림차순, capitalQueue는 오름차순으로 정렬한다.           0부터 profits의 길이 미만까지 idx를 증가시키며 아래를 반복한다.            capital의 idx번째 값이 w 이하인 경우, profitsQueue에 profits의 idx번째 값과 idx를 배열로 넣어준다.       capital의 idx번째 값이 w 초과인 경우, capitalQueue에 capital의 idx번째 값과 idx를 배열로 넣어준다.           k가 0 초과이고, profitsQueue가 비어있지 않을 때 까지 아래를 반복하고 매 횟수마다 k를 감소시킨다.      w에 profitsQueue의 배열을 꺼내 첫 값인 이익을 더해준다.   capitalQueue가 비어있지 않고, capitalQueue의 다음 배열의 첫 번째 값이 w 이하일 때 까지 반복하여 아래를 수행한다.            profitsQueue에 capitalQueue에서 꺼낸 배열의 두 번째 값인 위치 값에 해당하는 profits의 값을 꺼내 새 정수 배열로 0과 함께 넣어준다.              반복이 완료되면 최대화된 자본을 저장한 w를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/ipo/",
        "teaser": null
      },{
        "title": "Leetcode Java Next Greater Element II",
        "excerpt":"문제  Link   코드  class Solution {    public int[] nextGreaterElements(int[] nums) {     int length = nums.length;     int[] result = new int[length];     Deque&lt;int[]&gt; deque = new ArrayDeque&lt;&gt;();     Arrays.fill(result, -1);     for (int idx = 0; idx &lt; length * 2; idx++) {       while (!deque.isEmpty() &amp;&amp; deque.peek()[0] &lt; nums[idx % length]) {         result[deque.removeFirst()[1]] = nums[idx % length];       }       if (idx &lt; length) {         deque.addFirst(new int[] { nums[idx], idx });       }     }     return result;   }  }   결과  Link   설명     원형으로 순환되는 정수 배열인 nums의 각 요소의 우측에서 가장 가까우면서 현재 값보다 큰 값을 검색하고, 검색한 값들을 동일한 위치의 정수 배열로 만들어 반환하는 문제이다.            단 현재 위치의 값이 나머지 값보다 커서 해당 값보다 큰 값이 존재하지 않는 경우, -1을 넣어준다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장할 변수이다.       result는 결과를 저장할 변수로, length 크기의 정수 배열로 초기화하고 모든 위치에 존재하지 않을 경우에 대한 값인 -1을 넣어준다.       deque는 nums의 값을 위치 별 저장해서 순서 별 꺼내 사용하기 위한 변수로, ArrayDeque로 초기화한다.           0부터 $length \\times 2$ 미만까지 idx를 증가시키며 아래를 반복한다.            deque가 비어있지 않고, deque의 첫 배열의 nums 내 숫자가 nums의 idx % length 번째 값보다 작은 경우 해당 위치의 값보다 크므로 아래를 수행한다.                    deque에서 첫 번째 배열을 꺼내 위치 값에 해당하는 result의 위치에 idx % length 번째 값을 넣어준다.                       idx가 length보다 작을 경우, deque의 첫 값에 nums의 idx번째 값과 idx를 배열로 만들어 넣어준다.           반복이 완료되면 nums의 각 요소 별 값보다 가장 가까운 우측의 큰 값을 넣은 result를 주어진 문제의 결과로 반환한다.   해설  반복의 상한이 $length \\times 2$ 이고, nums의 idx % length 번째 값을 가져오는 이유는 원형으로 순환된다는 전제이기 때문에 최소 횟수의 순환으로 원하는 결과를 탐색하기 위한 아이디어이다.     예를 들어 nums의 배열의 크기가 2인 경우, 위를 통해 nums[0] -&gt; nums[1] -&gt; nums[0] -&gt; nums[1] 순서로 수행하면서 nums[1]보다 우측에 있는 nums[0]의 크기와 비교한 결과를 사용할 수 있다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/next-greater-element-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Base 7",
        "excerpt":"문제  Link   코드  class Solution {    public String convertToBase7(int num) {     if (num == 0) {       return \"0\";     } else {       StringBuilder sb = new StringBuilder();       String sign = \"\";       if (num &lt; 0) {         num *= -1;         sign = \"-\";       }       while (num &gt; 0) {         sb.append(num % 7);         num /= 7;       }       return sb.append(sign).reverse().toString();     }   }  }   결과  Link   설명          num을 7진수로 변환한 문자열로 반환하는 문제이다.            num이 0인 경우 변환할 필요가 없으므로, 그대로 0을 문자열로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            sb는 num을 7진수로 변환한 문자열을 동적으로 넣을 변수로, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.       sign은 num이 음수일 경우 부호를 넣을 변수로, 빈 문자열로 초기화한다.                num이 0보다 작은 음수인 경우, sign에 음수 기호인 “-“을 넣어주고 num에 -1을 곱해서 양수로 만들어준다.       num이 0보다 클 때 까지 반복하여 아래를 수행한다.            num을 7로 나눈 나머지 값을 sb에 넣어주고, num을 7로 나눠준다.           반복이 완료되면 부호를 저장한 sign을 이어주고 sb에 저장한 문자를 앞뒤로 반전시킨 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/base-7/",
        "teaser": null
      },{
        "title": "Leetcode Java Relative Ranks",
        "excerpt":"문제  Link   코드  class Solution {    public String[] findRelativeRanks(int[] score) {     int length = score.length;     int max = 0;     for (int s : score) {       if (s &gt; max) {         max = s;       }     }     int[] map = new int[max + 1];     for (int idx = 0; idx &lt; length; idx++) {       map[score[idx]] = idx + 1;     }     String[] result = new String[length];     int count = 0;     for (int idx = max; idx &gt;= 0; idx--) {       if (map[idx] != 0) {         switch (++count) {           case 1: result[map[idx] - 1] = \"Gold Medal\"; break;           case 2: result[map[idx] - 1] = \"Silver Medal\"; break;           case 3: result[map[idx] - 1] = \"Bronze Medal\"; break;           default: result[map[idx] - 1] = String.valueOf(count);         }       }     }     return result;   }  }   결과  Link   설명          점수를 담은 score를 이용하여 1위는 “Gold Medal”, 2위는 “Silver Medal”, 3위는 “Bronze Medal”, 그 외는 각자 등수를 담은 배열로 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 score의 길이를 저장할 변수이다.       max는 score 내 가장 큰 점수를 저장할 변수로, score를 반복하여 최댓값을 넣어준다.       map은 각 점수 별 위치를 저장할 배열로, $max + 1$ 크기로 정의하고 score를 반복하여 해당 점수에 해당하는 위치에 $idx + 1$을 넣어준다.       result는 결과를 넣어줄 배열로, length의 크기만한 문자열 배열로 정의한다.       count는 등수를 계산할 변수로, 0으로 초기화한다.           max부터 0까지 idx를 감소시키며 반복하여 아래를 수행한다.            map의 idx번째 값이 0이 아닌 경우 score에 존재하는 값으로, 아래의 절차대로 result에 값을 넣어준다.                    count를 증가시킨 값이 1인 경우, result의 $map[idx] - 1$번째 위치에 “Gold Medal”을 넣어준다.           count를 증가시킨 값이 2인 경우, result의 $map[idx] - 1$번째 위치에 “Silver Medal”을 넣어준다.           count를 증가시킨 값이 3인 경우, result의 $map[idx] - 1$번째 위치에 “Bronze Medal”을 넣어준다.           count를 증가시킨 값이 4 이상인 경우, result의 $map[idx] - 1$번째 위치에 count를 넣어준다.                           반복이 완료되면 결과를 넣은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/relative-ranks/",
        "teaser": null
      },{
        "title": "Leetcode Java Perfect Number",
        "excerpt":"문제  Link   코드  class Solution {    public boolean checkPerfectNumber(int num) {     if (num == 1) {       return false;     }     int sum = 1;     for (int idx = 2; idx * idx &lt;= num; idx++) {       if (num % idx == 0) {         sum += idx + (num / idx);       }     }     return sum == num;   }  }   결과  Link   설명     num이 완전수로 이루어졌는지 검증하는 문제이다.            완전수는 양의 제수의 합과 동일한 양의 정수로, 정수 x의 제수는 x를 균등하게 나눌 수 있는 정수이다.       예를 들어, $28 = 1 + 2 + 4 + 7 + 14$는 완전수이다.                nums이 1인 경우 자기 자신을 균등하게 나눌 수있는 양의 정수가 없으므로, 주어진 문제의 결과로 false를 반환한다.            sum은 완전수를 검증하기 위한 합계를 위한 변수로, 첫 값인 1로 초기화한다.       2부터 idx의 제곱이 sum보다 작을 때 까지 idx를 증가하여 아래를 검증한다.            num을 idx로 나머지 없이 나눌 수 있을 경우, sum에 idx와 $\\frac{num}{idx}$의 합을 더해준다.                    idx와 $\\frac{num}{idx}$의 곱은 num으로, num의 두 제수의 합을 의미한다.                           반복이 완료된 경우 sum과 num이 동일한지 검증하여, 해당 결과를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/perfect-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Most Frequent Subtree Sum",
        "excerpt":"문제  Link   코드  class Solution {    private int max = 0;    public int[] findFrequentTreeSum(TreeNode root) {     List&lt;Integer&gt; list = new ArrayList&lt;&gt;();     this.dfs(root, new HashMap&lt;&gt;(), list);     int[] result = new int[list.size()];     for (int idx = 0; idx &lt; list.size(); idx++) {       result[idx] = list.get(idx);     }     return result;   }    private int dfs(TreeNode root, Map&lt;Integer, Integer&gt; map, List&lt;Integer&gt; list) {     if (root == null) {       return 0;     }     int sum = root.val + this.dfs(root.left, map, list) + this.dfs(root.right, map, list);     int frequency = map.getOrDefault(sum, 0) + 1;     map.put(sum, frequency);     if (frequency &gt; this.max) {       max = frequency;       list.clear();       list.add(sum);     } else if (frequency == this.max) {       list.add(sum);     }     return sum;   }  }   결과  Link   설명          root 내 빈도수가 가장 많은 하위 트리의 합계를 반환하는 문제이다.            max는 최고 빈도수를 저장할 전역 변수로, 0으로 초기화한다.            빈도수가 가장 많은 하위 트리의 합계를 넣을 list를 정의하고, 새 HashMap과 함께 4번에서 정의한 dfs(TreeNode root, Map&lt;Integer, Integer&gt; map, List list) 메서드를 수행한다.       DFS 방식으로 root를 탐색하여 list에 결과를 넣어줄 dfs(TreeNode root, Map&lt;Integer, Integer&gt; map, List list) 메서드를 정의한다.            root가 null인 경우, 0을 반환한다.       sum에 root의 val 값과 left와 right의 TreeNode로 재귀 호출을 수행한 결과를 합쳐준다.       frequency에 map에서 sum에 해당하는 값을 가져와 1을 더한 값을 저장하고, 다시 해당 값을 넣어준다.       max보다 frequency가 높은 경우 최고 빈도인 부분 노드가 발생하였으므로, list를 초기화하고 sum을 넣어준다.       max와 frequency가 같은 경우 동일한 최고 빈도의 부분 노드이므로, list에 sum을 넣어준다.       수행이 완료되었으면 sum을 반환한다.                list의 값들을 정수 배열로 변환해서 넣을 result 배열을 list 크기로 초기화하고, list의 모든 값들을 result에 넣어준다.       반복이 완료되면 주어진 문제의 결과로 result를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/most-frequent-subtree-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Fibonacci Number",
        "excerpt":"문제  Link   코드  class Solution {    public int fib(int n) {     if (n &lt;= 1) {       return n;     }     int pre = 0;     int curr = 0;     int result = 1;     for (int idx = 2; idx &lt;= n; idx++) {       pre = curr;       curr = result;       result = pre + curr;     }     return result;   }  }   결과  Link   설명          피보나치 수열의 n번째 숫자를 반환하는 문제이다.            n 이 1 이하인 경우 피보나치 수열의 결과와 순번이 동일하므로, n을 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            pre는 피보나치 수열의 $n - 2$번째 값을 저장하기 위한 변수이다.       curr은 피보나치 수열의 $n - 1$번째 값을 저장하기 위한 변수이다.       result는 피보나치 수열의 n번째 값을 저장하기 위한 변수이다.           2부터 n까지 idx를 증가시키며 피보나치 수열의 값을 계산한다.            pre에 curr을, curr에 result 값을 넣어준다.       result는 pre와 curr의 값의 합을 넣어준다.           반복이 완료되면 피보나치 수열의 n번째 값을 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/fibonacci-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Bottom Left Tree Value",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public int findBottomLeftValue(TreeNode root) {     return this.dfs(root, 1, new int[] { 0, 0 });   }    private int dfs(TreeNode root, int depth, int[] result) {     if (result[1] &lt; depth) {       result[0] = root.val;       result[1] = depth;     }     if (root.left != null) {       this.dfs(root.left, depth + 1, result);     }     if (root.right != null) {       this.dfs(root.right, depth + 1, result);     }     return result[0];   }  }   결과  Link   설명          root의 왼쪽에 존재하는 모든 노드 중 가장 큰 값을 구하는 문제이다.            3번에서 정의한 dfs(TreeNode root, int depth, int[] result) 메서드를 1 depth부터 result에 [0, 0]를 넣어 수행한 결과를 반환한다.            DFS 방식으로 좌측의 모든 노드를 탐색해서 결과를 넣을 dfs(TreeNode root, int depth, int[] result) 메서드를 정의한다.             depth가 result[1]인 depth가 보다 큰 경우, root의 val 값과 depth를 쌍으로 result에 넣어준다.       root의 left가 null이 아니면 재귀 호출을 이용하여 depth를 1 증가하여 수행한다.       root의 right가 null이 아니면 재귀 호출을 이용하여 depth를 1 증가하여 수행한다.       result[0]인 최대 val 값을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-bottom-left-tree-value/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Game Play Analysis I",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT player_id, MIN(event_date) AS first_login FROM Activity GROUP BY player_id   결과  Link   설명     Activity Table의 player_id 별 최초 로그인 날자를 구하는 문제이다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/game-play-analysis-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Freedom Trail",
        "excerpt":"문제  Link   코드  class Solution {    public int findRotateSteps(String ring, String key) {     int length = ring.length();     List&lt;Integer&gt;[] position = new ArrayList[26];     int[][] dp = new int[length][key.length()];     for (int idx = 0; idx &lt; 26; idx++) {       position[idx] = new ArrayList&lt;&gt;();     }     for (int idx = 0; idx &lt; length; idx++) {       position[ring.charAt(idx) - 'a'].add(idx);     }     return this.dfs(position, dp, ring, length, key, 0, 0);   }    private int dfs(List&lt;Integer&gt;[] position, int[][] dp, String ring, int length, String key, int x, int y) {     if (y == key.length()) {       return 0;     } else if (dp[x][y] != 0) {       return dp[x][y];     } else {       int result = Integer.MAX_VALUE;       for (int num : position[key.charAt(y) - 'a']) {         int diff = Math.abs(x - num);         result = Math.min(result, Math.min(diff, length - diff) + this.dfs(position, dp, ring, length, key, num, y + 1));       }       dp[x][y] = result + 1;       return result + 1;     }   }  }   결과  Link   설명          ring에 포함된 문자를 다어얼 형태로 배치하여 key에 해당하는 단어를 만들기 위한 최소 횟수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 ring의 길이를 저장할 변수이다.       position은 ring에 포함된 단어의 위치 값을 저장하기 위한 변수로, 알파벳 크기인 26의 ArrayList 배열로 정의한다.       dp는 경우의 수를 저장하기 위한 변수로, length와 key의 길이 크기인 2차원 배열로 정의한다.                position에 ArrayList를 초기화하여 넣어주고, ring의 모든 문자의 위치 값을 position 내 해당 알파벳 위치값에 해당하는 ArrayList에 넣어준다.            5번에서 정의한 dfs(List[] position, int[][] dp, String ring, int length, String key, int x, int y) 메서드를 수행한 결과를 주어진 문제의 결과로 반환한다.       DFS 방식으로 문제를 탐색할 dfs(List[] position, int[][] dp, String ring, int length, String key, int x, int y) 메서드를 정의한다.            y가 key의 length와 동일한 경우, 해당 값이 존재하지 않으므로 0을 반환한다.       dp[x][y] 값이 0이 아닌 경우, 이미 탐색된 위치의 값이므로 dp[x][y]의 값을 반환한다.       result에 정수의 최댓값을 넣어준다.       key의 y번째 문자에 해당하는 ArrayList를 position에서 꺼내 각 값을 num으로 아래를 수행한다.                    diff에 x와 num의 차이의 절대값을 넣어준다.           result에 diff와 $length - diff$ 중 작은 값과 x에 num, y에 $y + 1$를 넣고 재귀 수행한 결과와 result 중 작은 값을 넣어준다.                       dp[x][y]에 $result + 1$를 넣어주고 해당 값을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/freedom-trail/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Largest Value in Each Tree Row",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; largestValues(TreeNode root) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     this.dfs(root, result, 0);     return result;   }    private void dfs(TreeNode root, List&lt;Integer&gt; result, int level) {     if (root != null) {       if (result.size() == level) {         result.add(root.val);       } else {         if (root.val &gt; result.get(level)) {           result.set(level, root.val);         }       }       this.dfs(root.left, result, level + 1);       this.dfs(root.right, result, level + 1);     }   }  }   결과  Link   설명          root의 level 별 가장 큰 값들을 반환하는 문제이다.            결과를 저장할 result 배열을 ArrayList로 정의한다.            4번에서 정의한 dfs(TreeNode root, List result, int level) 메서드를 level에 0을 넣어 수행한다.       DFS 방식으로 각 층 별 큰 값을 result에 넣기 위한 dfs(TreeNode root, List result, int level) 메서드를 정의한다.            root가 null이 아닌 경우만 아래를 수행한다.       result의 크기와 level이 동일한 경우 해당 level의 첫 수행이므로, root의 val 값을 우선 넣어준다.       result의 크기와 level이 다른 경우 각 level의 값이 있으므로, result에서 level에 해당하는 위치의 값과 root의 val 값을 비교해서 큰 값을 result의 level에 해당하는 위치에 넣어준다.       root의 left와 right TreeNode로 level을 1 증가시켜 각각 재귀 호출을 수행한다.           수행이 완료되면 root의 각 level 별 가장 큰 값을 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-largest-value-in-each-tree-row/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Palindromic Subsequence",
        "excerpt":"문제  Link   코드  class Solution {    public int longestPalindromeSubseq(String s) {     char[] charArray = s.toCharArray();     int length = charArray.length;     int max = 0;     int[] dp = new int[length];     for (int j = 0; j &lt; length; j++) {       dp[j] = 1;       max = 0;       for (int i = j - 1; i &gt;= 0; i--) {         int len = dp[i];         if (charArray[i] == charArray[j]) {           dp[i] = 2 + max;         }         max = Math.max(max, len);       }     }     for (int len : dp) {       max = Math.max(max, len);     }     return max;   }  }   결과  Link   설명          문자열의 앞과 끝을 이어 원형으로 구성했을 경우, 부분 문자열 중 가장 긴 반복되는 단어의 길이를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            charArray는 s의 문자를 배열로 전환해서 저장할 변수이다.       length는 s의 길이인 charArray의 길이를 저장할 변수이다.       max는 최댓값을 저장하기 위한 변수이다.       dp는 길이를 추정하기 위한 배열을 저장하기 위한 배열로, length 크기로 정의한다.           0부터 length 미만까지 j를 증가시키며 반복을 수행한다.            dp의 j번째 위치에 1으로, max를 0으로 초기화한다.       $j - 1$부터 0까지 i를 감소시키며 역순으로 탐색을 수행한다.                    len에 dp의 i번째 값을 보관해준다.           charArray의 i번쨰 값과 j번째 값이 동일한 경우 두 단어가 동일하므로, dp의 i번째 위치에 $2 + max$를 넣어준다.           max에 max와 len 중 큰 값을 넣어준다.                           반복이 완료되면 dp를 반복하여 max와 dp의 값중 가장 큰 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-palindromic-subsequence/",
        "teaser": null
      },{
        "title": "Leetcode Java Super Washing Machines",
        "excerpt":"문제  Link   코드  class Solution {    public int findMinMoves(int[] machines) {     int total = 0;     int length = machines.length;     for (int machine : machines) {       total += machine;     }     if (total % length != 0) {       return -1;     }     int avg = total / length;     int count = 0;     int max = 0;     int diff = 0;     for (int machine : machines) {       diff = machine - avg;       count += diff;       max = Math.max(Math.max(max, Math.abs(count)), diff);     }     return max;   }  }   결과  Link   설명     세탁기 내 옷의 개수를 담은 machines 배열의 모든 값들을 동일하게 맞추기 위한 최소 횟수를 구하는 문제이다.            단, 동일하게 맞추지 못하는 경우 -1을 주어진 문제의 결과로 반환한다.           사전 검증에 필요한 변수를 정의한다.            total은 모든 세탁기 내 옷의 개수를 저장할 변수로, machines를 반복하여 모든 옷의 개수를 더해준다.       length는 machines의 길이를 저장한 변수이다.                total을 length로 나눈 나머지 값이 0이 아닌 경우 모든 세탁기에 옷을 동일한 개수로 분배할 수 없으므로, -1을 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            avg는 각 세탁기에 옷을 나눠 넣을 개수를 저장할 변수로, total을 length로 나눈 결과를 저장한다.       count는 세탁기에 옷을 고르게 넣을 때 필요한 옷의 개수를 저장할 변수로, 0으로 초기화한다.       max는 세탁기 내 옷의 개수를 동일하게 맞추기 위한 최소 이동 횟수를 저장하기 위한 변수로, 0으로 초기화한다.       diff는 세탁기의 부족한 옷의 개수를 저장하기 위한 변수로, 0으로 초기화한다.           machines의 모든 값을 반복하여 아래를 수행한다.            diff에 machine에 avg를 뺀 값인 현재 세탁기의 부족하거나 여유있는 옷의 개수를 넣어준다.       count에는 diff를 추가하여 현재까지 고르게 분배하기 위한 부족하거나 여유있는 옷의 개수를 저장한다.       max, count의 절댓값, diff 세 값 중 가장 큰 값을 max에 넣어준다.                    count의 절댓값은 부족하거나(-) 여유있는(+) 옷을 이동하는 횟수로 부호가 중요하지 않고 값이 중요하기 때문에 절댓값으로 변환하여 비교를 한다.                           반복이 완료되면 최소 횟수를 저장한 max를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/super-washing-machines/",
        "teaser": null
      },{
        "title": "Leetcode Java Coin Change 2",
        "excerpt":"문제  Link   코드  class Solution {    public int change(int amount, int[] coins) {     int[] dp = new int[amount + 1];     dp[0] = 1;     for (int coin : coins) {       for (int idx = coin; idx &lt;= amount; idx++) {         dp[idx] += dp[idx - coin];       }     }     return dp[amount];   }  }   결과  Link   설명     Coin Change와 유사한 문제로, coins 내 각 coin을 활용하여 amount의 금액이 되는 경우의 수를 구하는 문제이다.            단, 각 coin은 반복 사용이 가능하다.                dp는 각 경우의 수를 구하기 위한 배열로, $amount + 1$ 크기로 정의하고 첫 값에 1을 넣어준다.       coins의 모든 값을 반복하고, coin부터 amount 이하까지 idx를 증가시키며 반복을 하여 아래를 수행한다.            dp의 idx번째 경우의 수에 dp의 $idx - coin$번째 경우의 수를 더하여 dp의 idx번째 위치의 값이 amount일 경우 만들 수 있는 경우의 수를 추가해준다.           반복이 완료되어 dp에 값이 다 들어가면 주어진 문제의 결과로 dp의 amount번째 값을 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/coin-change-2/",
        "teaser": null
      },{
        "title": "Leetcode Java Random Flip Matrix",
        "excerpt":"문제  Link   코드  class Solution {    private Map&lt;Integer, Integer&gt; map;   private int m;   private int n;   private int total;   private Random random;    public Solution(int m, int n) {     this.random = new Random();     this.m = m;     this.n = n;     this.reset();   }    public int[] flip() {     int num = this.random.nextInt(this.total--);     int value = this.map.getOrDefault(num, num);     this.map.put(num, this.map.getOrDefault(this.total, this.total));     this.map.put(this.total, value);     return new int[] { value / this.n, value % this.n };   }    public void reset() {     this.map = new HashMap&lt;&gt;();     this.total = this.m * this.n;   }  }  /**  * Your Solution object will be instantiated and called as such:  * Solution obj = new Solution(m, n);  * int[] param_1 = obj.flip();  * obj.reset();  */   결과  Link   설명     $m \\times n$ 크기의 이차원 배열은 모두 0으로 채워져 있으나, 특정 셀을 랜덤하게 선택하여 해당 행과 열을 배열로 반환하고 1로 뒤집는 Solution 클래스를 완성하는 문제이다.            생성자인 Solution(int m, int n)은 객체를 초기화하는 역할을 수행한다.       메서드인 flip()은 임의 셀을 선택하여 해당 값을 1로 변경 후, 해당 셀의 위치 값을 배열로 반환한다.       메서드인 reset()은 배열 내 값을 0으로 초기화하는 역할을 수행한다.           문제 풀이에 필요한 변수를 정의한다.            map은 Fisher–Yates shuffle 방식을 활용하여 임의 위치의 값을 저장하기 위한 변수이다.       m은 2차원 배열의 행, n은 열을 나타내고, total은 $m \\times n$의 크기르 저장하기 위한 변수이다.       random은 임의 위치를 동일한 확률로 탐색하기 위한 변수이다.           생성자인 Solution(int m, int n)을 정의한다.            random에 Java의 Random 객체를 정의해 넣어준다.       m과 n은 주어진 m과 n을 이용하여 값을 넣어주고, 5번에서 정의한 reset() 메서드를 호출하여 나머지 객체를 초기화한다.           메서드인 flip()을 정의한다.            num에 random을 활용하여 0 ~ total 까지의 임의 숫자인 인덱스를 생성하고 total을 감소시킨다.       value에 map 내 num이 키인 값이 있는지 확인하여 가져와 넣어주고, 없을 경우 num을 넣어준다.       map 내 total이 키인 값이 있으면 해당 값을, 없을 경우 total을 map 내 num이 키인 값에 넣어준다.       value를 행인 n으로 나누어 값을 행으로, 나머지를 열로 배열을 만들어 반환한다.           메서드인 reset()을 정의한다.            map에 HashMap을 넣어 초기화한다.       total에 2차원 배열의 크기인 $m \\times n$을 넣어준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/random-flip-matrix/",
        "teaser": null
      },{
        "title": "Leetcode Java Detect Capital",
        "excerpt":"문제  Link   코드  class Solution {    public boolean detectCapitalUse(String word) {     int count = 0;     for (char c : word.toCharArray()) {       if (c - 97 &lt; 0) {         count++;       }     }     return count == 0 ||         word.length() == count ||         (count == 1 &amp;&amp; word.charAt(0) - 97 &lt; 0);   }  }   결과  Link   설명     word가 아래의 조건을 만족하는지 검증하는 문제이다.            word의 모든 문자가 대문자 혹은 소문자로만 이루어져있다.       word의 첫 문자만 대문자로 이루어져있다.                대문자의 수를 저장할 count를 정의하고 word의 모든 문자를 확인하여 대문자의 수를 넣어준다.       아래 조건을 확인하여 만족하는지 검증하여 하나라도 만족하면 true를, 모두 아니면 false를 주어진 문제의 결과로 반환한다.            count가 0이면 word의 문자들이 모두 소문자로 이루어져있는 경우이다.       word의 길이와 count가 동일하면 모두 대문자로 이루어져있는 경우이다.       count가 1이고 word의 첫 글자가 대문자이면 첫 문자만 대문자이고 나머지는 소문자로 이루어져있는 경우이다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/detect-capital/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Uncommon Subsequence I",
        "excerpt":"문제  Link   코드  class Solution {    public int findLUSlength(String a, String b) {     return a.equals(b) ? -1 : Math.max(a.length(), b.length());   }  }   결과  Link   설명          영소문자로만 이루어진 문자열 a와 b 중 유일한 가장 긴 부분 수열 문자열의 길이를 구하는 문제로, 유일한 부분 수열 문자열이 존재하지 않으면 -1을 반환한다.            a와 b의 가장 긴 부분 수열 문자열은 a와 b이므로 아래의 검증을 통해 결과를 반환한다.             a와 b가 동일한 경우 부분 수열 문자열 모두가 동일하므로, -1을 주어진 문제의 결과로 반환한다.       a와 b가 동일하지 않은 경우 a와 b 중 가장 긴 문자열의 길이가 두 문자열 중 유일한 가장 긴 부분 수열 문자열의 길이이므로, 해당 값을 주어진 문제의 결과로 반환한다.           해설     제시된 문제가 헷갈릴 수 있으므로 해설을 추가하면, 단순히 제시하는 Longest Uncommon Subsequence(가장 긴 흔치 않은 부분 수열)에 초점을 잡아야 한다.            문제는 Uncommon(흔치 않은)이라고 제시하지만 내용을 확인해 보면 Unique(유일한)가 맞지 않을까 한다.           모든 문자열의 부분 수열 중 가장 긴 값은 자기 자신이다.            “abcde”의 부분 수열은 공백인 [””] 부터 한 문자로 이루어진 [“a”, … , “e”] ~ 자기 자신인 [“abcde”] 까지 존재하므로, Longest Subsequence(가장 긴 부분 수열)에 해당하는 문자열은 자기 자신인 “abcde”일 수 밖에 없다.           제시된 a와 b 문자열이 동일하면 부분 수열 문자열은 동일할 수 밖에 없으므로, Uncommon Subsequence(흔치않은 부분 수열)은 존재하지 않는다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-uncommon-subsequence-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Uncommon Subsequence II",
        "excerpt":"문제  Link   코드  class Solution {    public int findLUSlength(String[] strs) {     int result = -1;     int length = strs.length;     for (int i = 0; i &lt; length; i++) {       if (strs[i].length() &lt; result) {         continue;       }       int j = -1;       while (++j &lt; length) {         if (i != j &amp;&amp; this.isSubsequence(strs[i], strs[j])) {           break;         }       }       if (j == length) {         result = Math.max(result, strs[i].length());       }     }     return result;   }    private boolean isSubsequence(String s1, String s2) {     int i = 0;     int j = 0;     while (i &lt; s1.length() &amp;&amp; j &lt; s2.length()) {       if (s1.charAt(i) == s2.charAt(j++)) {         i++;       }     }     return i == s1.length();   }  }   결과  Link   설명          이전 Longest Uncommon Subsequence I와 유사한 문제로, strs 배열 내 문자열들 중 유일한 가장 긴 부분 수열 문자열의 길이를 구하는 문제로, 유일한 부분 수열 문자열이 존재하지 않으면 -1을 반환한다.       문제 풀이에 필요한 변수를 정의한다.            result는 strs 배열 내 문자열들 중 유일한 가장 긴 부분 수열 문자열의 길이를 저장할 변수로, 존재하지 않을 경우의 값인 -1로 초기화한다.       length는 strs 배열의 크기를 저장한 변수이다.           0부터 length 미만까지 i를 증가시키며 반복을 수행한다.            strs의 i번째 문자열의 길이가 result보다 작은 경우, 탐색할 의미가 없으므로 다음 반복을 수행한다.       j를 -1로 초기화 하여 length보다 작을 때 까지 j를 증가시키며, i와 j가 같지 않고 4번에서 정의한 isSubsequence(String s1, String s2) 메서드를 이용하여 i번째 문자열이 j번째 문자열의 부분 수열이면 반복을 중지한다.       j가 length와 동일한 경우 마지막 문자열까지 탐색하였으므로, result에 result와 i번째 문자열의 길이 중 큰 값을 넣어준다.           s1이 s2의 부분 수열인지를 검증하기 위한 isSubsequence(String s1, String s2) 메서드를 정의한다.            i는 s1의 위치 값을, j는 s2의 위치 값을 나타낼 변수로 0으로 초기화한다.       i가 s1 길이 미만이고, j가 s2 길이 미만일 때 까지 아래를 반복한다.                    s1의 i번째 문자가 s2의 j번째 문자와 동일한지 검증하면서 j를 증가시키고, 동일한 경우에만 i를 증가시킨다.                       반복이 완료되면 i와 s1의 길이가 동일한지 검증하여, s1이 s2의 부분 수열에 속하는지 결과를 반환한다.           반복이 완료되면 strs 배열 내 문자열들 중 유일한 가장 긴 부분 수열 문자열의 길이를 저장할 변수인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-uncommon-subsequence-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Continuous Subarray Sum",
        "excerpt":"문제  Link   코드  class Solution {    public boolean checkSubarraySum(int[] nums, int k) {     int length = nums.length;     int sum = nums[length - 1];     for (int i = length - 2; i &gt;= 0; i--) {       if (nums[i] == 0 &amp;&amp; nums[i + 1] == 0) {         return true;       } else {         sum += nums[i];       }       if (sum == 0 || sum &gt;= k) {         int subSum = nums[i];         for (int j = i + 1; j &lt; length; j++) {           subSum += nums[j];           if (subSum % k == 0) {             return true;           }         }       }     }     return false;   }  }   결과  Link   설명     nums의 최소 2개 이상의 연속된 요소로 이루어진 부분 배열의 합이 k의 배수를 충족하는지 검증하는 문제이다.            0은 항상 k의 배수이다.           문제 풀이에 필요한 변수를 정의한다.            length는 num의 길이를 저장한 변수이다.       sum은 연속된 값의 합을 저장하기 위한 변수로, nums의 $legnth - 1$번째 값을 넣어준다.                    부분 배열은 최소 2개 이상의 연속된 요소로 이루어져야 하므로, 모든 sum은 하나의 값을 넣어 초기화하고 다음 위치의 값부터 검증을 수행해야한다.                           $length - 2$ 부터 0까지 i를 감소시키며 아래의 반복을 수행한다.            nums의 i번째 값과 $i + 1$번째 값이 0이면 두 값의 합은 0으므로 무조건 k의 배수를 충족하므로, true를 주어진 문제의 결과로 반환한다.       그렇지 않은 경우 sum에 nums의 i번째 값을 넣어준다.       sum이 0이거나 k 이상인 경우 아래를 수행하여 부분 배열의 합이 조건을 만족하는지 검사한다.                    부분 배열의 합을 저장하기 위한 subSum을 정의하여 nums[i]을 넣어주고, $i + 1$부터 length까지 j를 증가시키며 subSum에 값을 더해준다.           위의 subSum이 k의 배수를 만족하면, true를 주어진 문제의 결과로 반환한다.                           반복이 완료되면 최소 2개 이상의 연속된 요소로 이루어진 부분 배열의 합이 k의 배수가 되는 경우가 없으므로, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/continuous-subarray-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Word in Dictionary through Deleting",
        "excerpt":"문제  Link   코드  class Solution {    public String findLongestWord(String s, List&lt;String&gt; dictionary) {     String result = \"\";     for (String word : dictionary) {       if ((word.length() &gt; result.length() || (word.length() == result.length() &amp;&amp; word.compareTo(result) &lt; 0))           &amp;&amp; this.isSubsequence(word, s)) {         result = word;       }     }     return result;   }    private boolean isSubsequence(String str1, String str2) {     int i = 0;     int j = 0;     while (i &lt; str1.length() &amp;&amp; j &lt; str2.length()) {       if (str1.charAt(i) == str2.charAt(j)) {         i++;       }       j++;     }     return i == str1.length();   }  }   결과  Link   설명     dictionary 중 s의 일부 문자를 제거하고 만들 수 있는 가장 긴 문자열을 찾는 문제이다.            동일한 길이의 문자열이 있는 경우, 사전 순서가 가장 작은(빠른) 순서의 단어를 반환한다.       만들 수 있는 문자열이 없는 경우, 빈 문자열(““)을 반환한다.                결과를 넣을 result를 빈 문자열(““)로 초기화한다.       dictionary를 모두 순회하여 아래의 경우를 모두 만족하면, result에 word를 넣어준다.            word의 길이가 result의 길이보다 길거나, word와 result의 길이가 같은 경우 word가 result보다 사전 순서가 빠른 경우 기본 조건을 만족한다.       4번에서 정의한 isSubsequence(String str1, String str2) 메서드를 만족한다.           s1이 s2의 부분 수열인지를 검증하기 위한 isSubsequence(String s1, String s2) 메서드를 정의한다.            i는 s1의 위치 값을, j는 s2의 위치 값을 나타낼 변수로 0으로 초기화한다.       i가 s1 길이 미만이고, j가 s2 길이 미만일 때 까지 아래를 반복한다.                    s1의 i번째 문자가 s2의 j번째 문자와 동일한지 검증하면서 j를 증가시키고, 동일한 경우에만 i를 증가시킨다.                       반복이 완료되면 i와 s1의 길이가 동일한지 검증하여, s1이 s2의 부분 수열에 속하는지 결과를 반환한다.           반복이 완료되면 조건에 부합하는 단어를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-word-in-dictionary-through-deleting/",
        "teaser": null
      },{
        "title": "Leetcode Java Contiguous Array",
        "excerpt":"문제  Link   코드  class Solution {    public int findMaxLength(int[] nums) {     int length = nums.length;     int[] dp = new int[2 * length + 1];     Arrays.fill(dp, -2);     dp[length] = -1;     int result = 0;     int index = length;     for (int idx = 0; idx &lt; length; idx++) {       index += nums[idx] == 0 ? -1 : 1;       if (dp[index] &gt;= -1) {         result = Math.max(result, idx - dp[index]);       } else {         dp[index] = idx;       }     }     return result;   }  }   결과  Link   설명          0과 1의 조합으로 연속되어 이루어진 가장 긴 부분 배열의 길이를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       dp는 길이를 계산에 활용하기 위한 배열로, $2 \\times length + 1$ 크기로 초기화 하고 nums의 length 위치에는 -1을 나머지는 -2를 넣어준다.                    nums가 1로만 이루어져 있을 경우, nums의 위치에서 증가하여 계산하기 때문에 nums의 길이를 중심으로 좌우의 공간을 맞춰주고 -1 낮은 값으로 초기화한다.                       result는 0과 1의 조합으로 연속되어 이루어진 가잔 긴 부분 배열의 길이를 넣을 변수로, 0으로 초기화한다.       index는 0과 1의 밸런스를 맞춰 계산하기 위한 가중치로, length로 초기화한다.           0부터 nums의 길이 미만까지 idx를 증가시키며 아래를 반복한다.            count에 nums의 idx가 0이면 -1을, 1이면 1을 더해준다.       dp의 index번째 값이 -1보다 크거나 같은 경우, result에 result와 $idx - dp[index]$ 값 중 큰 값을 넣어준다.                    단순히 dp[index]의 값은 위치에 대한 보정 값으로, $idx - dp[index]$는 idx번째까지 [0, 1] 혹은 [1, 0]의 조합의 반복 횟수를 나타낸다.                       dp의 index번째 값이 -1보다 작은 경우, dp의 index번째 값에 idx를 넣어준다.           반복이 완료되면 가장 긴 부분 배열의 길이를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/contiguous-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Beautiful Arrangement",
        "excerpt":"문제  Link   코드  class Solution {    public int countArrangement(int n) {     int[] array = new int[n];     for (int idx = 0; idx &lt; n; idx++) {       array[idx] = idx + 1;     }     return this.recursive(array, n - 1);   }    private int recursive(int[] array, int index) {     if (index == 0) {       return 1;     }     int count = 0;     for (int idx = index; idx &gt;= 0; idx--) {       this.swap(array, index, idx);       int num = index + 1;       if (array[index] % num == 0 || num % array[index] == 0) {         count += this.recursive(array, index - 1);       }       this.swap(array, index, idx);     }     return count;   }    private void swap(int[] array, int i, int j) {     int temp = array[i];     array[i] = array[j];     array[j] = temp;   }  }   결과  Link   설명     1 ~ n까지 아래의 조건을 만족하는 배열의 수를 구하는 문제이다.            i는 1 &lt;= i &lt;= n 를 만족한다.       perm[i]는 i로 나눌 수 있다.       i 는 perm[i]으로 나눌 수 있다.                n 크기의 배열인 array를 정의하여 모든 자리에 1부터 n까지 값을 넣어준다.            4번에서 정의한 recursive(int[] array, int index) 결과를 주어진 문제의 결과로 반환한다.       재귀 호출을 통해 1번의 조건을 만족하는 경우의 수를 계산하기 위한 recursive(int[] array, int index) 메서드를 정의한다.            index가 0인 경우, 계산할 필요 없이 1을 반환한다.       count를 0으로 정의하고 index부터 0까지 idx를 감소시키며 계산을 수행한다.                    array의 index번째 값과 idx번째 값을 바꾸어준다.           num에 $ndex + 1$인 위치를 숫자로 변환한 값을 넣어준다.           1번에서 정의한 조건인 array[index]를 num으로, num을 array[index]로 나눌 수 있는지 검증하여 count에 $index - 1$을 넣어 재귀 호출 한 결과를 더해준다.           다시 array의 index번째 값과 idx번쨰 값을 바꾸어 원상복구한다.                       반복이 완료되면 count를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/beautiful-arrangement/",
        "teaser": null
      },{
        "title": "Leetcode Java Random Pick with Weight",
        "excerpt":"문제  Link   코드  class Solution {    private Random random;   private int[] sum;   private int length;    public Solution(int[] w) {     this.random = new Random();     for (int i = 1; i &lt; w.length; ++i) {       w[i] += w[i - 1];     }     this.sum = w;     this.length = w.length;   }    public int pickIndex() {     int left = 0;     int right = this.length - 1;     int index = this.random.nextInt(this.sum[this.length - 1]) + 1;     while (left &lt; right) {       int mid = left + (right - left) / 2;       if (this.sum[mid] == index) {         return mid;       } else if (this.sum[mid] &lt; index) {         left = mid + 1;       } else {         right = mid;       }     }     return left;   }  }  /**  * Your Solution object will be instantiated and called as such:  * Solution obj = new Solution(w);  * int param_1 = obj.pickIndex();  */   결과  Link   설명     w 내 값을 저장하고 임의 확률대로 반환하는 Solution 객체를 완성하는 문제이다.            생성자인 Solution(int[] w)은 w를 이용하여 객체를 초기화한다.       메서드인 pickIndex()는 아래의 확률대로 w 내 임의 값을 반환하는 역할을 수행한다.                    w 내 모든 값의 합을 sum이라 할 때, w[i]의 선택 확률은 $\\frac{w[i]}{sum}$                           문제 풀이에 필요한 전역 변수를 정의한다.            random은 임의 확률로 값을 반환하기 위한 변수이다.       sum은 생성자를 통해 주입된 w의 각 요소 별 누계를 넣어 저장할 배열이다.       length는 생성자를 통해 주입된 w의 길이를 저장할 변수이다.           생성자인 Solution(int[] w)을 완성한다.            random에 java의 Random 객체로 초기화한다.       w를 반복하여 이전 값을 누계한 후 sum에 넣어준다.       length에 w의 길이를 넣어 초기화한다.           메서드인 pickIndex()를 완성한다.            left에 0, right에 $length - 1$을 넣어 초기화한다.       index에 random을 활용하여 0부터 sum의 가장 큰 값 사이의 임의 값을 가져와 1을 더한 값을 넣어준다.       left가 right 미만일 때 까지 반복하여 아래를 수행하여 탐색을 수행한다.                    mid에 $left + \\frac{right - left}{2}$를 넣어준다.           sum의 mid번째 값이 index인 경우, mid를 반환한다.           sum의 mid번째 값이 index보다 작은 경우, left에 $mid + 1$을 넣어 값의 범위를 좁혀준다.           sum의 mid번째 값이 index보다 큰 경우, right에 mid를 넣어 값의 범위를 좁혀준다.                       반복이 완료되면 index 값에 가까운 값이 계산된 위치인 left를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/random-pick-with-weight/",
        "teaser": null
      },{
        "title": "Leetcode Java Minesweeper",
        "excerpt":"문제  Link   코드  class Solution {    public char[][] updateBoard(char[][] board, int[] click) {     int x = click[0];     int y = click[1];     if (board[x][y] == 'M') {       board[x][y] = 'X';     } else {       this.dfs(board, x, y, board.length, board[0].length);     }     return board;   }    private void dfs(char[][] board, int x, int y, int rowLength, int colLength) {     if (x &lt; 0 || y &lt; 0 || x &gt;= rowLength || y &gt;= colLength || board[x][y] != 'E') {       return;     }     int num = this.findMines(board, x, y, rowLength, colLength);     if (num == 0) {       board[x][y] = 'B';       for (int i = -1; i &lt;= 1; i++) {         for (int j = -1; j &lt;= 1; j++) {           this.dfs(board, x + i, y + j, rowLength, colLength);         }       }     } else {       board[x][y] = (char) ('0' + num);     }   }    private int findMines(char[][] board, int x, int y, int rowLength, int colLength) {     int count = 0;     for (int i = -1; i &lt;= 1; i++) {       for (int j = -1; j &lt;= 1; j++) {         int x1 = x + i;         int y1 = y + j;         if (x1 &gt;= 0 &amp;&amp; y1 &gt;= 0 &amp;&amp; x1 &lt; rowLength &amp;&amp; y1 &lt; colLength &amp;&amp; board[x1][y1] == 'M') {           count++;         }       }     }     return count;   }  }  /**  * Your Solution object will be instantiated and called as such:  * Solution obj = new Solution(w);  * int param_1 = obj.pickIndex();  */   결과  Link   설명     board 크기의 지뢰찾기 게임을 하는 중 click한 위치부터 시작해서 지뢰를 모두 찾을 때 까지 단계를 반복하여 board를 반환하는 문제이다.            ‘M’은 미공개 지뢰를 의미한다.       ‘E’는 드러나지 않은 셀을 의미한다.       ‘B’는 인접한 지뢰가 없는 빈 셀을 의미한다.       ‘X’는 드러난 지뢰를 의미한다.                클릭한 위치가 지뢰인 경우 지뢰를 클릭했으므로, 해당 위치를 ‘X’로 변경하고 board를 반환한다.            클릭한 위치가 지뢰가 아닌 경우, 4번에서 정의한 dfs(char[][] board, int x, int y, int rowLength, int colLength) 메서드를 수행한다.       DFS 방식으로 지뢰를 찾기 위한 dfs(char[][] board, int x, int y, int rowLength, int colLength) 메서드를 정의한다.            x가 배열의 x축 범위를 벗어나거나, y가 y축 범위를 벗어나면 수행을 종료한다.       num에 5번에서 인접한 지뢰의 개수를 찾기 위한 findMines(char[][] board, int x, int y, int rowLength, int colLength) 메서드를 수행한 결과를 반환한다.       num이 0이면 지뢰가 없으므로, board[x][y]에 ‘B’를 넣어주고, x와 y 인접 셀을 재귀 호출을 이용하여 탐색한다.       num이 0이 아니면 board[x][y]에 인접한 지뢰의 개수를 넣어준다.           지뢰의 개수를 탐색하기 위한 findMines(char[][] board, int x, int y, int rowLength, int colLength) 메서드를 정의한다.            지뢰의 개수를 넣을 count를 0으로 정의한다.       x와 y축을 1씩 가감하며 ‘M’의 개수를 찾아 count를 증가시키고 해당 값을 반환한다.           4 ~ 5번의 수행이 완료되면 지뢰찾기 게임을 완성한 board를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minesweeper/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Absolute Difference in BST",
        "excerpt":"문제  Link   코드  class Solution {    private int min = Integer.MAX_VALUE;    public int getMinimumDifference(TreeNode root) {     this.dfs(root, null);     return this.min;   }    private TreeNode dfs(TreeNode root, TreeNode prev) {     if (root == null) {       return prev;     }     prev = this.dfs(root.left, prev);     if (prev != null) {       this.min = Math.min(this.min, Math.abs(root.val - prev.val));     }     return this.dfs(root.right, root);   }  }   결과  Link   설명          root에서 root와 leaf의 val 값 차이가 가장 작은 구간의 값을 구하는 문제이다.            최솟값을 넣을 min을 정의하고 정수의 가장 큰 값으로 초기화한다.            4번에서 정의한 dfs(TreeNode root, TreeNode prev) 메서드를 수행한다.       root와 leaf의 val 값 차이가 가장 작은 구간의 값을 구할 dfs(TreeNode root, TreeNode prev) 메서드를 정의한다.            root가 null인 경우 비교가 불가능하므로, prev를 반환한다.       prev에 root의 left TreeNode와 prev TreeNode를 이용한 재귀 호출 결과를 넣어준다.       prev가 null이 아니라면 min과 root의 val, prev의 val 차이 값 중 작은 값을 넣어준다.       pright TreeNode와 root TreeNode를 이용한 재귀 호출 결과를 반환한다.           재귀 호출이 완료되면 root와 leaf의 val 값 차이가 가장 작은 값을 저장한 min을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-absolute-difference-in-bst/",
        "teaser": null
      },{
        "title": "Leetcode Java K-diff Pairs in an Array",
        "excerpt":"문제  Link   코드  class Solution {    public int findPairs(int[] nums, int k) {     Arrays.sort(nums);     int slow = 0;     int fast = 1;     int count = 0;     while (slow &lt; nums.length &amp;&amp; fast &lt; nums.length) {       if (slow == fast || nums[fast] - nums[slow] &lt; k) {         fast++;       } else if (nums[fast] - nums[slow] &gt; k) {         slow++;       } else {         slow++;         fast++;         count++;         while (slow &lt; nums.length &amp;&amp; nums[slow] == nums[slow - 1]) {           slow++;         }       }     }     return count;   }  }   결과  Link   설명     nums와 k의 고유한 k-diff 쌍의 수를 계산하는 문제이다.            k-diff 쌍인 nums[i], nums[j]는 아래를 만족한다.                    0 &lt;= i, j &lt; nums.length           i != j           nums[i] - nums[j] == k                                순차적인 차이를 계산하기 위해 nums를 오름차순으로 정렬해준다.       문제 풀이에 필요한 변수를 정의한다.            slow는 작은 값의 위치를 이동하며 탐색할 변수로, 0으로 초기화한다.       fast는 slow보다 큰 값의 위치를 이동하며 탐색할 변수로, slow보다 큰 1로 초기화한다.       count는 k-diff 쌍의 수를 세기위한 변수로, 0으로 초기화한다.           slow 혹은 fast가 nums의 길이보다 커지기 전까지 아래의 반복을 수행한다.            slow와 fast가 동일하거나 nums[fast]에 nums[slow]를 뺀 값이 k보다 작을 경우, 더 큰 차잇값을 계산하기 위해서 fast를 증가시킨다.       위의 경우가 아니면서 nums[fast]에 nums[slow]를 뺀 값이 k보다 큰 경우, 더 작은 차잇값을 계산하기 위해서 slow를 증가시킨다.       그게 아니라면 nums[fast]에 nums[slow]를 뺀 값이 k와 동일하므로, slow와 fast와 count를 모두 증가시키고 slow가 마지막 값이 아니면서 이전 값과 동일한 경우가 아닐 때 까지 slow를 증가시킨다.           반복이 완료되면 k-diff 쌍의 수를 계산한 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/k-diff-pairs-in-an-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Encode and Decode TinyURL",
        "excerpt":"문제  Link   코드  class Codec {    private Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();   private static final String URL = \"http://tinyurl.com/\";    // Encodes a URL to a shortened URL.   public String encode(String longUrl) {     int key = longUrl.hashCode();     this.map.put(key, longUrl);     return URL.concat(String.valueOf(key));   }    // Decodes a shortened URL to its original URL.   public String decode(String shortUrl) {     return this.map.get(Integer.parseInt(shortUrl.replace(URL, \"\")));   }  }  // Your Codec object will be instantiated and called as such: // Codec codec = new Codec(); // codec.decode(codec.encode(url));   결과  Link   설명     URL을 임의 해시값을 사용하여 아래와 같이 암복호화하는 Codec 클래스를 완성하는 문제이다.            “https://leetcode.com/problems/design-tinyurl”의 url이 주어지면 “http://tinyurl.com/4e9iAk”와 같이 짧은 url을 반환하고, 해당 url을 호출하면 원본 url로 호출이 수행된다.           문제 풀이에 필요한 변수를 정의한다.            map은 hash값을 이용하여 원본 url을 저장하기 위한 변수로, HashMap으로 초기화한다.       URL은 예제와 같은 도메인을 저장할 변수로, “http://tinyurl.com/”로 초기화한다.           메서드인 encode(String longUrl)를 완성한다.            longUrl의 해시코드를 key로 정의하고, map 내 key에 해당하는 값을 longUrl로 넣어준다.       URL에 key를 이어서 짧은 url을 만들어 반환한다.           메서드인 decode(String shortUrl)를 완성한다.            shortUrl에서 URL부분을 제거하고 map에서 해시코드에 해당하는 값을 꺼내 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/encode-and-decode-tinyurl/",
        "teaser": null
      },{
        "title": "Leetcode Java Complex Number Multiplication",
        "excerpt":"문제  Link   코드  class Solution {    public String complexNumberMultiply(String num1, String num2) {     int[] num1Array = this.splitNumber(num1);     int[] num2Array = this.splitNumber(num2);     return new StringBuilder()         .append(num1Array[0] * num2Array[0] - num1Array[1] * num2Array[1])         .append('+')         .append(num2Array[0] * num1Array[1] + num1Array[0] * num2Array[1])         .append('i')         .toString();   }    private int[] splitNumber(String num) {     int index = num.indexOf('+');     return new int[] { Integer.parseInt(num.substring(0, index)), Integer.parseInt(num.substring(index + 1, num.length() - 1)) };   }  } // codec.decode(codec.encode(url));   결과  Link   설명     복소수를 나타내는 num1과 num2를 곱한 결과를 복소수로 반환하는 문제이다.            복소수는 실수 이후 “+” 기호를, 허수 이후 “i”를 붙인 “실수+허수i” 형태로 제공되고 해당 형태로 반환해야 한다.       단, $i^2 = -1$이다.                3번에서 정의한 splitNumber(String num) 메서드를 수행하여 num1과 num2의 실수와 허수를 num1Array와 num2Array에 넣어준다.       실수와 허수를 배열로 반환할 splitNumber(String num) 메서드를 정의한다.            index에 num 위치에 “+” 기호가 있는 위치를 넣어준다.       num의 처음부터 index까지 값을 숫자로 변환하고, $index + 1$ 위치에서 마지막에서 한 자리 이전 값을 숫자로 변환하여 배열에 넣어 반환한다.           num1Array와 num2Array의 결과를 계산하여 StringBuilder로 복소수 형태로 문자열을 만들어 반환한다.            동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.       $”1+1i” \\times “1+1i” = (1 + i) \\times (1 + i) = 1 + i2 + i^2 = 2i$ 이므로, 아래와 같이 복소수의 각 값을 계산한다.                    실수는 $num1Array[0] \\times num2Array[0] - num1Array[1] \\times num2Array[1]$의 결과로 값을 계산한다.           허수는 $num2Array[0] \\times num1Array[1] + num1Array[0] \\times num2Array[1]$의 결과로 값을 계산한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/complex-number-multiplication/",
        "teaser": null
      },{
        "title": "Leetcode Java Convert BST to Greater Tree",
        "excerpt":"문제  Link   코드  class Solution {    private int sum = 0;    public TreeNode convertBST(TreeNode root) {     if (root != null) {       this.convertBST(root.right);       sum += root.val;       root.val = sum;       this.convertBST(root.left);     }     return root;   }  }   결과  Link   설명     BST(Binary Search Tree)인 root를 이용하여 Greater Tree로 변환하는 문제이다.            Greater Tree는 BST의 가장 큰 값(오른쪽 맨 하위 노드)부터 작은 값(왼쪽 맨 하위 노드)까지 순차적인 합을 각 노드의 값으로 가진 TreeNode이다.                현재 위치의 합을 넣을 sum을 0으로 초기화한다.       root가 null이 아니면 아래를 수행한다.            root의 right TreeNode를 이용하여 재귀 호출을 수행한다.       sum에 root의 val 값을 더해주고, root의 val에 sum을 넣어준다.       root의 left TreeNode를 이용하여 재귀 호출을 수행한다.           수행이 완료되면 root를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/convert-bst-to-greater-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Time Difference",
        "excerpt":"문제  Link   코드  class Solution {    public int findMinDifference(List&lt;String&gt; timePoints) {     boolean[] visited = new boolean[1440];     int start = Integer.MAX_VALUE;     for (String timePoint : timePoints) {       String[] time = timePoint.split(\":\");       int minutes = Integer.parseInt(time[0]) * 60 + Integer.parseInt(time[1]);       if (visited[minutes]) {         return 0;       } else {         start = Math.min(start, minutes);         visited[minutes] = true;       }     }     int prev = start;     int result = Integer.MAX_VALUE;     for (int idx = start + 1; idx &lt; 1440; idx++) {       if (visited[idx]) {         result = Math.min(result, idx - prev);         prev = idx;       }     }     return Math.min(result, Math.abs(prev - start - 1440));   }  }   결과  Link   설명          시간을 저장한 timePoints 내 가장 작게 차이나는 두 시간의 차이를 분 단위로 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            visited는 timePoints의 모든 값의 방문 여부를 저장하기 위한 배열로, 하루의 총 시간인 $24 \\times 60 = 1440$ 크기로 정의한다.       start는 가장 작은 시간의 위치를 분 단위로 저장하기 위한 변수로, Integer의 가장 큰 숫자로 정의한다.           timePoints의 모든 값을 반복하여 아래를 수행한다.            timePoint의 시간과 분의 구분 값인 콜론(“:”)을 기준으로 문자열을 분리한다.       시간을 분으로 변환한 값을 넣을 minutes에 time을 이용하여 시간의 위치인 time[0]을 숫자로 변환하여 60을 곱하고, 분의 위치인 time[1]을 숫자로 변환하여 더한 값을 넣어준다.       visited의 minutes번째 값이 true인 경우 같은 시간이 존재하므로, 두 시간의 차이인 0을 주어진 문제의 결과로 반환한다.       visited의 minutes번째 값이 false인 경우 같은 값이 없으므로, start에 start와 minutes 중 작은 값을 넣고 visited의 minutes번째 값을 true로 바꾸어준다.                이전 값을 저장할 prev에 start를 넣어주고, result를 Integer의 가장 큰 숫자로 넣어 초기화한다.       $start + 1$부터 1440 미만까지 idx를 증가시키며 아래를 수행한다.            visited의 idx번째 값이 true인 경우, result에 시간의 차이가 작은 값을 넣기 위해 result와 $idx - prev$ 값 중 작은 값을 넣어주고 prev에 idx를 넣어준다.           반복이 완료되면 연속된 시간 중 가장 작은 result와 처음과 마지막 시간의 차이인 $prev - start - 1440$ 중 작은 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-time-difference/",
        "teaser": null
      },{
        "title": "Leetcode Java Single Element in a Sorted Array",
        "excerpt":"문제  Link   코드  class Solution {    public int singleNonDuplicate(int[] nums) {     int start = 0;     int end = nums.length - 1;     while (start &lt; end) {       int mid = (start + end) / 2;       if (mid % 2 == 1) {         mid--;       }       if (nums[mid] == nums[mid + 1]) {         start = mid + 2;       } else {         end = mid;       }     }     return nums[start];   }  }   결과  Link   설명     nums 내 유일한 값을 찾는 문제이다.            단, O(log n) 시간과 O(1)의 공간 복잡도를 가진 방법으로 풀어야 한다.           문제 풀이에 필요한 변수를 정의한다.            start는 num의 검색을 시작할 위치를 저장할 변수로, 0으로 정의한다.       end는 num의 검색을 종료할 위치를 저장할 변수로, nums의 길이에 1을 빼서 정의한다.           start가 end 미만일 때 까지 반복하여 탐색을 수행한다.            mid에 $\\frac{start + end}{2}$의 결과를 넣어준다.       만일 mid가 홀수인 경우, mid를 감소시켜 짝수로 만들어 우측에 값이 반드시 존재하도록 만들어준다.       num의 mid번째 값과 nums의 $mid + 1$번째 값이 동일한 경우, start에 $mid + 2$를 넣어 동일한 값까지 무시하고 시작 위치를 증가시켜 탐색 범위를 좁혀준다.       num의 mid번째 값과 nums의 $mid + 1$번째 값이 다른 경우, end에 mid를 넣어 종료 위치를 감소시켜 탐색 범위를 좁혀준다.           반복이 완료되면 탐색된 nums의 start번째 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/single-element-in-a-sorted-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Reverse String II",
        "excerpt":"문제  Link   코드  class Solution {    public String reverseStr(String s, int k) {     char[] array = s.toCharArray();     int length = array.length;     int i = 0;     while (i &lt; length) {       int j = Math.min(i + k - 1, length - 1);       this.swap(array, i, j);       i += 2 * k;     }     return new String(array);   }    private void swap(char[] array, int left, int right) {     while (left &lt; right) {       char temp = array[left];       array[left++] = array[right];       array[right--] = temp;     }   }  }   결과  Link   설명          s의 매 처음부터 k번째 값과 매 2k번쨰 위치에서 k개의 문자들을 역순으로 반전시켜준다.       문제 풀이에 필요한 변수를 정의한다.            array는 s를 문자 배열로 변환하여 저장한 배열이다.       length는 array의 길이를 저장한 변수이다.       i는 위치를 저장할 변수이다.           i가 length 미만까지 아래를 수행한다.            j에 $i + k - 1$ 혹은 문자의 길이를 벗어날 경우에 마지막 값인 $length - 1$ 중 작은 값을 넣어준다.       array의 i번째 문자부터 j번째 문자까지 순서를 역순으로 반전시킨다.       i에 다음 위치인 $2 \\times k$의 위치로 이동시켜준다.           반복이 완료되면 array를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reverse-string-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java 01 Matrix",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] updateMatrix(int[][] mat) {     int row = mat.length;     int col = mat[0].length;     int distance = row + col;     for (int i = 0; i &lt; row; i++) {       for (int j = 0; j &lt; col; j++) {         if (mat[i][j] == 0) {           continue;         }         int top = distance;         int left = distance;         if (i - 1 &gt;= 0) {           top = mat[i - 1][j];         }         if (j - 1 &gt;= 0) {           left = mat[i][j - 1];         }         mat[i][j] = Math.min(top, left) + 1;       }     }     for (int i = row - 1; i &gt;= 0; i--) {       for (int j = col - 1; j &gt;= 0; j--) {         if (mat[i][j] == 0) {           continue;         }         int bottom = distance;         int right = distance;         if (i + 1 &lt; row) {           bottom = mat[i + 1][j];         }         if (j + 1 &lt; col) {           right = mat[i][j + 1];         }         mat[i][j] = Math.min(mat[i][j], Math.min(bottom, right) + 1);       }     }     return mat;   }  }   결과  Link   설명          mat 내 요소들 간 0과의 인접 거리를 구해서 값을 바꾸는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            row는 mat 행의 개수를 저장한 변수이다.       col은 mat 열의 개수를 저장한 변수이다.       distance는 첫 셀에서 끝 셀까지 최대 이동 거리가 될 수 있는 거리를 저장할 변수로, $row + col$로 정의한다.           0부터 row 미만까지 i를 증가시키고, 0부터 col 미만까지 j를 증가시켜 좌측 위에서 우측 아래로 이동하며 아래를 수행한다.            mat[i][j]의 값이 0인 경우 자기 자신과 거리가 0이므로, 무시하고 넘어간다.       top과 left를 최대 이동 거리인 distance로 초기화 시킨다.       $i - 1$이 0 이상인 경우, top에 mat[$i - 1$][j]를 넣어준다.       $j - 1$이 0 이상인 경우, left에 mat[i][$j - 1$]를 넣어준다.       mat[i][j]에 top과 left중 작은 값인 가장 인접한 거리에 1을 더해서 넣어준다.           $row - 1$부터 0 이상까지 i를 감소시키고, $col - 1$부터 0 이상까지 j를 감소시켜 우측 아래에서 좌측 위로 이동하며 아래를 수행한다.            mat[i][j]의 값이 0인 경우 자기 자신과 거리가 0이므로, 무시하고 넘어간다.       bottom과 right를 최대 이동 거리인 distance로 초기화 시킨다.       $i + 1$이 0 이하인 경우, bottom에 mat[$i + 1$][j]를 넣어준다.       $j + 1$이 0 이하인 경우, right에 mat[i][$j + 1$]를 넣어준다.       mat[i][j]에 bottom, right중 작은 값인 가장 인접한 거리에 1을 더한 값과 mat[i][j]의 값 중 작은 값을 넣어준다.           두 반복이 완료되면 완성된 mat를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/01-matrix/",
        "teaser": null
      },{
        "title": "Leetcode Java Diameter of Binary Tree",
        "excerpt":"문제  Link   코드  class Solution {    public int diameterOfBinaryTree(TreeNode root) {     int[] result = new int[1];     this.dfs(root, result);     return result[0];   }    private int dfs(TreeNode root, int[] result) {     if (root == null) {       return -1;     } else {       int left = this.dfs(root.left, result);       int right = this.dfs(root.right, result);       result[0] = Math.max(result[0], left + right + 2);       return Math.max(left + 1, right + 1);     }   }  }   결과  Link   설명          root의 노드들 간 가장 긴 이동 거리(지름)를 구하는 문제이다.       결과를 저장할 result를 1크기의 정수 배열로 정의한다.            Primitive Type인 int형의 초기값은 0이므로 그대로 사용한다.       전역 변수가 아닌 생성된 객체를 활용하여 결과를 탐색하기 위해 배열을 생성하여 해당 내 값을 활용한다.                4번에서 정의한 dfs(TreeNode root, int[] result) 메서드를 수행한다.       노드 간 가장 긴 이동거리를 계산하기 위한 dfs(TreeNode root, int[] result) 메서드를 정의한다.            root가 null인 경우, -1을 반환하여 이전 거리까지만 계산한다.       left에 root의 left TreeNode로 재귀 호출한 결과를, right에 root의 right TreeNode로 재귀 호출한 결과를 넣어준다.       result의 첫 값에 해당 값과 $left + right + 2$의 값 중 큰 값을 넣어준다.       $left + 1$과 $right + 1$ 중 가장 거리가 긴 값을 반환한다.           수행이 완료되면 노드들 간 가장 긴 이동 거리를 저장한 result 내 첫 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/diameter-of-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Provinces",
        "excerpt":"문제  Link   코드  class Solution {    public int findCircleNum(int[][] isConnected) {     int length = isConnected.length;     boolean[] visited = new boolean[length];     int count = 0;     for (int idx = 0; idx &lt; length; idx++) {       if (!visited[idx]) {         this.dfs(isConnected, visited, idx);         count++;       }     }     return count;   }    private void dfs(int[][] isConnected, boolean[] visited, int i) {     for (int j = 0; j &lt; isConnected.length; j++) {       if (isConnected[i][j] == 1 &amp;&amp; !visited[j]) {         visited[j] = true;         this.dfs(isConnected, visited, j);       }     }   }  }   결과  Link   설명     각 도시의 연결 상태를 나타내는 isConnected를 이용하여 연결된 도시들은 하나의 지방으로 묶어주고, 지방의 수를 구하는 문제이다.            isConnected[i][j] 의 값이 1인 경우, i번째 도시와 j번째 도시가 연결되어 하나의 지방으로 구성된다.       isConnected[i][j] 의 값이 0인 경우, i번째 도시와 j번째 도시는 연결되지 않아 각 지방으로 분리된다.           문제 풀이에 필요한 변수를 정의한다.            length는 isConnected의 길이인 도시의 개수를 저장할 변수이다.       visited는 방문 여부를 저장할 배열로, length 길이로 초기화한다.       count는 지방의 개수를 저장할 변수로, 0으로 초기화한다.           0부터 length까지 idx를 증가시키며 아래를 수행한다.            visited의 idx번째 값이 false인 방문하지 않은 경우, 4번에서 정의한 dfs(int[][] isConnected, boolean[] visited, int i) 메서드를 수행하고 count를 증가한다.           DFS 방식으로 visited에 값을 넣을 dfs(int[][] isConnected, boolean[] visited, int i) 메서드를 정의한다.            0부터 isConnected의 길이 미만까지 j를 증가시키며 isConnected[i][j]가 1로 연결되어있고 visited[j]가 false인 방문하지 않은 경우, visited의 j번째 값을 true로 바꾸고 i에 j를 넣어 재귀 호출을 수행한다.           반복이 완료되면 지방의 개수인 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-provinces/",
        "teaser": null
      },{
        "title": "Leetcode Java Student Attendance Record I",
        "excerpt":"문제  Link   코드  class Solution {    public boolean checkRecord(String s) {     return s.indexOf(\"A\") == s.lastIndexOf(\"A\") &amp;&amp; !s.contains(\"LLL\");   }  }   결과  Link   설명     아래의 각 문자 별 출석 상태를 기준으로 개근상을 받을 수 있는지 여부를 검증하는 문제이다.            ‘A’는 결석을 의미한다.       ‘L’은 지각을 의미한다.       ‘P’는 출석을 의미한다.       위 세 값을 이용하여 1번 이하의 결석과 3번 연속 지각하지 않으면 개근상을 받을 수 있다.           s 내 결석인 “A”의 첫 위치와 마지막 위치가 동일하고, 3연속 지각인 “LLL”이 없으면 true를 아니면 false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/student-attendance-record-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Student Attendance Record II",
        "excerpt":"문제  Link   코드  class Solution {    public int checkRecord(int n) {     int[] dp = new int[] { 1, 1, 0, 1, 0, 0 };     for (int idx = 2; idx &lt;= n; idx++) {       dp = new int[] { this.getSum(dp, 0, 2), dp[0], dp[1], this.getSum(dp, 0, 5), dp[3], dp[4] };     }     return this.getSum(dp, 0, 5);   }    private int getSum(int[] dp, int low, int high) {     int sum = 0;     for (int idx = low; idx &lt;= high; idx++) {       sum = (sum + dp[idx]) % 1000000007;     }     return sum;   }  }   결과  Link   설명     아래의 각 문자 별 출석 상태를 기준으로 개근상을 받을 수 있는 n개의 가능한 출석 기록 수를 반환하는 문제이다.            ‘A’는 결석을 의미한다.       ‘L’은 지각을 의미한다.       ‘P’는 출석을 의미한다.       위 세 값을 이용하여 1번 이하의 결석과 3번 연속 지각하지 않으면 개근상을 받을 수 있다.       단, 답이 매우 클 수 있으므로 모듈러 $10^9 + 7$을 이용해 계산한다.           dp에 n이 1일 경우 받을 수 있는 경우인 [1, 1, 0, 1, 0, 0]으로 초기화한다.            n이 1일 경우, 아래와 같다.                                                                                    A0L0                   P                                                     A0L1                   L                                                     A0L2                                                                         A1L0                   A                                                     A1L1                                                                         A1L2                                                                                                   n이 2일 경우, 아래와 같다.                                                                                    A0L0                   LP, PP                                                     A0L1                   PL                                                     A0L2                   LL                                                     A1L0                   AP, LA, PA                                                     A1L1                   AL                                                     A1L2                                                                                                       2번의 계산 식을 이용하여 2부터 n까지 idx를 증가시키며 아래의 계산을 반복한다.            $dp[0] = dp[0] + dp[1] + dp[2]$       $dp[1] = dp[0]$       $dp[2] = dp[1]$       $dp[3] = dp[0] + … + dp[5]$       $dp[4] = dp[3]$       $dp[5] = dp[4]$       단, 모듈러 $10^9 +7$을 이용해야 하므로 모든 계산에 getSum(int[] dp, int low, int high) 메서드를 이용하여 $10^9 +7$을 나누어 수행해준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/student-attendance-record-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Optimal Division",
        "excerpt":"문제  Link   코드  class Solution {    public String optimalDivision(int[] nums) {     int length = nums.length;     StringBuilder sb = new StringBuilder();     sb.append(nums[0]);     for (int idx = 1; idx &lt; length; idx++) {       sb.append(\"/\");       if (idx == 1 &amp;&amp; length &gt; 2) {         sb.append(\"(\");       }       sb.append(nums[idx]);     }     if (length &gt; 2) {       sb.append(\")\");     }     return sb.toString();   }  }   결과  Link   설명     정수가 들어있는 nums를 나눗셈만 사용해서 나올 수 있는 최대의 값을 구하는 공식을 만들어 반환하는 문제이다.            수학 공식을 나눗셈만 사용하여 계산할 경우 나올 수 있는 최솟값과 최댓값은 아래와 같다.                    모든 값을 순차적으로 나눈 결과는 최솟값이 된다. (Ex. $1 / 2 / 3 / 4 = \\frac{1}{2} / 3 / 4 = \\frac{1}{6} / 4 = \\frac{1}{24}$)           첫 값을 나머지 값들을 순차적으로 나눈 결과로 나눈 결과는 최댓값이 된다. (Ex. $1 / (2 / 3 / 4) = 1 / (\\frac{2}{3} / 4) = 1 / \\frac{2}{12} = \\frac{12}{2} = 6$)                           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       sb는 주어진 문제의 공식을 동적으로 구성할 StringBuilder 객체로 정의하고, nums의 첫 값을 넣어준다.                    동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.                           1부터 length 미만까지 idx를 증가시키며 아래를 수행한다.            sb에 나눗셈 기호(“/”)를 추가한다.       idx가 1이고 length가 2 초과인 경우, 소괄호 시작 문자(“(“)를 추가한다.       sb에 nums의 idx번쨰 값을 넣어준다.                반복이 완료되고 length가 2 초과인 경우, 소괄호 종료 문자(“)”)를 추가한다.       완성된 공식인 sb를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/optimal-division/",
        "teaser": null
      },{
        "title": "Leetcode Java Brick Wall",
        "excerpt":"문제  Link   코드  class Solution {    public int leastBricks(List&lt;List&lt;Integer&gt;&gt; wall) {     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();     int count = 0;     for (List&lt;Integer&gt; row : wall) {       int sum = 0;       for (int idx = 0; idx &lt; row.size() - 1; idx++) {         sum += row.get(idx);         map.put(sum, map.getOrDefault(sum, 0) + 1);         count = Math.max(count, map.get(sum));       }     }     return wall.size() - count;   }  }   결과  Link   설명          벽의 벽돌을 나타내는 wall을 이용하여 위에서 아래로 직선을 그을 경우 만날 수 있는 최소한의 벽돌의 수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            줄을 긋는 위치에 빈 공간의 수를 저장할 map을 정의하고, HashMap으로 초기화한다.       벽돌의 빈 공간을 저장할 count를 정의하고, 0으로 초기화한다.           wall의 각 행을 row로 아래를 수행한다.            sum은 현재 가로의 위치를 저장할 변수로, 0으로 초기화한다.       마지막 벽돌의 위치는 중요하지 않으므로 0부터 row의 마지막 값을 제외하고 idx를 증가시키며 아래를 수행한다.                    sum의 row의 idx번째 값을 더한다.           map에서 sum에 해당하는 값을 가져오거나 없으면 0을 가져와 1을 증가시킨 값을 map에 다시 저장한다.           count에 count와 map의 sum에 해당하는 값 중 큰 값을 넣어준다.                           반복이 완료되면 벽돌 층의 수인 wall의 길이에 빈 공간의 수인 count의 차이를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/brick-wall/",
        "teaser": null
      },{
        "title": "Leetcode Java Reverse Words in a String III",
        "excerpt":"문제  Link   코드  class Solution {    public String reverseWords(String s) {     char[] charArray = s.toCharArray();     int start = 0;     int end = 0;     while (end &lt; charArray.length) {       if (charArray[end] == ' ') {         this.reverse(charArray, start, end - 1);         start = end + 1;       }       end++;     }     this.reverse(charArray, start, end - 1);     return new String(charArray);   }    private void reverse(char[] charArray, int start, int end) {     while (start &lt; end) {       char temp = charArray[start];       charArray[start++] = charArray[end];       charArray[end--] = temp;     }   }  }   결과  Link   설명          s의 문장 순서 그대로 각 단어들을 반전시켜 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            charArray는 s를 문자 배열로 변환하여 저장한 변수이다.       start와 end는 문자를 반전시킬 시작과 종료 위치를 넣을 변수로, 0으로 초기화한다.           end가 charArray의 길이 미만일 때 까지 반복을 수행한다.            charArray의 end번째 문자가 띄어쓰기(“ “)인 경우, charArray의 start 부터 $end - 1$번째 문자까지 반전시키고 start에 $end + 1$을 넣어준다.       end를 증가시키고 반복을 계속 수행한다.           반복이 완료되면 마지막 단어인 charArray의 start부터 $end - 1$번째 문자까지 반전시키고 문자열로 전환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reverse-words-in-a-string-iii/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Depth of N-ary Tree",
        "excerpt":"문제  Link   코드  /* // Definition for a Node. class Node {     public int val;     public List&lt;Node&gt; children;      public Node() {}      public Node(int _val) {         val = _val;     }      public Node(int _val, List&lt;Node&gt; _children) {         val = _val;         children = _children;     } }; */  class Solution {    public int maxDepth(Node root) {     if (root == null) {       return 0;     } else {       int max = 0;       for (Node children : root.children) {         max = Math.max(max, this.maxDepth(children));       }       return max + 1;     }   }  }   결과  Link   설명          root의 최대 깊이를 구하는 문제이다.            root가 null인 경우 더 이상 내려갈 수 없으므로, 0을 반환한다.            max를 0으로 정의하고 root의 children을 반복하여 children을 재귀 호출한 결과와 max 중 큰 값을 max에 넣어준다.            반복이 완료되면 최대 깊이가 저장된 max에 root를 포함해 1을 더해 결과를 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-depth-of-n-ary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Subarray Sum Equals K",
        "excerpt":"문제  Link   코드  class Solution {    public int subarraySum(int[] nums, int k) {     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();     int sum = 0;     int count = 0;     map.put(0, 1);     for (int num : nums) {       sum += num;       if (map.containsKey(sum - k)) {         count += map.get(sum - k);       }       map.put(sum, map.getOrDefault(sum, 0) + 1);     }     return count;   }  }   결과  Link   설명          nums의 연속된 요소의 합이 k인 부분 배열의 개수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            map은 부분 합을 이용한 개수를 저장할 변수로, HashMap으로 초기화하고 키가 0인 값을 1로 초기화한다.       sum은 부분 합을 저장할 변수로, 0으로 초기화한다.       count는 k가 되는 부분 배열의 개수를 저장할 변수로, 0으로 초기화한다.           nums의 모든 요소를 num에 넣어 반복한다.            sum에 num을 더해 합계를 계산한다.       map에 $sum - k$이 키인 값이 존재하면, count에 map에서 $sum - k$인 값을 더해 부분 배열의 합이 k인 개수를 증가시킨다.       map에 키가 sum인 값을 1 증가시키고 반복을 계속 수행한다.           반복이 완료되면 부분 배열의 개수를 저장한 count를 주어진 문제의 결과로 반환한다.   해설     nums의 [0, $i - 1$] 구간의 합과 [0, j] 구간의 합을 알면 [i, j] 구간의 합을 알 수 있다.   그러므로 map에 sum에 해당하는 값을 증가시키고, 다음 차례에서 $sum - k$의 값이 존재하면 count에 누적시키면 연속된 요소를 이용한 부분 배열의 합이 k인 개수를 구할 수 있다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/subarray-sum-equals-k/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Tree Tilt",
        "excerpt":"문제  Link   코드  class Solution {    private int sum = 0;    public int findTilt(TreeNode root) {     this.recursive(root);     return this.sum;   }    private int recursive(TreeNode root) {     if (root == null) {       return 0;     }     int left = this.recursive(root.left);     int right = this.recursive(root.right);     this.sum += Math.abs(left - right);     return left + right + root.val;   }  }   결과  Link   설명     root의 기울기를 구하는 문제이다.            기울기란 좌측 자식 노드 val 값의 합과 우측 자식 노드 val 값의 합을 뺀 값의 절댓값이다.                기울기를 구하기 위한 sum을 전역 변수로 정의하고, 0으로 초기화한다.            4번에서 정의한 recursive(TreeNode root) 메서드를 수행한다.       기울기를 구하기 위한 recursive(TreeNode root) 메서드를 정의한다.            root가 null인 경우, 0을 반환한다.       left와 right TreeNode를 이용하여 재귀 호출을 수행하고, left와 right에 결과를 넣어준다.       sum에 left와 right의 차이에 대한 절댓값을 넣어준다.       left와 right와 val 합을 반환한다.           재귀 호출이 완료되면 기울기를 저장한 sum을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-tree-tilt/",
        "teaser": null
      },{
        "title": "Leetcode Java Array Nesting",
        "excerpt":"문제  Link   코드  class Solution {    public int arrayNesting(int[] nums) {     int max = 0;     for (int i = 0; i &lt; nums.length; i++) {       int length = 0;       for (int j = i; nums[j] &gt;= 0; length++) {         int temp = nums[j];         nums[j] = -1;         j = temp;       }       max = Math.max(max, length);     }     return max;   }  }   결과  Link   설명     아래의 조건을 만족하는 집합의 가장 긴 길이를 구하는 문제이다.            s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], … }                최대 길이를 저장할 max를 정의하고, 0으로 초기화한다.       0부터 nums의 길이 미만까지 i를 증가시키며 아래를 반복한다.            부분 길이를 저장할 length를 0으로 초기화 한다.       i부터 nums[j]가 0 이상일 때 까지 j를 증가시키며 아래를 반복한다.                    temp에 nums의 j번째 값을 넣어주고 nums의 j번째 값에 -1을 넣어 방문 기록을 남긴다.           j에 temp를 넣어준다.                       반복이 완료되면 max에 max와 length중 큰 값을 넣어준다.           반복이 완료되면 조건을 만족하는 가장 길 길이인 max를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/array-nesting/",
        "teaser": null
      },{
        "title": "Leetcode Java Reshape the Matrix",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] matrixReshape(int[][] mat, int r, int c) {     int row = mat.length;     int col = mat[0].length;     if (r * c != row * col) {       return mat;     }     int[][] result = new int[r][c];     for (int idx = 0; idx &lt; r * c; idx++) {       result[idx / c][idx % c] = mat[idx / col][idx % col];     }     return result;   }  }   결과  Link   설명     MATLAB에서 제공하는 reshape 함수를 구현하는 문제이다.            reshape 함수는 주어진 2차원 배열을 해당 순서 그대로 $r \\tiems c$ 배열로 전환하고, 불가능하면 원래 배열을 그대로 반환하는 함수이다.                row에 mat 행의 수를, col에 mat 열의 수를 저장한다.            $r \\times c$의 값이 $row \\times col$와 동일하지 않으면 변환이 불가능하므로, mat를 주어진 문제의 결과로 반환한다.            3번의 경우가 아니라면 $r times c$ 크기의 배열로 변환이 가능하므로, result를 해당 배열 크기로 초기화한다.       0 부터 $r \\times c$ 미만까지 idx를 증가시키며 아래를 반복하여 mat의 값들을 순차적으로 result에 넣어준다.            $\\frac{idx}{c}$의 값과 나머지를 이용하여 result[값][나머지]의 위치에, $\\frac{idx}{col}$의 값과 나머지를 이용하여 mat[값][나머지]의 값을 넣어준다.           5번을 통해 만들어진 result 배열을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reshape-the-matrix/",
        "teaser": null
      },{
        "title": "Leetcode Java Permutation in String",
        "excerpt":"문제  Link   코드  class Solution {    public boolean checkInclusion(String s1, String s2) {     char[] s1CharArray = s1.toCharArray();     char[] s2CharArray = s2.toCharArray();     int start = 0;     int end = 0;     int[] count = new int[26];     for (char c : s1CharArray) {       count[c - 'a']++;     }     while (end &lt; s2CharArray.length) {       char curr = s2CharArray[end++];       count[curr - 'a']--;       while (count[curr - 'a'] &lt; 0 &amp;&amp; start &lt; end) {         count[s2CharArray[start++] - 'a']++;       }       if (end - start == s1CharArray.length) {         return true;       }     }     return false;   }  }   결과  Link   설명          s1의 순열이 s2에 포함되어 있는지 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            s1CharArray는 s1을, s2CharArray는 s2를 문자의 배열로 변환하여 넣어준 변수이다.       start와 end는 s2 문자열 내 s1의 순열이 포함되었는지 검증하기 위한 인덱스로, 둘 다 0으로 초기화한다.       count는 s1의 문자 개수를 저장할 배열로, 알파벳 크기인 26 크기로 초기화 하고 s1을 반복하여 각 자리의 값을 증가시킨다.           end가 s2의 길이 미만까지 아래를 반복한다.            curr에 s2의 end번째 문자를 넣어주고, end를 증가시키고, count의 curr번째 문자 위치의 값을 감소시켜준다.       count의 curr번쨰 문자 위치의 값이 0보다 작고, start가 end보다 작은 순열의 기준이 되는 경우 아래를 계속 수행한다.                    count 내 s2CharArray[start] 문자 위치의 값과 start를 증가시킨다.                       end - start가 s1CharArray의 길이와 동일하면 순열이 되는 경우이므로, true를 주어진 문제의 결과로 반환한다.           반복이 완료되면 순열이 될 수 없으므로, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/permutation-in-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Subtree of Another Tree",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isSubtree(TreeNode root, TreeNode subRoot) {     if ((root == null &amp;&amp; subRoot != null) || (root != null &amp;&amp; subRoot == null)) {       return false;     } else if (this.isSameTree(root, subRoot)) {       return true;     } else {       return this.isSubtree(root.left, subRoot) || this.isSubtree(root.right, subRoot);     }   }    private boolean isSameTree(TreeNode root, TreeNode subRoot) {     if (root == null || subRoot == null) {       return root == null &amp;&amp; subRoot == null;     } else if (root.val == subRoot.val) {       return this.isSameTree(root.left, subRoot.left) &amp;&amp; this.isSameTree(root.right, subRoot.right);     } else {       return false;     }   }  }   결과  Link   설명          subRoot가 root의 하위 트리인지 검증하는 문제이다.            root가 null이고 subRoot가 null이 아니거나, root가 null이 아니고 subRoot가 null이면 하위 트리가 될 수 없는 구성이므로 false를 주어진 문제의 결과로 반환한다.            root와 subRoot가 5번에서 정의한 isSameTree(TreeNode root, TreeNode subRoot) 메서드를 만족하는 경우, true를 반환한다.            root의 left와 right TreeNode를 이용한 재귀 호출을 수행한 결과가 하나라도 만족하면 true를, 아니면 false를 반환한다.            두 TreeNode가 동일한지 검증하기 위한 isSameTree(TreeNode root, TreeNode subRoot) 메서드를 정의한다.             root와 subRoot 둘 중 하나라도 null인 경우, 둘 다 null인지 여부를 반환한다.       root의 val 값과 subRoot의 val 값이 동일하면 root와 subRoot의 left와 right TreeNode를 이용하여 재귀 호출한 결과를 반환한다.       그 외의 경우 동일하지 않으므로 false를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/subtree-of-another-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Distribute Candies",
        "excerpt":"문제  Link   코드  class Solution {    public int distributeCandies(int[] candyType) {     Set&lt;Integer&gt; types = new HashSet&lt;&gt;();     for (int candy : candyType) {       types.add(candy);     }     return Math.min(candyType.length / 2, types.size());   }  }   결과  Link   설명          candyType의 캔디를 절반을 먹을 때, 중복되지 않은 candy의 최대 유형 개수를 구하는 문제이다.            중복을 배제한 캔디 유형의 개수를 저장하기 위한 types를 HashSet으로 초기화하고, candyType의 모든 값을 넣어준다.            candyType의 절반과 types의 크기 중 작은 값을 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/distribute-candies/",
        "teaser": null
      },{
        "title": "Leetcode Java Shortest Unsorted Continuous Subarray",
        "excerpt":"문제  Link   코드  class Solution {    public int findUnsortedSubarray(int[] nums) {     int length = nums.length;     int start = 0;     int end = -1;     int min = nums[length - 1];     int max = nums[0];     for (int idx = 1; idx &lt; length; idx++) {       max = Math.max(max, nums[idx]);       min = Math.min(min, nums[length - 1 - idx]);       if (nums[idx] &lt; max) {         end = idx;       }       if (nums[length - 1 - idx] &gt; min) {         start = length - 1 - idx;       }     }     return end - start + 1;   }  }   결과  Link   설명          nums 내 오름차순 정렬이 필요한 부분 배열의 최소 크기를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       start와 end는 부분 배열의 시작 위치와 종료 위치를 저장한 변수로, 0과 -1로 초기화한다.       min과 max는 전후의 요소에 대한 크기 검증을 하기위한 변수로, nums의 마지막의 이전 값과 첫 값으로 초기화한다.           1부터 length 미만까지 idx를 증가시키며 아래를 반복한다.            max에는 max와 nums의 idx번째 값 중 큰 값을 넣어준다.       min에는 min과 역순으로 탐색하여 nums의 $length - 1 - idx$번째 값 중 작은 값을 넣어준다.       max가 nums의 idx번째 값보다 큰 경우 이전 값이 더 작으므로, end에 idx를 넣어준다.       min이 nums의 $length - 1 - idx$번째 값보다 작은 경우 이전 값이 더 크므로, start에 $length - 1 - idx$를 넣어준다.           반복이 완료되면 부분 배열의 크기인 $end - start + 1$을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/shortest-unsorted-continuous-subarray/",
        "teaser": null
      },{
        "title": "Leetcode Java Delete Operation for Two Strings",
        "excerpt":"문제  Link   코드  class Solution {    public int minDistance(String word1, String word2) {     int word1Length = word1.length();     int word2Length = word2.length();     char[] word1CharArray = word1.toCharArray();     char[] word2CharArray = word2.toCharArray();     int dp[][] = new int[word1Length + 1][word2Length + 1];     for (int i = 0; i &lt;= word1Length; i++) {       for (int j = 0; j &lt;= word2Length; j++) {         if (i == 0 || j == 0) {           dp[i][j] = 0;         } else {           dp[i][j] = (word1CharArray[i - 1] == word2CharArray[j - 1]) ? dp[i - 1][j - 1] + 1 : Math.max(dp[i - 1][j], dp[i][j - 1]);         }       }     }     return word1Length + word2Length - (2 * dp[word1Length][word2Length]);   }  }   결과  Link   설명     word1과 word2를 동일하게 만들기 위한 최소 횟수를 구하는 문제이다.            단, 한 단계에서 두 문자열 중 한 문자만 삭제할 수 있다.           문제 풀이에 필요한 변수를 정의한다.            word1Length, word2Length는 word1과 word2 길이를 저장한 변수이다.       word1CharArray, word2CharArray는 word1과 word2의 문자 배열을 변환하여 저장한 변수이다.       dp는 두 문자를 동일하게 만들기 위한 최소 횟수를 구하기 위한 배열로, $(word1Length + 1) \\times (word2Length + 1)$ 크기로 초기화한다.           0부터 word1Length 이하까지 i를 증가하며, 0부터 word2Length를 증가하면 아래를 반복한다.            i 혹은 j가 0인 경우, dp[i][j]에 0을 넣어 초기화한다.       그 외의 경우 dp[i][j]에 word1CharArray[$i - 1$]의 문자와 word2CharArray[$j - 1$]의 문자가 동일하면 해당 단어를 삭제하지 않아도 되므로 대각선 상 존재하는 dp[i - 1][j - 1]의 값에 1을 더한 값을, 아니면 이전 값들인 dp[$i - 1$][j]의 값과 dp[i][$j - 1$] 값 중 큰 값을 넣어준다.           반복이 완료되면 word1Length과 word2Length를 더한 값에 dp[word1Length][word2Length] 값의 2배를 뺀 결과를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/delete-operation-for-two-strings/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Customer Placing the Largest Number of Orders",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT customer_number FROM Orders GROUP BY customer_number ORDER BY COUNT(order_number) DESC LIMIT 1   결과  Link   설명     Orders Table의 데이터 중 주문이 가장 많은 customer_number를 찾는 문제이다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/customer-placing-the-largest-number-of-orders/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Find Customer Referee",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT name FROM Customer WHERE referee_id != 2 OR referee_id IS NULL   결과  Link   설명     Customer Table의 referee_id 값이 2가 아닌 name을 출력하는 문제이다.            NULL의 경우, “!=” 부등호로 비교가 되지 않으므로 IS NULL을 추가해야 한다.          ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/find-customer-referee/",
        "teaser": null
      },{
        "title": "Leetcode Java N-ary Tree Preorder Traversal",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; preorder(Node root) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     this.dfs(root, result);     return result;   }    private void dfs(Node root, List&lt;Integer&gt; list) {     if (root != null) {       list.add(root.val);       if (root.children != null) {         for (Node node : root.children) {           this.dfs(node, list);         }       }     }   }  }   결과  Link   설명          root를 preorder 순으로 val 값들을 반환하는 문제이다.            result는 preorder 순으로 val 값을 넣을 변수로, ArrayList로 초기화한다.            4번에서 정의한 dfs(Node root, List list)에 result를 넣어 수행한다.       root를 preorder 순으로 val 값을 넣기 위한 dfs(Node root, List list)를 정의한다            root가 null이 아닌 경우 아래를 수행한다.       list의 root의 val 값을 먼저 넣어준다.       root의 children이 null이 아닌 경우, children을 순차적으로 root 자리에 넣어 재귀 호출을 한다.           root를 preorder 순으로 val 값들을 넣은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/n-ary-tree-preorder-traversal/",
        "teaser": null
      },{
        "title": "Leetcode Java N-ary Tree Postorder Traversal",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; postorder(Node root) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     this.dfs(root, result);     return result;   }    private void dfs(Node root, List&lt;Integer&gt; list) {     if (root != null) {       if (root.children != null) {         for (Node node : root.children) {           this.dfs(node, list);         }       }       list.add(root.val);     }   }  }   결과  Link   설명     root를 postorder 순으로 val 값들을 반환하는 문제이다.            이전 N-ary Tree Preorder Traversal과 유사한 문제로, order를 다르게 반환하는 문제이다.                result는 postorder 순으로 val 값을 넣을 변수로, ArrayList로 초기화한다.            4번에서 정의한 dfs(Node root, List list)에 result를 넣어 수행한다.       root를 postorder 순으로 val 값을 넣기 위한 dfs(Node root, List list)를 정의한다            root가 null이 아닌 경우 아래를 수행한다.       root의 children이 null이 아닌 경우, children을 순차적으로 root 자리에 넣어 재귀 호출을 한다.       list의 root의 val 값을 넣어준다.           root를 postorder 순으로 val 값들을 넣은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/n-ary-tree-postorder-traversal/",
        "teaser": null
      },{
        "title": "Leetcode Java Valid Square",
        "excerpt":"문제  Link   코드  class Solution {    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {     long a = this.getDistance(p1, p2);     long b = this.getDistance(p1, p3);     long c = this.getDistance(p1, p4);     if (a != this.getDistance(p3, p4) || b != this.getDistance(p2, p4) || c != this.getDistance(p2, p3) ||         a == 0 || b == 0 || c == 0) {       return false;     } else {       return a == b || b == c || a == c;     }   }        private long getDistance(int[] p1, int[] p2) {     return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);   }  }   결과  Link   설명          네 점인 p1, p2, p3, p4를 연결하면 사각형이 되는지 검증하는 문제이다.       두 점 사이의 거리를 계산할 getDistacne(int[] p1, int[] p2) 메서드를 정의한다.            두 점의 길이는 $\\sqrt{(x1 - x2)^2 + (y1 - y2)^2}$ 이지만, 거리를 구하는 문제가 아니므로 제곱근을 사용하지 않은 값으로도 검증이 가능하여 공식의 결과를 반환한다.                a, b, c에 p1과 p2, p1과 p3, p1과 p4의 거리를 순차적으로 넣어준다.       아래의 경우를 만족하면 false를 주어진 문제의 결과로 반환한다.            p1과 p2 간의 거리인 a가 p3과 p4 간의 거리가 같지 않은 경우, 다른 두 선이 동일한 길이가 되지 않으므로 사각형이 될 수 없다.       p1과 p3 간의 거리인 b가 p2와 p4 간의 거리가 같지 않은 경우도 위와 동일한 이유로 사각형이 될 수 없다.       p1과 p4 간의 거리인 c가 p2와 p3 간의 거리가 같지 않은 경우도 위와 동일한 이유로 사각형이 될 수 없다.       a혹은 b, c가 0인 경우 사각형을 이루는 한 변의 길이가 0이므로, 사각형이 될 수 없다.           그 외의 경우, a와 b가 같거나, b와 c가 같거나 a와 c가 같은지 여부를 주어진 문제의 결과로 반환한다.            p1 기준으로 각 점 간의 길이를 저장한 a, b, c 중 두 선의 길이가 같으면 사각형을 구성하는 기본 조건을 만족하므로 true를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/valid-square/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Harmonious Subsequence",
        "excerpt":"문제  Link   코드  class Solution {    public int findLHS(int[] nums) {     Arrays.sort(nums);     int max = 0;     for (int idx = 0; idx &lt; nums.length; idx++) {       if (idx == 0 || nums[idx] != nums[idx - 1]) {         int next = idx + 1;         int curr = nums[idx];         int length = 1;         while (next &lt; nums.length &amp;&amp; nums[next] - curr &lt;= 1) {           length++;           next++;         }         if (nums[next - 1] - curr == 1 &amp;&amp; length &gt; max) {           max = length;         }       }     }     return max;   }  }   결과  Link   설명          nums의 최댓값과 최솟값의 차이가 1인 가장 긴 부분 배열의 길이를 구하는 문제이다.            nums를 오름차순으로 정렬한다.            max는 부분 배열의 최대 길이를 담을 변수로, 0으로 초기화한다       0부터 nums의 길이 미만까지 idx를 증가시키며 아래를 반복한다.            idx가 0이거나 nums의 idx번째 값과 $idx - 1$번째 값이 동일하지 않은 경우 아래를 수행한다.                    next에 $idx + 1$을, curr에 nums의 idx번째 값을, length를 1을 넣어 초기화한다.           next가 nums의 길이보다 작고 nums의 next번째 값과 curr의 차이가 1 이하인 경우, length와 next를 증가시킨다.           nums의 $next - 1$번째 값과 curr의 차이가 1이고 length가 max보다 큰 경우, max에 length를 넣어준다.                           반복이 완료되면 max를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-harmonious-subsequence/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Big Countries",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT name, population, area FROM World WHERE area &gt;= 3000000 OR population &gt;= 25000000   결과  Link   설명     World Table의 area가 $3000000 km^2$ 이상이거나 population 이 25000000 이상인 경우의 나라을 구하는 문제이다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/big-countries/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Big Countries",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT class FROM Courses GROUP BY class HAVING COUNT(student) &gt; 4   결과  Link   설명     Courses Table 의 수강생이 5명 이상인 class를 찾는 문제이다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/classes-more-than-5-students/",
        "teaser": null
      },{
        "title": "Leetcode Java Range Addition II",
        "excerpt":"문제  Link   코드  class Solution {    public int maxCount(int m, int n, int[][] ops) {     for (int[] op : ops) {       m = Math.min(m, op[0]);       n = Math.min(n, op[1]);     }     return m * n;   }  }   결과  Link   설명     $m \\times n$ 크기의 행렬의 모든 값을 0으로 초기화한 M이 주어지면, 아래의 조건을 만족하는 최대 정수의 수를 반환하는 문제이다.            ops[i] = [ai, bi]일 때, 0 &lt;= x &lt; ai 및 0 &lt;= y &lt; bi에 대해 M[x][y]를 1씩 증가해야한다.           ops를 반복하여 아래를 수행한다.            m에 m과 op[0]의 값 중 작은 값을 넣어준다.       n에 n과 op[1]의 값 중 작은 값을 넣어준다.           반복이 완료되면 $m \\times n$의 결과를 주어진 문제의 결과로 반환한다.            최소 범위의 m과 n은 주어진 조건을 수행한 이후, 최댓 값이 되기 때문에 해당 결과가 주어진 문제의 결과가 되는 것이다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/range-addition-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Index Sum of Two Lists",
        "excerpt":"문제  Link   코드  class Solution {    public String[] findRestaurant(String[] list1, String[] list2) {     Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();     List&lt;String&gt; result = new ArrayList&lt;&gt;();     int min = Integer.MAX_VALUE;     for (int idx = 0; idx &lt; list1.length; idx++) {       map.put(list1[idx], idx);     }     for (int idx = 0; idx &lt; list2.length &amp;&amp; idx &lt;= min; idx++) {       if (map.containsKey(list2[idx])) {         int sum = idx + map.get(list2[idx]);         if (sum &lt; min) {           result.clear();           result.add(list2[idx]);           min = sum;         } else if (sum == min) {           result.add(list2[idx]);         }       }     }     return result.toArray(new String[result.size()]);   }  }   결과  Link   설명     좋아하는 음식점 순위가 담긴 list1과 list2 중 가장 우선 순위가 높은 음식점을 찾는 문제이다.            단, 동일한 순위의 음식점이 존재하면 해당 음식점들을 모두 반환한다.           문제 풀이에 필요한 변수를 정의한다.            map은 list1의 음식점의 순위를 담을 변수로, HashMap으로 초기화한다.       result는 동일한 우선 순위의 음식점들을 담을 변수로, ARrayList로 초기화한다.       min은 최소 순위를 저장할 변수로, 정수의 최댓값으로 초기화한다.                list1을 반복하여 map에 음식점 별 순위를 0부터 차례대로 넣어준다.       0부터 lst2의 길이 미만이며 idx가 min이하일 때 까지 idx를 증가시키며 아래를 반복한다.            map에 list2의 idx번째 음식점이 존재하지 않으면 다음 반복을 수행한다.       sum에 idx와 map에서 list2의 idx번째 음식점의 순위 합산을 넣어준다.       sum이 min 미만인 경우, result를 초기화하고 위의 음식점을 넣어준다.       sum이 min과 동일한 경우, result에 위의 음식점을 넣어준다.           반복이 완료되면 우선 순위가 높은 음식점들을 저장한 result를 배열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-index-sum-of-two-lists/",
        "teaser": null
      },{
        "title": "Leetcode Java Non-negative Integers without Consecutive Ones",
        "excerpt":"문제  Link   코드  class Solution {    public int findIntegers(int n) {     int[] dp = new int[32];     dp[0] = 1;     dp[1] = 2;     for (int i = 2; i &lt; dp.length; i++) {       dp[i] = dp[i - 1] + dp[i - 2];     }     int sum = 0;     int pre = 0;     for (int idx = 30; idx &gt;= 0; idx--) {       if ((n &amp; (1 &lt;&lt; idx)) != 0) {         sum += dp[idx];         if (pre == 1) {           sum--;           break;         }         pre = 1;       } else {         pre = 0;       }     }     return sum + 1;   }  }   결과  Link   설명          양의 정수 n이 주어지면 [0, n] 범위의 정수 중 이진수로 변환했을 때 1이 연속되지 않은 정수의 개수를 반환하는 문제이다.            dp를 정수 최대 길이인 32 크기로 초기화 하고, 1과 2를 차례대로 넣어준 후 피보나치 수열을 이용하여 dp를 초기화한다.            정수의 개수를 넣을 sum와 이전 자리의 이진수의 값을 저장할 pre를 0으로 초기화한다.       30부터 0 이상까지 idx를 감소시키며 아래를 반복한다.            n과 1을 idx번 이동시킨 값의 결과가 0이 아닌 경우, 아래를 수행한다.                    sum에 dp의 idx번째 값을 더해 문제의 조건을 만족하는 정수의 개수를 증가시켜준다.           pre가 1인 경우, 연속된 1이 발생했으므로 sum을 감소시키고 반복을 중지한다.                       위의 경우가 아닌 경우, pre에 0을 넣고 반복을 계속 수행한다.           반복이 완료되면 [1, n] 범위의 정수 중 이진수로 변환했을 때 1이 연속되지 않은 정수의 개수인 sum에 0인 경우를 추가한 $sum + 1$을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/non-negative-integers-without-consecutive-ones/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Human Traffic of Stadium",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below WITH tab AS (   SELECT id, visit_date, people, id - ROW_NUMBER() OVER(ORDER BY id) AS group_id   FROM Stadium   WHERE people &gt;= 100  ) SELECT id, visit_date, people from tab  WHERE group_id in (   SELECT group_id   FROM tab   GROUP BY group_id   HAVING COUNT(*) &gt;= 3 )   결과  Link   설명     Stadium Table의 people이 100 이상이고 연속한 3일 이상 해당 조건을 만족하는 경우의 데이터를 찾는 문제이다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/human-traffic-of-stadium/",
        "teaser": null
      },{
        "title": "Leetcode Java Can Place Flowers",
        "excerpt":"문제  Link   코드  class Solution {    public boolean canPlaceFlowers(int[] flowerbed, int n) {     if (n == 0) {       return true;     }     int pre = -1;     for (int idx = 0; idx &lt; flowerbed.length; idx++) {       if (flowerbed[idx] == 0 &amp;&amp;           (pre &lt; idx - 1 || idx == 0) &amp;&amp;           (idx + 1 == flowerbed.length || flowerbed[idx + 1] == 0)) {         n--;         if (n == 0) {           return true;         }         pre = idx;       } else if (flowerbed[idx] == 1) {         pre = idx;       }     }     return false;   }  }   결과  Link   설명          화단인 flowerbed에 n개의 꽃을 한 칸 건너 한 칸마다 심는 것이 가능한지 검증하는 문제이다.            꽃을 꽃의 수인 n이 0인 경우, 무조건 만족하므로 true를 주어진 문제의 결과로 반환한다.            이전 꽃의 위치 값을 저장하기 위한 pre를 -1로 초기화한다.       0부터 flowerbed의 길이 미만까지 idx를 증가시키며 아래를 반복한다.            flowerbed의 idx번째 값이 0이고, idx가 0이거나 pre가 $idx - 1$보다 작고, idx가 마지막 값 이전 위치거나 flowerbed의 마지막 값이 0인 경우 아래를 수행한다.                    n을 감소시키고, n이 0인 경우 꽃을 다 꽃았으면 true를 주어진 문제의 결과로 반환한다.           pre에 idx를 넣어 꽃의 위치를 갱신해준다.                       flowerbed의 idx번째 값이 1인 경우, pre에 idx를 넣어 꽃의 위치를 갱신해준다.           반복이 완료되면 꽃을 다 꽃지 못한 경우이므로, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/can-place-flowers/",
        "teaser": null
      },{
        "title": "Leetcode Java Construct String from Binary Tree",
        "excerpt":"문제  Link   코드  class Solution {    public String tree2str(TreeNode root) {     StringBuilder sb = new StringBuilder();     this.dfs(root, sb);     return sb.toString();   }    private void dfs(TreeNode root, StringBuilder sb) {     if (null != root) {       sb.append(root.val);       if (null != root.left) {         sb.append('(');         this.dfs(root.left, sb);         sb.append(')');       }       if (null != root.right) {         if (null == root.left) {           sb.append('(').append(')');         }         sb.append('(');         this.dfs(root.right, sb);         sb.append(')');       }     }   }  }   결과  Link   설명     이진 트리를 root 노드를 기준으로 Pre Order 순으로 소괄호를 이용한 관계를 문자열로 만들어 반환하는 문제이다.            단, 우측 자식 노드가 빈 경우 소괄호로 표시하지 않는다.           조건의 문자열을 동적으로 만들기 위한 sb 변수를 정의한다.            동적 문자열의 생성시, 효율적인 메모리 사용을 위해 StringBuilder를 사용한다.                4번에서 정의한 dfs(TreeNode root, StringBuilder sb)를 활용하여 sb에 주어진 조건을 만족하는 문자열을 넣어준다.       DFS 방식으로 문자열을 생성할 dfs(TreeNode root, StringBuilder sb) 메서드를 정의한다.            root가 null이면 아무것도 수행하지 않는다.       sb에 root의 val 값을 넣어준다.       root의 left 노드가 비어있지 않은 경우, sb에 소괄호 시작 문자를 넣은 후 root의 left 노드를 이용한 재귀 호출을 수행하고 sb에 소괄호의 종료 문자를 넣는다.       root의 right 노드가 비어있지 않은 경우, root의 left 노드가 비어있으면 sb에 빈 소괄호를 넣어주고 위와 동일하게 sb에 소괄호 시작 문자를 넣은 후 root의 right 노드를 이용한 재귀 호출을 수행하고 sb에 소괄호의 종료 문자를 넣는다.           수행이 완료되면 주어진 문제의 결과로 조건을 만족하는 문자열이 담긴 sb를 문자열로 변환하여 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/construct-string-from-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Sales Person",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT name FROM SalesPerson WHERE sales_id NOT IN (   SELECT Orders.sales_id   FROM Orders   JOIN Company ON Orders.com_id = Company.com_id   WHERE Company.name = 'RED' )   결과  Link   설명     ‘RED’라는 회사 외 주문이 없는 영업 사원의 이름을 찾는 문제이다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/sales-person/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Tree Node",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT DISTINCT Tree.id,   CASE WHEN Tree.p_id IS NULL THEN 'Root'     WHEN Tree.p_id IS NOT NULL AND Children.id IS NOT NULL THEN 'Inner'     WHEN Tree.p_id IS NOT NULL AND Children.id IS NULL THEN 'Leaf'   END AS Type FROM Tree LEFT OUTER JOIN Tree Children ON Tree.id = Children.p_id   결과  Link   설명     Tree 테이블 내 각 노드의 형태를 반환하는 문제이다.            Tree의 가장 꼭데기인 첫 노드를 “Root”로 반환한다.       Root가 아닌 자녀가 존재하는 중간에 있는 노드를 “Inner”로 반환한다.       Root가 아닌 자녀가 없는 노드를 “Leaf”로 반환한다.          ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/tree-node/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Duplicate File in System",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;String&gt;&gt; findDuplicate(String[] paths) {     Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();     for (String path : paths) {       String[] splits = path.split(\"\\\\s\");       for (int idx = 1; idx &lt; splits.length; idx++) {         String[] filePath = splits[idx].split(\"\\\\(\");         String content = filePath[1].substring(0, filePath[1].length() - 1);         if (!map.containsKey(content)) {           map.put(content, new ArrayList&lt;&gt;());         }         map.get(content).add(new StringBuilder(splits[0]).append(\"/\").append(filePath[0]).toString());       }     }     List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();     for (List&lt;String&gt; files : map.values()) {       if (files.size() &gt; 1) {         result.add(files);       }     }     return result;   }  }   결과  Link   설명          파일 위치가 담긴 paths에서 동일한 내용이 존재하는 파일들을 그룹지어 반환하는 문제이다.            동일한 내용이 담긴 파일들을 넣을 map을 정의한다.       paths의 모든 값들을 반복하여 아래를 수행한다.            splits에 path를 공백(“ “) 기준으로 문자열을 분리해서 배열로 넣어준다.       1부터 splits의 길이 미만까지 idx를 증가시키며 아래를 반복한다.                    filePath에 splits의 idx번째 값에서 소괄화의 시작 문자(“(“) 기준으로 문자열을 분리해서 배열로 넣어준다.           content에 filePath의 첫 번째인 텍스트 내용의 시작부터 끝까지 넣어준다.           map에 content가 존재하지 않으면, 신규 ArrayList를 생성하여 넣어준다.           map의 content에 대한 배열을 가져와 splits[0]인 디렉토리 위치에 filePath[0]인 파일 이름을 구분자(“//”)로 합친 문자열을 넣어준다.                                결과를 넣을 result를 ArrayList로 초기화 하고, map의 모든 값들을 반복하여 하나라도 값이 존재하는 파일 그룹들을 result에 넣어준다.       위의 반복이 완료되면 그룹화하여 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-duplicate-file-in-system/",
        "teaser": null
      },{
        "title": "Leetcode Java Valid Triangle Number",
        "excerpt":"문제  Link   코드  class Solution {    public int triangleNumber(int[] nums) {     if (nums.length &lt; 3) {       return 0;     }     Arrays.sort(nums);     int count = 0;     for (int idx = 2; idx &lt; nums.length; idx++) {       int left = 0;       int right = idx - 1;       while (left &lt; right) {         if (nums[left] + nums[right] &gt; nums[idx]) {           count += right - left;           right--;         } else {           left++;         }       }     }     return count;   }  }   결과  Link   설명          nums의 값들을 이용하여 삼각형을 만들 수 있는 경우의 수를 구하는 문제이다.            nums의 길이가 3 미만인 경우, 삼각형을 만들 수 없으므로 0을 주어진 문제의 결과로 반환한다.            nums의 값들을 오름차순으로 정렬한다.            count는 만들 수 있는 삼각형의 개수를 저장할 변수로, 0으로 초기화한다.       2부터 nums의 길이 미만까지 idx를 증가시키며 아래를 반복한다.            left에 0, right에 $idx - 1$을 넣어 탐색 위치를 초기화한다.       left가 right 미만일 때까지 반복하여 아래를 수행한다.                    nums의 left번째 값과 right번째 값의 합이 idx번째 값보다 큰 경우 삼각형을 만들 수 있으므로, 앞의 조합으로 만들 수 있는 조합의 수인 $right - left$ 값을 count에 더해주고 right를 감소시켜 범위를 축소시킨다.           위의 경우가 아니면 삼각형을 만들 수 없으므로, left를 증가시켜 범위를 축소시킨다.                           반복이 완료되면 경우의 수를 저장한 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/valid-triangle-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Merge Two Binary Trees",
        "excerpt":"문제  Link   코드  class Solution {    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {     if (root1 == null) {       return root2;     }     if (root2 == null) {       return root1;     }     root1.val += root2.val;     root1.left = this.mergeTrees(root1.left, root2.left);     root1.right = this.mergeTrees(root1.right, root2.right);     return root1;   }  }   결과  Link   설명          root1과 root2의 두 이진 트리를 합치는 문제이다.       합칠 노드가 없는 두 경우를 먼저 확인한다.            root1이 null인 경우 root2와 합칠 이진 트리가 없으므로, root2를 주어진 문제의 결과로 반환한다.       root2가 null인 경우 root1과 합칠 이진 트리가 없으므로, root1을 주어진 문제의 결과로 반환한다.                root1의 val 값에 root2의 val을 더해준다.            root1의 left TreeNode에 root1의 left TreeNode와 root2의 left TreeNode를 이용하여 재귀 호출을 수행한 결과를 넣어준다.            root1의 right TreeNode에 root1의 lrighteft TreeNode와 root2의 right TreeNode를 이용하여 재귀 호출을 수행한 결과를 넣어준다.       root1에 root2를 합쳤으므로, root1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/merge-two-binary-trees/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Not Boring Movies",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT * FROM Cinema WHERE id % 2 AND description NOT LIKE '%boring%' ORDER BY rating DESC   결과  Link   설명     Cinema 테이블 내 id가 홀수이면서 지루한(boring)하다고 남기지 않은 값들을 찾는 문제이다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/not-boring-movies/",
        "teaser": null
      },{
        "title": "Leetcode Java Task Scheduler",
        "excerpt":"문제  Link   코드  class Solution {    public int leastInterval(char[] tasks, int n) {     int[] counts = new int[26];     for (int task : tasks) {       counts[task - 'A']++;     }     int max = 0;     for (int count : counts) {       max = Math.max(max, count);     }     int maxCount = 0;     for (int count : counts) {       if (count == max) {         maxCount++;       }     }     return Math.max(tasks.length, (max - 1) * (n + 1) + maxCount);   }  }   결과  Link   설명     tasks를 이용하여 최소 n개의 유휴 시간을 이용해 작업을 아래의 조건을 만족하는 최소 단위의 수를 구하는 문제이다.            tasks에 존재하는 영대문자는 각자 다른 작업을 의미한다.       유휴 시간의 전과 후는 동일한 작업을 수행해야 한다.           문제 풀이에 필요한 변수를 정의한다.            counts는 tasks 내 각 작업의 개수를 저장할 변수로, tasks를 반복하여 count의 $task - ‘A’$번째 값을 증가시킨다.       max는 counts내 가장 큰 값을 저장할 변수로, counts를 반복하여 가장 큰 값을 max에 넣어준다.       maxCount는 counts 내 max에 해당하는 작업의 개수를 저장할 변수로, counts를 반복하여 max와 동일한 횟수인 작업의 개수를 넣어준다.           tasks의 길이와 $(max - 1) \\times (n + 1)$의 결과에 maxCount를 더한 결과 중 큰 값을 주어진 문제의 결과로 반환한다.            작업을 수행하는 최소 단위의 수는 tasks의 길이가 되므로, tasks의 길이와 비교한다.       $(max - 1) \\times (n + 1) + maxCount$은 아래를 뜻한다.                    최소 n개의 유휴 시간을 동일한 작업 사이에 넣어야 하므로, 부분 작업의 길이인 $max - 1$를 사용한다.           최소 n개의 유휴 시간을 사용하여 작업을 수행하므로, 부분 작업의 수인 $n + 1$을 사용한다.           두 경우를 곱하여 경우의 수를 구하고, 최대 작업의 수가 동일한 경우 바꿔 사용이 가능하므로 해당 개수를 더해준다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/task-scheduler/",
        "teaser": null
      },{
        "title": "Leetcode Java Design Circular Queue",
        "excerpt":"문제  Link   코드  class MyCircularQueue {    private final int[] array;   private int front;   private int rear;   private int length;    public MyCircularQueue(int k) {     this.array = new int[k];     this.front = 0;     this.rear = -1;     this.length = 0;   }    public boolean enQueue(int val) {     if (!this.isFull()) {       this.rear = (this.rear + 1) % this.array.length;       this.array[this.rear] = val;       this.length++;       return true;     } else {       return false;     }   }    public boolean deQueue() {     if (!this.isEmpty()) {       this.front = (this.front + 1) % this.array.length;       this.length--;       return true;     } else {       return false;     }   }    public int Front() {     return this.isEmpty() ? -1 : this.array[this.front];   }    public int Rear() {     return this.isEmpty() ? -1 : this.array[this.rear];   }    public boolean isEmpty() {     return this.length == 0;   }    public boolean isFull() {     return this.length == this.array.length;   }  }  /**  * Your MyCircularQueue object will be instantiated and called as such:  * MyCircularQueue obj = new MyCircularQueue(k);  * boolean param_1 = obj.enQueue(value);  * boolean param_2 = obj.deQueue();  * int param_3 = obj.Front();  * int param_4 = obj.Rear();  * boolean param_5 = obj.isEmpty();  * boolean param_6 = obj.isFull();  */   결과  Link   설명     아래의 구조의 순환되는 Queue를 구현하는 문제이다.            생성자인 MyCircularQueue(k)는 Queue 크기인 k를 이용하여 객체를 초기화한다.       메서드인 Front()는 Queue의 앞에서 값을 가져오는 역할을 수행하며, 값이 없을 경우 -1을 반환한다.       메서드인 Rear()는 Queue의 뒤에서 값을 가져오는 역할을 수행하며, 값이 없을 경우 -1을 반환한다.       메서드인 enQueue(int value)는 Queue에 value를 추가하는 역할을 수행하며, 성공 시 true를 반환한다.       메서드인 deQueue()는 Queue의 값을 삭제하는 역할을 수행하며, 성공 시 true를 반환한다.       메서드인 isEmpty()는 Queue가 비어있는지 검증하는 역할을 수행한다.       메서드인 isFull()은 Queue가 꽉 차있는지 검증하는 역할을 수행한다.           문제 풀이에 필요한 변수를 정의한다.            array는 Queue의 역할을 수행할 배열이다.       front와 rear는 Queue의 앞과 뒤의 값을 저장할 변수이다.       length는 Queue의 현재 크기를 저장할 변수이다.           생성자인 MyCircularQueue(k)를 정의한다.            Queue를 담당할 array를 k 크기의 정수 배열로 초기화한다.       front와 rear는 0과 -1로, length는 0으로 초기화한다.           메서드인 Front()를 정의한다.            8번에서 정의한 isEmpty() 메서드를 이용하여 Queue가 비어있는 경우 -1을, 비어있지 않으면 array의 front번째 값을 반환한다.           메서드인 Rear()를 정의한다.            8번에서 정의한 isEmpty() 메서드를 이용하여 Queue가 비어있는 경우 -1을, 비어있지 않으면 array의 rear번째 값을 반환한다.           메서드인 enQueue(int value)를 정의한다.            9번에서 정의한 isFull() 메서드를 이용하여 Queue가 꽉 차있지 않으면 아래를 수행한다.                    rear에 Overflow를 방지하기 위해 $rear + 1$에서 array의 길이를 나눈 나머지 값을 넣어준다.           array의 rear번째 위치에 val을 넣어준다.           값을 들어갔으므로 length를 증가시킨다.           값을 Queue에서 성공적으로 추가했으므로 true를 반환한다.                       위의 경우가 아니라면 false를 반환한다.           메서드인 deQueue()를 정의한다.            9번에서 정의한 isFull() 메서드를 이용하여 Queue가 꽉 차있지 않으면 아래를 수행한다.       front에 Overflow를 방지하기 위해 $front + 1$에서 array의 길이를 나눈 나머지 값을 넣어준다.       배열의 위치를 변경해서 시작 포인트를 뒤로 미뤘으므로, length를 감소시킨다.       값을 Queue에서 성공적으로 제거했으므로 true를 반환한다.       위의 경우가 아니라면 false를 반환한다.           메서드인 isEmpty()를 정의한다.            length가 0인지를 검증한 결과를 반환한다.           메서드인 isFull()을 정의한다.            length와 array의 길이가 같은지 결과를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/design-circular-queue/",
        "teaser": null
      },{
        "title": "Leetcode Java Add One Row to Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public TreeNode addOneRow(TreeNode root, int val, int depth) {     if (root != null) {       if (depth == 1) {         TreeNode treeNode = new TreeNode(val);         treeNode.left = root;         return treeNode;       } else if (depth == 2) {         TreeNode left = new TreeNode(val);         left.left = root.left;         TreeNode right = new TreeNode(val);         right.right = root.right;         root.left = left;         root.right = right;       } else {         root.left = this.addOneRow(root.left, val, depth - 1);         root.right = this.addOneRow(root.right, val, depth - 1);       }     }     return root;   }    }   결과  Link   설명     root의 depth번째 깊이에 val 값의 TreeNode를 아래대로 수행한 결과를 반환하는 문제이다.            depth가 주어지면 null이 아닌 cur TreeNode를 두 개 만들어 cur의 left TreeNode와 right TreeNode에 이어준다.       cur의 기존 left TreeNode는 새 TreeNode의 left TreeNode로 넣어준다.       cur의 기존 right TreeNode는 새 TreeNode의 right TreeNode로 넣어준다.       depth가 1인 경우, val 값인 TreeNode를 만들어 root를 앞에서 만든 TreeNode의 left TreeNode로 넣어준다.                root가 null이면 그대로 root를 반환한다.            depth가 1인 경우 val 값인 TreeNode를 treeNode로 정의하고, treeNode의 left TreeNode에 root를 넣어 treeNode를 반환한다.       depth가 1인 경우 아래를 수행한다.            val 값인 TreeNode를 left와 right 두 개를 만든다.       left의 left TreeNode에 root의 TreeNode를, right의 right TreeNode에 root의 right TreeNode를 넣어준다.       root의 left TreeNode에 left를, root의 right TreeNode에 right를 넣어준다.           그 외의 경우 아래를 수행한다.            root의 left TreeNode에 root의 left TreeNode와 depth를 1 감소시킨 값으로 재귀 호출 수행한 결과를 넣어준다.       root의 right TreeNode에 root의 right TreeNode와 depth를 1 감소시킨 값으로 재귀 호출 수행한 결과를 넣어준다.           수행이 완료되면 root를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/add-one-row-to-tree/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Exchange Seats",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT     CASE WHEN id % 2 = 0 THEN id - 1          WHEN id % 2 = 1 AND id &lt; (SELECT COUNT(*) FROM Seat) THEN id + 1          ELSE id     END AS id, student FROM Seat ORDER BY id   결과  Link   설명     Seat 테이블 내 연속된 순서의 학생들의 id를 바꾸는 문제이다.            단, 학생의 수가 홀수인 경우 마지막 학생의 id는 바꾸지 않는다.          ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/exchange-seats/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Product of Three Numbers",
        "excerpt":"문제  Link   코드  class Solution {    public int maximumProduct(int[] nums) {     if (nums.length == 3) {       return nums[0] * nums[1] * nums[2];     }     int[] max = new int[] { Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE };     int[] min = new int[] { Integer.MAX_VALUE, Integer.MAX_VALUE };     for (int idx = 0; idx &lt; nums.length; idx++) {       if (nums[idx] &lt; min[1]) {         if (nums[idx] &lt; min[0]) {           min[1] = min[0];           min[0] = nums[idx];         } else {           min[1] = nums[idx];         }       }       if (nums[idx] &gt; max[0]) {         if (nums[idx] &gt; max[2]) {           max[0] = max[1];           max[1] = max[2];           max[2] = nums[idx];         } else if (nums[idx] &gt; max[1]) {           max[0] = max[1];           max[1] = nums[idx];         } else {           max[0] = nums[idx];         }       }     }     return Math.max(max[2] * max[1] * max[0], max[2] * min[0] * min[1]);   }  }   결과  Link   설명          nums 내 세 숫자의 곱이 최댓값되는 값을 구하는 문제이다.            nums의 길이가 3인 경우, 세 값의 곱이 최대인 수는 해당 세 숫자의 곱이므로 모든 값을 곱한 값을 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            max는 가장 큰 세 값을 저장할 배열로, 정수의 가장 작은 값을 세 개를 넣어 초기화한다.       min은 가장 작은 두 값을 저장할 배열로, 정수의 가장 큰 값을 두 개 넣어 초기화한다.           0부터 nums의 길이 미만까지 idx를 증가시키며 아래를 반복한다.            nums의 idx 값을 이용하여 가장 작은 두 값을 min에 오름차순으로 넣어준다.       nums의 idx 값을 이용하여 가장 큰 세 값을 max에 오름차순으로 넣어준다.           max의 세 값의 곱과 min의 두 값의 곱과 max의 가장 큰 값의 곱 중 가장 큰 값을 주어진 문제의 결과로 반환한다.            가장 큰 세 숫자가 모두 양수인 경우, 앞의 숫자들의 곱은 일반적으로 가장 큰 값이 된다.       하지만 음수를 포함하는 경우, 두 값이 모두 음수인 가장 작은 두 값과 한 값이 양수인 가장 큰 값의 곱이 가장 큰 값이 되기도 한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-product-of-three-numbers/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Swap Salary",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below UPDATE Salary SET sex = CASE WHEN sex = 'm' THEN 'f' ELSE 'm' END   결과  Link   설명     Salary 테이블 내 sex 컬럼의 값을 ‘m’은 ‘f’로, ‘f’는 ‘m’으로 변환하는 쿼리를 만드는 문제이다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/swap-salary/",
        "teaser": null
      },{
        "title": "Leetcode Java Sum of Square Numbers",
        "excerpt":"문제  Link   코드  class Solution {    public boolean judgeSquareSum(int c) {     for (int idx = 2; idx * idx &lt;= c; idx++) {       int count = 0;       if (c % idx == 0) {         while (c % idx == 0) {           count++;           c /= idx;         }         if (idx % 4 == 3 &amp;&amp; count % 2 != 0) {           return false;         }       }     }     return c % 4 != 3;   }  }   결과  Link   설명          음이 아닌 정수 c가 주어졌을 때, $a^2 + b^2 = c$를 만족하는 a와 b가 있는지 검증하는 문제이다.       2부터 $idx^2$이 c 이하인 경우까지 idx를 증가시키며 아래를 반복한다.            count는 c를 idx로 나눈 횟수를 저장할 변수로, 0으로 초기화한다.       c와 idx를 나눈 나머지가 0인 경우, 아래를 수행한다.                    c와 idx를 나눈 나머지가 0이 될 때 까지 반복하여 count를 증가시키고, c에 c와 idx를 나눈 몫을 저장한다.           idx와 4를 나눈 나머지가 3이고 count가 홀수인 경우, 주어진 조건을 만족하는 경우가 없으므로 false를 주어진 문제의 결과로 반환한다.                           반복이 완료되면 c를 4로 나눈 나머지 값이 3이 아닌지를 검증하여 주어진 문제의 결과로 반환한다.   해설     페르마의 마지막 정리를 이용한 방법으로 n이 3 이상의 정수일 때, $a^n + b^n = c^n$을 만족하는 양의 정수 a, b, c가 존재하지 않는다.   위에 따르면 $4k + 3$ 형태의 모든 n의 소인수가 n의 소인수 분해에서 짝수 제곱을 가질 때에만 숫자 n은 두 제곱의 합이므로, 해당 경우에 대한 값의 검증을 수행하면 아래의 각 경우를 수행한다.            반복을 이용하여 c를 4로 나눈 나머지 값이 3이고 짝수 제곱인 경우를 검증하여 먼저 위의 공식에 만족하는 경우를 배제한다.       마지막으로 나머지 값인 c를 4로 나눈 나머지 값이 3이면 동일하게 위의 공식에 만족하는 경우이므로 배제하여 검증 결과를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sum-of-square-numbers/",
        "teaser": null
      },{
        "title": "Leetcode Java Exclusive Time of Functions",
        "excerpt":"문제  Link   코드  class Solution {    public int[] exclusiveTime(int n, List&lt;String&gt; logs) {     int[] result = new int[n];     Stack&lt;int[]&gt; stack = new Stack&lt;&gt;();     for (String log : logs) {       String[] split = log.split(\":\");       int id = Integer.valueOf(split[0]);       int timestamp = Integer.valueOf(split[2]);       if (split[1].equals(\"start\")) {         stack.push(new int[] { id, timestamp });       } else {         int time = timestamp - stack.pop()[1] + 1;         result[id] += time;         if (!stack.empty()) {           result[stack.peek()[0]] -= time;         }       }     }     return result;   }  }   결과  Link   설명     단일 스레드의 CPU에서 0부터 $n - 1$의 고유한 아이디를 가지는 n개의 기능 별 수행 시간이 저장된 logs를 이용하여 id에 해당하는 크기의 배열의 각 자리에 맞추어 반환하는 문제이다.            logs는 id, status(start OR end), timestamp를 콜론(“:”)을 사용해서 묶은 log들을 순차적으로 저장한 배열이다.           문제 풀이에 필요한 변수를 정의한다.            result는 각 기능의 수행 시간을 저장하기 위한 배열로, n의 크기로 초기화한다.       stack은 로그를 이용하여 수행 내열을 저장하기 위한 변수로, Stack으로 정의한다.           logs의 모든 값들을 아래를 이용하여 반복 수행한다.            log를 콜론(“:”)을 구분자로 나누어 split에 넣어준다.       id에 split의 첫 번째 값을, timestamp에 split의 세 번째 값을 넣어준다.       split의 두 번째 값이 “start”인 경우, stack에 id와 timestamp를 배열로 넣어 저장한다.       split의 두 번째 값이 “end”인 경우 아래를 수행한다.                    stack에서 저장한 값을 빼와 timestamp 차이를 계산해서 time에 넣어준다.           result의 id번째 값에 time을 더해준다.           stack이 비어있지 않은 경우 유휴 시간을 빼주어야 하므로, result의 stack의 다음 저장된 값의 id에 해당하는 값에 time을 빼준다.                           반복이 완료되면 각 기능 별 수행 시간을 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/exclusive-time-of-functions/",
        "teaser": null
      },{
        "title": "Leetcode Java Solve the Equation",
        "excerpt":"문제  Link   코드  class Solution {    public String solveEquation(String equation) {     String[] split = equation.split(\"=\");     int[] values = new int[4];     this.caculate(split[0], values, 0);     this.caculate(split[1], values, 2);     int left = values[0] - values[2];     int right = values[3] - values[1];     if (left == 0 &amp;&amp; right == 0) {       return \"Infinite solutions\";     } else if (left == 0) {       return \"No solution\";     } else {       return new StringBuilder(\"x=\").append(right / left).toString();     }   }    private void caculate(String s, int[] values, int index) {     int sign = 1;     int value = 0;     char prev = '1';     for (char c : s.toCharArray()) {       if (c == 'x') {         if (value == 0 &amp;&amp; (prev != '0')) {           value = 1;         }         values[index] += sign * value;         value = 0;       } else if (c == '+' || c == '-') {         values[index + 1] += sign * value;         value = 0;         sign = (c == '+') ? 1 : -1;       } else {         value = (value * 10) + (c - '0');       }       prev = c;     }     values[index + 1] += sign * value;   }  }   결과  Link   설명     x에 대한 방정식을 문자열로 저장한 equation을 계산하는 문제이다.            방정식의 풀이가 불가능한 경우, “No solution”을 반환한다.       x의 값이 무한히 가능한 경우, “Infinite solutions”을 반환한다.           문제 풀이에 필요한 변수를 정의한다.            split은 equation을 “=” 기준으로 분리한 문자 배열을 저장한다.       values는 방정식의 값들을 저장할 배열로, 좌변과 우변의 x와 상수 값을 차례대로 3번에서 정의한 caculate(String s, int[] values, int index) 메서드를 이용하여 넣어준다.           방정식의 좌변과 우변의 값을 정리하기 위한 caculate(String s, int[] values, int index) 메서드를 정의한다.            문제 풀이에 필요한 변수를 정의한다.                    sign은 양수와 음수를 구분하기 위한 변수로, 1로 초기화한다.           value는 계산한 값을 저장하기 위한 변수로, 0으로 초기화한다.           prev는 이전 값을 저장하기 위한 임시 변수로 ,1로 초기화한다.                       s의 모든 문자를 c로 처음부터 끝까지 아래를 이용하여 반복한다.                    c가 ‘x’인 경우, value가 0이고 prev가 ‘0’이 아니면 value를 1로 초기화 후 values의 index번째 위치에 $sign \\times value$의 결과를 더하고 value를 0으로 초기화한다.           c가 ‘+’이거나 ‘-‘인 경우, values의 $index + 1$번째 위치에 $sign \\times value$를 더하고 value를 0으로 초기화 후 sign을 c가 ‘+’이면 1로, 아니면 -1로 초기화한다.           그 외의 경우 value에 $value \\times 10$에 c를 숫자로 변환한 값을 더한 결과를 넣어 value의 자릿수를 증가시킨다.                       반복이 완료되면 values의 $index + 1$번째 위치에 $sign \\times value$를 더해 마무리한다.           방정식 형태의 값을 계산한다.            방정식 내 x의 값을 저장할 left에 values의 0번째 값과 2번째 값의 차이를 넣어준다.       방정식 내 상수의 값을 저장할 right에 value의 3번째 값과 1번째 값의 차이를 넣어준다.       예를 들어 $2x + 1 = x + 2$인 경우, $x = 1$로 만들어준다.           아래의 경우를 검증하여 주어진 문제의 결과를 반환한다.            left와 right가 0이면 $0x = 0$이므로 x는 무한한 값이 가능하므로, “Infinite solutions”를 주어진 문제의 결과로 반환한다.       위의 경우가 아니면서 left만 0인 경우 $0x = 1$이므로 방정식 풀이가 불가능하므로, “No solution”을 주어진 문제의 결과로 반환한다.       위의 경우들이 아니면, “x=” 다음 값에 $\\frac{right}{left}$인 결과를 더해 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/solve-the-equation/",
        "teaser": null
      },{
        "title": "Leetcode Java Design Circular Deque",
        "excerpt":"문제  Link   코드  class MyCircularDeque {    private int[] deque;    private int front;   private int rear;    private int max;   private int size;    public MyCircularDeque(int k) {     this.deque = new int[k];     this.max = k;     this.rear = 1;   }    public boolean insertFront(int value) {     if (this.isFull()) {       return false;     } else {       this.front = (this.front + 1) % this.max;       this.deque[this.front] = value;       this.size++;       return true;     }   }    public boolean insertLast(int value) {     if (this.isFull()) {       return false;     } else {       this.rear = ((this.rear - 1) + this.max) % this.max;       this.deque[this.rear] = value;       this.size++;       return true;     }   }    public boolean deleteFront() {     if (this.isEmpty()) {       return false;     } else {       this.front = ((this.front - 1) + this.max) % this.max;       this.size--;       return true;     }   }    public boolean deleteLast() {     if (this.isEmpty()) {       return false;     } else {       this.rear = (this.rear + 1) % this.max;       this.size--;       return true;     }   }    public int getFront() {     return this.size == 0 ? -1 : this.deque[this.front];   }    public int getRear() {     return this.size == 0 ? -1 : this.deque[this.rear];   }    public boolean isEmpty() {     return this.size == 0;   }    public boolean isFull() {     return this.size == this.max;   }  }  /**  * Your MyCircularDeque object will be instantiated and called as such:  * MyCircularDeque obj = new MyCircularDeque(k);  * boolean param_1 = obj.insertFront(value);  * boolean param_2 = obj.insertLast(value);  * boolean param_3 = obj.deleteFront();  * boolean param_4 = obj.deleteLast();  * int param_5 = obj.getFront();  * int param_6 = obj.getRear();  * boolean param_7 = obj.isEmpty();  * boolean param_8 = obj.isFull();  */   결과  Link   설명     지난 번 Design Circular Queue와 유사하게 아래의 구조의 순환되는 Deque를 구현하는 문제이다.            생성자인 MyCircularDeque(int k)는 Deque 크기인 k를 이용하여 객체를 초기화한다.       메서드인 insertFront()는 Deque의 앞에 입력된 값을 넣어주는 역할을 수행하며, 성공했는지 결과를 boolean 값으로 반환한다.       메서드인 insertLast()는 Deque의 뒤에 입력된 값을 넣어주는 역할을 수행하며, 성공했는지 결과를 boolean 값으로 반환한다.       메서드인 deleteFront()는 Deque의 앞에 입력된 값을 제거하는 역할을 수행하며, 성공했는지 결과를 boolean 값으로 반환한다.       메서드인 deleteLast()는 Deque의 뒤에 입력된 값을 제거하는 역할을 수행하며, 성공했는지 결과를 boolean 값으로 반환한다.       메서드인 getFront()는 Deque의 앞에 있는 값을 반환하는 역할을 수행하며, 비어있으면 -1을 반환한다.       메서드인 getRear()는 Deque의 뒤에 있는 값을 반환하는 역할을 수행하며, 비어있으면 -1을 반환한다.       메서드인 isEmpty()는 Deque가 비어있는지 검증하는 역할을 수행한다.       메서드인 isFull()은 Deque가 꽉 차있는지 검증하는 역할을 수행한다.           문제 풀이에 필요한 변수를 정의한다.            deque는 입력된 값들을 순환되는 Deque로 관리하기 위한 배열이다.       front와 rear는 입력된 값 중 가장 앞과 뒤에 입력된 값을 저장하는 변수이다.       max는 deque의 최대 크기를 저장할 변수이다.       size는 deque의 현재 크기를 저장할 변수이다.           생성자인 MyCircularDeque(int k)를 정의한다.            deque를 입력된 k 크기인 정수 배열로 초기화한다.       max에 k를 넣어 보관한다.       rear는 초기 값인 1을 넣어 초기화한다.           메서드인 insertFront()를 정의한다.            11번에서 정의한 isFull() 메서드를 수행하여 deque가 꽉 차있는 경우 입력이 불가능하므로, false를 반환한다.       위의 경우가 아니라면 아래를 수행한다.                    front에 overflow를 방지하기 위해 $front + 1$에서 max를 나눈 나머지 값을 넣어준다.           deque의 front번째 위치에 value를 넣어주고, size를 증가시킨다.           정상적으로 value를 deque의 앞에 저장하였으므로, true를 반환한다.                           메서드인 insertLast()를 정의한다.            11번에서 정의한 isFull() 메서드를 수행하여 deque가 꽉 차있는 경우 입력이 불가능하므로, false를 반환한다.       위의 경우가 아니라면 아래를 수행한다.                    rear에 overflow를 방지하기 위해 $(rear - 1) + max$에서 max를 나눈 나머지 값을 넣어준다.           deque의 rear번째 위치에 value를 넣어주고, size를 증가시킨다.           정상적으로 value를 deque의 뒤에 저장하였으므로, true를 반환한다.                           메서드인 deleteFront()를 정의한다.            10번에서 정의한 isEmpty() 메서드를 수행하여 deque가 비어있는 경우 값이 없으므로, false를 반환한다.       위의 경우가 아니라면 아래를 수행한다.                    front에 overflow를 방지하기 위해 $(front - 1) + max$에 max를 나눈 나머지 값을 넣어준다.           size를 감소시켜 현재 크기를 감소시킨다.           정상적으로 deque의 앞의 값을 제거하였으므로, true를 반환한다.                           메서드인 deleteLast()를 정의한다.            10번에서 정의한 isEmpty() 메서드를 수행하여 deque가 비어있는 경우 값이 없으므로, false를 반환한다.       위의 경우가 아니라면 아래를 수행한다.                    rear에 overflow를 방지하기 위해 $rear + 1$에 max를 나눈 나머지 값을 넣어준다.           size를 감소시켜 현재 크기를 감소시킨다.           정상적으로 deque의 뒤의 값을 제거하였으므로, true를 반환한다.                           메서드인 getFront()를 정의한다.            10번에서 정의한 isEmpty() 메서드를 수행하여 deque가 비어있는 경우 값이 없으므로, -1을 반환한다.       위의 경우가 아니라면 deque의 front번째 값을 반환한다.           메서드인 getRear()를 정의한다.            10번에서 정의한 isEmpty() 메서드를 수행하여 deque가 비어있는 경우 값이 없으므로, -1을 반환한다.       위의 경우가 아니라면 deque의 rear번째 값을 반환한다.           메서드인 isEmpty()를 정의한다.            size가 0인지를 검증한 결과를 반환한다.           메서드인 isFull()를 정의한다.            size가 max인지를 검증한 결과를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/design-circular-deque/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Average Subarray I",
        "excerpt":"문제  Link   코드  class Solution {    public double findMaxAverage(int[] nums, int k) {     long sum = 0;     long max = Long.MIN_VALUE;     for (int idx = 0; idx &lt; nums.length; idx++) {       sum += nums[idx];       if (idx &gt; k - 1) {         sum -= nums[idx - k];       }       if (idx &gt;= k - 1) {         max = Math.max(max, sum);       }     }     return (double) max / k;   }  }   결과  Link   설명          nums 내 k개의 연속된 값들의 평균이 최대인 값을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            sum은 nums 내 k개의 연속된 값들을 더한 결과를 저장할 변수로, 0으로 초기화한다.       max는 nums 내 k개의 연속된 값들의 평균이 최대인 값을 저장할 변수로, 0으로 초기화한다.           0부터 nums의 길이 미만까지 idx를 증가시키며 아래를 반복한다.            sum에 nums의 idx번째 값을 더해준다.       idx가 $k - 1$보다 큰 경우, sum에 nums의 $idx - k$번째 값을 빼주어 연속된 k개 합을 유지한다.       idx가 $k - 1$보다 크거나 같은 경우, max에 max와 sum 중 큰 값을 넣어준다.           반복이 완료되면 max를 실수형으로 형 변환 후 $\\frac{max}{k}$의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-average-subarray-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Set Mismatch",
        "excerpt":"문제  Link   코드  class Solution {    public int[] findErrorNums(int[] nums) {     int[] count = new int[nums.length + 1];     int[] result = new int[2];     for (int num : nums) {       count[num]++;     }     for (int idx = 0; idx &lt; count.length; idx++) {       switch (count[idx]) {         case 0: result[1] = idx; break;         case 2: result[0] = idx; break;       }     }     return result;   }  }   결과  Link   설명          nums 내 중복된 값과 빠진 값 순으로 배열로 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            count는 nums의 개수를 구하기 위한 배열로, nums의 길이보다 1 큰 정수 배열로 초기화한다.       result는 중복된 값과 빠진 값을 반환하기 위한 배열로, 2 크기의 정수 배열로 초기화한다.                nums를 반복하여 count의 num번째 위치값을 증가시킨다.       0부터 count의 길이 미만까지 아래를 반복한다.            count의 idx번째 값이 0이면 빠진 값이므로, result의 두 번째 값을 idx로 넣어준다.       count의 idx번째 값이 2이면 중복된 값이므로, result의 첫 번째 값을 idx로 넣어준다.           중복된 값과 빠진 값 순서로 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/set-mismatch/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Length of Pair Chain",
        "excerpt":"문제  Link   코드  class Solution {    public int findLongestChain(int[][] pairs) {     Arrays.sort(pairs, (a, b) -&gt; a[0] - b[0]);     int pre = pairs[0][1];     int count = 1;     for (int idx = 1; idx &lt; pairs.length; idx++) {       if (pairs[idx][0] &gt; pre) {         pre = pairs[idx][1];         count++;       } else {         pre = Math.min(pre, pairs[idx][1]);       }     }     return count;   }  }   결과  Link   설명     pairs 내 아래의 조건으로 연결 할 경우, 최대 길이를 구하는 문제이다.            pairs[i] = [lefti, righti], lefti &lt; righti       p1 = [a, b]이고 p2 = [c, d]일 때, b &lt; c을 만족하는 경우 연결이 가능하다.                pairs의 모든 배열들을 배열 내 첫 번째 값의 오름차순으로 정렬한다.       문제 풀이에 필요한 변수를 정의한다.            pre는 연결된 이전 배열의 두 번째 값을 저장할 변수로, pairs의 첫 배열의 두 번째 값으로 초기화한다.       count는 연결 쌍의 최대 길이를 계산할 변수로, 위의 첫 배열이 포함되었으므로 1로 초기화한다.           첫 값이 포함되었으므로, 1부터 pairs의 길이 미만까지 idx를 증가시키며 아래를 반복한다.            pairs[idx][0]의 값이 pre보다 큰 경우 연결이 가능하므로, pre에 pairs[idx][1] 값을 넣어주고 count를 증가시킨다.       그 외의 경우 pre에 pre와 pairs[idx][1] 중 작은 값을 넣어준다.           반복이 완료되면 계산된 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-length-of-pair-chain/",
        "teaser": null
      },{
        "title": "Leetcode Java Palindromic Substrings",
        "excerpt":"문제  Link   코드  class Solution {    public int countSubstrings(String s) {     int count = 0;     char[] charArray = s.toCharArray();     for (int idx = 0; idx &lt; s.length(); idx++) {       count += this.isPalindrome(charArray, idx, idx) + this.isPalindrome(charArray, idx, idx + 1);     }     return count;   }    private int isPalindrome(char[] charArray, int start, int end) {     int count = 0;     while (start &gt;= 0 &amp;&amp; end &lt; charArray.length &amp;&amp; charArray[start] == charArray[end]) {       count++;       start--;       end++;     }     return count;   }  }   결과  Link   설명          문자열 s 내 앞뒤로 읽어도 같은 문자열(이하 회문)을 만들 수 있는 하위 문자열의 수를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            count는 문제에 해당하는 하위 문자열의 수를 계산하기 위한 변수로, 0으로 초기화한다.       charArray는 문자열 s를 문자 배열로 저장하기 위한 변수이다.           0부터 s의 길이 미만까지 idx를 증가시키며 아래를 반복한다.            count에 4번에서 정의한 isPalindrome(char[] charArray, int start, int end) 메서드를 end에 idx와 $idx + 1$인 홀수와 짝수의 경우를 각각 계산하여 더해준다.           회문이 되는 문자열의 수를 계산하기 위한 isPalindrome(char[] charArray, int start, int end)을 정의한다.            count는 start부터 end까지 회문이 되는 문자열의 숫자로, 0으로 초기화한다.       start가 0 이상이고, end가 charArray 길이 미만이면서 charArray의 start번째 문자와 end번째 문자가 동일하면 아래를 수행한다.                    위를 만족하면 회문이 되므로, count를 증가시킨다.           범위를 축소하기 위해 start를 감소시키고, end를 증가시킨다.                       반복이 완료되면 count를 반환한다.           모든 수행이 완료되면 회문을 만들 수 있는 하위 문자열의 수를 계산한 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/palindromic-substrings/",
        "teaser": null
      },{
        "title": "Leetcode Java Dota2 Senate",
        "excerpt":"문제  Link   코드  class Solution {    public String predictPartyVictory(String senate) {     char[] charArray = senate.toCharArray();     int flag = 0;     boolean radiant = true;     boolean dire = true;     while (radiant &amp;&amp; dire) {       radiant = false;       dire = false;       for (int idx = 0; idx &lt; charArray.length; idx++) {         if (charArray[idx] == 'R') {           if (flag &gt; 0) {             charArray[idx] = 'X';           } else {             radiant = true;           }           flag--;         } else if (charArray[idx] == 'D') {           if (flag &lt; 0) {             charArray[idx] = 'X';           } else {             dire = true;           }           flag++;         }       }     }     return radiant ? \"Radiant\" : \"Dire\";   }  }   결과  Link   설명     senate를 이루는 문자를 이용하여 아래의 규칙을 만족하는 경우에 대한 결과를 반환하는 문제이다.            R과 D는 각각 Radiant와 Dire를 뜻하는 문자이다.       R이 나온 경우 다음 D를 제거할 수 있고, D가 나온 경우 다음 R을 제거할 수 있다.       마지막으로 남아있는 문자를 뜻하는 단어를 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            charArray는 senate를 문자 배열로 저장한 배열이다.       flag는 D가 R보다 큰 개수를 저장할 변수로, 0으로 초기화한다.       radiant와 dire는 이전 자리의 단어가 R인지 D인지를 구분하기 위한 변수로, true로 초기화한다.           radiant와 dire 모두 true일 때 까지 아래를 반복한다.            radiant와 dire를 false로 변경한다.       0부터 charArray 길이 미만까지 idx를 증가시키며 아래를 수행한다.                    charArray의 idx번째 값이 R이면서 flag가 0 초과인 경우, charArray의 idx번째 위치에 X를 넣어 무시해준다.           charArray의 idx번째 값이 R이면서 flag가 0 이하인 경우, radiant를 true로 변경해준다.           위를 수행한 이후 flag를 감소시킨다.           charArray의 idx번째 값이 D이면서 flag가 0 미만인 경우, charArray의 idx번째 위치에 X를 넣어 무시해준다.           charArray의 idx번째 값이 D이면서 flag가 0 이상인 경우, dire를 true로 변경해준다.           위를 수행한 이후 flag를 감소시킨다.                           반복이 완료되면 radiant가 true면 Radiant를, 아니면 Dire를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/dota2-senate/",
        "teaser": null
      },{
        "title": "Leetcode Java 2 Keys Keyboard",
        "excerpt":"문제  Link   코드  class Solution {    public int minSteps(int n) {     int result = 0;     for (int idx = 2; idx * idx &lt;= n;) {       if (n % idx == 0) {         result += idx;         n /= idx;       } else {         idx++;       }     }     if (n != 1) {       result += n;     }     return result;   }  }   결과  Link   설명          A 한 문자만 존재하는 메모장에서 모두 복사, 붙여넣기 두 기능만 사용 가능했을 때 A 문자를 정확히 n번 나타낼 수 있는 최소 기능 사용 횟수를 구하는 문제이다.            최소 횟수를 담기 위한 result를 0으로 초기화한다.       n이 2이면 복사 -&gt; 붙여넣기 순으로 되므로 최소 횟수인 2부터 $idx^2$이 n 이하일 때까지 아래를 반복한다.            n을 idx로 나눈 나머지가 0이면 계산된 순번을 반복할 수 있으므로, result에 idx를 더해주고 n에 n을 idx로 나눈 값을 넣어준다.       위의 경우가 아니라면 idx를 증가시켜 붙여넣기를 추가로 수행했을 경우로 계산을 수행한다.                n이 1이 아닌 경우 추가로 기능을 수행해야 하므로, result에 남은 n을 더해준다.       최소 기능 사용 횟수를 계산한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/2-keys-keyboard/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Duplicate Subtrees",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;TreeNode&gt; findDuplicateSubtrees(TreeNode root) {     List&lt;TreeNode&gt; result = new ArrayList&lt;&gt;();     this.dfs(root, new HashMap&lt;&gt;(), result);     return result;   }    private String dfs(TreeNode treeNode, Map&lt;String, Integer&gt; map, List&lt;TreeNode&gt; result) {     if (treeNode == null) {       return \".\";     }     String subTree = new StringBuilder()         .append(treeNode.val)         .append(\",\")         .append(this.dfs(treeNode.left, map, result))         .append(\",\")         .append(this.dfs(treeNode.right, map, result))         .toString();     map.put(subTree, map.getOrDefault(subTree, 0) + 1);     if (map.get(subTree) == 2) {       result.add(treeNode);     }     return subTree;   }  }   결과  Link   설명          root 내 중복된 TreeNode를 반환하는 문제이다.       결과를 넣을 result를 정의하고, ArrayList로 초기화한다.            3번에서 정의한 dfs(TreeNode treeNode, Map&lt;String, Integer&gt; map, List result) 메서드에 root와 새 HashMap, result를 넣고 수행한다.           DFS preorder로 탐색을 수행할 dfs(TreeNode treeNode, Map&lt;String, Integer&gt; map, List result) 메서드를 정의한다.            treeNode가 null인 경우 임의 값인, “.”를 반환한다.       subTree에 아래를 순차적으로 넣은 StringBuilder를 문자열로 변환하여 넣어준다.                    treeNode.val와 “,”를 순차적으로 넣어준다.           treeNode의 left TreeNode를 이용하여 재귀 호출을 수행한 결과를 넣고 “,”를 넣어준다.           마지막으로 treeNode의 right TreeNode를 이용하여 재귀 호출을 수행한 결과를 넣어준다.                       map의 subTree에 해당하는 값이 있으면 가져오고, 없으면 0을 가져와 1을 더한 값을 다시 map의 subTree에 해당하는 값에 넣어준다.       만일 map의 subTree번째 값이 2인 경우 중복된 subTree이므로, result에 subTree를 넣어준다.       수행이 완료되면 subTree를 반환한다.           모든 중복된 subTree의 preorder 값들을 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-duplicate-subtrees/",
        "teaser": null
      },{
        "title": "Leetcode Java Two Sum IV - Input is a BST",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public boolean findTarget(TreeNode root, int k) {     return this.dfs(root, root, k);   }    private boolean dfs(TreeNode root, TreeNode curr, int k) {     if (curr == null) {       return false;     } else {       return this.search(root, curr, k - curr.val)           || this.dfs(root, curr.left, k)           || this.dfs(root, curr.right, k);     }   }    private boolean search(TreeNode root, TreeNode curr, int k) {     if (root == null) {       return false;     } else {       return ((root.val == k) &amp;&amp; (root != curr))           || ((root.val &lt; k) &amp;&amp; this.search(root.right, curr, k))           || ((root.val &gt; k) &amp;&amp; this.search(root.left, curr, k));     }   }  }   결과  Link   설명          root의 자식 노드들 중 두 TreeNode의 값을 이용해서 k를 만들 수 있는지 검증하는 문제이다.            3번에서 정의한 dfs(TreeNode root, TreeNode curr, int k) 메서드에 root를 root와 curr 자리에 넣어 수행한 결과를 주어진 문제의 결과로 반환한다.       DFS 방식으로 탐색할 dfs(TreeNode root, TreeNode curr, int k) 메서드를 정의한다.            curr이 null인 경우 수행이 불가능하므로, false를 반환한다.       그렇지 않은 경우 아래의 경우 중 하나라도 만족하면 true를, 아니면 false를 반환한다.                    4번에서 정의한 search(TreeNode root, TreeNode curr, int k) 메서드에 $k - curr.val$를 k 자리에 넣어 수행 결과가 true인 경우.           curr의 left TreeNode를 이용하여 재귀 호출한 결과가 true인 경우.           curr의 right TreeNode를 이용하여 재귀 호출한 결과가 true인 경우.                           root 기준으로 탐색하기 위한 search(TreeNode root, TreeNode curr, int k) 메서드를 정의한다.            root가 null인 경우 수행이 불가능하므로, false를 반환한다.       그렇지 않은 경우 아래의 결과 중 하나라도 만족하면 true를, 아니면 false를 반환한다.                    root의 val 값이 k와 동일하고 root와 curr이 다른 경우.           root의 val 값이 k보다 작고, root의 right TreeNode를 이용하여 재귀 호출한 결과가 true인 경우.           root의 val 값이 k보다 크고, root의 left TreeNode를 이용하여 재귀 호출한 결과가 true인 경우.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/two-sum-iv-input-is-a-bst/",
        "teaser": null
      },{
        "title": "Leetcode Java Robot Return to Origin",
        "excerpt":"문제  Link   코드   class Solution {    public boolean judgeCircle(String moves) {     int x = 0;     int y = 0;     for (char move : moves.toCharArray()) {       switch (move) {         case 'U': y++; break;         case 'R': x++; break;         case 'D': y--; break;         case 'L': x--; break;       }     }     return x == 0 &amp;&amp; y == 0;   }  }   결과  Link   설명     (0, 0) 위치에서 moves에 따라 움직이는 로봇이 원래 위치로 복귀하는지 여부를 검증하는 문제이다.            ‘U’는 로봇이 위로, ‘R’은 우측으로, ‘D’는  아래로, ‘L’은 좌측으로 이동한다.                x축과 y축의 위치를 저장할 x와 y를 0으로 초기화한다.       moves를 처음부터 끝까지 한 단어씩 반복하여 아래를 수행한다.            move가 ‘U’인 경우 y를 증가시키고, ‘D’인 경우 y를 감소시킨다.       move가 ‘R’인 경우 x를 증가시키고, ‘L’인 경우 x를 감소시킨다.           반복이 완료되면 x와 y가 0인지를 검증하여 원점으로 복귀했는지 여부를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/robot-return-to-origin/",
        "teaser": null
      },{
        "title": "Leetcode Java Find K Closest Elements",
        "excerpt":"문제  Link   코드   class Solution {    public List&lt;Integer&gt; findClosestElements(int[] arr, int k, int x) {     int left = 0;     int right = arr.length - k;     while (left &lt; right) {       int mid = left + ((right - left) / 2);       if (x - arr[mid] &gt; arr[mid + k] - x) {         left = mid + 1;       } else {         right = mid;       }     }     List&lt;Integer&gt; result = new ArrayList&lt;&gt;(k);     for (int idx = 0; idx &lt; k; idx++) {       result.add(arr[left + idx]);     }     return result;   }  }   결과  Link   설명     arr 배열의 x에 가까운 k개의 정수를 반환하는 문제이다.            아래 중 하나의 경우라도 만족하면 a는 b보다 x에 가깝다.                    |a - x| &lt; |b - x|인 경우.           |a - x| == |b - x|이고 a &lt; b인 경우.                           문제 풀이에 필요한 변수를 정의한다.            left는 배열의 좌측 탐색 위치를 저장하기 위한 변수로, 첫 위치인 0으로 초기화한다.       right는 배열의 우측 탐색 위치를 저장하기 위한 변수로, 연속된 k를 골라야하므로 arr 길이보다 k 작은 값으로 초기화한다.           left가 right보다 작을 때 까지 아래를 반복한다.            mid에 x에 가까운 위치를 추정하기 위해 $left + \\frac{right - left}{2}$를 넣어준다.       $x - arr[mid]$가 $arr[mid + k] - x$보다 큰 경우 arr[mid]가 x에 가까우므로, left에 $mid + 1$을 넣어 범위를 좁혀준다.       위의 경우가 아니면 arr[mid + k]가 x에 가깝거나 동일한 위치이므로, right에 mid를 넣어 범위를 좁혀준다.           반복이 완료되면 결과를 넣을 result를 k 크기의 ArrayList로 초기화하고, arr[left] 값부터 우측으로 k개를 result에 넣어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-k-closest-elements/",
        "teaser": null
      },{
        "title": "Leetcode Java Image Smoother",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] imageSmoother(int[][] img) {     int row = img.length;     int col = img[0].length;     int[][] result = new int[row][col];     for (int i = 0; i &lt; row; i++) {       for (int j = 0; j &lt; col; j++) {         result[i][j] = this.caculate(img, row, col, i, j);       }     }     return result;   }    private int caculate(int[][] img, int row, int col, int i, int j) {     int count = 1;     int sum = img[i][j];     if (i - 1 &gt;= 0) {       count++;       sum += img[i - 1][j];       if (j - 1 &gt;= 0) {         count++;         sum += img[i - 1][j - 1];       }       if (j + 1 &lt; col) {         count++;         sum += img[i - 1][j + 1];       }     }     if (j - 1 &gt;= 0) {       count++;       sum += img[i][j - 1];     }     if (j + 1 &lt; col) {       count++;       sum += img[i][j + 1];     }     if (i + 1 &lt; row) {       count++;       sum += img[i + 1][j];       if (j - 1 &gt;= 0) {         count++;         sum += img[i + 1][j - 1];       }       if (j + 1 &lt; col) {         count++;         sum += img[i + 1][j + 1];       }     }     return sum / count;   }  }   결과  Link   설명          img 배열 의 각 요소 별 자신을 포함한 인접한 셀 값들의 평균 값을 넣은 배열로 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            row와 col은 img의 행과 열의 개수를 넣어 보관할 변수이다.       result는 img를 이용하여 결과를 넣을 배열로, img와 동일한 크기로 초기화한다.                img의 모든 값들을 이용하여 모든 셀들의 값들에 4번에서 정의한 caculate(int[][] img, int row, int col, int i, int j) 메서드를 수행한 결과를 넣어준다.       자신을 포함한 인접한 셀들의 값의 평균을 계산하기위한 caculate(int[][] img, int row, int col, int i, int j) 메서드를 정의한다.            인접한 셀의 개수인 count를 1로, 자신을 포함한 인접한 셀들의 합을 저장할 sum을 현재 셀의 값인 img[i][j]으로 초기화한다.       해당 위치의 위, 아래, 왼쪽, 오른쪽과 대각선에 위치한 셀의 유무를 확인하여 count를 증가시키고 sum에 각 값을 더해준다.       소수점을 절사한 정수를 반환해야 하므로 $\\frac{sum}{count}$의 정수 값만 반환한다.           반복이 완료되면 결과를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/image-smoother/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Width of Binary Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public int widthOfBinaryTree(TreeNode root) {     return this.dfs(root, 0, 0, new HashMap&lt;&gt;(), 1);   }    private int dfs(TreeNode treeNode, int level, int max, Map&lt;Integer, Integer&gt; map, int id) {     if (treeNode == null) {       return 0;     } else {       map.putIfAbsent(level, id);       max = Math.max(max, id - map.get(level) + 1);       max = Math.max(max, this.dfs(treeNode.left, level + 1, max, map, 2 * id));       max = Math.max(max, this.dfs(treeNode.right, level + 1, max, map, 2 * id + 1));       return max;     }   }  }   결과  Link   설명          root의 level 별 가장 좌측에 존재하는 노드와 가장 우측에 존재하는 노드 간 길이가 가장 긴 값을 구하는 문제이다.            3번에서 정의한 dfs(TreeNode treeNode, int level, int max, Map&lt;Integer, Integer&gt; map, int id) 메서드에 treeNode엔 root, level과 max엔 0, id는 1을 넣고, map은 HashMap으로 초기화 하여 수행한 결과를 주어진 문제의 결과로 반환한다.            DFS 방식으로 root를 탐색하여 노드 간 최대 길이를 구할 dfs(TreeNode treeNode, int level, int max, Map&lt;Integer, Integer&gt; map, int id) 메서드를 정의한다.             treeNode가 null인 경우 길이 탐색이 불가능하므로, 0을 반환한다.       map의 level이 키인 값이 없을 경우, 노드 길이 계산의 시작 위치인 id를 넣는다.       max에 max와 아래의 수행 결과 중 큰 값을 넣어준다.                    현재 노드의 id 값과 해당 level의 노드 시작 id의 차이에 1을 더한 값인 현재 level 내 treeNode의 길이.           treeNode의 left TreeNode와 고유 id인 $id \\times 2$를 이용하여 재귀 호출하여 수행된 결과.           treeNode의 right TreeNode와 고유 id인 $(id \\times 2) + 1$를 재귀 호출하여 수행된 결과.                       수행이 완료되면 가장 긴 길이인 max를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-width-of-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Strange Printer",
        "excerpt":"문제  Link   코드  class Solution {    public int strangePrinter(String s) {     int length = s.length();     int[][] dp = new int[length][length];     for (int idx = 0; idx &lt; length; idx++) {       dp[idx][idx] = 1;       if (idx + 1 &lt; length) {         dp[idx][idx + 1] = s.charAt(idx) == s.charAt(idx + 1) ? 1 : 2;       }     }     for (int l = 3; l &lt;= length; l++) {       for (int i = 0; i &lt;= length - l; i++) {         int j = i + l - 1;         dp[i][j] = Integer.MAX_VALUE;         for (int k = i; k &lt; j; k++) {           dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j]);         }         if (s.charAt(i) == s.charAt(j)) {           dp[i][j]--;         }       }     }     return dp[0][length - 1];   }  }   결과  Link   설명     s의 문자열을 이용하여 아래의 조건을 만족하는 프린터의 최소 출력 횟수를 구하는 문제이다.            프린터는 매 번 동일한 문자의 시퀀스만 인쇄할 수 있다.       각 출력은 임의 위치에서 시작하고 끝나는 문자를 인쇄할 수 있으며, 기존 문자를 덮을 수 있다.           문제 풀이에 필요한 변수를 정의한다.            length는 s의 길이를 저장한 변수이다.       dp는 최소 출력 횟수를 구하기 위한 배열로, $length \\times length$ 크기로 초기화한다.                dp의 대각선 위치에 1을 넣고, 그 오른쪽 위치에 각 위치 문자가 동일한 경우 1을 아니면 2를 넣어준다.       3부터 length 이하까지 l을 증가시키고, 0부터 $length - l$ 이하까지 i를 증가시키며 아래를 수행한다.            j에 $i + l - 1$을 넣어준다.       dp[i][j]에 정수 최댓값을 넣어주고, i부터 j 미만까지 k를 증가시키며 dp[i][j]와 $dp[i][k] + dp[k + 1][j]$ 중 작은 값을 dp[i][j]에 넣어 최소 횟수를 탐색한다.       s의 i번째 문자와 j번째 문자가 동일한 경우 같은 출력 횟수에 포함 가능하므로, dp[i][j]를 감소시킨다.           반복이 완료되면 최소 횟수인 dp[0][$length - 1$]을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/strange-printer/",
        "teaser": null
      },{
        "title": "Leetcode Java Non-decreasing Array",
        "excerpt":"문제  Link   코드  class Solution {    public boolean checkPossibility(int[] nums) {     int count = 0;     for (int idx = 1; idx &lt; nums.length &amp;&amp; count &lt;= 1; idx++) {       if (nums[idx - 1] &gt; nums[idx]) {         count++;         if (idx - 2 &lt; 0 || nums[idx - 2] &lt;= nums[idx]) {           nums[idx - 1] = nums[idx];         } else {           nums[idx] = nums[idx - 1];         }       }     }     return count &lt;= 1;   }  }   결과  Link   설명     nums의 값을 최대 하나만 수정하여 감소하지 않는 배열을 만들 수 있는지 검증하는 문제이다.            0 &lt;= i &lt;= $n - 2$ 처럼 모든 i에 대해 num[i] &lt;= nums[$i + 1$]이 유지되는 경우 배열이 감소하지 않는 배열이라고 한다.                count는 수정 횟수를 계산할 변수로, 0으로 초기화한다.       1부터 nums의 길이 미만이고 count가 1 이하일 때 까지 idx를 증가시키며 아래를 반복한다.            nums의 $idx - 1$번째 값이 idx보다 큰 경우, 값을 수정해야하므로 아래를 수행한다.                    수정 횟수인 count를 증가시킨다.           $idx - 2$가 0보다 작거나 nums의 $idx - 2$번째 값이 idx번째 값과 같거나 작은 경우, nums의 $idx - 1$ 위치에 idx번째 값을 넣어준다.           위의 경우가 아니라면, nums의 idx번째 위치에 $idx - 1$번째 값을 넣어준다.                           반복이 완료되면 수정 횟수가 1 이하인지 검증한 결과를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/non-decreasing-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Beautiful Arrangement II",
        "excerpt":"문제  Link   코드  class Solution {    public int[] constructArray(int n, int k) {     int[] result = new int[n];     int left = 1;     int right = n;     for (int idx = 0; idx &lt; n; idx++) {       result[idx] = k % 2 != 0 ? left++ : right--;       if (k &gt; 1) {         k--;       }     }     return result;   }  }   결과  Link   설명     1부터 n까지 아래의 조건을 만족하는 양의 정수가 k개가 되는 조합을 배열로 만드는 문제이다.            문제의 결과인 answer = [a1, a2, a3, … , an]일 때, [|a1 - a2|, |a2 - a3|, |a3 - a4|, … , |an-1 - an|]의 결과의 중복되지 않은 양의 정수는 k개가 된다.           문제 풀이에 필요한 변수를 정의한다.            result는 1부터 n까지 숫자를 중복되지 않은 k개의 결과가 되는 순서의 조합을 저장할 배열로, n의 크기로 초기화한다.       left와 right는 해당 숫자를 순차적으로 넣기 위한 위치를 넣을 변수로, 1과 n으로 초기화한다.           0부터 n 미만까지 idx를 증가시키며 아래를 수행한다.            k가 홀수인 경우, left를 증가하여 이전 값보다 1 큰 값을 result의 idx번째 위치에 넣어준다.       k가 짝수인 경우, right를 감소하여 이전 값과 차이가 가장 큰 값을 result의 idx번째 위치에 넣어준다.       k가 1보다 큰 경우, 값의 차이가 되는 숫자를 더 만들어야 하므로 k를 감소시켜 1이 될 때 까지 반복한다.           반복이 완료되면 주어진 문제의 결과로 result를 넣어준다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/beautiful-arrangement-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Kth Smallest Number in Multiplication Table",
        "excerpt":"문제  Link   코드  class Solution {    public int findKthNumber(int m, int n, int k) {     int left = 1;     int right = m * n;     while (left &lt; right) {       int mid = (left + right) / 2;       int count = (mid / n) * n;       for (int idx = (mid / n) + 1; idx &lt;= m; idx++) {         count += mid / idx;       }       if (count &gt;= k) {         right = mid;       } else {         left = mid + 1;       }     }     return left;   }  }   결과  Link   설명     $m \\times n$ 크기의 2차원 배열에서 k번째로 작은 값을 찾는 문제이다.            mat[i][j] == $i \\times j$를 만족한다.           문제 풀이에 필요한 변수를 정의한다.            left는 배열의 최솟값인 1로 초기화한다.       right는 배열의 최댓값인 $m \\times n$으로 초기화한다.           left가 right보다 작을 때 까지 아래를 반복한다.            mid는 중간 값을 넣을 변수로, $\\frac{left + right}{2}$을 넣어준다.       count는 현재 위치에서 작은 값의 수를 계산할 변수로, $\\frac{mid}{n}$의 정수 값에 n을 곱해서 넣어준다.       $\\frac{mid}{n}$의 정수 값에 1을 더한 값부터 m 이하까지 idx를 증가시키며, count에 $\\frac{mid}{idx}$ 값을 넣어준다.       count가 k이상인 경우, right에 mid를 넣어 right보다 작은 숫자의 범위로 좁혀준다.       count가 k미만인 경우, left에 $mid + 1$을 넣어 left보다 큰 숫자의 범위로 좁혀준다.           반복이 완료되면 k번째로 작은 값인 left를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/kth-smallest-number-in-multiplication-table/",
        "teaser": null
      },{
        "title": "Leetcode Java Trim a Binary Search Tree",
        "excerpt":"문제  Link   코드  class Solution {    public TreeNode trimBST(TreeNode root, int low, int high) {     if (root == null) {       return null;     } else if (root.val &lt; low) {       return this.trimBST(root.right, low, high);     } else if (root.val &gt; high) {       return this.trimBST(root.left, low, high);     } else {       root.left = this.trimBST(root.left, low, high);       root.right = this.trimBST(root.right, low, high);       return root;     }   }  }   결과  Link   설명          root의 val 값들을 [low, high] 범위에 위치하도록 root를 수정하는 문제이다.            root가 null인 경우 수정할 항목이 없으므로, null을 반환한다.            위의 경우가 아니면서 root의 val 값이 low보다 작은 경우 해당 TreeNode를 무시하고 root의 right TreeNode를 이용하여 재귀 호출한 결과를 반환한다.            위의 경우가 아니면서 root의 val 값이 high보다 큰 경우 해당 TreeNode를 무시하고 root의 left TreeNode를 이용하여 재귀 호출한 결과를 반환한다.            위의 모든 경우가 아닌 경우 정상적인 노드이므로 아래를 수행하고 root를 반환한다.             root의 left TreeNode에 해당 TreeNode로 재귀 호출한 결과를 이어준다.       root의 right TreeNode에 해당 TreeNode로 재귀 호출한 결과를 이어준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/trim-a-binary-search-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Swap",
        "excerpt":"문제  Link   코드  class Solution {    public int maximumSwap(int num) {     char[] numCharArray = Integer.toString(num).toCharArray();     int length = numCharArray.length;     int[] nums = new int[10];     for (int idx = 0; idx &lt; length; idx++) {       nums[numCharArray[idx] - '0'] = idx;     }     for (int i = 0; i &lt; length; i++) {       for (int j = 9; j &gt; numCharArray[i] - '0'; j--) {         if (nums[j] &gt; i) {           char temp = numCharArray[i];           numCharArray[i] = numCharArray[nums[j]];           numCharArray[nums[j]] = temp;           return Integer.valueOf(new String(numCharArray));         }       }     }     return num;   }  }   결과  Link   설명          num의 모든 숫자를 이용하여 최대 한 번만 숫자를 변경하여 가장 큰 숫자를 만드는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            numCharArray는 num의 각 자리수를 순차적인 문자 배열로 전환하여 저장한 변수이다.       length는 numCharArray의 길이를 저장한 변수이다.       nums는 각 숫자의 마지막 위치를 저장할 배열로, 0 ~ 9 까지 10개이므로 해다 개수만큼의 크기로 초기화하고 numCharArray를 모두 반복하여 발생한 숫자의 마지막 위치를 넣어준다.           0부터 length까지 i를 증가시키고, 9부터 $numCharArray[i] - ‘0’$인 numCharArray의 i번째 문자를 숫자로 변환한 값 미만까지 j를 감소시키며 아래를 반복한다.            nums의 j에 해당하는 위치가 i보다 큰 경우 현재 자리보다 큰 값이 존재하므로, numCharArray의 i번째 값과 nums[j]번째 값의 위치를 변경해주고 주어진 문제의 결과로 반환한다.           반복이 완료되면 현재 숫자가 가장 큰 숫자이므로, num을 그대로 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-swap/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Swap",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public int findSecondMinimumValue(TreeNode root) {     return this.dfs(root, root.val);   }    private int dfs(TreeNode root, int min) {     if (root == null) {       return -1;     } else if (root.val &gt; min) {       return root.val;     } else {       int left = this.dfs(root.left, min);       int right = this.dfs(root.right, min);       return left == -1 || right == -1 ? Math.max(left, right) : Math.min(left, right);     }   }  }   결과  Link   설명     root의 모든 TreeNode의 두 번째로 작은 값을 찾는 문제이다.            단, 두 번째로 작은 값이 없으면 -1을 반환한다.                3번에서 정의한 dfs(TreeNode root, int min) 메서드에 root와 root의 val 값을 이용하여 탐색된 값을 주어진 문제의 결과로 반환한다.       두 번째로 작은 값을 찾기 위한 dfs(TreeNode root, int min) 메서드를 정의한다.            root가 null인 경우 탐색이 불가능하므로, -1을 반환한다.       위의 경우가 아니면서 root의 val 값이 min보다 큰 경우 최소 값보다 크므로, root의 val 값을 반환한다.       위의 경우들이 아니면 아래를 수행한다.                    left에 root의 left TreeNode와 min을 이용하여 재귀 호출을 수행한 결과를 넣어준다.           right에 root의 right TreeNode와 min을 이용하여 재귀 호출을 수행한 결과를 넣어준다.           left가 -1이거나 right가 -1인 경우 두 노드 중 존재하지 않는 노드가 있으므로, left와 right 중 큰 값을, 아니면 left와 right 중 작은 값을 반환한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/second-minimum-node-in-a-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Longest Increasing Subsequence",
        "excerpt":"문제  Link   코드  class Solution {    public int findNumberOfLIS(int[] nums) {     int length = nums.length;     int result = 0;     int max = 0;     int[] dp = new int[length];     int[] count = new int[length];     for (int i = 0; i &lt; length; i++) {       dp[i] = count[i] = 1;       for (int j = 0; j &lt; i; j++) {         if (nums[i] &gt; nums[j]) {           if (dp[i] == dp[j] + 1) {             count[i] += count[j];           } else if (dp[i] &lt; dp[j] + 1) {             dp[i] = dp[j] + 1;             count[i] = count[j];           }         }       }       if (max == dp[i]) {         result += count[i];       } else if (max &lt; dp[i]) {         max = dp[i];         result = count[i];       }     }     return result;   }  }   결과  Link   설명     nums를 이용하여 가장 긴 부분 배열의 수를 구하는 문제이다.            단, 위의 부분 배열은 연속된 요소가 점층적으로 증가하여야 한다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       result는 가장 긴 배열의 개수를 계산하기 위한 변수로, 0으로 초기화한다.       max는 가장 긴 배열의 길이를 저장하기 위한 변수로, 0으로 초기화한다.       dp는 nums의 각 위치 값으로 끝나는 가장 긴 부분 배열의 길이를 저장할 배열로, length 크기로 초기화한다.       count는 nums의 각 위치 값으로 끝나는 가장 긴 부분 배열의 수를 저장할 배열로, length 크기로 초기화한다.           0부터 length 미만까지 i를 증가시키며 아래를 수행한다.            dp와 count의 i번째 위치를 1로 초기화한다.       0부터 i 미만까지 j를 증가시키며, nums[i]가 nums[j]보다 크면 부분 배열에 포함 가능하므로 아래를 수행한다.                    dp[i]의 값과 $dp[j] + 1$이 같은 경우 dp[j]에 해당하는 부분 배열들에 nums[i]만 마지막 값에 추가하면 전체 부분 배열에 포함되므로, count[i]의 값에 count[j]의 값을 더해준다.           dp[i]의 값이 $dp[j] + 1$보다 작은 경우 이전 값보다 긴 부분 배열이 발견되었으므로, dp[i]에 $dp[j] + 1$을 넣어주고 count[i]에 count[j]를 넣어준다.                       max와 dp[i]가 동일한 경우, result에 count[i]를 넣어 가장 긴 부분 배열의 수를 더해준다.       max가 dp[i]보다 작은 경우, max에 dp[i]를 넣고 result에 count[i]를 넣어 최대 길이와 해당 길이의 부분 배열 수를 현재 값으로 초기화한다.           반복이 완료되면 조건을 충족하는 가장 긴 부분 배열의 수를 계산한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-longest-increasing-subsequence/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Continuous Increasing Subsequence",
        "excerpt":"문제  Link   코드  class Solution {    public int findLengthOfLCIS(int[] nums) {     int result = 0;     int count = 1;     for (int idx = 1; idx &lt; nums.length; idx++) {       if (nums[idx - 1] &lt; nums[idx]) {         count++;       } else {         result = Math.max(result, count);         count = 1;       }     }     return Math.max(result, count);   }   }   결과  Link   설명          nums를 이용하여 점층적으로 증가하는 가장 긴 부분 배열의 길이를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 점층적으로 증가하는 가장 긴 부분 배열의 길이를 저장할 변수로, 0으로 초기화한다.       count는 점층적으로 증가하는 숫자의 수를 계산할 변수로, 첫 값을 포함하여 1로 초기화한다.           1부터 nums의 길이 미만까지 idx를 증가시키며 아래를 수행한다.            nums의 $idx - 1$번째 값이 idx번째 값보다 작은 경우 값이 증가하므로, count를 증가시킨다.       위의 경우가 아닌 경우 그 전까지가 증가하는 부분 배열이므로, result에 result와 count 중 큰 값을 넣어주고 count를 1로 초기화한다.           반복이 완료되면 result와 마지막으로 계산된 부분 배열의 길이인 count중 큰 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-continuous-increasing-subsequence/",
        "teaser": null
      },{
        "title": "Leetcode Java Cut Off Trees for Golf Event",
        "excerpt":"문제  Link   코드  class Solution {    private static final int[][] DIRECTIONS = {     { 0, 1 },     { 1, 0 },     { 0, -1 },     { -1, 0 }   };      public int cutOffTree(List&lt;List&lt;Integer&gt;&gt; forest) {     int row = forest.size();     int col = forest.get(0).size();     List&lt;int[]&gt; trees = new ArrayList&lt;&gt;();     for (int i = 0; i &lt; row; i++) {       for (int j = 0; j &lt; col; j++) {         if (forest.get(i).get(j) &gt; 1) {           trees.add(new int[] { i, j, forest.get(i).get(j) });         }       }     }     Collections.sort(trees, (tree1, tree2) -&gt; tree1[2] - tree2[2]);     int result = 0;     int x = 0;     int y = 0;     for (int[] tree : trees) {       int steps = this.bfs(forest, row, col, x, y, tree);       if (steps &lt; 0) {         return -1;       }       result += steps;       x = tree[0];       y = tree[1];     }     return result;   }    private int bfs(List&lt;List&lt;Integer&gt;&gt; forest, int row, int col, int x, int y, int[] tree) {     Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();     queue.add(new int[] { x, y });     boolean[][] visited = new boolean[row][col];     visited[x][y] = true;     int steps = 0;     while (!queue.isEmpty()) {       int size = queue.size();       while (size-- &gt; 0) {         int[] curr = queue.poll();         if (curr[0] == tree[0] &amp;&amp; curr[1] == tree[1]) {           return steps;         }         for (int[] direction : DIRECTIONS) {           x = direction[0] + curr[0];           y = direction[1] + curr[1];           if (x &lt; 0 || y &lt; 0 || x &gt;= row || y &gt;= col || visited[x][y] || forest.get(x).get(y) == 0) {             continue;           }           visited[x][y] = true;           queue.add(new int[] { x, y });         }       }       steps++;     }     return -1;   }  }   결과  Link   설명     2차원 숲의 지도를 나타내는 forest를 이용하여 아래의 규칙대로 모든 나무를 자를 수 있는 최소 단계를 구하는 문제이다.            forest의 값은 각각 아래의 의미를 가진다.                    0은 통과할 수 없는 길을 나타낸다.           1은 걸어서 통과할 수 있는 길을 나타낸다.           1보다 큰 값은 나무의 높이를 나타낸다.                       첫 위치인 (0, 0)에서 동서남북 모든 방향으로 이동이 가능하며, 나무를 마주치면 자를 수 있다.       나무를 자르는 순서는 낮은 순에서 높은 순으로 잘라야 하며, 자른 나무의 위치 값은 길(forest의 값인 1)이 된다.       모든 나무를 자를 수 없으면 -1을 반환한다.       동일한 높이의 나무는 없으며, 최소한 하나 이상의 나무를 자를 수 있는 입력 값(forest)이 주어진다.                한 위치에서 동서남북 모든 방향을 구할 수 있는 전역 변수인 DIRECTIONS를 정의하고, 현재 위치 기준으로 위, 왼쪽, 아래, 오른쪽의 위치를 임의 순서로 넣어준다.       문제 풀이에 필요한 변수를 정의한다.            row와 col은 forest의 행과 열의 길이를 저장한 변수이다.       trees는 나무 위치를 새로 저장할 변수로, ArrayList로 초기화하고 forest 내 값이 0이 아닌 모든 나무의 정보를 [행 위치, 열 위치, 높이] 형태의 배열로 넣어준다.                trees의 모든 값들을 높이 기준으로 오름차순 정렬한다.            모든 나무를 자르기 위한 최소 이동 횟수인 result와 행과 열 위치를 임시 저장할 x와 y 모두 0으로 초기화한다.       trees의 모든 tree를 이용하여 아래를 반복한다.            steps에 7번에서 정의한 bfs(List&lt;List&gt; forest, int row, int col, int x, int y, int[] tree)를 이용하여 최소 이동 횟수를 구해준다.       steps가 0 미만인 경우 나무를 자르기 위해 이동할 수 없으므로, -1을 주어진 문제의 결과로 반환한다.       위의 경우가 아니라면 result에 steps를 더해주고, x와 y에 tree의 첫 번째와 두 번째인 행과 열의 위치를 넣어주고 반복을 계속 수행한다.           x와 y의 위치에서 다음으로 잘라야 하는 나무의 위치인 tree까지 최소 이동 횟수를 계산하기 위한 bfs(List&lt;List&gt; forest, int row, int col, int x, int y, int[] tree) 메서드를 정의한다.            메서드를 수행하기 위한 변수를 정의한다.                    queue는 자를 수 있는 나무를 임시 저장하기 위한 변수로, LinkedList로 초기화하고 현재 위치인 x와 y를 배열로 넣어준다.           visited는 이동 위치를 저장하기 위한 배열로, $row \\times col$ 크기의 2차원 배열로 정의하고 초기 위치인 visited[x][y]를 true로 초기화한다.           steps는 tree까지 이동하기 위한 이동 거리를 저장할 변수로, 0으로 초기화한다.                       queue가 비어있지 않을 때 까지 반복하고, size에 queue의 크기를 넣은 후 size가 0이 될 때 까지 아래를 반복한다.                    curr에 queue에서 꺼낸 나무의 위치를 넣어준다.           만일 tree의 위치와 curr이 동일한 경우, [x, y]에서 출발하여 tree에 도착하기위한 최소 이동 거리인 steps를 반환한다.           위의 경우가 아니라면 DIRECTIONS를 반복하여 [x, y] 위치의 동서남북 위치의 나무가 존재하면 x축과 y축을 배열로 생성하여 queue 넣어주고 visited의 각 위치를 true로 변경해준다.                       위의 반복이 완료되면 steps를 증가시키고, 다시 queue가 비어있지 않을 때 까지 반복을 수행한다.       queue가 빌때 까지 반복이 완료되면 tree에 도달하지 못하였으므로, -1을 반환한다.           6번의 반복이 완료되면 최소 이동 거리를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/cut-off-trees-for-golf-event/",
        "teaser": null
      },{
        "title": "Leetcode Java Implement Magic Dictionary",
        "excerpt":"문제  Link   코드  class MagicDictionary {    private Map&lt;Integer, List&lt;String&gt;&gt; map;    public MagicDictionary() {     this.map = new HashMap&lt;&gt;();   }    public void buildDict(String[] dictionary) {     for (String word : dictionary) {       List&lt;String&gt; words = this.map.get(word.length());       if (words == null) {         words = new ArrayList&lt;&gt;();         this.map.put(word.length(), words);       }       words.add(word);     }   }    public boolean search(String searchWord) {     List&lt;String&gt; words = this.map.get(searchWord.length());     if (words != null) {       for (String word : words) {         int count = 0;         for (int idx = 0; idx &lt; word.length(); idx++) {           if (word.charAt(idx) != searchWord.charAt(idx)) {             count++;             if (count &gt; 1) {               break;             }           }         }         if (count == 1) {           return true;         }       }     }     return false;   }  }  /**  * Your MagicDictionary object will be instantiated and called as such:  * MagicDictionary obj = new MagicDictionary();  * obj.buildDict(dictionary);  * boolean param_2 = obj.search(searchWord);  */   결과  Link   설명     문자열을 입력받아 데이터 구조 내 단어에서 검색 단어의 한 문자만 수정해서 구성할 수 있는지 검색하는 기능을 수행하는 MagicDictionary 클래스를 완성하는 문제이다.            생성자인 MagicDictionary()는 객체를 초기화한다.       메서드인 buildDict(String[] dictionary)은 데이터 구조 내 dictionary를 넣어주는 역할을 수행한다.       메서드인 search(String searchWord)는 데이터 구조 내 문자들 중 searchWord의 한 문자만 변경한 값과 동일한지 검증한 결과를 반환하는 역할을 수행한다.           문제 풀이에 필요한 전역 변수를 정의한다.            map은 문자열의 길이 별 문자들을 저장할 변수이다.           생성자인 MagicDictionary()를 정의한다.            map을 HashMap으로 초기화 한다.           메서드인 buildDict(String[] dictionary)을 정의한다.            dictionary의 모든 단어를 word에 순차적으로 넣어 아래를 반복한다.                    words에 map 내 word의 길이가 키인 값을 가져온다.           words가 없는 경우, words를 새 ArrayList로 초기화하고 map에 words 길이의 값에 words를 넣어준다.           words에 word를 넣고 반복을 계속 수행한다.                           메서드인 search(String searchWord)를 정의한다.            words에 map 내 searchWord의 길이가 키인 값을 가져온다.       words가 null이 아니면 words의 모든 단어를 word에 순차적으로 넣어 아래를 반복한다.                    count는 변경된 문자의 개수를 넣을 변수로, 0으로 초기화한다.           word와 searchWord를 비교하여 변경할 단어인 count가 1인 경우, true를 반환한다.                       반복이 완료되면 한 문자만 변경해서 동일하게 구성할 단어를 찾지 못했으므로, false를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/implement-magic-dictionary/",
        "teaser": null
      },{
        "title": "Leetcode Java Map Sum Pairs",
        "excerpt":"문제  Link   코드  class MapSum {    private Map&lt;String, Integer&gt; map;   private TrieNode root;    public MapSum() {     this.map = new HashMap&lt;&gt;();     this.root = new TrieNode();   }    public void insert(String key, int val) {     int diff = val - this.map.getOrDefault(key, 0);     TrieNode curr = this.root;     for (char c : key.toCharArray()) {       int num = c - 'a';       if (curr.children[num] == null) {         curr.children[num] = new TrieNode();       }       curr = curr.children[num];       curr.sum += diff;     }     this.map.put(key, val);   }    public int sum(String prefix) {     TrieNode curr = this.root;     for (char c : prefix.toCharArray()) {       int num = c - 'a';       if (curr.children[num] == null) {         return 0;       }       curr = curr.children[num];     }     return curr.sum;   }  }  class TrieNode {    public int sum;   public TrieNode[] children;    public TrieNode() {     this.sum = 0;     this.children = new TrieNode[26];   }  }  /**  * Your MapSum object will be instantiated and called as such:  * MapSum obj = new MapSum();  * obj.insert(key,val);  * int param_2 = obj.sum(prefix);  */   결과  Link   설명     문자들을 입력받고, 임의 문자열이 주어지면 해당 문자열이 접두사인 문자들의 값을 모두 합한 값을 반환하는 객체를 만드는 문제이다.            생성자인 MapSum()는 객체를 초기화한다.       메서드인 insert(String key, int val)는 객체 내 key 값과 val 값을 저장한다. 단, 동일한 key가 주어지면 새로 주입된 val 값으로 덮어쓴다.       메서드인 sum(string prefix)은 prefix로 시작되는 key들을 찾아 val 값들을 더해 반환한다.           문제 풀이에 필요한 TrieNode 클래스를 정의한다.            sum은 해당 단어까지의 문자열이 접두사인 val 값의 합을 저장할 변수이다.       children은 해당 단어까지의 문자열 이후의 문자열을 이어주기 위한 변수로, 객체 생성 시 다음 문자를 저장하기 위해 알파벳의 개수인 26 크기의 TrieNode 배열로 초기화 한다.           문제 풀이에 필요한 변수를 정의한다.            map은 insert(String key, int val)로 주입된 key와 val을 저장할 변수이다.       root는 Trie의 가장 최상위 노드를 저장하기 위한 변수이다.           생성자인 MapSum()를 정의한다.            map을 HashMap으로, root를 TrieNode로 초기화한다.           메서드인 insert(String key, int val)를 정의한다.            diff에 val 값과 map에서 key에 해당하는 값 혹은 값이 없으면 0을 뺀 값을 넣어준다.       현재 TrieNode를 의미하는 curr에 root를 넣어준다.       key를 문자 배열로 변환하여 c에 각각 넣어 아래를 반복한다.                    num에 문자 c의 알파벳 순서인 0(a) ~ 25(z)를 계산하여 넣어준다.           curr 내 children의 num번째 값이 null이면 새 TrieNode를 넣어 초기화해준다.           curr에 curr의 children의 num번째 TrieNode를 넣어 다음 문자로 이동한다.           curr의 sum에 diff를 더해 해당 문자열이 접두사인 값의 합을 증가시킨다.                       반복이 완료되면 map의 key에 해당하는 값에 val을 넣어 저장한다.           메서드인 sum(string prefix)을 정의한다.            현재 TrieNode를 의미하는 curr에 root를 넣어준다.       key를 문자 배열로 변환하여 c에 각각 넣어 아래를 반복한다.                    num에 문자 c의 알파벳 순서인 0(a) ~ 25(z)를 계산하여 넣어준다.           curr 내 children의 num번째 값이 null이면 해당 prefix에 해당하는 문자열이 없으므로, 0을 반환한다.           curr에 curr의 children의 num번째 TrieNode를 넣어 다음 문자로 이동한다.                       반복이 완료되면 접두사 위치의 문자들 값의 합인 curr의 sum을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/map-sum-pairs/",
        "teaser": null
      },{
        "title": "Leetcode Java Valid Parenthesis String",
        "excerpt":"문제  Link   코드  class Solution {    public boolean checkValidString(String s) {     int min = 0;     int max = 0;     for (char c : s.toCharArray()) {       switch (c) {         case '(':           max++;           min++;           break;         case ')':           max--;           min--;           break;         case '*':           max++;           min--;           break;       }       if (max &lt; 0) {         return false;       }       min = Math.max(min, 0);     }     return min == 0;   }  }   결과  Link   설명     s는 ‘(‘, ‘)’, ‘*’ 문자들만 포함된 문자열로, 아래의 조건을 만족하는지 검증하는 문제이다.            왼쪽에 ‘(‘ 문자가 존재하는 경우, 오른쪽에 ‘)’ 문자가 존재하여 쌍을 반드시 이루어야 한다.       ’(‘ 문자는 ‘)’ 문자 앞에 와야 한다.       ‘*’ 문자는 ‘(‘ 문자 혹은 ‘)’ 문자, 빈 문자인 ‘’ 문자로 취급이 가능하다.           문제 풀이에 필요한 변수를 정의한다.            min은 규칙을 만족하기 위한 ‘(‘문자와 ‘)’문자의 최소 차잇값을 저장할 변수로, 0으로 초기화한다.       max는 위와 동일하지만 최대 차잇값을 저장할 변수로, 0으로 초기화한다.           s의 모든 문자를 c에 넣어 아래를 순서대로 반복한다.            c가 ‘(‘ 문자의 경우 열린 괄호가 생겼으므로, max와 min을 증가시킨다.       c가 ‘)’ 문자의 경우 딛힌 괄호가 생겼으므로, max와 min을 감소시킨다.       c가 ‘*’ 문자의 경우 아무 문자의 처리가 가능하므로, max를 증가시키고 min을 감소시킨다.                    ’(‘인 경우 max는 증가 가능하며, ‘)’인 경우 min은 감소가 가능하기 떄문이다.                       max가 0보다 작게되면 조건을 충족하는 경우의 수가 없으므로, false를 주어진 문제의 결과로 반환한다.       max가 0보다 크면서 min이 음수가 되는 경우는 가능한 경우가 존재한다는 의미이므로, min에 min과 0 중 큰 값을 반환한다.           반복이 완료되면 min이 0인지를 검증하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/valid-parenthesis-string/",
        "teaser": null
      },{
        "title": "Leetcode Java 24 Game",
        "excerpt":"문제  Link   코드  class Solution {    public boolean judgePoint24(int[] cards) {     return this.dfs(new double[] { cards[0], cards[1], cards[2], cards[3] });   }    private boolean dfs(double[] cards) {     int length = cards.length;     if (length == 1) {       return Math.abs(cards[0] - 24) &lt; 0.001;     }     for (int i = 0; i &lt; length; i++) {       for (int j = i + 1; j &lt; length; j++) {         double[] temp = new double[length - 1];         for (int k = 0, index = 0; k &lt; length; k++) {           if (k != i &amp;&amp; k != j) {             temp[index++] = cards[k];           }         }         for (double d : this.compute(cards[i], cards[j])) {           temp[temp.length - 1] = d;           if (this.dfs(temp)) {             return true;           }         }       }     }     return false;   }    private double[] compute(double a, double b) {     return new double[] { a + b, a - b, b - a, a * b, a / b, b / a };   }  }   결과  Link   설명          4개의 정수가 들어 있는 cards를 이용하여 ‘+’, ‘-‘, ‘*’, ‘/’ 연산자와 소괄호 ‘(‘, ‘)’ 문자를 이용하여 24를 만드는 문제이다.            cards를 실수 배열로 변환하여 3번에서 정의한 dfs(double[] cards) 메서드를 수행한 결과를 주어진 문제의 결과로 반환한다.       DFS 방식으로 cards를 이용하여 24를 만들 수 있는지 여부를 검증하기 위한 dfs(double[] cards) 메서드를 정의한다.            length에 cards의 길이를 저장한다.       length가 1인 경우, $cards[0] - 24$가 0이 아닌 작은 수인 0.001보다 작은지 여부를 반환한다.       0부터 length 미만까지 i를 증가하고, $i + 1$부터 length 미만까지 j를 증가시키며 아래를 수행한다.                    temp는 임시 검증 값을 담을 배열로, $length - 1$ 크기의 실수 배열로 초기화한다.           index를 0으로 정의하고, 0부터 length 미만까지 k를 증가시키며 k가 i나 j가 아닌 값일 경우, temp[index]에 cards[k]를 계속 넣어준다.           4번에서 정의한 compute(double a, double b) 메서드의 수행 결과를 이용한 결과를 각각 d에 넣어 반복하여, temp의 마지막 위치에 d를 넣고 temp로 재귀 호출을 수행한 결과가 true인 경우 true를 반환한다.                       반복이 완료되면 24를 만들 수 없으므로, false를 반환한다.           a와 b를 이용하여 각 연산의 결과를 넣을 compute(double a, double b) 메서드를 정의한다.            a와 b를 ‘+’, ‘-‘, ‘*’, ‘/’ 연산자에 대입하여 나오는 모든 경우의 수를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/24-game/",
        "teaser": null
      },{
        "title": "Leetcode Java Valid Palindrome II",
        "excerpt":"문제  Link   코드  class Solution {    public boolean validPalindrome(String s) {     char[] charArray = s.toCharArray();     int length = s.length();     int index = this.isPalindrome(charArray, 0, length - 1);     if (index == -1) {       return true;     } else {       return this.isPalindrome(charArray, index + 1, length - index - 1) == -1           || this.isPalindrome(charArray, index, length - index - 2) == -1;     }   }    private int isPalindrome(char[] charArray, int left, int right) {     while (left &lt; right) {       if (charArray[left] != charArray[right]) {         return left;       }       left++;       right--;     }     return -1;   }  }   결과  Link   설명          문자열 s에서 최대 하나의 문자를 제거하여 앞뒤로 같은 문자열(이하 회문)이 되는지 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            charArray는 s를 문자 배열로 변환해서 저장한 변수이다.       length는 s의 길이를 저장한 변수이다.       index는 3번을 통해 s의 처음부터 끝까지 회문이 되는 지점을 검증한 값을 탐색하여 넣어준다.           회문이 되는 지점을 탐색하기 위한 isPalindrome(char[] charArray, int left, int right) 메서드를 정의한다.            left가 right보다 작을 때 까지 아래를 반복한다.                    charArray의 left번째 문자와 right번째 문자가 다른 경우 회문이 틀어지는 위치이므로, left를 반환한다.           위의 경우가 아니라면 left를 증가시키고 right를 감소시켜 검증 범위를 좁혀주고 반복을 계속 수행한다.                       반복이 완료되면 정상적으로 회문이 되는 경우이므로, -1을 반환한다.                index가 -1인 경우 s가 정상적으로 회문이 되므로, true를 주어진 문제의 결과로 반환한다.       index가 -1보다 큰 경우 아래의 경우대로 index번쨰 문자나 마지막 문자를 제거하고 검증하여 하나라도 만족하면 true를, 둘 다 만족하지 않으면 false를 주어진 문제의 결과로 반환한다.            index의 문자를 제외하는 $index + 1$ 부터 $length - index - 1$ 까지 isPalindrome(char[] charArray, int left, int right) 메서드를 수행한 값이 -1인지 검증한 결과.       마지막 문자를 제외하는 index 부터 $length - index - 2$ 까지 isPalindrome(char[] charArray, int left, int right) 메서드를 수행한 값이 -1인지 검증한 결과.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/valid-palindrome-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Baseball Game",
        "excerpt":"문제  Link   코드  class Solution {    public int calPoints(String[] operations) {     Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();     int sum = 0;     for (String operation : operations) {       int num;       switch (operation) {         case \"+\":           num = stack.pop();           int add = num + stack.peek();           sum += add;           stack.push(num);           stack.push(add);           break;         case \"D\":           num = stack.peek() * 2;           sum += num;           stack.push(num);           break;         case \"C\":           sum -= stack.pop();           break;         default:           num = Integer.parseInt(operation);           sum += num;           stack.push(num);       }     }     return sum;   }  }   결과  Link   설명     operations의 모든 값들을 순차적으로 아래의 문자에 해당하는 규칙으로 점수를 계산하여 반환하는 문제이다.            정수인 경우, 해당 값으로 점수를 기록한다.       ”+” 문자인 경우, 이전 두 정수인 점수들의 합으로 점수를 기록한다.       “D” 문자인 경우, 이전 정수인 점수의 두 배로 점수를 기록한다.       “C” 문자인 경우, 이전 정수인 점수를 무효 처리하여 제거한다.           문제 풀이에 필요한 변수를 정의한다.            stack은 기록된 점수를 순차적으로 넣고 꺼내 계산하기 위한 변수로, Stack으로 초기화한다.       sum은 계산된 최종 점수를 저장할 변수로, 0으로 초기화한다.           oprations의 모든 문자열을 operation로 아래를 반복한다.            num은 stack에서 꺼내 임시 보관할 변수이다.       operation이 “+” 문자인 경우 아래를 수행한다.                    num에 stack에서 값을 꺼내 넣어주고, add에 num과 stack의 다음 값을 더해준다.           sum에 add를 더해 두 점수의 합을 더해준다.           stack에 num과 add를 순서대로 다시 넣어 다음 계산에 포함되도록 한다.                       operation이 “D” 문자인 경우 아래를 수행한다.                    num에 stack의 이전 값의 두 배를 넣어준다.           sum에 num을 더해주고, stack에 현재 점수인 num을 넣어준다.                       operation이 “C” 문자인 경우 아래를 수행한다.                    sum에 stack의 값을 꺼내 빼준다.                       위의 문자들이 아닌 경우 숫자이므로 아래를 수행한다.                    num에 operation을 숫자로 변환해 넣어준다.           sum에 num을 더하고, stack에 num을 넣어준다.                           반복이 완료되면 계산된 총점인 sum을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/baseball-game/",
        "teaser": null
      },{
        "title": "Leetcode Java Redundant Connection",
        "excerpt":"문제  Link   코드  class Solution {    public int[] findRedundantConnection(int[][] edges) {     int[] parents = new int[edges.length + 1];     for (int[] edge : edges) {       int a = this.find(parents, edge[0]);       int b = this.find(parents, edge[1]);       if (a == b) {         return edge;       } else {         parents[a] = b;       }     }     return new int[] {};   }    private int find(int[] parents, int index) {     return parents[index] == 0 ? index : this.find(parents, parents[index]);   }  }   결과  Link   설명     트리 형태로 구성된 edges가 주어지면 n개의 노드로 구성된 트리가 되도록 제거할 배열을 찾는 문제이다.            edges[i] = [ai, bi] 는 그래프에서 노드 ai와 bi 사이에 edge가 있음을 나타낸다.       제거할 edges 내 배열이 여러 개일 경우, 마지막 하나를 반환한다.                parents는 edges내 값들을 저장할 배열로, 최댓값으로 가능한 $edges.length + 1$ 크기의 정수 배열로 초기화한다.       edges의 모든 배열들을 순차적으로 각자 edge로 정의하여 아래를 반복한다.            a에 4번에서 정의한 find(int[] parents, int index) 메서드를 이용하여 parents 배열에서 edge[0] 값에 해당하는 부모 노드의 값을 넣어준다.       a에 4번에서 정의한 find(int[] parents, int index) 메서드를 이용하여 parents 배열에서 edge[1] 값에 해당하는 부모 노드의 값을 넣어준다.       a와 b가 동일한 경우 동일한 부모 노드를 가지고 있으므로 제거해야 할 edge이므로, edge를 주어진 문제의 결과로 반환한다.       a와 b가 동일하지 않은 경우, parents의 a번째 위치에 b를 넣어 부모 노드의 값을 저장하고 반복을 계속 수행한다.           부모 노드의 값을 탐색하기 위한 find(int[] parents, int index) 메서드를 정의한다.            parents의 index번째 값이 0이면 부모가 존재하지 않으므로, index를 반환한다.       위의 경우가 아니라면 index의 부모 노드 값으로 재귀 호출하여 더 상위 부모 노드의 값을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/redundant-connection/",
        "teaser": null
      },{
        "title": "Leetcode Java Repeated String Match",
        "excerpt":"문제  Link   코드  class Solution {    public int repeatedStringMatch(String a, String b) {     StringBuilder sb = new StringBuilder(a);     int count = 1;     while (sb.indexOf(b) == -1) {       if (sb.length() - a.length() &gt; b.length()) {         return -1;       }       sb.append(a);       count++;     }     return count;   }  }   결과  Link   설명     b가 존재하기 위한 a의 반복 횟수를 구하는 문제이다.            “abc”를 0번 반복된 문자열은 ““이며, 1번 반복된 문자열은 “abc”, 2번 반복된 문자열은 “abcabc”이다.           문제 풀이에 필요한 변수를 정의한다.            sb는 동적으로 문자열을 이어줄 변수로, a를 넣어 초기화한다.       count는 반복 횟수를 저장할 변수로, 1로 초기화한다.           sb에서 b가 존재하지 않을 때 까지 아래를 반복한다.            sb의 길이에서 a의 길이를 뺀 값이 b의 길이보다 큰 경우 이미 존재하지 않는 결과이므로, -1을 주어진 문제의 결과로 반환한다.       위의 경우가 아니라면 sb에 a 문자열을 이어주고, count를 증가시킨다.           반복이 완료되면 반복 횟수인 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/repeated-string-match/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Univalue Path",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    private int length;    public int longestUnivaluePath(TreeNode root) {     if (root == null) {       return 0;     } else {       this.length = 0;       this.getLength(root, root.val);       return this.length;     }   }    private int getLength(TreeNode node, int val) {     if (node == null) {       return 0;     }     int left = this.getLength(node.left, node.val);     int right = this.getLength(node.right, node.val);     this.length = Math.max(this.length, left + right);     if (val == node.val) {       return Math.max(left, right) + 1;     } else {       return 0;     }   }  }   결과  Link   설명          root 내 동일한 값을 가지는 노드들의 연결 선의 수가 가장 긴 값을 찾는 문제이다.            length는 root 내 동일한 값을 가지는 노드들의 연결 선의 수가 가장 긴 값을 저장할 변수이다.            root가 null인 경우 계산이 불가능하므로, 0을 주어진 문제의 결과로 반환한다.            root가 null이 아니면, length를 0으로 초기화하고 5번에서 정의한 getLength(TreeNode node, int val)를 이용하여 length에 가장 긴 연결 선의 수를 계산해 넣어준 후 length를 주어진 문제의 결과로 반환한다.            root를 이용하여 length에 가장 긴 연결 선의 수를 넣어줄 getLength(TreeNode node, int val) 메서드를 정의한다.             node가 null인 경우, 연결 선의 수가 없으므로 0을 반환한다.       left에 node의 left TreeNode와 node의 val 값을 이용해서 재귀 호출한 결과를 넣어준다.       right에 node의 right TreeNode와 node의 val 값을 이용해서 재귀 호출한 결과를 넣어준다.       length에 length와 $left + right$ 중 큰 값인 긴 연결 선의 수를 넣어준다.       val이 node의 val 값과 동일한 경우, left와 right 중 큰 값에 호출된 위치의 노드를 포함한 1을 더해 반환한다.       val이 node의 val 값과 동일하지 않은 경우 동일한 값을 가지는 연결된 노드가 아니므로, 0을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-univalue-path/",
        "teaser": null
      },{
        "title": "Leetcode Java Employee Importance",
        "excerpt":"문제  Link   코드  /* // Definition for Employee. class Employee {     public int id;     public int importance;     public List&lt;Integer&gt; subordinates; }; */  class Solution {    public int getImportance(List&lt;Employee&gt; employees, int id) {     Map&lt;Integer, Employee&gt; map = new HashMap&lt;&gt;();     for (Employee employee : employees) {       map.put(employee.id, employee);     }     Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();     queue.add(id);     int importance = 0;     while (!queue.isEmpty()) {       int size = queue.size();       while (size-- &gt; 0) {         Employee employee = map.get(queue.poll());         importance += employee.importance;         queue.addAll(employee.subordinates);       }     }     return importance;   }  }   결과  Link   설명          employees에서 아이디가 id에 해당하는 직원의 모든 부하 직원의 중요도 합을 반환하는 문제이다.            map은 모든 직원 정보를 저장할 변수로, HashMap으로 초기화하고 employees의 모든 객체를 id가 key인 value로 map에 넣어준다.            queue는 모든 직원의 id 값을 넣어 BFS 방식으로 탐색하기 위한 변수로, LinkedList로 초기화하고 id를 넣어준다.            아이디가 id인 직원의 모든 부하 직원의 중요도 합을 저장할 importance를 0으로 초기화한다.       queue가 비어있지 않을 때까지 아래를 반복한다.            size에 queue의 크기를 넣어준다.       size가 0 초과일 때 까지 아래를 수행하고 size를 감소시킨다.                    employee에 queue에서 꺼낸 아이디를 이용하여 map에서 꺼낸 직원 정보를 저장한다.           importance에 employee의 importance 값을 더해준다.           queue에 employee의 부하 직원 아이디 값인 subordinates를 모두 넣어주고 반복을 계속 수행한다.                           반복이 완료되면 계산된 중요도인 importance를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/employee-importance/",
        "teaser": null
      },{
        "title": "Leetcode Java Stickers to Spell Word",
        "excerpt":"문제  Link   코드  class Solution {    public int minStickers(String[] stickers, String target) {     int length = stickers.length;     int[][] dp = new int[length][26];     for (int idx = 0; idx &lt; length; idx++) {       for (char c : stickers[idx].toCharArray()) {         dp[idx][c - 'a']++;       }     }     Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();     map.put(\"\", 0);     return this.recursive(dp, target, map);   }    private int recursive(int[][] dp, String target, Map&lt;String, Integer&gt; map) {     if (map.containsKey(target)) {       return map.get(target);     }     int min = Integer.MAX_VALUE;     int length = dp.length;     int[] str = new int[26];     for (char c : target.toCharArray()) {       str[c - 'a']++;     }     for (int i = 0; i &lt; length; i++) {       if (dp[i][target.charAt(0) - 'a'] == 0) {         continue;       }       StringBuilder sb = new StringBuilder();       for (int j = 0; j &lt; 26; j++) {         if (str[j] &gt; 0) {           for (int k = 0; k &lt; Math.max(0, str[j] - dp[i][j]); k++) {             sb.append((char) (j + 'a'));           }         }       }       int temp = this.recursive(dp, sb.toString(), map);       if (temp != -1) {         min = Math.min(min, 1 + temp);       }     }     map.put(target, min == Integer.MAX_VALUE ? -1 : min);     return map.get(target);   }  }   결과  Link   설명     stickers의 문자들을 이용하여 target 문자열을 만드는데 필요한 최소 stickers의 개수를 구하는 문제이다.            stickers의 특정 문자열을 이용하여 target을 만들고 다시 정렬하여 나머지 문자를 이어 완성한다.       단, 만들 수 없을 결우 -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            length는 stickers의 길이를 저장한 변수이다.       dp는 stickers의 문자들을 저장할 변수로, length의 길이와 영문자의 개수인 $length \\times 26$ 크기로 초기화하고 stickers를 차례대로 반복하여 모든 문자들을 기록해준다.       map은 각 문자열의 만들 수 있는 stickers 내 문자열 개수를 저장할 변수로, HashMap으로 초기화하고 빈 값에 매치할 값을 0으로 넣어준다.                4번에서 정의한 recursive(int[][] dp, String target, Map&lt;String, Integer&gt; map) 메서드를 수행한 결과를 주어진 문제의 결과로 반환한다.       재귀 호출을 이용하여 순차적으로 모든 문자 조합을 만들 recursive(int[][] dp, String target, Map&lt;String, Integer&gt; map) 메서드를 정의한다.            map의 target에 해당하는 값이 존재하는 경우, 해당 값을 반환한다.       문자 조합에 필요한 변수를 정의한다.                    min은 최소 문자열 사용 횟수를 저장할 변수로, 정수의 가장 큰 값을 넣어준다.           length는 dp의 길이인 stickers의 문자열 개수를 넣어준다.           str은 target의 문자를 넣어줄 변수로, 영문자 개수은 26의 크기로 초기화 하고 각 위치에 target의 문자 개수를 기록한다.                       0부터 length 미만까지 i를 증가하며 아래를 수행한다.                    target의 첫 문자열로 시작하는 문자열이 아닌 경우, 다음 문자열로 넘어간다.           sb는 target을 만들기 위한 문자를 넣을 변수로, StringBuilder로 초기화한다.           0부터 26 미만까지 j를 증가시키며, str[j]와 dp[i][j]의 차이 만큼 sb에 j를 문자로 변환한 값을 넣어준다.           temp에 sb를 문자열로 변환한 값을 target 자리에 넣은 재귀 호출 결과를 넣어준다.           temp가 -1이 아닌 경우 target을 만들기 위한 문자가 되므로 min과 $temp + 1$ 중 작은 값을 넣어준다.                       map의 target 문자가 키인 값에 min에 값이 들어가면 min을, 아니면 -1을 넣어주고 해당 값을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/stickers-to-spell-word/",
        "teaser": null
      },{
        "title": "Leetcode Java Top K Frequent Words",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; topKFrequent(String[] words, int k) {     Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();     for (String word : words) {       map.put(word, map.getOrDefault(word, 0) + 1);     }     Queue&lt;String&gt; queue = new PriorityQueue&lt;&gt;((String str1, String str2) -&gt; {       if (map.get(str1) == map.get(str2)) {         return str1.compareTo(str2);       } else {         return map.get(str2) - map.get(str1);       }     });     queue.addAll(map.keySet());     List&lt;String&gt; result = new ArrayList&lt;&gt;();     while (k-- &gt; 0) {       if (!queue.isEmpty()) {         result.add(queue.poll());       }     }     return result;   }  }   결과  Link   설명     words 내 가장 많이 반복된 문자열 k개를 찾아 반환하는 문제이다.            반환되는 단어들은 가장 많이 반복된 문자열 순으로, 동일하게 반복된 문자열은 사전 순으로 정렬한다.                map은 문자열의 빈도를 저장할 변수로, HashMap으로 초기화하고 words를 반복하여 word 별 발생 횟수를 계산하여 넣어준다.       queue는 발생 빈도 순, 사전 순으로 정렬해서 순차적으로 정렬해서 저장할 Queue로, 아래의 규칙대로 정렬하는 PriorityQueue로 초기화한다.            str1과 str2의 발생 빈도가 같은 경우, 두 단어는 사전순으로 정렬한다.       str1과 str2의 발생 빈도가 다른 경우, 발생 빈도가 큰 순서로 정렬한다.                3번에서 정의한 queue에 map의 key들을 모두 넣어 queue에 정렬시킨다.            result는 결과를 반환할 변수로, ArrayList로 초기화한다.       k이 0 이상일 때 까지 아래를 반복하고, k를 감소시킨다.            queue가 비어있지 않으면, result에 queue의 값을 꺼내 넣어준다.           반복이 완료되면 words 내 가장 많이 반복된 문자열 k개를 넣은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/top-k-frequent-words/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Number with Alternating Bits",
        "excerpt":"문제  Link   코드  class Solution {    public boolean hasAlternatingBits(int n) {     n ^= (n &gt;&gt; 1);     return (n &amp; (n + 1)) == 0;   }   }   결과  Link   설명     양의 정수인 n이 주어지면 교대로 비트가 존재하는지 검증하는 문제이다.            단, 인접한 값들은 항상 10101과 01010과 같이 다른 값을 가져야한다.                n의 비트를 오른쪽으로 한 칸 이동하고, 앞의 값과 n과 XOR(^) 비트 연산 결과를 n에 넣어준다.       n과 $n + 1$의 AND(&amp;) 비트 연산의 결과가 0인지를 검증한 결과를 주어진 문제의 결과로 반환한다.   해설     n이 5인 경우를 예를 들어보자.            5의 비트 값은 101이므로 비트를 오른쪽으로 한 칸 이동시키면 00101이 된다.       위에서 계산한 값인 010과 n의 비트인 101을 XOR(^) 비트 연산 결과는 111으로, 앞의 값을 n에 넣어준다.       111에 1을 더하면 000이 되므로, 111과 000의 AND(&amp;) 비트 연산 결과는 000인 0이 되어 n은 서로 교차한 값으로 이어진 것이 검증되었다.           n이 11인 경우를 예를 들어보자.            11의 비트 값은 01011이므로 비트를 오른쪽 한 칸 이동시키면 00101이 된다.       위에서 계산한 값인 00101과 n의 비트인 01011을  XOR(^) 비트 연산 결과는 01110으로, 앞의 값을 n에 넣어준다.       01110에 1을 더하면 01111이 되므로, 01110과 01111의 AND(&amp;) 비트 연산 결과는 01110인 14가 되어 n은 서로 교차한 값으로 이어지지 않은 것이 검증되었다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-number-with-alternating-bits/",
        "teaser": null
      },{
        "title": "Leetcode Java Max Area of Island",
        "excerpt":"문제  Link   코드  class Solution {    public int maxAreaOfIsland(int[][] grid) {     int max = 0;     for (int i = 0; i &lt; grid.length; i++) {       for (int j = 0; j &lt; grid[0].length; j++) {         if (grid[i][j] == 1) {           max = Math.max(max, this.dfs(grid, i, j));         }       }     }     return max;   }    private int dfs(int[][] grid, int i, int j) {     if (i &lt; 0 || j &lt; 0 || i &gt;= grid.length || j &gt;= grid[0].length || grid[i][j] != 1) {       return 0;     } else {       int area = 1;       grid[i][j] = 2;       area += this.dfs(grid, i - 1, j);       area += this.dfs(grid, i + 1, j);       area += this.dfs(grid, i, j - 1);       area += this.dfs(grid, i, j + 1);       return area;     }   }  }   결과  Link   설명     grid 내 섬 중 가장 큰 섬의 면적을 구하는 문제이다.            gird[i][j]의 값이 0인 경우 해상을, 1인 경우 육지를 의미한다.                max는 가장 큰 섬의 면적을 저장할 변수로, 0으로 초기화한다.            gird의 모든 값들을 이용하여 gird[i][j]가 1인 경우, 4번에서 정의한 dfs(int[][] grid, int i, int j) 메서드를 이용하여 육지 면적을 계산 후 해당 값과 max 중 큰 값을 max에 넣어준다.       섬의 크기를 계산할 dfs(int[][] grid, int i, int j) 메서드를 정의한다.            i와 j가 grid의 범위 내에 있으면서, grid의 값이 1인 경우 아래를 수행한다.                    area에 1을 넣어주고, 현재 위치는 이미 계산에 포함되었으므로 값을 2로 변경해준다.           현재 위치의 4방면의 위치 값을 이용한 재귀 호출 결과를 area에 합해준다.           계산이 완료되면 area를 반환한다.                       위의 경우가 아니라면 0을 반환한다.           반복이 완료되면 가장 큰 섬의 면적을 저장한 max를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/max-area-of-island/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Binary Substrings",
        "excerpt":"문제  Link   코드  class Solution {    public int countBinarySubstrings(String s) {     int prev = 0;     int curr = 1;     int result = 0;     char[] charArray = s.toCharArray();     for (int idx = 1; idx &lt; s.length(); idx++) {       if (charArray[idx - 1] == charArray[idx]) {         curr++;       } else {         result += Math.min(curr, prev);         prev = curr;         curr = 1;       }     }     return result + Math.min(curr, prev);   }  }   결과  Link   설명          0과 1인 이진 값으로 구성된 s를 이용하여 0과 1의 수가 동일한 부분 문자열의 수를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            prev는 이전 이진 값의 반복 횟수를 저장하기 위한 변수로, 0으로 초기화한다.       curr은 현재 이진 값의 반복 횟수를 저장하기 위한 변수로, 첫 값을 포함하여 1로 초기화한다.       result는 0과 1의 수가 동일한 부분 문자열의 수를 계산하기 위한 변수로, 0으로 초기화한다.       charArray는 s를 문자 배열로 저장한 변수이다.           1부터 s의 길이 미만까지 idx를 증가시키며 아래를 반복한다.            charArray의 $idx - 1$번째 문자와 idx번째 문자가 동일한 경우, curr을 증가시킨다.       위의 경우가 아니라면 이진 값이 변경된 위치이므로 아래를 수행한다.                    result에 curr과 prev 중 작은 값인 0과 1이 동일하게 반복된 횟수를 넣어준다.           prev에 현재 값의 반복 횟수인 curr을 넣은 후 다음 이진 값의 반복 횟수인 curr을 1로 초기화한다.                           3번에서 계산된 result와 마지막으로 반복 횟수인 curr와 prev 중 작은 값을 더해서 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-binary-substrings/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Binary Substrings",
        "excerpt":"문제  Link   코드  class Solution {    public int findShortestSubArray(int[] nums) {     int degree = 0;     for (int num : nums) {       degree = Math.max(degree, num);     }     int[] count = new int[degree + 1];     int[] first = new int[degree + 1];     int[] last = new int[degree + 1];     int max = 1;     for (int idx = 0; idx &lt; nums.length; idx++) {       count[nums[idx]]++;       max = Math.max(max, count[nums[idx]]);       if (first[nums[idx]] == 0) {         first[nums[idx]] = idx + 1;       }       last[nums[idx]] = idx + 1;     }     int result = Integer.MAX_VALUE;     for (int idx = 0; idx &lt; count.length; idx++) {       if (count[idx] == max) {         result = Math.min(result, last[idx] - first[idx] + 1);       }     }     return result;   }  }   결과  Link   설명          nums 내 최대 반복된 숫자를 포함한 연속된 부분 배열 중 가장 작은 배열의 길이를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            degree는 nums 내 가장 큰 값을 넣기 위한 변수로, nums를 반복하여 가장 큰 값을 넣어준다.       count는 nums 내 값들의 반복 횟수를 저장하기 위한 배열로, 최대 값까지 넣기 위해 $degree + 1$ 크기로 초기화한다.       first는 nums 내 값의 시작 위치를, last는 nums 내 값의 마지막 위치를 저장하기 위한 배열로 count와 동일하게 최대 값까지 넣기 위해 $degree + 1$ 크기로 초기화한다.       max는 가장 많이 반복된 횟수를 저장할 변수로, 1로 초기화한다.           nums의 모든 값을 이용하여 아래를 반복한다.            count의 nums[idx] 번째 값을 증가시켜 발생 빈도를 저장한다.       max에는 max와 count의 nums[idx] 번째 값 중 큰 값을 넣어 최대 발생 빈도를 저장한다.       first의 nums[idx] 번째 값이 0인 경우, 처음 해당 값이 발생한 위치이므로 first의 nums[idx] 번째 위치에 $idx + 1$을 넣어준다.       first의 nums[idx] 번째 값에 $idx + 1$을 넣어 마지막으로 발생한 위치를 기록한다.           최소 길이를 저장할 result에 정수의 가장 큰 값을 넣어 초기화하고, count를 처음부터 반복하여 아래를 수행하여 result에 가장 작은 부분 배열의 길이를 저장한다.            count[idx]가 최대 발생 횟수와 동일하면 result에 자기 자신과 마지막 발생 위치와 첫 발생 위치를 이용하여 길이를 계산해 넣어준다.           모든 수행이 완료되면 가장 작은 부분 배열의 길이를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/degree-of-an-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Search in a Binary Search Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public TreeNode searchBST(TreeNode root, int val) {     while (root != null &amp;&amp; root.val != val) {       root = val &lt; root.val ? root.left : root.right;     }     return root;   }  }   결과  Link   설명          이진 탐색 트리인 root 내 val 값인 노드를 찾는 문제이다.       root가 null이 아니면서 root의 val 값이 val과 다른 경우, 계속 반복하여 아래의 경우에 따라 탐색을 수행한다.            val의 값이 root의 val 값보다 작은 경우, val 값이 root의 left TreeNode의 val 값에 가까우므로 root에 left TreeNode를 넣어준다.       위의 경우가 아닌 경우, val 값이 root의 right TreeNode의 val 값에 가까우므로 root에 right TreeNode를 넣어준다.           반복이 완료되면 탐색된 노드인 root를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/search-in-a-binary-search-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Insert into a Binary Search Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public TreeNode insertIntoBST(TreeNode root, int val) {     if (root == null) {       return new TreeNode(val);     } else if (root.val &gt; val) {       root.left = this.insertIntoBST(root.left, val);     } else {       root.right = this.insertIntoBST(root.right, val);     }     return root;   }  }   결과  Link   설명          이진 탐색 트리인 root 내 val 값인 노드를 추가하는 문제이다.            root가 null이면, 해당 자리에 노드를 추가하면 되므로 새 TreeNode를 val 값으로 초기화하여 반환한다.            아래의 경우에 따라 수행하여 val 값의 노드를 추가한 root를 주어진 문제의 결과로 반환한다.             root의 val 값이 val보다 큰 경우 좌측 자식 노드 방향으로 탐색해야하므로, root의 left TreeNode에 root의 left TreeNode로 재귀 호출한 결과를 넣어준다.       root의 val 값이 val보다 작거나 같은 경우 우측 자식 노드 방향으로 탐색해야하므로, root의 right TreeNode에 root의 right TreeNode로 재귀 호출한 결과를 넣어준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/insert-into-a-binary-search-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Kth Largest Element in a Stream",
        "excerpt":"문제  Link   코드  class KthLargest {    private Queue&lt;Integer&gt; queue;   private int k;    public KthLargest(int k, int[] nums) {     this.k = k;     this.queue = new PriorityQueue&lt;Integer&gt;(k);     for (int num : nums) {       this.add(num);     }   }    public int add(int val) {     this.queue.offer(val);     if (this.queue.size() &gt; k) {       this.queue.poll();     }     return this.queue.peek();   }  }  /**  * Your KthLargest object will be instantiated and called as such:  * KthLargest obj = new KthLargest(k, nums);  * int param_1 = obj.add(val);  */   결과  Link   설명     k번째로 큰 값을 반환하는 스트림 객체를 만드는 문제이다.            생성자인 KthLargest(int k, int[] nums)는 k번째 큰 값을 찾을 k와 초기 스트림인 nums를 이용하여 객체를 초기화한다.       메서드인 add(int val)는 val 값을 스트림에 넣어주고, k번째 큰 값을 반환한다.           문제 풀이에 필요한 변수를 정의한다.            queue는 스트림의 값들을 차례대로 저장할 변수이다.       k는 스트림의 k번째 큰 값을 저장할 변수이다.           생성자인 KthLargest(int k, int[] nums)를 완성한다.            k에 주어진 k를 넣어 저장한다.       queue에 k번째 큰 값을 유지하기 위해 k 크기의 PriorityQueue로 초기화한다.           메서드인 add(int val)를 완성한다.            queue에 val 값을 넣어준다.       queue의 크기가 k를 초과하는 경우, 가장 앞의 큰 값을 꺼내준다.       qeuue의 맨 앞의 값은 k번째로 큰 값을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/kth-largest-element-in-a-stream/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Search",
        "excerpt":"문제  Link   코드  class Solution {    public int search(int[] nums, int target) {     int left = 0;     int right = nums.length - 1;     while (left &lt;= right) {       int mid = left + ((right - left) / 2);       if (nums[mid] &gt; target) {         right = mid - 1;       } else if (nums[mid] &lt; target) {         left = mid + 1;       } else {         return mid;       }     }     return -1;   }  }   결과  Link   설명     기초적인 Binary Search Algorithm을 수행하는 문제이다.            단, 탐색 결과가 없을 경우 -1을 반환한다.           문제 풀이에 필요한 변수를 정의한다.            left는 좌측 탐색 범위를 제한할 변수로, 0으로 초기화한다.       right는 우측 탐색 범위를 제한할 변수로, nums의 길이보다 1 작게 정의한다.           left가 right보다 작거나 같을 때 까지 아래의 이진 탐색을 수행한다.            mid는 이진 탐색의 중위값을 정의할 변수로, $\\frac{right - left}{2}$에 left를 더해 넣어준다.       nums의 mid번째 값이 target보다 큰 경우, 우측의 범위를 좁혀야 하므로 right에 $mid - 1$을 넣어준다.       nums의 mid번째 값이 target보다 작은 경우, 좌측의 범위를 좁혀야 하므로 left에 $mid + 1$을 넣어준다.       그 외의 경우인 nums의 mid번째 값이 target인 경우, 원하는 값의 위치를 찾았으므로 mid를 주어진 문제의 결과로 반환한다.           반복이 완료되면 탐색 결과가 없으므로, -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-search/",
        "teaser": null
      },{
        "title": "Leetcode Java Design HashSet",
        "excerpt":"문제  Link   코드  class MyHashSet {    private boolean[] set;    public MyHashSet() {     this.set = new boolean[10];   }    public void add(int key) {     if (key &gt;= this.set.length) {       this.set = Arrays.copyOf(this.set, key + 1);     }     this.set[key] = true;   }    public boolean contains(int key) {     if (key &gt;= this.set.length) {       return false;     } else {       return this.set[key];     }   }    public void remove(int key) {     if (key &lt; this.set.length) {       this.set[key] = false;     }   }  }  /**  * Your MyHashSet object will be instantiated and called as such:  * MyHashSet obj = new MyHashSet();  * obj.add(key);  * obj.remove(key);  * boolean param_3 = obj.contains(key);  */   결과  Link   설명     HashSet과 동일한 기능인 MyHashSet을 구현하는 문제이다.            생성자인 MyHashSet()은 객체를 초기화한다.       메서드인 add(key)는 HashSet 내 key를 저장한다.       메서드인 contains(key)는 HashSet 내 key가 있는지 검증 결과를 반환한다.       메서드인 remove(key)는 HashSet 내 key를 제거한다.           문제 풀이에 필요한 변수를 정의한다.            set은 key가 추가되었는지 검증하기 위한 배열이다.           생성자인 MyHashSet()을 완성한다.            set을 임시로 10 크기의 배열로 초기화한다.           메서드인 add(key)를 완성한다.            set의 길이보다 key가 더 크거나 같은 경우, set의 크기를 key가 들어갈 수 있도록 $key + 1$ 크기로 확장한다.       key의 값이 포함되었다는 의미로 set의 key번째 자리의 값을 true로 바꾸어준다.           메서드인 contains(key)를 완성한다.            set의 길이보다 key가 더 크거나 같은 경우, set의 key번째 자리 결과를 반환한다.       위의 경우가 아니라면 해당 값이 추가된 적이 없으므로, false를 반환한다.           메서드인 remove(key)를 완성한다.            set의 길이가 key보다 큰 경우, key의 값을 제거한다는 의미로 set의 key번째 위치의 값을 false로 바꾸어준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/design-hashset/",
        "teaser": null
      },{
        "title": "Leetcode Java Design HashMap",
        "excerpt":"문제  Link   코드  class MyHashMap {    private int[] map;    public MyHashMap() {     this.map = new int[10];   }    public void put(int key, int value) {     if (key &gt;= this.map.length) {       this.map = Arrays.copyOf(this.map, key + 1);     }     this.map[key] = value == 0 ? -1 : value;   }    public int get(int key) {     if (key &gt;= this.map.length || this.map[key] == 0) {       return -1;     } else {       return this.map[key] == -1 ? 0 : this.map[key];     }   }    public void remove(int key) {     if (key &lt; this.map.length) {       this.map[key] = 0;     }   }  }  /**  * Your MyHashMap object will be instantiated and called as such:  * MyHashMap obj = new MyHashMap();  * obj.put(key,value);  * int param_2 = obj.get(key);  * obj.remove(key);  */   결과  Link   설명     HashMap과 동일한 기능인 MyHashMap을 구현하는 문제이다.            생성자인 MyHashMap()은 객체를 초기화한다.       메서드인 put(int key, int value)은 HashMap 내 key의 값에 value를 저장한다. 단, 동일한 key에 값이 존재한다면 value로 값을 바꾸어준다.       메서드인 get(key)는 HashMap 내 key의 값을 반환한다.       메서드인 remove(key)는 HashMap 내 key의 값을 제거한다.           문제 풀이에 필요한 변수를 정의한다.            map은 key번째 value를 저장하기 위한 배열이다.           생성자인 MyHashSet()을 완성한다.            map을 임시로 10 크기의 배열로 초기화한다.           메서드인 put(int key, int value)을 완성한다.            map의 길이보다 key가 더 크거나 같은 경우, map의 크기를 key가 들어갈 수 있도록 $key + 1$ 크기로 확장한다.       map의 key번째 자리의 값에 value가 0인 경우 -1을 넣어 0이 들어간 것을 표시해주고, 아니면 value를 그대로 넣어준다.           메서드인 get(key)를 완성한다.            map의 길이보다 key가 더 크거나 같거나 map의 key번째 자리의 값이 0인 경우, 값이 존재하지 않으므로 -1을 반환한다.       위의 경우가 아니라면 map의 key번째 자리가 -1인 경우 0을 추가한 경우이므로 0을, 아니면 해당 값 그대로 반환한다.           메서드인 remove(key)를 완성한다.            map의 길이가 key보다 큰 경우, key의 값을 0을 넣어 초기화한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/design-hashmap/",
        "teaser": null
      },{
        "title": "Leetcode Java To Lower Case",
        "excerpt":"문제  Link   코드  class Solution {    public String toLowerCase(String s) {     char[] charArray = s.toCharArray();     StringBuilder sb = new StringBuilder(charArray.length);     for (char c : charArray) {       if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') {         sb.append((char) (c + 32));       } else {         sb.append(c);       }     }     return sb.toString();   }  }   결과  Link   설명          문자열 s의 대문자를 소문자로 변환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            charArray는 s의 문자 배열을 변환하여 저장한 변수이다.       sb는 동적 문자열로 결과를 저장하기 위한 변수로, 효율적인 메모리 사용을 위해 StringBuilder를 사용하여 charArray의 길이의 크기로 초기화한다.           charArray를 반복하여 아래를 수행한다.            c가 ‘A’ ~ ‘Z’의 대문자인 경우, 32를 더한 소문자로 변환하여 sb에 넣어준다.       위의 경우가 아니라면 sb에 c를 그대로 넣어준다.           반복이 완료되면 소문자로 변환한 sb를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/to-lower-case/",
        "teaser": null
      },{
        "title": "Leetcode Java Random Pick with Blacklist",
        "excerpt":"문제  Link   코드  class Solution {    private Random random;   private Map&lt;Integer, Integer&gt; map;   private int size;    public Solution(int n, int[] blacklist) {     this.random = new Random();     this.map = new HashMap&lt;Integer, Integer&gt;();     this.size = n - blacklist.length;     for (int blacklistNum : blacklist) {       if (blacklistNum &gt;= this.size) {         this.map.put(blacklistNum, -1);       }     }     int index = n - 1;     for (int blacklistNum : blacklist) {       if (blacklistNum &lt; this.size) {         while (this.map.containsKey(index--)) {         }         this.map.put(blacklistNum, index + 1);       }     }   }    public int pick() {     int num = this.random.nextInt(this.size);     return this.map.getOrDefault(num, num);   }  }  /**  * Your Solution object will be instantiated and called as such:  * Solution obj = new Solution(n, blacklist);  * int param_1 = obj.pick();  */   결과  Link   설명     blacklist 내 값들을 제외한 [0, $n - 1$] 범위 내 값들을 동일한 확률로 반환하는 객체를 만드는 문제이다.            생성자인 Solution(int n, int[] blacklist)은 n과 blaclist를 이용하여 객체를 초기화한다.       메서드인 pick()은 [0, $n - 1$] 범위 내 값들 중 blacklist 외 값들을 동일한 확률로 반환하는 역할을 수행한다.                    일반적으로 blacklist의 반의어는 whitelist라고 한다.                           문제 풀이에 필요한 전역 변수를 정의한다.            random은 객체 내 존재하는 값을 동일한 확률로 반환하기 위한 변수이다.       map은 [0, $n - 1$] 범위 내 값들을 blacklist를 제외하고 값을 저장하기 위한 변수이다.       size는 blacklist에 포함되지 않은 값들의 크기를 저장할 변수이다.           생성자인 Solution(int n, int[] blacklist)을 완성한다.            문제 풀이에 필요한 전역 변수를 초기화한다.                    random에 Random 객체를 초기화하여 넣어준다.           map은 key와 value로 넣기 위해 HashMap으로 초기화한다.           size는 blacklist를 제외한 값들의 길이를 구하기 위해 n에서 해당 길이를 빼서 저장한다.                       blacklist를 반복하여 size보다 큰 값이 key인 value에 -1을 넣어, blacklist에 포함되는 값임을 표시해준다.       index는 [0, size] 범위에 포함되는 blacklist 값과 범위 외 whitelist 값을 key-value로 묶기 위한 값으로, 최대 숫자 범위인 $n - 1$로 초기화한다.       blacklist의 모든 값들을 blacklistNum에 넣어 아래를 반복 수행한다.                    blacklistNum이 size보다 작은 경우, [0, size] 범위 밖의 whitelist 값과 key-value로 연동하기 위해서 다음을 수행하고 그렇지 않으면 반복을 계속 수행한다.           map에 index가 key인 값이 존재하면 index를 감소시켜 blacklist에 포함되지 않은 값을 찾는다.           위의 반복이 완료되면 blacklistNum이 key인 value에 $index + 1$인 whitelist 값을 넣어준다.                           메서드인 pick()을 완성한다.            num에 [0, size] 내 임의 정수를 반환시킨다.       map에서 num번째 값이 존재하는 경우 blacklist 값과 위치를 바꾼 whitelist 값을 가져오고, 존재하지 않는 경우 num인 whitelist 값을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/random-pick-with-blacklist/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum ASCII Delete Sum for Two Strings",
        "excerpt":"문제  Link   코드  class Solution {    public int minimumDeleteSum(String s1, String s2) {     int s1Length = s1.length();     int s2Length = s2.length();     char[] s1CharArray = s1.toCharArray();     char[] s2CharArray = s2.toCharArray();     int s1Sum = 0;     int s2Sum = 0;     int[][] dp = new int[s1Length + 1][s2Length + 1];     for (int i = 0; i &lt; s1Length; i++) {       s1Sum += s1CharArray[i];       for (int j = 0; j &lt; s2Length; j++) {         if (i == 0) {           s2Sum += s2CharArray[j];         }         dp[i + 1][j + 1] = s1CharArray[i] == s2CharArray[j] ? dp[i][j] + s1CharArray[i] : Math.max(dp[i][j + 1], dp[i + 1][j]);       }     }     return s1Sum + s2Sum - (2 * dp[s1Length][s2Length]);   }  }   결과  Link   설명          문자열 s1과 s2이 같아지기 위해 삭제한 문자의 ASCII 코드의 합이 가장 작은 결과를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            s1Length와 s2Length는 s1과 s2의 길이를 각각 저장한 변수이다.       s1CharArray와 s2CharArray는 s1과 s2를 문자 배열로 각각 변환하여 저장한 변수이다.       s1Sum과 s2Sum은 s1과 s2 각각 모든 문자의 ASCII 코드 합을 저장할 변수로 둘 다 0으로 초기화한다.       dp는 s1과 s2가 같은 문자의 ASCII 코드 합이 가장 큰 값을 구할 변수로, [$s1Length + 1$][$s2Length + 1$] 크기의 2차원 정수 배열로 초기화 한다.           0부터 s1Length까지 i를 증가시키며 아래를 수행한다.            s1Sum에 s1CharArray의 i번쨰 값을 더해 s1의 모든 문자 ASCII 코드 합을 저장한다.       0부터 s2Length까지 j를 증가시키며 아래를 수행한다.                    i가 0인 경우, s2Sum에 s2CharArray의 j번째 값을 더해 s2의 모든 문자 ASCII 코드 합을 저장한다.           s1CharArray의 i번째 문자와 s2CharArray의 j번째 문자가 동일한 경우, dp[$i + 1$][$j + 1$]에 dp[i][j]의 값에 공통된 문자의 ASCII 코드 값을 더한 값을 저장한다.           위의 경우가 아니라면, dp[$i + 1$][$j + 1$]에 dp[i][$j + 1$]의 값과 dp[$i + 1$][j]의 값 중 큰 값을 넣어준다.                           반복이 완료되면 s1Sum과 s2Sum의 합인 모든 문자의 ASCII 코드 값의 합에 s1과 s2의 공통된 문자의 ASCII 코드 값이 최대인 dp[s1Length][s2Length]값의 2배를 뺀 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-ascii-delete-sum-for-two-strings/",
        "teaser": null
      },{
        "title": "Leetcode Java Subarray Product Less Than K",
        "excerpt":"문제  Link   코드  class Solution {    public int numSubarrayProductLessThanK(int[] nums, int k) {     if (k == 0) {       return 0;     }     int count = 0;     int product = 1;     for (int i = 0, j = 0; j &lt; nums.length; j++) {       product *= nums[j];       while (i &lt;= j &amp;&amp; product &gt;= k) {         product /= nums[i++];       }       count += j - i + 1;     }     return count;   }  }   결과  Link   설명          num의 연속된 값들의 부분 배열 내 모든 값을 곱한 결과가 k 미만인 부분 배열의 수를 구하는 문제이다.            nums내 최솟값은 1로 k가 0인 경우 나올 수 있는 경우가 없으므로, 0을 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            count는 부분 배열 내 곱의 결과가 k 미만인 부분 배열의 수를 저장할 변수로, 0으로 초기화한다.       product는 부분 배열 내 곱의 결과를 저장할 변수로, 최소 크기인 1로 초기화한다.           i를 0으로 초기화시키고, 0부터 nums의 길이 미만까지 j를 증가시키며 아래를 반복한다.            product에 nums의 j번째 값을 곱해준다.       i가 j 이하이고 product가 k 이상일 때까지 아래를 반복하여 부분 배열을 만들 수 있는 개수를 산정한다.                    product에 nums의 i번째 값을 나누어 k 미만이 되는 부분 배열 곱의 결과를 구한다.           i를 증가시킨 후 반복을 계속 수행하여 부분 배열에 포함될 숫자의 범위를 좁혀준다.                       위를 통해 좁혀진 범위인 i와 j를 이용하여 $j - i + 1$을 count에 더해준다.           반복이 완료되면 부분 배열의 수를 계산한 count를 주어진 문제의 결과로 반환한다.   해설     nums가 [10, 5, 2, 6]이고, k가 13인 경우를 예를 보면 아래의 두 경우가 복수개의 부분 배열의 범위가 된다.            i가 2인 값이 2의 위치인 경우, 10이 포함되면 k를 넘으므로 [5, [2]] 형태로 [2], [5, 2]가 k 미만의 부분 집합이 2개가 된다.       i가 3인 값이 6의 위치인 경우, 5부터 포함되면 k를 넘으므로 [2, [6]] 형태로 [6], [2, 6]가 k 미만의 부분 집합이 2개가 된다.           위와 같이 특정 값 미만의 연속된 값들이 부분 배열이 되면 해당 숫자 개수만큼 부분 배열이 완성된다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/subarray-product-less-than-k/",
        "teaser": null
      },{
        "title": "Leetcode Java Best Time to Buy and Sell Stock with Transaction Fee",
        "excerpt":"문제  Link   코드  class Solution {    public int maxProfit(int[] prices, int fee) {     int profit = 0;     int hold = -prices[0];     for (int price : prices) {       profit = Math.max(profit, hold + price - fee);       hold = Math.max(hold, profit - price);     }     return profit;   }  }   결과  Link   설명     동일 주식의 가격을 넣은 배열인 prices를 이용하여 거래 수수료가 fee인 거래를 통해 최대 이익을 찾는 문제이다.            단, 주식을 구매하면 반드시 판매 후 구매해야한다.           문제 풀이에 필요한 변수를 정의한다.            profit은 최대 이익을 넣을 변수로, 0으로 초기화한다.       hold는 판매하지 않고 유지할 경우의 금액으로, prices의 첫 값을 음수로 전환한 임의 값을 넣어준다.           prices의 모든 값을 price에 넣어 아래를 반복 수행한다.            profit에 기존 이익 금액인 profit과 구매했을 때의 값인 $hold + price - fee$ 중 큰 값을 넣어준다.       hold에 기존 유지 금액인 hold와 판매했을 때의 값인 $profit - price$ 중 큰 값을 넣어준다.           반복이 완료되면 최대 이익을 저장한 profit을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/best-time-to-buy-and-sell-stock-with-transaction-fee/",
        "teaser": null
      },{
        "title": "Leetcode Java Range Module",
        "excerpt":"문제  Link   코드  class RangeModule {    private TreeMap&lt;Integer, Integer&gt; map;    public RangeModule() {     this.map = new TreeMap&lt;&gt;();   }    public void addRange(int left, int right) {     Integer start = this.map.floorKey(left);     Integer end = this.map.floorKey(right);     if (start != null &amp;&amp; this.map.get(start) &gt;= left) {       left = start;     }     if (end != null &amp;&amp; this.map.get(end) &gt; right) {       right = this.map.get(end);     }     this.map.put(left, right);     this.map.subMap(left, false, right, true).clear();   }    public boolean queryRange(int left, int right) {     Integer start = this.map.floorKey(left);     if (start == null) {       return false;     } else {       return this.map.get(start) &gt;= right;     }   }    public void removeRange(int left, int right) {     Integer start = this.map.floorKey(left);     Integer end = this.map.floorKey(right);     if (end != null &amp;&amp; this.map.get(end) &gt; right) {       this.map.put(right, this.map.get(end));     }     if (start != null &amp;&amp; this.map.get(start) &gt; left) {       this.map.put(start, left);     }     this.map.subMap(left, true, right, false).clear();   }  }  /**  * Your RangeModule object will be instantiated and called as such:  * RangeModule obj = new RangeModule();  * obj.addRange(left,right);  * boolean param_2 = obj.queryRange(left,right);  * obj.removeRange(left,right);  */   결과  Link   설명     반 열린 구간으로 표현하고, 이에 대한 쿼리할 데이터 구조인 Range Module을 설계하는 문제이다.            생성자인 RangeModule()은 데이터 구조를 초기화한다.       메서드인 addRange(int left, int right)는 반 열린 구간인 [left, right)를 추가하고, 기존에 존재하는 간격과 부분적으로 겹치는 경우 해당 구간을 추가한다.       메서드인 queryRange(int left, int right)는 [left, right) 범위가 현재 범위에 포함되면 true를 반환하고, 아니면 false를 반환한다.       메서드인 removeRange(int left, int right)는 반 열린 구간인 [left, right)를 현재 범위에서 제거한다.           문제 풀이에 필요한 변수를 정의한다.            map은 구간을 저장하기 위해 이진 트리 기반으로 저장할 TreeMap으로 정의한다.           생성자인 RangeModule()을 완성한다.            전역 변수로 정의한 map을 TreeMap으로 초기화한다.           메서드인 addRange(int left, int right)를 완성한다.            start와 end에 map에서 각각 left, right와 같거나 작은 값 중 가장 큰 키 값을 넣어준다.       start가 null이거나 map에서 start에 해당하는 값이 left보다 크거나 같은 경우, left에 start를 넣어준다.       end가 null이거나 map에서 end에 해당하는 값이 right보다 큰 경우, right에 map에서 end에 해당하는 값을 넣어준다.       map에 left에 해당하는 값에 right를 넣어 확장된 [left, right) 구간을 저장해준다.       위에서 추가된 값에 포함된 map에 left 초과부터 right 이하까지 값들을 모두 제거한다.           메서드인 queryRange(int left, int right)를 완성한다.            start에 map에서 left와 같거나 작은 값 중 가장 큰 키 값을 넣어준다.       start가 null인 경우, 구간 시작에 대한 결과가 없으므로 false를 주어진 문제의 결과로 반환한다.       start가 null이 아닌 경우, map의 start에 해당하는 값이 right보다 크거나 같은지 여부를 반환한다.           메서드인 removeRange(int left, int right)를 완성한다.            start와 end에 map에서 각각 left, right와 같거나 작은 값 중 가장 큰 키 값을 넣어준다.       end가 null이거나 map에서 end에 해당하는 값이 right보다 큰 경우, map에 right가 키인 값에 map에 end가 키인 값을 넣어준다.       start가 null이거나 map에서 start에 해당하는 값이 left보다 크거나 같은 경우, map에 start가 키인 값에 left를 넣어준다.       map에 left 이상부터 right 미만까지 해당하는 값들을 모두 제거한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/range-module/",
        "teaser": null
      },{
        "title": "Leetcode Java 1-bit and 2-bit Characters",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isOneBitCharacter(int[] bits) {     int bit = 0;     for (int idx = bits.length - 2; idx &gt;= 0 &amp;&amp; bits[idx] != 0; idx--) {       bit++;     }     return bit % 2 == 0;   }  }   결과  Link   설명          0으로 끝나는 bits 배열의 값들은 0, 1, 10, 11로 값이 들어가 있으며, 이 값들을 이용하여 마지막 문자가 1비트 문자인지 검증하는 문제이다.            bit는 문자의 비트를 계산하기 위한 변수로, 0으로 초기화한다.            마지막 값은 0이므로 무시하고 bits의 길이보다 2 작은 길이부터 idx가 0 이상이고 bits의 idx번째 값이 0이 아닐 때 까지 bit를 증가시킨다.            1비트 문자가 되기 위해선 110, 11110과 같이 bit의 1의 개수가 짝수가 되어야 하므로 bit가 짝수인지 여부를 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/1-bit-and-2-bit-characters/",
        "teaser": null
      },{
        "title": "Leetcode Java 1-bit and 2-bit Characters",
        "excerpt":"문제  Link   코드  class Solution {    public int findLength(int[] nums1, int[] nums2) {     int nums1Length = nums1.length;     int nums2Length = nums2.length;     int[][] dp = new int[nums1Length + 1][nums2Length + 1];     int max = 0;     for (int i = 0; i &lt; nums1Length; i++) {       for (int j = 0; j &lt; nums2Length; j++) {         if (nums1[i] == nums2[j]) {           dp[i + 1][j + 1] = dp[i][j] + 1;           max = Math.max(max, dp[i + 1][j + 1]);         }       }     }     return max;   }  }   결과  Link   설명          num1과 num2에 동시에 포함되는 부분 배열의 최대 길이를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            nums1Length와 nums2Length는 nums1과 nums2의 길이를 각각 저장한 변수이다.       dp는 num1과 num2에 동시에 포함되는 부분 배열의 최대 길이를 구하기 위한 변수로, [$nums1Length + 1$][$nums2Length + 1$] 크기의 2차원 배열로 초기화한다.       max는 num1과 num2에 동시에 포함되는 부분 배열의 최대 길이를 저장하기 위한 변수로, 0으로 초기화한다.           0부터 nums1Length 미만까지 i를 증가시키고, 0부터 nums2Length 미만까지 j를 증가시키며 아래를 반복 수행한다.            num1[i]의 값과 num2[j]의 값이 동일한 경우, 아래를 수행한다.                    dp[$i + 1$][$j + 1$]의 자리에 dp[i][j]의 값에 1을 더해 연속된 부분 배열의 길이를 저장한다.           max에 max와 위에서 계산된 부분 배열의 길이인 dp[$i + 1$][$j + 1$] 값 중 큰 값을 넣어준다.                           반복이 완료되면 num1과 num2에 동시에 포함되는 부분 배열의 최대 길이를 저장한 max를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-length-of-repeated-subarray/",
        "teaser": null
      },{
        "title": "Leetcode Java Find K-th Smallest Pair Distance",
        "excerpt":"문제  Link   코드  class Solution {    public int smallestDistancePair(int[] nums, int k) {     Arrays.sort(nums);     int low = 0;     int high = nums[nums.length - 1] - nums[0];     while (low &lt; high) {       int mid = (low + high) / 2;       int count = 0;       for (int i = 0, j = 0; i &lt; nums.length; i++) {         while (nums[i] - nums[j] &gt; mid) {           j++;         }         count += i - j;       }       if (count &gt;= k) {         high = mid;       } else {         low = mid + 1;       }     }     return low;   }  }   결과  Link   설명     nums의 값들을 이용하여 k번째로 작은 거리를 반환하는 문제이다.            a와 b의 거리는 두 값의 절대값의 차이로 정의된다.       k번째로 작은 거리인 nums[i]의 값과 nums[j]의 값은, 0 &lt; = i &lt; j &lt; nums.length를 만족한다.                nums의 모든 값들을 오름차순 정렬한다.            최소 거리인 low에는 0을, 최대 거리인 high에는 nums의 마지막 값에서 첫 번째 값의 차이를 넣어준다.       low가 high 미만일 때 까지 아래를 반복한다.            mid에 low와 high의 중간 값인 $\\frac{low + high}{2}$을 넣어준다.       count는 mid에 해당하는 거리 이하인 nums의 숫자 개수를 넣을 변수로, 0으로 초기화한다.       0부터 nums의 길이 미만까지 i를 증가시키고, j는 0으로 아래를 반복한다.                    $nums[i] - nums[j]$의 결과가 mid보다 클 때까지 j를 증가시켜준다.           count에 $i - j$를 더해서 mid 이하인 작은 거리 개수를 계산한다.                       count가 k 이상인 경우, high에 mid를 넣어 범위를 낮은 수로 좁힌다.       count가 k 미만인 경우, low에 $mid + 1$을 넣어 범위를 높은 수로 좁힌다.           반복이 완료되면 k번째로 작은 거리인 low를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-k-th-smallest-pair-distance/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Word in Dictionary",
        "excerpt":"문제  Link   코드  class Solution {    public String longestWord(String[] words) {     String result = \"\";     Set&lt;String&gt; set = new HashSet&lt;&gt;();     for (String word : words) {       set.add(word);     }     for (String word : words) {       int wordLength = word.length();       int longestLength = result.length();       if (wordLength &gt; longestLength || (wordLength == longestLength &amp;&amp; word.compareTo(result) &lt; 0)) {         boolean isLongestWord = true;         for (int idx = 1; idx &lt; wordLength; idx++) {           if (!set.contains(word.substring(0, idx))) {             isLongestWord = false;             break;           }         }         if (isLongestWord) {           result = word;         }       }     }     return result;   }   }   결과  Link   설명     words의 각 문자열들을 한 문자씩 사용하여 만들 수 있는 가장 긴 문자열의 길이인 문자열을 찾는 문제이다.            단어는 각 문자열의 한 문자씩 사용하여 왼쪽에서 오른쪽으로 이전까지 만들었던 문자열 끝에 앞의 문자를 붙이는 식으로 만들어야 한다.       둘 이상의 정답이 존재하는 경우, 사전순으로 긴 단어를 반환한다.           문제 풀이에 필요한 변수를 정의한다.            result는 가장 긴 문자열을 넣을 변수로, 빈 값으로 초기화한다.       set은 words 내 문자열들을 중복 제거하여 저장할 변수로, HashSet으로 초기화하여 words의 모든 문자열을 넣어준다.           words의 모든 문자열을 word에 넣어 아래를 반복한다.            wordLength에 word의 길이를, longestLength에 result의 길이를 넣어 초기화한다.       wordLength가 longestLength보다 긴 경우이거나, 동일한 길이인 경우 word가 사전순 우선되는 단어인 경우 아래를 수행한다.                    word의 처음부터 한 문자씩 붙인 부분 문자열이 words에 포함되지 않는 경우, 조건에 해당하지 않으므로 isLongestWord를 false로 바꾸고 반복을 중지한다.                       isLongestWord가 true인 경우만 result에 word를 넣어준다.           반복이 완료되면 조건을 만족하는 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-word-in-dictionary/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove Comments",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; removeComments(String[] source) {     List&lt;String&gt; result = new ArrayList&lt;&gt;();     StringBuilder sb = new StringBuilder();     boolean inBlock = false;     for (String line : source) {       for (int idx = 0; idx &lt; line.length(); idx++) {         if (!inBlock) {           if (line.charAt(idx) == '/' &amp;&amp; idx + 1 &lt; line.length() &amp;&amp; line.charAt(idx + 1) == '/') {             break;           }           if (line.charAt(idx) == '/' &amp;&amp; idx + 1 &lt; line.length() &amp;&amp; line.charAt(idx + 1) == '*') {             inBlock = true;             idx++;           } else {             sb.append(line.charAt(idx));           }         } else {           if (line.charAt(idx) == '*' &amp;&amp; idx + 1 &lt; line.length() &amp;&amp; line.charAt(idx + 1) == '/') {             idx++;             inBlock = false;           }         }       }       if (!inBlock &amp;&amp; sb.length() &gt; 0) {         result.add(sb.toString());         sb.setLength(0);       }     }     return result;   }  }   결과  Link   설명     소스 코드의 라인을 배열로 저장한 source를 이용하여 주석을 제거하는 문제이다.            문자열 “//”의 경우, 해당 문자열 우측의 모든 내용이 주석이므로 제거한다.       문자열 “/“의 경우, “/”의 문자열이 존재하면 두 문자열 사이의 모든 문자열이 주석이므로 제거한다.           문제 풀이에 필요한 변수를 정의한다.            result는 주석을 제거한 소스 코드를 저장할 변수로, ArrayList로 초기화한다.       sb는 주석을 제거한 문자열을 만들 변수로, 동적 문자열을 효율적으로 생성하기 위해 StringBuilder로 초기화한다.       inBlock은 주석에 포함되는 영역을 구분하기 위한 변수로, false로 초기화한다.           source의 모든 문자열들을 line에 넣어 아래를 반복한다.            0부터 line의 길이 이전까지 idx를 증가시키며 아래를 수행한다.                    inBlock이 false인 경우, 문자열 “//”이 시작하는 위치이면 반복을 중단하고 문자열 “/*“이 시작하는 위치이면 inBlock을 true로 바꾸어 주석 시작을 체크하고 idx를 증가시켜 주석 내 문장 위치로 이동한다.           inBlock이 아니면서 위의 문자열 “//”과 “/*“이 아닌 경우 소스 코드이므로, sb에 line의 idx번째 문자를 넣어준다.           inBlock이 true이면서 “*/”문자열의 위치인 경우, idx를 증가시켜 주석 영역 밖으로 이동시키고 inBlock을 false로 바꾸어 주석 영역을 종료한다.                           반복이 종료되면 주석을 제거한 문자열을 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-comments/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove Comments",
        "excerpt":"문제  Link   코드  class Solution {    public int pivotIndex(int[] nums) {     int sum = 0;     int half = 0;     for (int num : nums) {       sum += num;     }     for (int idx = 0; idx &lt; nums.length; idx++) {       if (half * 2 == sum - nums[idx]) {         return idx;       } else {         half += nums[idx];       }     }     return -1;   }  }   결과  Link   설명     피벗 인덱스를 찾는 문제이다.            피벗 인덱스란 특정 위치 기준으로 좌측 값들의 합과 우측 값들의 합이 동일한 인덱스이다.       피벗 인덱스가 존재하지 않는 경우, -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            sum은 nums 내 모든 값들을 더한 값을 저장할 변수로, nums의 모든 값들을 더해준다.       half는 좌측의 값들을 더해 피벗 인덱스를 구하기 위한 절반 값을 저장할 변수로, 0으로 초기화한다.           0부터 nums의 길이 전까지 idx를 증가시키며 아래를 반복한다.            half의 2배가 $sum - nums[idx]$를 만족하는 경우, 현재 위치가 피벗 인덱스이므로 idx를 주어진 문제의 결과로 반환한다.       위를 만족하지 않는 경우, half에 nums의 idx번째 값을 더해준다.           반복이 완료되면 피벗 인덱스가 존재하지 않으므로 -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-pivot-index/",
        "teaser": null
      },{
        "title": "Leetcode Java Self Dividing Numbers",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; selfDividingNumbers(int left, int right) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     for (int idx = left; idx &lt;= right; idx++) {       int num = idx;       boolean valid = true;       while (num &gt; 0) {         int remain = num % 10;         if (remain == 0 || idx % remain != 0) {           valid = false;           break;         }         num /= 10;       }       if (valid) {         result.add(idx);       }     }     return result;   }  }   결과  Link   설명          [left, right] 구간 내 각 자릿수에 해당하는 값들로 해당 숫자를 나누었을 때 나머지가 모두 0이 되는 자기 나눗셈 숫자를 구하는 문제이다.            결과를 넣을 result를 ArrayList로 초기화한다.       left부터 right까지 idx를 증가시키며 아래를 반복한다.            num에 idx를 넣어주고, 자기 나눗셈 숫자를 검증한 결과를 넣기 위한 valid를 true로 초기화한다.       num이 0 초과일 때 까지 remain에 num을 10으로 나눈 나머지 값을 넣고 자기 나눗셈 숫자가 될 수 없으므로 valid를 false로 넣고 반복을 중지하고, 아니면 num에 10으로 나눈 값을 넣어 반복을 계속한다.                    num을 10으로 나눈 나머지가 0인 경우 나눗셈을 진행할 수 없다.           idx를 remain으로 나눈 나머지가 0이 아닌 경우 만족하지 않는다.                       위의 반복이 완료되고 valid가 true이면 idx는 자기 나눗셈 숫자이므로, result에 idx를 넣어준다.           반복이 완료되면 [left, right] 구간 내 존재하는 자기 나눗셈 숫자를 넣은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/self-dividing-numbers/",
        "teaser": null
      },{
        "title": "Leetcode Java My Calendar I",
        "excerpt":"문제  Link   코드  class MyCalendar {    private TreeMap&lt;Integer, Integer&gt; bookings;    public MyCalendar() {     this.bookings = new TreeMap&lt;&gt;();   }    public boolean book(int start, int end) {     Map.Entry&lt;Integer, Integer&gt; booking = this.bookings.floorEntry(--end);     if (booking == null || booking.getValue() &lt; start) {       this.bookings.put(start, end);       return true;     } else {       return false;     }   }  }  /**  * Your MyCalendar object will be instantiated and called as such:  * MyCalendar obj = new MyCalendar();  * boolean param_1 = obj.book(start,end);  */   결과  Link   설명     날자가 겹치지 않게 관리하는 일정 관리 시스템인 MyCalendar 클래스를 완성하는 문제이다.            일정은 [start, end) 형태로 주입되며, 반 열림 구간인 start &lt;= x &lt; end 를 만족한다.       생성자인 MyCalendar()는 일정 관리 객체를 초기화한다.       메서드인 book(int start, int end)은 [start, end) 구간의 일정 추가가 가능하면 일정 관리 시스템에 추가 후 true를 반환하고, 겹치는 일정이 존재하면 일정을 추가하지 않고 end를 반환한다.                bookings는 일정을 저장하고 관리할 객체로 구간 관리를 하기 위해 TreeMap으로 정의한다.       생성자인 MyCalendar()를 완성한다.            일정 관리를 하기 위한 bookings를 TreeMap으로 초기화한다.           메서드인 book(int start, int end)을 완성한다.            일정은 반열림 구간이므로 end를 1 감소시키고 bookings에서 해당 값보다 같거나 작은 값 중 가장 큰 값이 키인 Entry 객체를 booking에 넣어준다.       booking이 null이거나 booking의 값이 start보다 작은 경우 예약 가능한 일정이므로, bookings에 키가 start에 값은 end로 추가하고 true를 반환한다.       위의 경우가 아니라면 예약 불가능하므로 false를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/my-calendar-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Flood Fill",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] floodFill(int[][] image, int sr, int sc, int color) {     if (image[sr][sc] != color) {       this.dfs(image, sr, sc, image[sr][sc], color);     }     return image;   }    private void dfs(int[][] image, int sr, int sc, int color, int newColor) {     if (sr &gt;= 0 &amp;&amp; sr &lt; image.length &amp;&amp; sc &gt;= 0 &amp;&amp; sc &lt; image[0].length &amp;&amp; image[sr][sc] == color) {       image[sr][sc] = newColor;       this.dfs(image, sr + 1, sc, color, newColor);       this.dfs(image, sr - 1, sc, color, newColor);       this.dfs(image, sr, sc + 1, color, newColor);       this.dfs(image, sr, sc - 1, color, newColor);     }   }  }   결과  Link   설명          image[sr][sc]에서 시작하여 4 방향의 색상이 동일한 경우, color를 넣어 수정된 image를 반환하는 문제이다.       image[sr][sc]의 생상이 color와 동일하지 않은 경우만 3번에서 정의한 dfs(int[][] image, int sr, int sc, int color, int newColor) 메서드를 수행한다.            시작 지점의 색상인 image[sr][sc]가 color와 동일하면 예시에서 제공한대로 이미지를 변경하지 않는다.           DFS 방식으로 color를 채워 넣을 dfs(int[][] image, int sr, int sc, int color, int newColor) 메서드를 정의한다.            sr이 [0, image.length]를 만족하고, sc도 image[0].length를 만족하면서 image[sr][sc]의 색상이 동일한 경우, 상하좌우에 대한 재귀 호출을 수행한다.           반복이 완료되면 주어진 조건에 맞춘 color를 image에 채워넣어 수정된 image를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/flood-fill/",
        "teaser": null
      },{
        "title": "Leetcode Java Asteroid Collision",
        "excerpt":"문제  Link   코드  class Solution {    public int[] asteroidCollision(int[] asteroids) {     int index = -1;     for (int asteroid : asteroids) {       boolean alive = true;       while (alive &amp;&amp; asteroid &lt; 0 &amp;&amp; index &gt;= 0 &amp;&amp; asteroids[index] &gt; 0) {         alive = asteroids[index] + asteroid &lt; 0;         if (asteroids[index] + asteroid &lt;= 0) {           index--;         }       }       if (alive) {         asteroids[++index] = asteroid;       }     }     return Arrays.copyOf(asteroids, index + 1);   }  }   결과  Link   설명     연속적으로 소행성의 크기를 저장한 asteroids 배열을 이용하여 살아남은 소행성을 반환하는 문제이다.            양수는 오른쪽 음수는 왼쪽으로 이동하는 방향을 나타낸다.       양수와 음수로 마주치는 두 소행성의 경우, 크기가 큰 소행성만 살아남는다.       양수와 음수로 마주치는 두 소행성의 크기가 같은 경우, 두 소행성 모두 폭발한다.       소행성은 모두 같은 속도로 움직이며, 같은 방향으로 움직이는 소행성은 절대 만나지 않는다.                index는 살아남은 소행성만 저장한 asteroids 배열을 자르기 위한 위치 변수로, -1로 초기화한다.       asteroids 배열을 순서대로 asteroid 변수에 넣어 아래를 반복한다.            alive는 살아있는 상태를 저장하기 위한 변수로, true로 초기화한다.       alive가 true로 살아있는 소행성이면서 asteroid인 소행성의 크기가 음수이고 index가 0보다 크면서 asteroids의 index번째 소행성의 크기가 0보다 커서 마주치면 아래를 계속 수행한다.                    alive에 asteroids의 index번째 소행성의 크기와 asteroid의 합이 0보다 작은지를 여부를 넣어준다.           asteroids의 index번째 소행성의 크기와 asteroid의 합이 0보다 같거나 작으면 해당 행성을 제거해야하므로, index를 감소시킨다.                       alive가 true인 살아남는 소행성인 경우, index를 증가시키고 asteroid의 index번째 위치에 해당 소행성의 크기인 asteroid를 넣어준다.           반복이 완료되면 살아남은 소행성을 순차적으로 index번째까지 저장한 asteroids를 $index + 1$ 크기의 새 배열로 복사하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/asteroid-collision/",
        "teaser": null
      },{
        "title": "Leetcode Java Monotone Increasing Digits",
        "excerpt":"문제  Link   코드  class Solution {    public int monotoneIncreasingDigits(int n) {     char[] charArray = String.valueOf(n).toCharArray();     int end = charArray.length - 1;     for (int idx = charArray.length - 1; idx &gt; 0; idx--) {       if (charArray[idx - 1] &gt; charArray[idx]) {         end = idx - 1;         charArray[idx - 1]--;       }     }     for (int idx = end + 1; idx &lt; charArray.length; idx++) {       charArray[idx] = '9';     }     return Integer.parseInt(new String(charArray));   }  }   결과  Link   설명          n의 각 자릿수의 숫자가 점층적으로 증가하는지 확인하여 해당 조건을 만족하지 않는 경우, n보다 작은 숫자 중 가장 큰 조건에 만족하는 숫자를 반환한다.       문제 풀이에 필요한 변수를 정의한다.            charArray는 정수인 n을 문자의 배열로 변환하여 저장한 변수이다.       end는 조건을 만족하지 않는 마지막 위치를 저장할 변수로, charArray의 길이보다 1 작은 값으로 초기화한다.           chaArray의 길이보다 1 작은 수부터 0 초과까지 idx를 증가시키며 아래를 반복한다.            charArray의 $idx - 1$번째 문자가 idx번째 문자보다 큰 경우, 조건을 만족하지 않기 때문에 end에 $idx - 1$을 넣고 charArray의 $idx - 1$번째 값을 1 작게 한다.                $end + 1$부터 charArray의 길이 미만까지 idx를 증가시키며 각 자리에 9를 넣어 n 미만의 점층적으로 증가하는 가장 큰 숫자를 만들어준다.       반복이 완료되면 charArray를 정수로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/monotone-increasing-digits/",
        "teaser": null
      },{
        "title": "Leetcode Java Daily Temperatures",
        "excerpt":"문제  Link   코드  class Solution {    public int[] dailyTemperatures(int[] temperatures) {     int length = temperatures.length;     int lastTemperature = 0;     int[] result = new int[length];     for (int idx = length - 1; idx &gt;= 0; idx--) {       int currentTemperature = temperatures[idx];       if (currentTemperature &gt;= lastTemperature) {         lastTemperature = currentTemperature;         continue;       }       int days = 1;       while (temperatures[idx + days] &lt;= currentTemperature) {         days += result[idx + days];       }       result[idx] = days;     }     return result;   }  }   결과  Link   설명     일자별 온도 정보를 저장하는 temperatures를 이용하여 현재 온도에서 더 따뜻한 온도가 되는 날까지의 일수 차이를 계산하여 반환하는 문제이다.            더 따뜻한 온도의 날자 정보가 없는 경우, 0을 넣어준다.           문제 풀이에 필요한 변수를 정의한다.            length는 temperatures의 길이를 저장한 변수이다.       lastTemperature는 이전 온도 정보를 저장할 변수로, 0으로 초기화한다.       result는 일수 차이를 계산해서 넣어줄 배열로, temperatures와 동일한 크기인 length 크기의 정수 배열로 초기화한다.           $length - 1$부터 0까지 idx를 감소시키면서 아래를 수행한다.            temperatures의 idx번째 온도 정보를 currentTemperature에 임시 저장한다.       currentTemperature가 lastTemperature보다 크거나 같은 경우, lastTemperature에 currentTemperature를 저장하고 다음 반복을 수행한다.       날자 차이를 계산할 days를 1로 초기화하고, temperatures의 현재 위치 이후인 $idx + days$번째 온도 정보부터 currentTemperature 이하인 경우, days에 result의 $idx + days$ 번째 위치 값을 더해준다.       위의 반복이 완료되면 result의 idx번째 위치에 계산된 days를 넣어준다.           반복이 완료되면 날자 차이 값을 계산한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/daily-temperatures/",
        "teaser": null
      },{
        "title": "Leetcode Java Delete and Earn",
        "excerpt":"문제  Link   코드  class Solution {    public int deleteAndEarn(int[] nums) {     int[] dp = new int[10001];     int max = 0;     for (int num : nums) {       dp[num] = dp[num] + num;       max = Math.max(num, max);     }     for (int idx = 2; idx &lt;= max; idx++) {       dp[idx] = Math.max(dp[idx - 1], dp[idx] + dp[idx - 2]);     }     return dp[max];   }  }   결과  Link   설명          nums의 idx번째 값을 선택하면 $num[i] - 1$과 $num[i] + 1$의 값들을 배열에서 제거하면서 점수를 획득할 수 있는데, 해당 값이 최대인 값을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            dp는 값을 계산하기 위한 변수로, 정수의 최대 범위의 한계인 10001 크기의 정수 배열로 초기화한다.       max는 nums 내 최댓 값을 저장하기 위한 변수로, 0으로 초기화한다.           nums의 모든 값을 num에 순차적으로 넣어 아래를 반복한다.            dp의 num번쨰 위치에 해당 위치 값과 num을 더해서 넣어주고, max에 num과 max 중 큰 값을 저장한다.           위의 반복이 완료되면 2부터 max 이하까지 idx를 증가시키며 아래를 반복한다.            dp의 idx번째 위치에 dp의 $idx - 1$번째 값과 idx와 $idx - 2$번째 값의 합 중 큰 값을 넣어 해당 값을 선택할 경우 얻을 수 있는 포인트를 저장한다.           포인트의 최댓 값이 저장된 dp의 max번째 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/delete-and-earn/",
        "teaser": null
      },{
        "title": "Leetcode Java Network Delay Time",
        "excerpt":"문제  Link   코드  class Solution {    public int networkDelayTime(int[][] times, int n, int k) {     int[][] graph = new int[n][n];     for (int idx = 0; idx &lt; n; idx++) {       Arrays.fill(graph[idx], Integer.MAX_VALUE);     }     for (int[] time : times) {       graph[time[0] - 1][time[1] - 1] = time[2];     }     int[] distances = new int[n];     Arrays.fill(distances, Integer.MAX_VALUE);     distances[k - 1] = 0;     boolean[] visited = new boolean[n];     for (int i = 0; i &lt; n; i++) {       int index = this.findMinimumIndex(distances, visited);       if (index == -1) {         continue;       }       visited[index] = true;       for (int j = 0; j &lt; n; j++) {         if (graph[index][j] != Integer.MAX_VALUE) {           int distance = graph[index][j] + distances[index];           if (distance &lt; distances[j]) {             distances[j] = distance;           }         }       }     }     int result = 0;     for (int distance : distances) {       if (distance == Integer.MAX_VALUE) {         return -1;       }       result = Math.max(result, distance);     }     return result;   }    private int findMinimumIndex(int[] distances, boolean[] visited) {     int min = Integer.MAX_VALUE;     int index = -1;     for (int idx = 0; idx &lt; distances.length; idx++) {       if (!visited[idx] &amp;&amp; distances[idx] &lt; min) {         min = distances[idx];         index = idx;       }     }     return index;   }  }   결과  Link   설명     n개의 노드로 이루어진 네트워크에 1부터 n까지 레이블이 지정되면, 노드 k부터 n개의 모든 노드가 신호를 수신하는데 필요한 최소 시간을 반환한다.            단, n 개의 노드가 모두 신호를 수신할 수 없는 경우, -1을 주어진 문제의 결과로 반환한다.       times[i] = (ui, vi, wi) 이며 각 값은 아래를 의미한다.                    ui는 시작 노드를 의미한다.           vi는 도착 노드를 의미한다.           wi는 시작 노드에서 도착 노드까지 신호를 보내는데 걸리는 시간을 의미한다.                           문제 풀이에 필요한 변수를 정의한다.            graph는 n개의 노드 정보를 넣을 배열로, $n \\times n$ 크기의 2차원 정수 배열로 정의하고 아래를 수행한다.                    times의 모든 값을 이용하여 times[i]인 경우, graph[ui][vi]에 wi를 넣어준다.           위의 값이 존재하지 않는 모든 위치에 빈 값을 정수의 최댓 값을 넣어 존재하지 않은 노드임을 체크해준다.                       distances는 각 노드 별 거리를 저장하기 위한 배열로, n 크기의 정수 배열로 초기화하고 아래를 수행한다.                    노드의 시작 위치인 $k - 1$에는 0을 넣어준다.           시작 위치가 아닌 모든 위치의 값에는 최댓 값을 모두 넣어준다.                       visited는 노드의 방문 여부를 기록하기 위한 배열로, n 크기의 부울 배열로 초기화한다.           최소 거리의 위치를 탐색하기 위한 findMinimumIndex(int[] distances, boolean[] visited) 메서드를 정의한다.            위치 탐색에 필요한 변수를 정의한다.                    min은 최소 거리를 넣을 변수로, 정수의 최댓값으로 초기화한다.           index는 최소 거리 위치를 넣을 위치로, -1로 초기화한다.                       0 부터 distnaces의 길이 미만까지 idx를 증가시키며, 방문하지 않은 최소 거리의 노드의 위치를 탐색한다.       탐색된 노드의 위치인 index를 반환한다.           0 부터 n 미만까지 i를 증가시키며 아래를 반복한다.            index에 3번에서 정의한 findMinimumIndex(int[] distances, boolean[] visited) 메서드를 수행한 결과인 위치 값을 넣어주고, 해당 노드의 위치가 존재하지 않는 -1이면 다음 반복을 수행한다.       위가 아닌경우 visited의 index번째 값에 true를 넣어 방문했다는 것을 체크해준다.       0부터 n 미만까지 j를 증가시키며 아래를 다시 반복한다.                    graph[index][j]의 값이 정수 최댓값이 아닌 존재하는 노드인 경우, graph[index][j]의 값과 distances[index]의 값이 distances[j]보다 작은지 검증하여 더 거리가 짧은 경우 distances[j]에 계산된 값을 넣어준다.                           4번의 반복이 완료되면 result에 0을 넣고 distances를 반복하여 아래를 확인한다.            distances에 정수의 최댓 값이 있는 경우 연결되지 않은 노드가 존재하므로, -1을 주어진 문제의 결과로 반환한다.       위의 경우가 아니라면 distances 내 최댓값인 모든 노드의 반복된 시간을 찾아 result에 넣어준다.           5번의 반복이 완료되면 모든 노드가 신호를 수신하는 최소 시간인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/network-delay-time/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Smallest Letter Greater Than Target",
        "excerpt":"문제  Link   코드  class Solution {    public char nextGreatestLetter(char[] letters, char target) {     int length = letters.length;     int left = 0;     int right = length;     while (left &lt; right) {       int mid = left + ((right - left) / 2);       if (letters[mid] &gt; target) {         right = mid;       } else {         left = mid + 1;       }     }     return letters[left % length];   }  }   결과  Link   설명     사전적 순서가 증가하는 형태의 문자 배열인 letters 이용하여 target 다음으로 큰 문자를 찾는 문제이다.            단, 해당 문자가 존재하지 않은 경우 letters의 첫 문자를 반환한다.           문제 풀이에 필요한 변수를 정의한다.            length는 letters의 길이를 저장한 변수이다.       left와 right는 문자열 탐색의 기준이 될 위치 값으로, 0과 length로 초기화한다.           left가 right보다 작을 때 까지 아래를 반복하여 문자를 탐색한다.            mid에 중앙값인 $left + \\frac{right - left}{2}$를 넣어준다.       letters의 mid번째 문자가 target보다 크면 right에 mid를, 그렇지 않으면 left에 $mid + 1$을 넣어 탐색을 계속한다.           letters 내 left를 length로 나눈 나머지 값의 위치에 해당하는 문자를 주어진 문제의 결과로 반환한다.            모든 문자 탐색하여 해당 문자를 찾지 못한 경우 left와 length는 동일하므로, 나눈 결과의 나머지인 0번째 문자를 반환하기 위함이다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-smallest-letter-greater-than-target/",
        "teaser": null
      },{
        "title": "Leetcode Java Prefix and Suffix Search",
        "excerpt":"문제  Link   코드  class TrieNode {    public int index;   public TrieNode[] children;    public TrieNode() {     this.children = new TrieNode[27];   }  }  class WordFilter {    private TrieNode root = new TrieNode();    public WordFilter(String[] words) {     for (int i = 0; i &lt; words.length; i++) {       char[] charArray = (words[i] + \"{\" + words[i]).toCharArray();       for (int j = 0; j &lt; charArray.length; j++) {         TrieNode temp = this.root;         for (int k = j; k &lt; charArray.length; k++) {           int num = charArray[k] - 'a';           if (temp.children[num] == null) {             temp.children[num] = new TrieNode();           }           temp = temp.children[num];           temp.index = i;         }       }     }   }    public int f(String pref, String suff) {     char[] charArray = (suff + \"{\" + pref).toCharArray();     TrieNode temp = this.root;     for (char c : charArray) {       temp = temp.children[c - 'a'];       if (temp == null) {         return -1;       }     }     return temp.index;   }  }  /**  * Your WordFilter object will be instantiated and called as such:  * WordFilter obj = new WordFilter(words);  * int param_1 = obj.f(pref,suff);  */   결과  Link   설명     접두사와 접미사를 이용하여 단어 검색을 수행하는 사전을 만드는 문제이다.            생성자인 WordFilter(string[] words)는 words를 이용하여 사전을 초기화하는 역할을 수행한다.       메서드인 f(string pref, string suff)는 접두사인 pref와 접미사인 suff를 이용하여 일치하는 단어들의 위치 중 가장 큰 위치 값을 반환한다.           단어를 저장 및 검색하기 위한 TrieNode를 정의한다.            index는 words 내 위치 값을 저장하기 위한 변수이다.       children은 다음 문자를 이어주기 위한 변수이다.       생성자인 TrieNode()를 호출하면 children에 영소문자 26 문자와 구분 기호 1 문자을 이용하기 위해 27 크기의 TrieNode 배열로 초기화한다.                root는 생성자를 통해 입력된 전체 문자열을 순차적으로 저장할 TrieNode 객체이다.       생성자인 WordFilter(string[] words)를 완성한다.            0 부터 words의 길이 미만까지 i를 증가시키며 아래를 수행한다.                    charArray에 words의 i번째 문자를 구분 문자인 “{“ 단어 앞뒤로 이어준 문자열의 문자 배열을 저장한다.           구분 문자를 “{“로 사용하는 이유는 영소문자 “z” 이후에 나오는 단어이므로, 순차적으로 children에 저장하기 수월하기 때문이다.           앞에서 만들어준 charArray를 이용하여 temp에 차례대로 TrieNode로 연결시켜준다.                           메서드인 f(string pref, string suff)를 완성한다.            charArray에 구분 문자인 “{“ 단어 앞뒤로 suff와 pref를 이어준 문자열의 문자 배열을 저장한다.       temp에 root를 넣어주고, charArray를 이용하여 TrieNode를 순차 탐색한다.       탐색 중 문자를 찾지 못하면 -1을, 탐색 완료되면 temp의 index를 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/prefix-and-suffix-search/",
        "teaser": null
      },{
        "title": "Leetcode Java Min Cost Climbing Stairs",
        "excerpt":"문제  Link   코드  class Solution {    public int minCostClimbingStairs(int[] cost) {     int length = cost.length;     int[] dp = new int[length];     dp[0] = cost[0];     dp[1] = cost[1];     for (int idx = 2; idx &lt; length; idx++) {       dp[idx] = Math.min(dp[idx - 1], dp[idx - 2]) + cost[idx];     }     return Math.min(dp[length - 1], dp[length - 2]);   }  }   결과  Link   설명     아래의 규칙을 이용하여 바닥부터 계단을 오르는 비용을 저장한 cost를 이용하여 계단 아래에서 맨 위까지 올라가기 위한 최소 비용을 찾는 문제이다.            계단은 비용 지불 후 한 번에 하나 혹은 두 계단을 오를 수 있다.       계단 시작 위치는 계단 아래인 인덱스가 0인 위치이거나, 한 계단 위인 인덱스가 1인 위치에서 시작 할 수 있다.           문제 풀이에 필요한 변수를 정의한다.            length는 cost의 길이를 저장한 변수이다.       dp는 최소 비용을 계산하기 위한 배열로, length 길이의 정수 배열로 초기화하고 dp의 첫 번째와 두 번째 위치에 cost의 첫 번째와 두 번째 값을 넣어준다.           2부터 length 미만까지 idx를 증가시키면서 아래를 반복한다.            dp의 idx번째 위치에 dp의 $idx - 2$번째 값과 $idx - 1$번째 값 중 작은 값인 최소 비용에 cost의 idx번째 값을 더한 값을 넣어준다.           반복이 완료되면 dp의 $length - 2$번째 값과 $length - 1$번째 값 중 작은 값인 최소 비용을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/min-cost-climbing-stairs/",
        "teaser": null
      },{
        "title": "Leetcode Java Largest Number At Least Twice of Others",
        "excerpt":"문제  Link   코드  class Solution {    public int dominantIndex(int[] nums) {     int max = -1;     int index = -1;     int second = -1;     for (int idx = 0; idx &lt; nums.length; idx++) {       if (nums[idx] &gt; max) {         second = max;         max = nums[idx];         index = idx;       } else if (nums[idx] &gt; second) {         second = nums[idx];       }     }     return max &gt;= second * 2 ? index : -1;   }  }   결과  Link   설명     nums 내 가장 큰 값이 다른 값보다 최소 두 배 이상 큰지를 검증하여 해당 값의 위치를 반환하는 문제이다.            단, 가장 큰 값이 다른 값보다 최소 두 배 이상 크지 않는다면 -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            max는 가장 큰 값을 저장할 변수로, -1로 초기화한다.       index는 가장 큰 값의 위치 값을 저장할 변수로, -1로 초기화한다.       second는 두 번째로 큰 값을 저장할 변수로, -1로 초기화한다.           0부터 nums의 길이 미만까지 idx를 증가시키며 아래를 반복한다.            nums의 idx번쨰 값이 max보다 큰 경우, 현재까지 가장 큰 값이므로 아래를 수행한다.                    second에 기존까지 가장 큰 값인 max 값을 넣어준다.           max에 현재까지 가장 큰 값인 nums의 idx번째 값을 넣어준다.           index에 현재까지 가장 큰 값의 위치인 idx를 넣어준다.                       nums의 idx번쨰 값보다 second의 값이 큰 경우, 두 번째로 큰 값이므로 second에 해당 값을 넣어준다.           반복이 완료되면 max가 second의 두 배 보다 큰 값인지 검증하여 큰 경우 index를, 아니면 -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/largest-number-at-least-twice-of-others/",
        "teaser": null
      },{
        "title": "Leetcode Java Shortest Completing Word",
        "excerpt":"문제  Link   코드  class Solution {    public String shortestCompletingWord(String licensePlate, String[] words) {     int[] licenseChars = this.getCharCounts(licensePlate);     String result = null;     for (String word : words) {       if ((result == null || result.length() &gt; word.length()) &amp;&amp; this.isCompletingWord(licenseChars, this.getCharCounts(word))) {         result = word;       }     }     return result;   }    private boolean isCompletingWord(int[] licenseChars, int[] wordChars) {     for (int idx = 0; idx &lt; 26; idx++) {       if (licenseChars[idx] != 0 &amp;&amp; licenseChars[idx] &gt; wordChars[idx]) {         return false;       }     }     return true;   }    private int[] getCharCounts(String s) {     int[] charCounts = new int[26];     for (char c : s.toCharArray()) {       if (Character.isLetter(c)) {         charCounts[Character.toLowerCase(c) - 'a']++;       }     }     return charCounts;   }  }   결과  Link   설명     wordChars에서 licensePlate에 존재하는 영문자가 모두 포함된 최소 길이의 문자열을 찾아 반환하는 문제이다.            정답이 여러 개인 경우, 첫 번째로 일치하는 문자열을 반환한다.           문자열에 포함된 영문자의 개수를 반환하는 getCharCounts(String s) 메서드를 먼저 정의한다.            charCounts는 영문자의 개수를 저장하기 위한 배열로, 영문자의 수인 26 크기로 초기화한다.       s의 모든 단어를 반복하여 영문자에 해당하는 경우, 소문자로 변경하여 charCounts에 ‘a’는 0부터 ‘z’는 25까지 위치에 넣어준다.       모든 영문자 개수를 저장한 charCounts를 반환한다.           licensePlate에 존재하는 문자들이 wordChars 내 특정 문자열에 모두 포함되었는지 검증하기 위한 isCompletingWord(int[] licenseChars, int[] wordChars) 메서드를 완성한다.            영문자의 크기인 0부터 26 미만까지 idx를 증가시키며 아래를 검증한다.                    licenseChars의 idx번째 값이 0이 아니면서 licenseChars의 idx번째 문자의 개수가 wordChars의 idx번째 문자 개수보다 큰 경우, licensePlate의 모든 영문자가 word에 포함되어 있지 않으므로 false를 반환한다.                       반복이 완료되면 모두 포함된 경우이므로, true를 반환한다.           문제 풀이에 필요한 변수를 정의한다.            licenseChars는 licensePlate 내 포함된 영문자의 개수를 저장할 변수로, 2번에서 정의한 getCharCounts(String s) 메서드를 수행한 결과를 넣어준다.       result는 주어진 조건을 만족하는 최소 길이의 문자열을 저장할 변수로, null로 초기화한다.           words의 모든 단어를 word에 넣어 아래를 반복 수행한다.            아래의 조건을 모두 만족하는 경우, word가 기존보다 더 짧은 첫 문자열이므로 result에 word를 넣어준다.                    reulst가 null인 첫 단어이거나 result의 길이가 word보다 더 긴 단어인 경우.           licenseChars와 word를 이용하여 2번에서 정의한 getCharCounts(String s) 메서드를 수행한 결과를 3번에서 정의한 isCompletingWord(int[] licenseChars, int[] wordChars) 메서드를 수행한 결과가 true인 모두 포함된 단어로 검증된 경우.                           반복이 완료되면 조건을 만족하는 문자열인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/shortest-completing-word/",
        "teaser": null
      },{
        "title": "Leetcode Java Open the Lock",
        "excerpt":"문제  Link   코드  class Solution {    public int openLock(String[] deadends, String target) {     Set&lt;String&gt; start = new HashSet&lt;&gt;();     start.add(\"0000\");     Set&lt;String&gt; end = new HashSet&lt;&gt;();     end.add(target);     Set&lt;String&gt; checked = new HashSet&lt;&gt;(Arrays.asList(deadends));     int step = 0;     while (!start.isEmpty() &amp;&amp; !end.isEmpty()) {       Set&lt;String&gt; temp = new HashSet&lt;&gt;();       for (String curr : start) {         if (end.contains(curr)) {           return step;         } else if (checked.contains(curr)) {           continue;         } else {           checked.add(curr);           temp.addAll(this.getNexts(curr));         }       }       step++;       start = end;       end = temp;     }     return -1;   }    private List&lt;String&gt; getNexts(String lock) {     List&lt;String&gt; locks = new ArrayList&lt;&gt;();     char[] charArray = lock.toCharArray();     for (int idx = 0; idx &lt; charArray.length; idx++) {       char c = charArray[idx];       charArray[idx] = c == '9' ? '0' : (char) (c + 1);       locks.add(String.valueOf(charArray));       charArray[idx] = c == '0' ? '9' : (char) (c - 1);       locks.add(String.valueOf(charArray));       charArray[idx] = c;     }     return locks;   }  }   결과  Link   설명     0 ~ 9 까지로 이루어져 있는 원형 자물쇠의 잠금을 해제하기 위해 휠을 돌리는 최소 횟수를 구하는 문제이다.            단, 해제가 불가능한 경우 -1을 반환한다.       잠금은 초기 상태인 ‘0000’에서 시작한다.       잠금의 해제 도중 deadends에 포함된 번호에 도달하면 잠금 해제가 불가능한 경우로 취급한다.           문제 풀이에 필요한 변수를 정의한다.            start는 자물쇠 잠금 해제 시 시작할 번호를 저장할 변수로, 초기 값인 “0000”을 넣은 HashSet으로 초기화한다.       end는 자물쇠 잠금 해제 시 종료될 번호를 저장할 변수로, 비밀번호인 target을 넣은 HashSet으로 초기화한다.       checked는 이미 확인한 번호를 저장할 변수로, 사용 불가 번호인 deadends를 넣은 HashSet으로 초기화한다.       step은 최소 이동 횟수를 저장할 변수로, 0으로 초기화한다.           start와 end가 비어있지 않을 때 까지 아래를 반복한다.            임시 번호를 저장할 temp를 HashSet으로 초기화한다.       start의 모든 값을 순차적으로 curr에 넣어 아래를 수행한다.                    curr의 값이 end에 포함되는 경우 종료 위치에 도달했으므로, step을 주어진 문제의 결과로 반환한다.           위의 경우가 아니면서 curr의 값이 checked에 포함되는 경우 무시해야하므로, 다음 반복을 수행한다.           그 외의 경우, checked에 curr을 넣고 4번에서 정의한 getNexts(String lock) 메서드를 이용하여 다음에 검증할 번호들을 temp에 모두 넣고 반복을 계속 수행한다.                       반복이 완료되면 수행이 완료되었으므로 아래를 수행하고 반복을 계속 수행한다.                    한 순서를 사용했으므로, 휠을 돌리는 최소 횟수인 step을 증가시킨다.           start를 end로 바꾸어주고, end를 temp로 바꾸어준다.                           현재 번호에서 탐색하기 위해 다음 번호들을 생성하는 getNexts(String lock) 메서드를 정의한다.            수행을 위한 변수를 정의한다.                    locks는 다음 번호들을 저장할 변수로, ArrayList로 초기화한다.           charArray는 현재 번호인 lock을 문자 배열로 저장한 변수이다.                       0부터 charArray의 길이 미만까지 idx를 증가시키며 아래를 반복한다.                    c에 charArray의 idx번째 문자를 넣어준다.           c가 ‘9’인 경우 ‘0’으로 바꾸어주고, 그렇지 않으면 다음 번호로 증가시켜 charArray의 idx번째 위치에 넣어준 후 locks에 charArray를 문자열로 변환하여 저장한다.           위와 동일하게 c가 ‘0’인 경우 ‘9’로 바꾸어주고, 그렇지 않으면 아래 번호로 감소시켜 charArray의 idx번째 위치에 넣어준 후 locks에 charArray를 문자열로 변환하여 저장한다.           charArray의 idx번째 문자에 c를 넣어 원복시켜준다.                       반복이 완료되면 다음 번호들이 저장된 locks를 반환한다.           해설     3번의 반복의 마지막에서 “start를 end로 바꾸어주고, end를 temp로 바꾸어준다.”의 의미는 2-end BFS를 수행하는 것이다.   2-end BFS란 아래의 사진을 보면서 설명하겠다.    보라색 지점에서 녹청색 지점으로 가기 위해서 최단 경로를 탐색하기 위해서 각 지점에서 BFS를 수행한다.   각 포인트에서 BFS를 수행하다보면 최소 경로가 되기 위한 노란색 접점이 발생하게 되며, 이 부분이 최단 경로가 되기 위한 지점이 된다.   이는 3번의 반복에서 “curr의 값이 end에 포함되는 경우 종료 위치에 도달”의 내용과 같이, 두 외각 지점의 접점이 존재하는 경우이므로 해당 횟수가 최소 횟수가 되는 것이다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/open-the-lock/",
        "teaser": null
      },{
        "title": "Leetcode Java Reach a Number",
        "excerpt":"문제  Link   코드  class Solution {    public int reachNumber(int target) {     target = Math.abs(target);     int numMoves = 0;     while (target &gt; 0) {       target -= ++numMoves;      }     if (target != 0 &amp;&amp; target % 2 != 0) {       while (target % 2 != 0) {         target -= ++numMoves;       }     }     return numMoves;   }  }   결과  Link   설명     0에서 시작하여 target까지 가기 위한 최소한의 이동 횟수를 구하는 문제이다.            이동은 좌측(-) 혹은 우측(+)으로 이동이 가능하다.       각 이동은 1부터 점층적으로 증가하는 숫자만큼 이동이 가능하다.                target에 target의 절댓값을 넣어준다.            numMoves를 0으로 초기화 하고, target이 0 이상일 때 까지 numMoves 증가시키고 target에서 빼준다.       target이 0이 아니면서, 홀수인 경우 정확히 target에 도달하지 못하므로 아래를 수행한다.            target이 짝수가 될 때까지 3번과 동일하게 numMoves 증가시키고 target에서 빼주어 이동 횟수를 계산한다.           계산된 최소 이동 횟수인 numMoves를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reach-a-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Pyramid Transition Matrix",
        "excerpt":"문제  Link   코드  class Solution {    public boolean pyramidTransition(String bottom, List&lt;String&gt; allowed) {     Map&lt;String, List&lt;Character&gt;&gt; map = new HashMap&lt;&gt;();     for (String s : allowed) {       String key = s.substring(0, 2);       map.putIfAbsent(key, new ArrayList&lt;&gt;());       map.get(key).add(s.charAt(2));     }     return this.dfs(map, bottom + \"&amp;\", new HashSet&lt;&gt;());   }    private boolean dfs(Map&lt;String, List&lt;Character&gt;&gt; map, String s, Set&lt;String&gt; set) {     if (s.length() == 1) {       return true;     }     if (set.contains(s)) {       return false;     }     String prefix = s.substring(0, 2);     if (prefix.charAt(1) == '&amp;') {       return this.dfs(map, s.substring(2) + '&amp;', set);     }     for (char c : map.getOrDefault(prefix, new ArrayList&lt;&gt;())) {       if (this.dfs(map, s.substring(1) + c, set)) {         return true;       }     }     set.add(s);     return false;   }  }   결과  Link   설명     가장 밑 바닥이 bottom으로 시작하는 피라미드를 allowed 내 삼각형을 이용하여 완성 가능한지 검증하는 문제이다.            allowed[i] = “ABC”인 경우, 좌측의 “A”와 우측의 “B” 블록 위에 “C” 블록이 있는 삼각형을 나타낸다.                삼각형의 패턴을 저장할 map을 HashMap으로 초기화 하고, allowed의 모든 값을 이용하여 앞의 두 문자가 키이고 삼각형의 윗 블록인 마지막 문자가 값으로 넣어준다.            4번에서 정의한 dfs(Map&lt;String, List&gt; map, String s, Set set) 메서드에 위의 map과 bottom에 피라미드 층간 구분 기호인 '&amp;', 새 HashMap을 이용하여 수행한 결과를 주어진 문제의 결과로 반환한다.       DFS 방식으로 피라미드가 완성 가능한지 검증하기 위한 dfs(Map&lt;String, List&gt; map, String s, Set set) 메서드를 정의한다.            s의 길이가 1인 경우, 구분 기호인 ‘&amp;’인 경우이므로 true를 반환한다.       set에 s가 포함된 경우, 이미 포함되지 않는 것으로 검증된 패턴이므로 false를 반환한다.       prefix에 s의 앞 두 문자열을 넣어준다.       prefix의 두 번째 문자가 구분 기호인 ‘&amp;’인 경우, s의 앞 두 문자를 제거하고 ‘&amp;’ 구분 문자를 붙여 재귀 호출한 겨로가를 반환한다.       map의 prefix의 값을 가져와 c에 각각 넣어 아래를 반복한다.                    s의 첫 문자를 제거하고 c를 붙여 재귀 호출한 결과가 true인 경우, 피라미드에 포함되는 문자열 이므로 true를 반환한다.                       위의 수행에 포함되지 않으면 s를 set에 넣어 피라미드에 포함되지 않는 문자열임을 저장한 후, false를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/pyramid-transition-matrix/",
        "teaser": null
      },{
        "title": "Leetcode Java Set Intersection Size At Least Two",
        "excerpt":"문제  Link   코드  class Solution {    public int intersectionSizeTwo(int[][] intervals) {     Arrays.sort(intervals, (a, b) -&gt; a[1] != b[1] ? a[1] - b[1] : b[0] - a[0]);     int start = intervals[0][1] - 1;     int end = intervals[0][1];     int size = 2;     for (int idx = 1; idx &lt; intervals.length; idx++) {       if (intervals[idx][0] &gt; start &amp;&amp; intervals[idx][0] &lt;= end) {         start = end;         end = intervals[idx][1];         size++;       } else if (intervals[idx][0] &gt; end) {         start = intervals[idx][1] - 1;         end = intervals[idx][1];         size += 2;       }     }     return size;   }  }   결과  Link   설명     정수 구간을 저장한 intervals의 각 구간 별 최소 두 개의 정수를 가지는 가장 작은 집합의 크기를 구하는 문제이다.            intervals[i] = [starti, endi] 이며, 정수의 시작과 끝의 구간을 나타낸다.           intervals를 아래의 조건으로 정렬한다.            구간의 종료 위치가 동일하지 않은 경우, 종료 위치가 빠른 순서로 정렬한다.       구간의 종료 위치가 동일한 경우, 시작 위치가 늦은 순서로 정렬한다.           문제 풀이에 필요한 변수를 정의한다.            start는 이전 시작 위치를 저장할 변수로, intervals의 첫 구간의 시작 위치로 초기화한다.       end는 이전 종료 위치를 저장할 변수로, intervals의 첫 구간의 종료 위치로 초기화한다.       size는 가장 작은 집합의 크기를 저장할 변수로, 앞의 두 값이 포함되었으므로 2로 초기화한다.           첫 값은 변수 초기화에 사용하였으므로, 1부터 intervals의 길이 미만까지 idx를 증가시키며 아래를 반복한다.            intervals의 idx번째 구간의 시작 위치가 start 보다 크고, 종료 위치가 end보다 작거나 같으면 아래를 수행한다.                    start에 end를 넣어 시작 위치를 변경한다.           end에 intervals의 idx번째 구간의 종료 위치를 넣어 종료 위치를 변경한다.           하나의 겹치는 구간이 발생하므로, size는 1만 증가시킨다.                       위의 경우가 아니면서 intervals의 idx번째 구간의 시작 위치가 end보다 크면 구간이 겹치지 않으므로 아래를 수행한다.                    start에 intervals의 idx번째 구간의 종료 위치보다 1 작은 값을 넣어준다.           end에 intervals의 idx번째 구간의 종료 위치를 넣어준다.           구간이 겹치는 구간이 없으므로, 이전 구간에 2개의 값을 추가하여 size를 2 증가시킨다.                           반복이 완료되면 조건을 충족하는 최소 집합의 크기인 size를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/set-intersection-size-at-least-two/",
        "teaser": null
      },{
        "title": "Leetcode Java Prime Number of Set Bits in Binary Representation",
        "excerpt":"문제  Link   코드  class Solution {    public int countPrimeSetBits(int left, int right) {     Set&lt;Integer&gt; primes = new HashSet&lt;&gt;(Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19));     int count = 0;     for (int idx = left; idx &lt;= right; idx++) {       int bits = 0;       for (int n = idx; n &gt; 0; n &gt;&gt;= 1) {         bits += n &amp; 1;       }       if (primes.contains(bits)) {         count++;       }     }     return count;   }  }   결과  Link   설명          left에서 right까지 각 숫자를 이진수로 표현할 때 1의 개수가 소수인 숫자의 개수를 계산하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            primes는 소수를 넣어 저장할 변수로, 2 ~ 19까지 소수를 넣어 저장한다.                    left와 right의 범위는 $1 &lt;= left &lt;= right &lt;= 10^6$ 이다.           $10^6 = (10^3)^2 &lt; (2^{10})^2 = 2^{20}$를 만족하므로 이진수로 변환할 경우의 최대 길이는 20이다.           그렇기 때문에 20 이상의 소수는 저장할 필요가 없으므로, 19까지 넣어준다.                       count는 이진 표현법 내 소수인 숫자의 개수를 저장할 변수로, 0으로 초기화한다.           left부터 right까지 idx를 증가시키며 아래를 반복한다.            bits는 1의 개수를 저장할 변수로, 0으로 초기화한다.       idx부터 0 초과일때 까지 n의 비트를 우측으로 하나씩 이동시키며 bits에 1의 개수를 저장한다.       primes에 bits가 포함되는 경우, count를 증가시킨다.           반복이 완료되면 조건을 만족하는 숫자의 개수인 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/prime-number-of-set-bits-in-binary-representation/",
        "teaser": null
      },{
        "title": "Leetcode Java Partition Labels",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; partitionLabels(String s) {     char[] charArray = s.toCharArray();     int length = charArray.length;     int[] last = new int[26];     for (int idx = 0; idx &lt; length; idx++) {       last[charArray[idx] - 'a'] = idx;     }     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     int start = 0;     int end = 0;     for (int idx = 0; idx &lt; length; idx++) {       int index = last[charArray[idx] - 'a'];       if (index &gt; end) {         end = index;       }       if (end == idx) {         result.add(end - start + 1);         start = end + 1;       }     }     return result;   }  }   결과  Link   설명          s의 문자열을 최대한 같은 문자열끼리 묶어 가능한 많은 부분 문자열로 분리할 때, 각 문자열의 길이를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            charArray는 s를 문자 배열로 변환하여 저장하는 변수이다.       length는 charArray의 길이를 저장하는 변수이다.       last는 charArray의 각 문자 별 마지막 위치를 담기 위한 변수로, 알파벳 개수인 26 크기로 정의하고 charArray를 반복하여 last에 각 문자 별 마지막 위치를 넣어준다.       result는 분리한 문자열의 길이를 저장할 변수로, ArrayList로 초기화한다.       start와 end는 각 부분 문자열을 분리하기 위해 사용될 위치 변수로, 모두 0으로 초기화한다.           0부터 length까지 idx를 증가시키며 아래를 수행한다.            index에 charArray의 idx번째 문자의 마지막 위치 값을 last에서 찾아 넣어준다.       index가 end보다 큰 경우, end에 index를 넣어 종료 위치를 갱신시켜준다.       end와 idx가 동일하면 해당 위치까지 부분 문자열로 자를 수 있으므로 아래를 수행한다.                    result에 $end - start + 1$인 부분 문자열의 길이를 넣어준다.           start에 $end + 1$인 다음 문자 위치를 넣어 다음 부분 문자열 계산을 준비한다.                           반복이 완료되면 부분 문자열의 길이가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/partition-labels/",
        "teaser": null
      },{
        "title": "Leetcode Java Largest Plus Sign",
        "excerpt":"문제  Link   코드  class Solution {    public int orderOfLargestPlusSign(int n, int[][] mines) {     int[][] grid = new int[n][n];     for (int[] row : grid) {       Arrays.fill(row, n);     }     for (int[] mine : mines) {       grid[mine[0]][mine[1]] = 0;     }     for (int i = 0; i &lt; n; i++) {       int[] direction = new int[] { 0, 0, 0, 0 };       for (int j = 0, k = n - 1; j &lt; n; j++, k--) {         grid[i][j] = Math.min(grid[i][j], direction[0] = (grid[i][j] == 0 ? 0 : direction[0] + 1));         grid[i][k] = Math.min(grid[i][k], direction[1] = (grid[i][k] == 0 ? 0 : direction[1] + 1));         grid[j][i] = Math.min(grid[j][i], direction[2] = (grid[j][i] == 0 ? 0 : direction[2] + 1));         grid[k][i] = Math.min(grid[k][i], direction[3] = (grid[k][i] == 0 ? 0 : direction[3] + 1));       }     }     int result = 0;     for (int i = 0; i &lt; n; i++) {       for (int j = 0; j &lt; n; j++) {         result = Math.max(result, grid[i][j]);       }     }     return result;   }  }   결과  Link   설명     $n \\times n$ 크기의 배열 내 지뢰의 좌표인 mines를 피해서 만들 수 있는 상하좌우의 길이가 동일한 ‘+’ 기호의 중심으로부터 최대 길이를 구하는 문제이다.            배열 내 빈 칸은 1로, 지뢰는 0으로 표기한다.           grid는 주어진 배열을 구성하기 위한 변수로, $n \\times n$ 크기로 초기화 하고 아래를 수행한다.            grid의 모든 값에 임의 큰 숫자인 n을 넣어준다.       grid 내 mines의 모든 위치에 0을 넣어준다.           0부터 n까지 i를 증가시키며 direction 배열을 좌, 우, 상, 하 순으로 0으로 초기화시키고 아래를 반복한다.            j는 0부터 n 미만까지 증가시키고, k는 $n - 1$부터 감소시키며 아래를 반복하여 사방면으로 검증을 수행한다.                    grid[i][j]의 값에 해당 값과 grid[i][j]의 값이 0인 지뢰인 값인지 검증하여 지뢰의 경우 direction[0]을 0으로 초기화시키고, 아니면 direction[0]을 증가시킨 값 중 작은 값을 넣어 위에서 우측으로 최대 길이 계산을 수행한다.           grid[i][k]의 값에 해당 값과 grid[i][k]의 값이 0인 지뢰인 값인지 검증하여 지뢰의 경우 direction[1]을 0으로 초기화시키고, 아니면 direction[1]을 증가시킨 값 중 작은 값을 넣어 위에서 좌측으로 최대 길이 계산을 수행한다.           grid[j][i]의 값에 해당 값과 grid[j][i]의 값이 0인 지뢰인 값인지 검증하여 지뢰의 경우 direction[2]을 0으로 초기화시키고, 아니면 direction[2]을 증가시킨 값 중 작은 값을 넣어 좌측에서 아래로 최대 길이 계산을 수행한다.           grid[k][i]의 값에 해당 값과 grid[k][i]의 값이 0인 지뢰인 값인지 검증하여 지뢰의 경우 direction[3]을 0으로 초기화시키고, 아니면 direction[3]을 증가시킨 값 중 작은 값을 넣어 우측에서 위로 최대 길이 계산을 수행한다.                                결과를 넣어줄 result에 grid 내 모든 값 중 최댓 값인 ‘+’ 기호의 중심으로부터 최대 길이를 넣어준다.       4번을 통해 찾은 최대 길이인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/largest-plus-sign/",
        "teaser": null
      },{
        "title": "Leetcode Java Toeplitz Matrix",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isToeplitzMatrix(int[][] matrix) {     for (int i = 0; i &lt; matrix.length - 1; i++) {       for (int j = 0; j &lt; matrix[i].length - 1; j++) {         if (matrix[i][j] != matrix[i + 1][j + 1]) {           return false;         }       }     }     return true;   }  }   결과  Link   설명          $m \\times n$ 크기의 matrix가 Toeplitz matrix인지 검증하는 문제이다.            Toeplitz matrix는 좌측 아래로 이어지는 대각선 상 존재하는 모든 값이 동일한 숫자로 존재해야 하므로, 모든 값을 반복하여 좌측 하단의 값이 동일하지 않으면 false를 주어진 문제의 결과로 반환한다.            검증이 완료되면 Toeplitz matrix이므로, true를 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/toeplitz-matrix/",
        "teaser": null
      },{
        "title": "Leetcode Java Reorganize String",
        "excerpt":"문제  Link   코드  class Solution {    public String reorganizeString(String s) {     int length = s.length();     int[] hash = new int[26];     for (char c : s.toCharArray()) {       hash[c - 'a']++;     }     int letter = 0;     int count = 0;     for (int idx = 0; idx &lt; hash.length; idx++) {       if (hash[idx] &gt; count) {         letter = idx;         count = hash[idx];       }     }     if (count &gt; (length + 1) / 2) {       return \"\";     }     char[] result = new char[length];     int index = 0;     while (hash[letter] &gt; 0) {       result[index] = (char) (letter + 'a');       index += 2;       hash[letter]--;     }     for (int idx = 0; idx &lt; hash.length; idx++) {       while (hash[idx] &gt; 0) {         if (index &gt;= length) {           index = 1;         }         result[index] = (char) (idx + 'a');         index += 2;         hash[idx]--;       }     }     return String.valueOf(result);   }  }   결과  Link   설명     s의 문자들이 동일한 문자가 붙지 않도록 재 정렬해서 반환하는 문제이다.            동일한 문자가 붙을 수 밖에 없는 경우, 빈 문자열인 ““을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            length는 s의 길이를 저장한 변수이다.       counts는 s의 각 문자 별 발생 횟수를 저장할 변수로, s의 각 문자를 반복하여 개수를 계산해준다.       letter와 count는 가장 많이 발생한 문자의 위치와 개수를 저장할 변수로, counts를 반복하여 가장 많이 발생한 문자의 위치와 개수를 저장해준다.                    count가 length의 절반 이상인 경우, 동일한 문자가 반드시 붙으므로 ““을 주어진 문제의 결과로 반환한다.                       result는 결과 문자열을 만들기 위한 배열로, length 길이의 문자 배열로 초기화한다.       index는 result에 문자를 순차적으로 넣기 위한 위치 변수로, 0으로 초기화한다.           counts의 letter 문자의 개수가 0 초과일 때까지 아래를 반복한다.            result의 index번째 위치에 letter를 영문자로 변환하여 넣어준다.       index를 2씩 증가시켜 같은 문자가 붙지 않도록 띄어 넣어준다.       letter번째 영문자를 사용했으므로, counts 내 개수를 차감해준다.           0부터 counts의 길이까지 idx를 증가시키며 아래를 반복하여 문자열을 완성한다.            counts의 idx번째 문자의 개수가 0 초과일 때 까지 아래를 반복한다.                    index가 result의 길이를 초과하는 경우, 이미 들어간 문자 사이에 넣도록 index를 1로 초기화해준다.           result의 index번째 위치에 idx를 영문자로 변환하여 넣어준다.           index를 2씩 증가시켜 같은 문자가 붙지 않도록 띄어 넣어준다.           idx번째 영문자를 사용했으므로, counts 내 개수를 차감해준다.                           반복이 완료되면 result를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reorganize-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Max Chunks To Make Sorted II",
        "excerpt":"문제  Link   코드  class Solution {    public int maxChunksToSorted(int[] arr) {     int length = arr.length;     int[] dp = new int[length];     dp[0] = arr[0];     for (int idx = 1; idx &lt; length; idx++) {       dp[idx] = Math.max(dp[idx - 1], arr[idx]);     }     int result = 1;     int min = arr[length - 1];     for (int idx = length - 2; idx &gt;= 0; idx--) {       if (dp[idx] &lt;= min) {         result++;       }       min = Math.min(min, arr[idx]);     }     return result;   }  }   결과  Link   설명          arr내 부분 배열로 나눌 때, 부분 배열을 각각 정렬해서 이어준 결과와 기존 배열을 정렬한 결과가 동일하기 위한 최대 부분 배열의 수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 arr의 길이를 저장한 변수이다.       dp는 arr의 좌측부터 현재 위치까지 최대 값을 저장하기 위한 배열로, arr의 좌측부터 우측까지 이동하며 현재 위치까지의 최댓 값을 위치 별 저장한다.       result는 부분 배열의 수를 저장하기 위한 변수로, 최소 개수인 1로 초기화한다.       min은 최솟값을 저장할 변수로, arr의 마지막 값을 넣어준다.           $length - 2$부터 0 이상까지 idx를 감소시키며, 우측에서 좌측으로 이동하며 아래를 반복한다.            dp의 idx번째 값이 min보다 작거나 같은 경우, 부분 배열의 수인 result를 증가시켜준다.                    위를 만족하는 경우, 우측으로 점층적으로 증가하는 오름차순 정렬을 만족한다.           그렇기 때문에 최대 부분 배열의 수를 만족하기 위해서 한 숫자 씩 분리해서 부분 배열로 저장시키는 것이다.                       min에 현재 위치까지 가장 작은 수를 넣어 준다.           반복이 완료되면 최대 부분 배열의 수를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/max-chunks-to-make-sorted-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Max Chunks To Make Sorted",
        "excerpt":"문제  Link   코드  class Solution {    public int maxChunksToSorted(int[] arr) {     int max = 0;     int result = 0;     for (int idx = 0; idx &lt; arr.length; idx++) {       max = Math.max(max, arr[idx]);       if (max == idx) {         result++;       }     }     return result;   }  }   결과  Link   설명          지난 번 Max Chunks To Make Sorted II와 비슷한 문제로 [0, n - 1] 범위의 길이 n의 정수 배열인 arr을 부분 배열로 나눌 때, 부분 배열을 각각 정렬해서 이어준 결과와 기존 배열을 정렬한 결과가 동일하기 위한 최대 부분 배열의 수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            max는 최댓 값을 저장할 변수로, 0으로 초기화한다.       result는 최대 부분 배열의 수를 저장할 변수로, 0으로 초기화한다.           0부터 arr의 길이 전까지 idx를 증가시키며 아래를 반복한다.            max에 현재 위치까지 가장 큰 값을 임시 저장시킨다.       max와 idx가 동일하면 정렬된 위치와 같아 하나의 부분 배열로 분리 가능하므로, result를 증가시킨다.           반복이 완료되면 최대 부분 배열의 수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/max-chunks-to-make-sorted/",
        "teaser": null
      },{
        "title": "Leetcode Java Jewels and Stones",
        "excerpt":"문제  Link   코드  class Solution {    public int numJewelsInStones(String jewels, String stones) {     int count = 0;     for (char c : stones.toCharArray()) {       if (jewels.indexOf(c) != -1) {         count++;       }     }     return count;   }  }   결과  Link   설명          보석의 종류인 jewels를 이용하여 stones 내 몇 개의 보석이 포함되었는지 찾는 문제이다.            count는 stones 내 보석의 개수를 저장할 변수이다.            stones의 모든 문자들을 이용하여 jewels에 포함된 단어가 있으면 count를 증가시킨다.            반복이 완료되면 stones 내 보석의 개수인 count를 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/jewels-and-stones/",
        "teaser": null
      },{
        "title": "Leetcode Java Global and Local Inversions",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isIdealPermutation(int[] nums) {     int max = 0;     for (int idx = 0; idx &lt; nums.length - 2; idx++) {       max = Math.max(max, nums[idx]);       if (max &gt; nums[idx + 2]) {         return false;       }     }     return true;   }  }   결과  Link   설명     [0, n - 1] 범위의 값을 담은 num를 이용하여 아래의 규칙대로 수행되는 Global Inversions의 수와 Local Inversions의 수가 동일한지 검증하는 문제이다.            Global Inversions의 수는 아래의 조건을 만족하는 (i, j)의 다른 쌍의 수이다.                    0 &lt;= i &lt; j &lt; n           nums[i] &gt; nums[j]                       Local Inversions의 수는 아래의 조건을 만족하는 인덱스 i의 수이다.                    0 &lt;= i &lt; n - 1           nums[i] &gt; nums[i + 1]                                max는 가장 큰 값을 저장할 변수로, 0으로 초기화한다.       0부터 nums의 길이보다 2 작은 크기 미만으로 idx를 증가시키며 아래를 반복한다.            max에 max와 nums의 idx번째 값 중 큰 값을 저장한다.       max와 nums의 $idx + 2$번째 값 중 max가 큰 경우, 두 Inversions의 수가 다르므로 false를 반환한다.                    모든 Local Inversions는 Global Inversions를 만족하므로, 두 수가 같다는 의미는 Global Inversions 또한 Local Inversions를 만족한다는 의미이다.           그렇기 때문에 $i + 2 &lt;= j$일때 nums[i] &gt; nums[j]를 찾을 수 없다는 의미가 된다.           즉, nums의 idx번째 값까지의 가장 큰 값이 $idx + 2$번째 값보다 크게되는 경우, 두 Inversions의 수가 다르게된다.                           반복이 완료되면 두 Inversions의 수가 같으므로, true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/global-and-local-inversions/",
        "teaser": null
      },{
        "title": "Leetcode Java Swap Adjacent in LR String",
        "excerpt":"문제  Link   코드  class Solution {    public boolean canTransform(String start, String end) {     char[] startCharArray = start.toCharArray();     char[] endCharArray = end.toCharArray();     int length = startCharArray.length;     int next = 1;     for (int idx = 0; idx &lt; length; idx++) {       if (startCharArray[idx] == endCharArray[idx]) {         continue;       }       if ((startCharArray[idx] == 'R' &amp;&amp; endCharArray[idx] == 'X')           || (endCharArray[idx] == 'L' &amp;&amp; startCharArray[idx] == 'X')) {         next = Math.max(next, idx + 1);         while (next &lt; length &amp;&amp; startCharArray[next] == startCharArray[idx]) {           next++;         }         if (next == length || startCharArray[next] != endCharArray[idx]) {           return false;         }         startCharArray[next] = startCharArray[idx];       } else {         return false;       }     }     return true;   }  }   결과  Link   설명     ‘L’, ‘R’, ‘X’ 로 이루어진 start를 아래의 규칙대로 변환되는 문자열이 end에 존재하는지 검증하는 문제이다.            “XL”를 “LX”로 변환.       “RX”를 “XR”로 변환.           문제 풀이에 필요한 변수를 정의한다.            startCharArray는 start를 문자 배열로 변환하여 저장한 변수이다.       endCharArray는 end를 문자 배열로 변환하여 저장한 변수이다.       length는 startCharArray의 길이를 저장한 변수이다.       next는 다음 위치를 지정할 위치 변수로, 처음 시작하는 0보다 큰 1로 초기화한다.           0부터 length까지 idx를 증가시키며 아래를 반복한다.            startCharArray의 idx번째 문자와 endCharArray의 idx번째 문자가 동일한 경우, 다음 위치로 반복을 계속 수행한다.       startCharArray의 idx번째 문자가 ‘R’이면서 endCharArray의 idx번째 문자가 ‘X’이거나 endCharArray의 idx번째 문자가 ‘L’이면서 startCharArray의 idx번째 문자가 ‘X’인 경우 아래를 수행한다.                    next에 next와 $idx + 1$ 중 큰 값을 넣어준다.           next가 length 미만이면서 startCharArray의 next번째 문자가 startCharArray의 idx번째 문자와 동일할 때 까지 next를 계속 증가시킨다.           next가 length와 동일한 마지막 위치거나 startCharArray의 next번째 문자가 startCharArray의 idx번째 문자가 달라 변환이 가능한 경우, false를 주어진 문제의 결과로 반환한다.           startCharArray의 next번째 문자에 idx번째 문자를 넣어 확인한 문자를 제거한다.                       위의 경우가 아니라면 변환 가능한 문자가 이어지므로, false를 주어진 문제의 결과로 반환한다.           반복이 완료되면 모든 변환 가능한 문자가 없으므로, true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/swap-adjacent-in-lr-string/",
        "teaser": null
      },{
        "title": "Leetcode Java K-th Symbol in Grammar",
        "excerpt":"문제  Link   코드  class Solution {    public int kthGrammar(int n, int k) {     if (n == 1) {       return 0;     } else if (k % 2 == 0) {       return 1 - this.kthGrammar(n - 1, k / 2);     } else {       return this.kthGrammar(n - 1, (k + 1) / 2);     }   }  }   결과  Link   설명     1-indexed의 n개의 행으로 이루어진 테이블에서 k번째 값을 반환하는 문제이다.            이전 행에서 0을 01로, 1을 10으로 변경해서 다음 행을 구성한다.       예를 들어 n이 3인 경우 테이블은 아래의 사진과 동일한 트리 형태인 테이블로 구성된다.             아래의 각 경우에 따라 값을 반환한다.            n이 1인 경우, 처음 값은 무조건 0이므로 0을 반환한다.       k가 짝수인 경우, 1에서 $n - 1$과 $\\frac{k}{2}$를 이용하여 재귀 호출 한 값을 빼서 반환한다.       k가 홀수인 경우, $n - 1$과 $\\frac{k + 1}{2}$를 이용하여 재귀 호출 한 값을 반환한다.           해설     F($n - 1$)을 사용해서 F(n)의 값을 탐색하는 방식이다.   즉, 짝수 인덱스의 경우 값을 재귀 호출의 값을 반전시킨 값을 통해 지속 탐색한 결과가 해당 위치의 값이 된다.            0과 1의 경우, 1에서 빼면 값은 반전된다.           홀수 인덱스의 경우 재귀 호출을 통해 지속 탐색된 결과가 해당 위치의 값이 된다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/k-th-symbol-in-grammar/",
        "teaser": null
      },{
        "title": "Leetcode Java Reaching Points",
        "excerpt":"문제  Link   코드  class Solution {    public boolean reachingPoints(int sx, int sy, int tx, int ty) {     while (sx &lt; tx &amp;&amp; sy &lt; ty) {       if (tx &lt; ty) {         ty %= tx;       } else {         tx %= ty;       }     }     return (sx == tx &amp;&amp; sy &lt;= ty &amp;&amp; (ty - sy) % sx == 0) || (sy == ty &amp;&amp; sx &lt;= tx &amp;&amp; (tx - sx) % sy == 0);   }  }   결과  Link   설명     [sx, sy] 위치에서 아래의 규칙대로 이동하여 [tx, ty]로 도착 가능한지 검증하는 문제이다.            시작 위치에서 (x, $x + y$) 혹은 ($x + y$, y)의 크기대로 이동할 수 있다.           sx가 tx보다 크고 sy가 ty보다 클 때 까지 아래를 수행한다.            tx보다 ty가 큰 경우, ty에 tx를 나눈 나머지 값을 넣어준다.       위의 경우가 아니라면, tx에 ty를 나눈 나머지 값을 넣어준다.           반복이 완료되면 아래의 경우를 검증하여 하나라도 만족하면 true를, 아니면 false를 주어진 문제의 결과로 반환한다.            sx와 tx가 동일하면서 sy가 ty보다 작거나 같은 경우, ty에 sy를 빼서 sx를 나눈 나머지가 0인 경우.       sy가 ty와 동일하면서 sx가 tx보다 작거나 같은 경우, tx에 sx를 빼서 sy를 나눈 나머지가 0인 경우.           해설     시작 위치에서 도착 위치를 탐색하기 가장 수월한 방법은 도착 위치에서 시작 위치로 회귀 가능한지 검증하는 것이다.   그렇기 때문에 ty와 tx를 위의 규칙에 대입해 여러 번 빼서 TLE(Time Limit Exceeded)가 발생하지 않도록 나머지 값을 활용해서 각 축의 위치를 좁혀간다.   결과에서 다시 규칙을 검증하는 이유는 2번의 수행이 완료되거나 수행하지 않는 한 축의 값이 동일한 경우, x축 혹은 y축의 값 중 최소 하나만 만족하는 경우로 끝나므로 각 축에 대해서 다시 이동 가능한지 마지막으로 검증하는 것이다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reaching-points/",
        "teaser": null
      },{
        "title": "Leetcode Java Rabbits in Forest",
        "excerpt":"문제  Link   코드  class Solution {    public int numRabbits(int[] answers) {     int result = 0;     int[] count = new int[1000];     for (int answer : answers) {       if (count[answer] % (answer + 1) == 0) {         result += answer + 1;       }       count[answer]++;     }     return result;   }  }   결과  Link   설명          숲 안에 있는 n마리의 토끼에게 자신과 동일한 색상의 토끼의 수를 물어본 결과가 담긴 answers 배열을 이용하여 숲 안에 있을 최소 토끼의 수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 최소 토끼의 수를 저장하기 위한 변수로, 0으로 초기화한다.       count는 최소 토끼의 수를 계산하기 위한 배열로, answers의 최대 크기인 1000으로 초기화한다.           answers의 각 값을 answer에 넣어 아래를 반복한다.            count의 answer번째 값에 $answer + 1$을 나눈 나머지가 0인 경우, result에 $answer + 1$을 더해준다.       count의 answer번째 값을 증가시켜준다.           반복이 완료되면 최소 토끼의 수가 저장된 result를 주어진 문제의 결과로 반환한다.   해설     count 배열의 answer번째 값에 $answer + 1$의 값을 나눈 경우가 0이면, 아래의 각 경우 별 토끼의 수를 계산할 수 있다.            [1, 1]의 경우, 대답한 두 토끼는 각각 자신과 동일한 토끼가 한 마리 더 있다고 대답했으므로 대답한 두 마리의 토끼는 같은 색상인 경우가 될 수 있으므로 최소 토끼의 수는 두 마리이다.       [1, 1, 1]의 경우, 첫 번째와 세 번째 대답한 토끼는 위의 조건을 만족하는 경우로 자신과 동일한 토끼가 한 마리 더 있다고 하였으므로 첫 번째와 두 번째가 같은 색상의 토끼로 가정하고 세 번째 토끼는 자신과 같은 색상의 토끼가 있지만 그 토끼는 응답하지 않은 경우가 될 수 있으므로 최소 토끼의 수는 네 마리이다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/rabbits-in-forest/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Distance Between BST Nodes",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    private int min = Integer.MAX_VALUE;   private int pre = -1;    public int minDiffInBST(TreeNode root) {     if (root.left != null) {       this.minDiffInBST(root.left);     }     if (this.pre != -1) {       this.min = Math.min(this.min, root.val - this.pre);     }     this.pre = root.val;     if (root.right != null) {       this.minDiffInBST(root.right);     }     return this.min;   }  }   결과  Link   설명          이진 탐색 트리(BST)인 root를 이용하여 인접한 두 노드 간 값의 차이가 가장 작은 값을 구하는 문제이다.       문제 풀이에 필요한 전역 변수를 정의한다.            min은 최솟값을 저장하기 위한 변수로, 정수의 가장 큰 값을 넣어준다.       pre는 이전 값을 임시 저장할 변수로, val 값의 범위에 존재하지 않는 -1로 초기화한다.                root의 left TreeNode가 null이 아닌 경우, root의 left TreeNode를 이용하여 재귀 호출을 수행한다.            pre의 값이 -1이 아닌 경우, min에 min과 root의 val 값과 pre의 차이 중 작은 값을 저장한다.            pre에 root의 val 값을 넣어 값을 임시 저장한다.            root의 right TreeNode가 null이 아닌 경우, root의 right TreeNode를 이용하여 재귀 호출을 수행한다.       반복이 완료되면 인접한 두 노드 간 값의 차이가 가장 작은 값을 저장한 min을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-distance-between-bst-nodes/",
        "teaser": null
      },{
        "title": "Leetcode Java Letter Case Permutation",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; letterCasePermutation(String s) {     List&lt;String&gt; result = new ArrayList&lt;&gt;();     this.dfs(result, s.toCharArray(), 0);     return result;   }    private void dfs(List&lt;String&gt; result, char[] charArray, int index) {     if (index == charArray.length) {       result.add(new String(charArray));     } else if (Character.isDigit(charArray[index])) {       this.dfs(result, charArray, index + 1);     } else {       charArray[index] = Character.toLowerCase(charArray[index]);       this.dfs(result, charArray, index + 1);       charArray[index] = Character.toUpperCase(charArray[index]);       this.dfs(result, charArray, index + 1);     }   }  }   결과  Link   설명          s를 이용하여 영문 대소문자를 변환하여 만들 수 있는 모든 문자열을 만드는 문제이다.            결과를 넣을 result를 ArrayList로 초기화 시키고, 3번에서 정의한 dfs(List result, char[] charArray, int index)에 s를 문자 배열로 변환하고 index를 0으로 수행한다.       DFS 방식으로 문자열을 만들 dfs(List result, char[] charArray, int index) 메서드를 정의한다.            index가 charArray의 길이와 동일하면 문자열이 완성되었으므로, result에 charArray를 문자열로 변환하여 넣어준다.       charArray의 index번째 문자가 숫자인 경우, index를 증가시켜 재귀 호출을 수행한다.       위의 경우가 아니라면 아래를 수행한다.                    charArray의 index번째 문자를 소문자로 변환하고 index를 증가시켜 재귀 호출을 수행한다.           charArray의 index번째 문자를 대문자로 변환하고 index를 증가시켜 재귀 호출을 수행한다.                           수행이 완료되어 가능한 문자열이 들어간 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/letter-case-permutation/",
        "teaser": null
      },{
        "title": "Leetcode Java Is Graph Bipartite?",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isBipartite(int[][] graph) {     int[] sets = new int[graph.length];     for (int idx = 0; idx &lt; graph.length; idx++) {       if (sets[idx] == 0 &amp;&amp; !this.dfs(graph, sets, 1, idx)) {         return false;       }     }     return true;   }    private boolean dfs(int[][] graph, int[] sets, int set, int index) {     if (sets[index] != 0) {       return sets[index] == set;     }     sets[index] = set;     for (int node : graph[index]) {       if (!this.dfs(graph, sets, -set, node)) {         return false;       }     }     return true;   }  }   결과  Link   설명     아래의 조건을 만족하는 n개의 노드들의 정보인 graph를 이용하여 두 그룹으로 나눌 때 맨 앞과 끝의 노드가 다른 그룹으로 이어져 분리할 수 있는지를 검증하는 문제이다.            자기 자신 노드와 연결되는 노드는 없다.       한 노드에서 다음 노드로 병렬 연결된 노드는 없다.       graph[u]에 ‘v’가 포함된 경우, graph[v]에 ‘u’가 포함되어있다. (단, 방향은 지정되어 있지 않다.)       graph의 각 노드들은 연결되어 있지 않을 수 있다.           sets는 각 노드 별 아래와 같은 값의 구분을 통해 그룹을 지정할 배열로, graph의 길이 크기로 초기화한다.            ‘0’은 그룹을 지정하지 않은 노드이다.       ‘1’은 그룹 A를 의미한다.       ‘-1’은 그룹 B를 의미한다.           0부터 graph의 길이 미만까지 idx를 증가시키며 아래를 반복한다.            아래의 조건을 모두 만족하는 경우, 주어진 조건에 따른 두 그룹으로 분리할 수 없으므로 false를 주어진 문제의 결과로 반환한다.                    sets의 idx번째 값이 0인 그룹을 지정하지 않은 노드인 경우.           4번에서 정의한 dfs(graph, sets, 1, idx) 메서드의 수행 결과가 false인 분리 불가능한 노드인 경우.                           DFS 방식으로 조건에 따른 그룹 분리가 가능한지 검증하기 위한 dfs(graph, sets, 1, idx) 메서드를 정의한다.            sets의 index번째 그룹이 0이 아닌 경우, 해당 위치의 값이 set인지 검증한 결과를 반환한다.       sets의 index번째 그룹에 set을 넣어 그룹을 분류한다.       graph의 index번째 노드 정보들을 node에 넣어 아래를 반복 수행한다.                    set의 값을 다른 그룹 값으로 전환하여 재귀 호출을 수행한 결과가 false인 경우, 조건에 따른 분리가 불가능하므로 false를 반환한다.                       위의 모든 절차가 완료되면 index번째 노드의 위치에서 검증이 완료되었으므로 true를 반환한다.           3번의 반복이 완료되면 조건에 따른 분리가 가능한 것으로 검증되었으므로 true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/is-graph-bipartite/",
        "teaser": null
      },{
        "title": "Leetcode Java K-th Smallest Prime Fraction",
        "excerpt":"문제  Link   코드  class Solution {    public int[] kthSmallestPrimeFraction(int[] arr, int k) {     Queue&lt;int[]&gt; queue = new PriorityQueue&lt;int[]&gt;((a, b) -&gt; arr[a[0]] * arr[b[1]] - arr[a[1]] * arr[b[0]]);     for (int idx = 1; idx &lt; arr.length; idx++) {       queue.add(new int[] { 0, idx });     }     while (--k &gt; 0) {       int[] fraction = queue.poll();       if (fraction[0]++ &lt; fraction[1]) {         queue.add(fraction);       }     }     int[] result = queue.poll();     return new int[] { arr[result[0]], arr[result[1]] };   }  }   결과  Link   설명     arr은 아래의 규칙으로 이루어진 분수 표현법을 적용할 경우 k번째 작은 값을 찾는 문제이다.            배열 arr의 첫 값은 ‘1’이며, 양의 정수로 이루어져있다.       배열 arr의 값은 [i, …, j]로 이루어져 있으며, $0 &lt;= i &lt; j &lt; arr.length$를 만족한다.       arr은 $frac{i}{j}$의 분수로 표현 가능하며, 결과 값인 answer은 [arr[i], arr[j]] 형태의 정수 배열로 반환한다.           queue는 작은 분수 값이 가장 앞에 위치하도록 각 값의 위치 정보를 저장할 변수로, 아래의 정렬을 기반으로 한 PriorityQueue로 초기화한다.            queue 내 정수 배열 a와 b를 arr을 이용해 더 작은 값이 맨 앞으로 위치하도록 아래의 두 값의 차이가 큰 수가 앞으로 나오게 정렬하게 한다.                    arr에서 a의 분자에 해당하는 a의 첫 번째 값과 b의 분모에 해당하는 b의 두 번째 값의 곱.           arr에서 a의 분모에 해당하는 a의 두 번째 값과 b의 분자에 해당하는 b의 첫 번째 값의 곱.                                queue에 1부터 arr의 길이 미만까지 반복하여, [1, idx] 형태로 arr의 위치 값을 배열로 넣어준다.       k를 감소시키고 0보다 클 때 까지 아래를 수행한다.            fraction을 queue에서 가장 작은 값을 꺼내 넣어준다.       faction의 첫 번째 값을 증가시켰을 경우, 두 번째 값보다 작으면 1 미만의 값이므로 queue에 다시 faction을 넣어준다.           반복이 완료되면 result에 k번째 작은 분수의 값을 표현할 값을 queue에서 꺼내 넣어주고, 주어진 문제의 결과로 arr에서 result의 첫 번째 값과 result의 두 번째 값을 배열로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/k-th-smallest-prime-fraction/",
        "teaser": null
      },{
        "title": "Leetcode Java Cheapest Flights Within K Stops",
        "excerpt":"문제  Link   코드  class Solution {    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {     int[] dp = new int[n];     Arrays.fill(dp, Integer.MAX_VALUE);     dp[src] = 0;     while (k-- &gt;= 0) {       if (this.isExistsRoute(flights, dp)) {         break;       }     }     return dp[dst] == Integer.MAX_VALUE ? -1 : dp[dst];   }    private boolean isExistsRoute(int[][] flights, int[] dp) {     int[] temp = Arrays.copyOf(dp, dp.length);     boolean result = true;     for (int[] flight : flights) {       int src = flight[0];       int dst = flight[1];       int cost = flight[2];       if (temp[src] &lt; Integer.MAX_VALUE &amp;&amp; dp[dst] &gt; dp[src] + cost) {         dp[dst] = temp[src] + cost;         result = false;       }     }     return result;   }  }   결과  Link   설명     n개의 도시 중 k번 멈춰서 src에서 출발하여 dst에 도착하기 위해 가장 저렴한 가격을 찾는 문제이다.            항공편 정보가 담긴 flights는 flights[i] = [fromi, toi, pricei]를 만족한다.       가장 저렴한 가격이 없는 경우, -1을 주어진 문제의 결과로 반환한다.                dp는 최소 가격을 구하기 위해 사용할 정수 배열로, n 크기로 정의하여 첫 값은 0 나머지는 정수의 최댓값을 넣어준다.       k가 0보다 클 때 까지 k를 감소시키며 아래를 반복한다.            만일 flights와 dp를 이용하여 4번에서 정의한 isExistsRoute(int[][] flights, int[] dp) 메서드를 수행한 결과가 true이면 반복을 중지시킨다.           최소 비용을 dp에 저장하고 경로가 존재하는지 검증하기 위한 isExistsRoute(int[][] flights, int[] dp) 메서드를 정의한다.            temp에 dp를 Deep copy하여 넣어준다.       경로가 존재하는지 여부를 저장한 result를 true로 임시 저장한다.       flights의 모든 값을 flight에 넣어 아래를 반복한다.                    src와 dst, cost에 flight의 모든 값을 순차적으로 넣어준다.           temp의 src번째 값이 정수의 최댓값이면서 dp의 dst번째 값이 src번째 값과 cost를 더한 값보다 큰 경우, dp의 dst번째 위치에 temp의 src번째 값과 cost를 더한 값을 넣고 result를 false로 바꾸어준다.                       반복이 완료되면 result를 반환한다.           3번의 반복이 완료되면 dp의 dst번째 값이 정수의 최댓값인 경우 경로가 존재하지 않으므로 -1을, 존재하면 해당 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/cheapest-flights-within-k-stops/",
        "teaser": null
      },{
        "title": "Leetcode Java Escape The Ghosts",
        "excerpt":"문제  Link   코드  class Solution {    public boolean escapeGhosts(int[][] ghosts, int[] target) {     int distance = Math.abs(target[0]) + Math.abs(target[1]);     for (int[] ghost : ghosts) {       if (distance &gt;= Math.abs(target[0] - ghost[0]) + Math.abs(target[1] - ghost[1])) {         return false;       }     }     return true;   }  }   결과  Link   설명     [0, 0]에서 시작해서 귀신들의 위치가 저장된 ghosts의 귀신들보다 빠르게 target에 도달할 수 있는지 검증하는 문제이다.            모든 이동은 상하좌우로 1칸씩 이동 가능하다.                distance는 현재 위치인 [0, 0]에서 target까지 거리를 저장하기 위한 변수로, target의 x축과 y축의 절댓값의 합을 넣어준다.       ghosts의 모든 값을 ghost에 넣어 아래를 검증한다.            distance가 target과 ghost의 x축 y축 차이의 절댓값의 합보다 큰 경우, 귀신이 target에 더 빠르게 도달하므로 false를 주어진 문제의 결과로 반환한다.           반복이 완료되면 귀신들보다 빠르게 target에 도달 가능하므로 true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/escape-the-ghosts/",
        "teaser": null
      },{
        "title": "Leetcode Java Domino and Tromino Tiling",
        "excerpt":"문제  Link   코드  class Solution {    public int numTilings(int n) {     if (n &lt; 3) {       return n;     }     long[] dp = new long[n + 1];     dp[0] = 1;     dp[1] = 1;     dp[2] = 2;     for (int idx = 3; idx &lt; n + 1; idx++) {       dp[idx] = ((2 * dp[idx - 1]) + dp[idx - 3]) % 1000000007;     }     return (int) dp[n];   }  }   결과  Link   설명     $2 \\times 1$의 도미노 타일과 ‘ㄱ’자 모양을 좌우 반전시킨 트로미노 타일을 이용하여 $2 \\times n$ 크기의 보드에 타일을 붙이는 방법의 수를 구하는 문제이다.            단, 답이 매우 클 수 있으므로 모듈러 $10^9 + 7$을 이용해 계산한다.                n이 3 미만인 경우, 붙일 수 있는 타일의 수가 n과 동일하므로 n을 주어진 문제의 결과로 반환한다.            dp는 각 방법의 수를 저장할 배열로, 각 계산에 overflow를 방지하기 위해 long 형태의 $n + 1$ 크기로 초기화하고 처음 세 값을 1, 1, 2로 넣어준다.       3부터 $n + 1$까지 idx를 증가시키며 아래를 수행한다.            dp의 idx번째 위치에 그 전 위치 값의 두 배와 dp의 $idx - 3$번째 값을 더한 값에 모듈러 $10^9 + 7$을 수행한 결과를 넣어준다.                    아래의 각 경우를 이용하여 경우의 수 계산을 수행하면 $2 \\times 4$의 크기인 보드부터 규칙이 나타난다.           $dp[1] = 1$           $dp[2] = 2$           $dp[3] = 5$           $dp[4] = 11 = dp[3] \\times 2 + dp[1]$           $dp[5] = 24 = dp[4] \\times 2 + dp[2]$                           반복이 완료되면 dp의 n번째 값을 int형으로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/domino-and-tromino-tiling/",
        "teaser": null
      },{
        "title": "Leetcode Java Custom Sort String",
        "excerpt":"문제  Link   코드  class Solution {    public String customSortString(String order, String s) {     int[] count = new int[26];     for (char c : s.toCharArray()) {       count[c - 'a']++;     }     StringBuilder sb = new StringBuilder();     for (char c : order.toCharArray()) {       while (count[c - 'a']-- &gt; 0) {         sb.append(c);       }     }     for (int idx = 0; idx &lt; count.length; idx++) {       while (count[idx]-- &gt; 0) {         sb.append((char) ('a' + idx));       }     }     return sb.toString();   }  }   결과  Link   설명          s 문자열을 이용하여 order 문자열의 각 문자의 순서대로 정렬된 문자열을 만드는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            count 배열은 s 문자열의 각 문자 개수를 저장할 변수로, 알파벳 개수인 26 크기로 초기화하여 s의 각 문자 개수를 넣어준다.       sb는 정렬된 문자열을 동적으로 만들기 위한 변수로, StringBuilder로 초기화한다.           order의 모든 문자열을 c에 넣어 아래를 반복한다.            count에서 c의 영문자 순서에 해당하는 횟수만큼 sb에 c를 이어준다.           3번이 완료되면 0부터 count의 길이까지 아래를 반복한다.            count에 남아있는 값이 있으면 차례대로 sb에 해당 순서에 해당하는 영문자로 변환하여 이어준다.           모든 수행이 완료되어 order의 문자 순으로 정렬된 sb를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/custom-sort-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Matching Subsequences",
        "excerpt":"문제  Link   코드  class Solution {    public int numMatchingSubseq(String s, String[] words) {     Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();     for (String word : words) {       map.put(word, map.getOrDefault(word, 0) + 1);     }     int count = 0;     char[] sCharArray = s.toCharArray();     for (String word : map.keySet()) {       char[] wordCharArray = word.toCharArray();       int i = 0;       int j = 0;       while (i &lt; sCharArray.length &amp;&amp; j &lt; wordCharArray.length) {         if (sCharArray[i] == wordCharArray[j]) {           j++;         }         i++;       }       if (j == wordCharArray.length) {         count += map.get(word);       }     }     return count;   }  }   결과  Link   설명     words 배열 내 s의 부분 수열의 개수를 구하는 문제이다.            “abc”와 “ace”는 “abcde”의 부분 수열이다.           문제 풀이에 필요한 변수를 정의한다.            map은 words 내 중복된 문자열의 개수를 저장할 변수로, words를 이용하여 문자별 발생 횟수를 값에 넣어준다.       count는 words 배열 내 s의 부분 수열의 개수를 저장할 변수로, 0으로 초기화한다.       sCharArray는 s를 문자 배열로 저장한 변수이다.           map의 키 값들을 차례대로 word로 넣어 아래를 반복한다.            부분 수열 검증에 필요한 변수들을 정의한다.                    wordCharArray는 word를 문자 배열로 저장한 변수이다.           i와 j는 s와 word의 각 문자 배열을 차례대로 검증할 변수로, 모두 0으로 초기화한다.                       i가 sCharArray의 길이 미만이고 j가 wordCharArray의 길이 미만일 때 까지 아래를 반복하여 수행한다.                    sCharArray의 i번째 문자와 wordCharARray의 j번째 문자가 동일한 경우, j를 다음 위치로 이동시킨다.           i를 증가시켜 sCharArray의 다음 위치로 이동시켜준다.                       j가 wordCharArray의 길이와 동일한 경우, 부분 순열에 속하므로 count에 map의 word에 해당하는 개수를 더해준다.           반복이 완료되면 words 배열 내 s의 부분 수열의 개수를 저장한 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-matching-subsequences/",
        "teaser": null
      },{
        "title": "Leetcode Java Preimage Size of Factorial Zeroes Function",
        "excerpt":"문제  Link   코드  class Solution {    public int preimageSizeFZF(int k) {     int num = 1;     while (num &lt; k) {       num = (num * 5) + 1;     }     while (num &gt; 1) {       k %= num;       if (num - 1 == k) {         return 0;       }       num = (num - 1) / 5;     }     return 5;   }  }   결과  Link   설명     아래의 f(x) 함수를 통해 수행된 결과를 구하는 문제이다.            f(x)는 x!(Factorial) 값의 마지막에 존재하는 0의 개수가 k인 x의 수이다.       $f(11) = 2$로, 11!의 결과는 39916800이므로 뒤에 존재하는 0은 2개라는 의미이다.           num은 결과를 구하기 위한 임시 값을 생성할 변수로, 1로 초기화 하여 아래를 수행한 결과를 넣어준다.            num이 k 미만일 때 까지 num에 $(num \\times 5) + 1$의 값을 넣어 num을 증가시켜준다.           num이 1 초과일 때 까지 아래를 수행한다.            k를 num으로 나눈 나머지 값을 넣어준다.       $num - 1$의 값이 k인 경우, f(x)의 결과가 k를 만족하는 x가 존재하지 않으므로 0을 주어진 문제의 결과로 반환한다.       num에 $\\frac{num - 1}{5}$의 몫을 넣어 범위를 좁혀준다.           반복이 정상적으로 종료되면 f(x)의 결과가 k를 만족하는 숫자의 개수인 5를 주어진 문제의 결과로 반환한다.   해설     x!은 $1 \\times 2 \\times … \\times x$ 이고, x! 결과의 마지막에 0이 k개 존재하는 경우는 10을 만들 수 있는 5의 개수가 k개인 것으로 판단 할 수 있으므로 아래의 각 경우를 확인해보자.            k가 0인 경우, 0에서 4까지 5의 배수가 한 개도 없으므로 5개의 숫자가 만족한다.       k가 4인 경우, 20에서 24까지 5의 배수가 네 개(5, 10, 15, 20)이므로 5개의 숫자가 만족한다.       k가 5인 경우, 25($5 \\times 5$)는 5가 두 번 발생하므로 마지막의 0의 수가 5개인 숫자는 없다.       k가 6인 경우, 25에서 29까지 5의 배수가 여섯 개(5, 10, 15, 20, 25)이므로 5개의 숫자가 만족한다.       k가 10인 경우, 45에서 49까지 5의 배수가 열 개(5, 10, 15, 20, 25, 30, 35, 40, 45)이므로 5개의 숫자가 만족한다.       k가 11인 경우, 50($5 \\times 5 \\times 2$)는 5가 두 번 발생하므로 마지막의 0의 수가 11개인 숫자는 없다.           위의 각 경우와 같이 주어진 k 값이 5의 제곱수가 처음 발생하는 구간임이 확인 되면 0, 아니면 5를 반환하는 것이다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/preimage-size-of-factorial-zeroes-function/",
        "teaser": null
      },{
        "title": "Leetcode Java Valid Tic-Tac-Toe State",
        "excerpt":"문제  Link   코드  class Solution {    public boolean validTicTacToe(String[] board) {     int diff = 0;     for (int i = 0; i &lt; 3; i++) {       for (int j = 0; j &lt; 3; j++) {         if (board[i].charAt(j) == 'X') {           diff++;         }         if (board[i].charAt(j) == 'O') {           diff--;         }       }     }     return !((diff != 0 &amp;&amp; diff != 1) || (this.isWin(board, 'X') &amp;&amp; diff == 0) || (this.isWin(board, 'O') &amp;&amp; diff == 1));   }    private boolean isWin(String[] board, char c) {     return (board[0].charAt(0) == c &amp;&amp; board[0].charAt(1) == c &amp;&amp; board[0].charAt(2) == c)         || (board[1].charAt(0) == c &amp;&amp; board[1].charAt(1) == c &amp;&amp; board[1].charAt(2) == c)         || (board[2].charAt(0) == c &amp;&amp; board[2].charAt(1) == c &amp;&amp; board[2].charAt(2) == c)         || (board[0].charAt(0) == c &amp;&amp; board[1].charAt(0) == c &amp;&amp; board[2].charAt(0) == c)         || (board[0].charAt(1) == c &amp;&amp; board[1].charAt(1) == c &amp;&amp; board[2].charAt(1) == c)         || (board[0].charAt(2) == c &amp;&amp; board[1].charAt(2) == c &amp;&amp; board[2].charAt(2) == c)         || (board[0].charAt(0) == c &amp;&amp; board[1].charAt(1) == c &amp;&amp; board[2].charAt(2) == c)         || (board[0].charAt(2) == c &amp;&amp; board[1].charAt(1) == c &amp;&amp; board[2].charAt(0) == c);   }  }   결과  Link   설명     ‘O’, ‘X’, ‘’ 문자로 이루어진 $3 \\times 3$ 크기의 Tic-Tac-Toe 보드를 이용하여 아래의 규칙을 이용한 게임이 유효하게 종료될 수 있는지를 검증하는 문제이다.            ’’ 문자는 빈 공간을 의미하며, 첫 번째 플레이어는 ‘X’ 문자로 두 번째 플레이어는 ‘O’ 문자로 시작한다.       ‘X’와 ‘O’ 문자는 빈 공간인 ‘‘에 들어갈 수 있으며, 채워진 값은 바뀌지 않는다.       행, 열, 대각선에 ‘X’ 혹은 ‘O’ 문자가 동일하게 들어간 경우, 게임은 종료된다.       모든 빈 값에 값이 채워지면 게임은 종료되며, 더 이상 값을 변경할 수 없다.                diff는 ‘X’와 ‘O’의 개수의 차이를 저장할 변수로, 0으로 초기화하고 board의 모든 값을 이용하여 ‘X’는 값을 더하고 ‘O’는 값을 빼준다.       아래의 경우에 하나라도 해당하는 경우 규칙을 만족하지 않으므로 false를, 모두 만족하지 않으면 true를 주어진 문제의 결과로 반환한다.            ‘X’와 ‘O’의 개수가 동일하지 않으며 ‘X’가 하나 더 많지 않은 경우.                    플레이어가 정상적으로 번갈아 두는 경우, ‘X’가 하나 더 많거나 ‘X’와 ‘O’는 동일한 개수가 된다.                       4번의 isWin(String[] board, char c) 메서드를 board와 ‘X’로 수행한 결과가 true면서, ‘X’와 ‘O’의 개수가 동일한 경우.                    첫 번째 플레이어가 이기게 되면, 자신의 차례를 통해 ‘X’를 하나 추가한 상태이므로 ‘X’가 하나 더 많아야한다.                       4번의 isWin(String[] board, char c) 메서드를 board와 ‘O’로 수행한 결과가 true면서, ‘O’의 개수가 하나 더 많은 경우.                    두 번째 플레이어가 이기게 되면, 자신의 차례를 통해 ‘O’를 하나 추가한 상태이므로 ‘O’와 ‘X’의 개수가 동일해야한다.                           board에서 c 문자를 둔 플레이어가 이기는 경우를 검증하기 위한 isWin(String[] board, char c) 메서드를 정의한다.            c 문자열이 가로/세로/대각선 모든 경우의 수 중 하나라도 만족하면 true를, 아니면 false를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/valid-tic-tac-toe-state/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Subarrays with Bounded Maximum",
        "excerpt":"문제  Link   코드  class Solution {    public int numSubarrayBoundedMax(int[] nums, int left, int right) {     return this.getCount(nums, right) - this.getCount(nums, left - 1);   }    private int getCount(int[] nums, int bound) {     int total = 0;     int count = 0;     for (int num : nums) {       count = num &lt;= bound ? count + 1 : 0;       total += count;     }     return total;   }  }   결과  Link   설명          nums 내 값을 이용하여 [left, right] 범위에 존재하는 연속된 숫자들을 이용한 부분 배열의 수를 구하는 문제이다.       nums 내 bound까지 부분 배열의 수를 계산할 getCount(int[] nums, int bound) 메서드를 정의한다.            부분 배열의 수를 계산할 변수를 정의한다.                    total은 bound까지 부분 배열의 총 개수를 저장할 변수로, 0으로 초기화한다.           count는 nums 내 연속된 값들을 이용한 부분 배열의 숫자를 저장할 변수로, 0으로 초기화한다.                       nums의 값들을 차례대로 num에 넣어 아래를 수행한다.                    num이 bound 이하인 경우 count를 증가시키고, 초과인 경우 범위를 넘었으므로 count를 0으로 초기화한다.           total에 num 위치까지 부분 배열의 수를 저장한 count를 더해준다.                       반복이 완료되면 bound까지 부분 배열의 수를 저장한 total을 반환한다.           2번에서 정의한 getCount(int[] nums, int bound) 메서드를 이용하여 right까지 범위의 부분 배열의 수에 left까지 범위의 부분 배열의 수를 뺀 값을 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-subarrays-with-bounded-maximum/",
        "teaser": null
      },{
        "title": "Leetcode Java Rotate String",
        "excerpt":"문제  Link   코드  class Solution {    public boolean rotateString(String s, String goal) {     return s.length() == goal.length() &amp;&amp; (s + s).contains(goal);   }  }   결과  Link   설명          문자열 s의 좌측 문자열을 우측으로 이동시키며 goal의 문자열을 만들 수 있는지 검증하는 문제이다.            아래의 두 조건을 만족하면 true를, 아니면 false를 주어진 문제의 결과로 반환한다.             s의 길이와 goal의 길이가 동일한 경우.                    동일한 길이여야 s를 이용하여 goal로 변경이 가능하다.                       s를 두 번 반복한 문자열에 goal이 포함되는 경우.                    s를 두 번 반복하면 좌측 문자를 우측으로 이동시키지 않아도 동일한 효과를 볼 수 있다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/rotate-string/",
        "teaser": null
      },{
        "title": "Leetcode Java All Paths From Source to Target",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(int[][] graph) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     this.dfs(result, new ArrayList&lt;&gt;(), graph, 0, graph.length - 1);     return result;   }    private void dfs(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; path, int[][] graph, int start, int end) {     path.add(start);     if (start == end) {       result.add(new ArrayList&lt;&gt;(path));     } else {       for (int node : graph[start]) {         this.dfs(result, path, graph, node, end);       }     }     path.remove(path.size() - 1);   }  }   결과  Link   설명          [0, $n - 1$] 까지 값을 가진 n개 노드의 Directed Acyclic Graph(DAG)가 주어지면 값이 0인 노드에서 $n - 1$까지 도달하기 위한 모든 경로를 찾는 문제이다.            결과를 넣을 result를 ArrayList로 초기화하여 3번의 dfs(List&lt;List&gt; result, List path, int[][] graph, int start, int end) 메서드를 수행해준다.       DFS 방식으로 경로를 찾기 위한 dfs(List&lt;List&gt; result, List path, int[][] graph, int start, int end) 메서드를 정의한다.            path에 start를 넣어준다.       start와 end가 동일한 마지막 위치인 경우, result에 path를 Deep copy하여 넣어준다.       위의 경우가 아니라면 graph의 start번째 노드 값의 경로를 가져와 node에 넣어 start 자리에 해당 값으로 재귀 호출을 수행한다.       path에서 마지막 값을 제거한다.           수행이 완료되어 모든 경로가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/all-paths-from-source-to-target/",
        "teaser": null
      },{
        "title": "Leetcode Java Smallest Rotation with Highest Score",
        "excerpt":"문제  Link   코드  class Solution {    public int bestRotation(int[] nums) {     int length = nums.length;     int[] change = new int[length];     for (int idx = 0; idx &lt; length; idx++) {       change[(idx - nums[idx] + 1 + length) % length]--;     }     int rotation = 0;     for (int idx = 1; idx &lt; length; idx++) {       change[idx] += change[idx - 1] + 1;       rotation = change[idx] &gt; change[rotation] ? idx : rotation;     }     return rotation;   }  }   결과  Link   설명          nums의 각 위치에 존재하는 값이 위치 인덱스 보다 작거나 같으면 점수가 부여되는데, 이 때 가장 큰 점수가 되기 위해 nums를 좌측으로 이동해야하는 횟수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       change는 현재 위치에 따른 점수의 손실을 저장할 변수로, length 길이로 초기화 하여 $idx - nums[idx] + 1 + length$를 length로 나눈 나머지 값에 해당하는 위치 값을 감소시켜 현재 위치에 대한 손실된 값을 계산해준다.       rotation은 좌측으로 이동해야하는 횟수를 저장한 변수로, 0으로 초기화한다.           1부터 length까지 idx를 증가시키며 아래를 수행한다.            change의 idx번째 값에 이전 위치의 값에 1을 증가시켜준다.       rotation에 change의 idx번째 값이 rotation번째 값보다 큰 경우 idx를, 아니면 rotation을 넣어준다.           반복이 완료되면 이동 횟수가 저장된 rotation을 주어진 문제의 결과로 반환한다.   해설     nums의 각 위치 idx에서 $(idx - 1 + length) % length$로 이동할 때 기본적으로 아래의 경우 중 하나를 만족해야 한다.            change[idx] &gt; idx를 만족할 때, 점수를 잃지 않는다.       우측인 0에서 $length - 1$로 이동하는 경우, 점수를 획득한다.       좌측인 $change[idx] == idx$이면서 $idx - 1$로 이동할 때, 점수를 잃는다.           회전이 되는 위치인 k와 값 idx번째 위치의 관계는 $k = (idx - change[idx] + 1 + length) % length$로, idx를 반복하여 잃은 점수가 저장된 change[k]를 2번의 변수 선언 이후 계산하는 것이다.   3번에서 $k - 1$에서 왼쪽으로 이동하는 k단계를 계산하기 위해 $change[k] = change[k - 1] + 1$를 이용하여 각 변화된 값을 넣어 change내 idx와 rotation번째 값의 비교를 통해 최종 이동 횟수를 구한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/smallest-rotation-with-highest-score/",
        "teaser": null
      },{
        "title": "Leetcode Java Champagne Tower",
        "excerpt":"문제  Link   코드  class Solution {    public double champagneTower(int poured, int query_row, int query_glass) {     double[] dp = new double[101];     dp[0] = poured;     for (int row = 1; row &lt;= query_row; row++) {       for (int col = row; col &gt;= 0; col--) {         double overflow = (dp[col] - 1) / 2.0;         overflow = overflow &lt;= 0 ? 0 : overflow;         dp[col] = overflow;         dp[col + 1] += overflow;       }     }     return dp[query_glass] &gt;= 1 ? 1 : dp[query_glass];   }  }   결과  Link   설명     첫 번째 줄에 1개의 샴페인 잔으로 시작하여 각 층별 1잔씩 증가시켜 100 번째 줄까지 샴페인으로 된 타워에 1층부터 poured 잔의 샴페인을 부을 경우, query_row번째 줄의 query_glass번째 샴페인잔에 얼마나 많은 양의 샴페인이 차는지를 검증하는 문제이다.            첫 번째 줄의 샴페인 잔이 가득 차면, 두 번쨰 줄의 샴페인 잔이 순차적으로 차게 된다.       모든 샴페인 잔이 가득 차면, 추가로 부어지는 샴페인은 바닥에 흐르게 된다.                dp는 총 100개의 줄로 이루어진 샴페인의 찬 정도를 넣을 배열로, 최대 줄의 크기가 될 수 있도록 101 크기로 초기화하고 첫 값에 poured를 넣어준다.       1부터 query_row 이하까지 row를 증가시키고, row부터 0 이상까지 col을 감소시키며 아래를 반복한다.            overflow는 넘치는 양의 샴페인을 담을 변수로, dp의 col번째 값에 1을 뺀 값을 2로 나눈 결과를 실수형으로 넣어준다.       overflow에 overflow가 0 이하면 0을, 아니면 overflow를 넣어준다.       dp의 col번째 값에 overflow를 넣고, $col + 1$번째 값에 overflow를 더해준다.           반복이 완료되면 dp의 query_glass번째 값이 1 이상이면 1을, 아니면 해당 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/champagne-tower/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Swaps To Make Sequences Increasing",
        "excerpt":"문제  Link   코드  class Solution {    public int minSwap(int[] nums1, int[] nums2) {     int swap = 1;     int fix = 0;     for (int idx = 1; idx &lt; nums1.length; idx++) {       if (nums1[idx - 1] &gt;= nums2[idx] || nums2[idx - 1] &gt;= nums1[idx]) {         swap++;       } else if (nums1[idx - 1] &gt;= nums1[idx] || nums2[idx - 1] &gt;= nums2[idx]) {         int temp = swap;         swap = fix + 1;         fix = temp;       } else {         int min = Math.min(swap, fix);         swap = min + 1;         fix = min;       }     }     return Math.min(swap, fix);   }  }   결과  Link   설명          num1과 num2의 값들이 점층적으로 증가하는 값의 배열로 만들기 위해서 같은 위치의 값을 바꾸는 최소 횟수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            swap은 nums1과 nums2의 동일 위치 값을 바꾸기 위한 최소 횟수를 저장할 변수로, 현 위치의 최소 변경 횟수인 1로 초기화한다.       fix는 nums1과 nums2의 동일 위치 값을 바꾸지 않는 최소 횟수를 저장할 변수로, 현 위치의 최소 고정 횟수인 0으로 초기화한다.           1부터 nums1의 길이 미만까지 idx를 증가시키며 아래를 수행한다.            아래의 경우 중 하나라도 만족하면 두 배열 내 idx번째 값을 바꾸어 swap을 증가시킨다.                    nums1의 $idx - 1$번째 값이 nums2의 idx번째 값보다 크거나 같은 경우.           nums2의 $idx - 1$번째 값이 nums1의 idx번째 값보다 크거나 같은 경우.                       위의 경우가 아니면서 아래의 경우 중 하나라도 만족하면 temp에 swap 값을 임시 저장 후 swap에 fix보다 1 큰 값을 넣고, fix에 temp를 넣어준다.                    nums1 혹은 nums2의 idx번째 값이 이전 값보다 크거나 같은 경우.                       위의 두 경우가 아니라면 변경하거나 변경하지 않아도 되므로, min에 swap과 fix 중 작은 값을 임시 저장 후 swap에 $min + 1$을 fix에 min을 넣어준다.           반복이 완료되면 swap과 fix 중 작은 값을 넣어준다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-swaps-to-make-sequences-increasing/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Eventual Safe States",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; eventualSafeNodes(int[][] graph) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     int length = graph.length;     int[] state = new int[length];     for (int idx = 0; idx &lt; length; idx++) {       if (this.dfs(graph, state, idx)) {         result.add(idx);       }     }     return result;   }    private boolean dfs(int[][] graph, int[] state, int index) {     if (state[index] != 0) {       return state[index] == 1;     } else {       state[index] = 2;       for (int node : graph[index]) {         if (!this.dfs(graph, state, node)) {           return false;         }       }       state[index] = 1;       return true;     }   }  }   결과  Link   설명     [0, $n - 1$]까지 n개의 노드의 방향이 저장된 graph는 각각 아래의 노드로 구분이 되며, 그 중 안전한 노드를 찾아 오름차순으로 정렬하여 반환하는 문제이다.            터미널 노드는 나가는 방향이 없는 노드이다.       안전한 노드는 터미널 노드 또는 안전한 노드로 이어지는 노드이다.           문제 풀이에 필요한 변수를 정의한다.            result는 안전한 노드를 오름차순 저장하여 반환할 변수로, ArrayList로 초기화한다.       length는 graph의 길이를 저장한 변수이다.       state는 n개의 노드의 각 상태를 저장할 배열로, length 크기로 초기화하며 아래의 각 상태를 가진다.                    0은 아직 노드를 탐색하지 않은 값이다.           1은 안전한 노드를 의미하는 값이다.           2는 안전하지 않은 노드를 의미하는 값이다.                           0부터 length 미만까지 idx를 증가시키며 아래를 검증한다.            4번에서 정의한 dfs(int[][] graph, int[] state, int index) 메서드에 각 변수와 idx를 넣어 수행한 결과가 true인 안전한 노드인 경우, result에 idx를 넣어준다.           DFS 방식으로 graph 내 안전한 노드를 찾기 위한 dfs(int[][] graph, int[] state, int index) 메서드를 정의한다.            state의 index번째 상태가 0인 탐색하지 않은 노드가 아니라면, 해당 값이 1인 안전한 노드인지 검증한 결과를 반환한다.       위의 경우가 아니라면 아래를 수행한다.                    state의 index번째 값에 안전하지 않은 노드라는 의미의 2를 넣어준다.           graph의 index번째 값들을 node에 넣어 반복하여 index 자리에 해당 값으로 재귀 호추한 결과가 false인 경우 안전하지 않은 노드이므로, false를 반환한다.           위의 반복이 완료되면 안전한 노드이므로 state의 index번째 값에 1을 넣고, true를 반환한다.                           3번의 반복이 완료되면 안전한 노드를 오름차순으로 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-eventual-safe-states/",
        "teaser": null
      },{
        "title": "Leetcode Java Unique Morse Code Words",
        "excerpt":"문제  Link   코드  class Solution {    private static String[] LETTERS = new String[] {     \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\",     \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"   };      public int uniqueMorseRepresentations(String[] words) {     Set&lt;String&gt; set = new HashSet&lt;&gt;();     for (String word : words) {       StringBuilder sb = new StringBuilder();       for (char c : word.toCharArray()) {         sb.append(LETTERS[c - 'a']);       }       set.add(sb.toString());     }     return set.size();   }  }   결과  Link   설명          words의 문자열들의 각 문자들을 정의된 문장으로 모두 변경하였을 경우, 고유 문자열의 개수를 구하는 문제이다.            set은 고유 문자열의 개수를 저장할 변수로, HashSet으로 초기화한다.       words의 모든 단어를 word에 순차적으로 넣어 아래를 반복한다.            sb는 word의 각 문자들을 주어진 문자열로 변환하여 저장할 변수로, 동적인 문자열 생성을 위해 StringBuilder로 정의한다.       word의 각 문자들을 순차적으로, sb에 LETTERS의 해당 알파벳 순서에 해당하는 문자열로 이어준다.       set에 sb를 문자열로 변환하여 추가해준다.           변환된 고유 문자열이 저장된 set의 크기를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/unique-morse-code-words/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Lines To Write String",
        "excerpt":"문제  Link   코드  class Solution {    public int[] numberOfLines(int[] widths, String s) {     int[] result = new int[] { 1, 0 };     for (char c : s.toCharArray()) {       int curr = widths[c - 'a'];       if (result[1] + curr &gt; 100) {         result[0]++;         result[1] = curr;       } else {         result[1] += curr;       }     }     return result;   }  }   결과  Link   설명          각 영문자 별 길이를 저장한 widths를 이용하여 각 라인 별 길이가 100을 넘지 않도록 문자열 s를 개행 처리하였을 때, [행의 수, 마지막 줄의 길이] 형태의 배열을 반환하는 문제이다.            result는 결과를 저장할 변수로, 첫 행의 수와 초기 길이인 [1, 0]으로 초기화한다.       s의 각 문자를 c에 넣어 아래를 반복한다.            curr은 현재 문자인 c의 길이를 widths에서 찾아 넣어준다.       result[1]인 현재 길이와 curr의 합이 100을 초과하는 경우, 행의 수인 result의 첫 번째 값을 증가시키고 현재 행의 길이인 result의 두 번째 값에 curr을 넣어 새로운 행의 길이를 초기화 시켜준다.       위의 경우가 아니라면 현재 행의 길이인 result의 두 번쨰 값에 curr을 더해준다.           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-lines-to-write-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Max Increase to Keep City Skyline",
        "excerpt":"문제  Link   코드  class Solution {    public int maxIncreaseKeepingSkyline(int[][] grid) {     int length = grid.length;     int[] row = new int[length];     int[] col = new int[length];     for (int i = 0; i &lt; length; i++) {       for (int j = 0; j &lt; length; j++) {         row[i] = Math.max(row[i], grid[i][j]);         col[j] = Math.max(col[j], grid[i][j]);       }     }     int result = 0;     for (int i = 0; i &lt; length; i++) {       for (int j = 0; j &lt; length; j++) {         result += Math.min(row[i], col[j]) - grid[i][j];       }     }     return result;   }  }   결과  Link   설명          각 건물의 높이가 저장된 grid를 이용하여 네 방향에서 보았을 때 동일한 외부 윤곽을 유지하면서 올릴 수 있는 최대한의 건물 높이로 건물을 증축할 때, 증축할 수 있는 건물들의 높이 합을 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 grid 행의 길이를 저장한 변수이다.       row는 각 행별 가장 큰 높이를 저장하기 위한 배열로, length 길이로 초기화한다.       col은 각 열별 가장 큰 높이를 저장하기 위한 배열로, length 길이로 초기화한다.                0부터 length까지 i와 j를 증가시키며 row와 col에 각 행과 열의 가장 큰 값을 저장한다.            result는 올릴 수 있는 높이를 저장할 변수로, 0으로 초기화한다.       0부터 length까지 i와 j를 증가시키며 아래를 수행한다.            result에 row의 i번째 값과 col의 j번째 값중 가장 낮은 높이에 grid[i][j]의 값을 뺀 증가할 수 있는 높이를 더해준다.           반복이 완료되면 각 건물의 증축 횟수인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/max-increase-to-keep-city-skyline/",
        "teaser": null
      },{
        "title": "Leetcode Java Soup Servings",
        "excerpt":"문제  Link   코드  class Solution {    public double soupServings(int n) {     n = (n + 24) / 25;     return n &gt; 500 ? 1.0 : this.dfs(new double[n + 1][n + 1], n, n);   }    private double dfs(double[][] dp, int a, int b) {     if (a &lt;= 0 &amp;&amp; b &lt;= 0) {       return 0.5;     } else if (a &lt;= 0) {       return 1;     } else if (b &lt;= 0) {       return 0;     } else if (dp[a][b] &gt; 0) {       return dp[a][b];     } else {       return dp[a][b] = 0.25 * (this.dfs(dp, a - 4, b) + this.dfs(dp, a - 3, b - 1) + this.dfs(dp, a - 2, b - 2) + this.dfs(dp, a - 1, b - 3));     }   }  }   결과  Link   설명     A와 B 스프를 각각 n ml씩 가지고 아래의 네 유형으로 제공할 때, 스프가 하나라도 바닥이 날 때 까지 반복하여 A가 먼저 비어있을 확률과 A와 B가 동시에 비어있을 확률의 절반을 반환한다.            단, 결과는 소수점 다섯 자리 이내의 답을 반환한다.       B 스프 100ml를 모두 먼저 사용하는 경우는 없으며, 유형은 아래의 네 유형으로 존재한다.                    A 스프 100ml만 제공한다.           A 스프 75ml와 B 스프 25ml를 제공한다.           A 스프 50ml와 B 스프 50ml를 제공한다.           A 스프 25ml와 B 스프 75ml를 제공한다.                                n에 $\\frac{n + 24}{25}$를 넣어 25ml 단위로 산정한 횟수를 넣어준다.       n이 192를 초과하는 경우, 해당 경우는 1에 수렴하므로 1.0을 반환하고 아닌 경우 $n + 1$ 크기의 2차원 실수 배열을 이용하여 4번에서 정의한 dfs(double[][] dp, int a, int b) 메서드를 수행한 결과를 주어진 문제의 결과로 반환한다.            n이 192인 이유는 아래와 같다.                    파라미터로 주어진 초기 n이 4800이면 확률은 0.99999499이고, 4801인 경우 0.99999538으로 4800이 초과되면 반올림하여 1.0에 수렴한다.           4800을 25로 나눈 결과는 192이므로, 해당 결과를 기반으로 산정된 임계치이다.                       또한 b를 먼저 모두 사용하는 경우는 없으므로, n이 무한히 증가되면 A가 먼저 비어있을 확률은 1에 수렴하게 된다.           DFS 방식으로 확률을 계산하기 위한 dfs(double[][] dp, int a, int b) 메서드를 정의한다.            a와 b가 0 이하인 경우, 둘 다 부족하다는 의미이므로 1의 절반인 0.5를 반환한다.       a만 0 이하인 경우, 3번에서 설명하였듯이 1을 반환한다.       b만 0 이하인 경우, 불가능한 경우이므로 0을 반환한다.       dp[a][b]의 값이 0 초과인 경우, 아직 확률이 존재하므로 해당 값을 반환한다.       그 외의 경우, dp[a][b]에 0.25와 스프를 제공하는 네 확률의 합의 곱을 넣고 반환한다.                    a 스프만 100ml 반환하면 4번 사용하므로 $a - 4$를 이용한 재귀 호출을 수행한 결과를 이용한다.           위와 동일하게 마지막으로 a 스프를 25ml 반환하면 1번, b 스프를 75ml 반환하면 3번 사용하므로 $a - 1$과 $b - 3$을 이용한 재귀 호출을 수행한 결과를 이용한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/soup-servings/",
        "teaser": null
      },{
        "title": "Leetcode Java Expressive Words",
        "excerpt":"문제  Link   코드  class Solution {    public int expressiveWords(String s, String[] words) {     int result = 0;     for (String word : words) {       if (this.isPossible(s.toCharArray(), word.toCharArray())) {         result++;       }     }     return result;   }    private boolean isPossible(char[] sCharArray, char[] wordCharArray) {     int sLength = sCharArray.length;     int wordLength = wordCharArray.length;     int j = 0;     for (int i = 0; i &lt; sLength; i++) {       if (j &lt; wordLength &amp;&amp; sCharArray[i] == wordCharArray[j]) {         j++;       } else if (!(0 &lt; i &amp;&amp; i &lt; sLength - 1 &amp;&amp; sCharArray[i - 1] == sCharArray[i] &amp;&amp; sCharArray[i] == sCharArray[i + 1])           &amp;&amp; !(1 &lt; i &amp;&amp; sCharArray[i - 2] == sCharArray[i - 1] &amp;&amp; sCharArray[i - 1] == sCharArray[i])) {         return false;       }     }     return j == wordLength;   }  }   결과  Link   설명     words의 문자들 중 s로 확장 가능한 문자열의 수를 구하는 문제이다.            확장은 동일한 문자가 3번 이상 반복되도록만 확장이 가능하다.                result는 확장 가능한 문자열의 수를 저장하기 위한 변수로, 0으로 초기화한다.       words의 모든 문자열을 word에 넣어 아래를 반복한다.            4번에서 정의한 isPossible(char[] sCharArray, char[] wordCharArray) 메서드를 s와 word 모두 문자 배열로 변환하여 수행한 결과가 true이면 result를 증가시킨다.           문자열 word가 문자열 s로 확장 가능한지를 검증하기 위한 isPossible(char[] sCharArray, char[] wordCharArray) 메서드를 정의한다.            검증을 위한 변수를 정의한다.                    sLength와 wordLength는 s와 word의 길이를 저장한 변수이다.           j는 wordCharArray를 탐색하기 위한 위치 변수로, 0으로 초기화한다.                       0부터 sLength 미만까지 i를 증가시키며 아래를 검증한다.       j가 wordLength 미만이면서 sCharArray의 i번째 문자와 wordCharArray의 j번째 문자가 동일하면 j를 증가시키고 반복을 계속한다.       위의 경우가 아니고 아래를 동일 문자가 세 번 반복된 경우를 만족하지 않으면 확장이 불가능하므로, false를 반환한다.                    i가 0 초과이면서 $sLength - 1$ 미만인 경우, sCharArray의 i번째 문자의 이전 문자와 이후 문자 모두 동일한 경우.           i가 1 초과인 경우, sCharArray의 $i - 1$번째 문자의 이전 문자와 이후 문자 모두 동일한 경우.                       반복이 완료되면 j가 wordLegnth와 동일한 마지막 위치인지 검증하여 확장 가능한지 여부를 반환한다.           3번의 반복이 완료되면 확장 가능한 문자열의 수인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/expressive-words/",
        "teaser": null
      },{
        "title": "Leetcode Java Chalkboard XOR Game",
        "excerpt":"문제  Link   코드  class Solution {    public boolean xorGame(int[] nums) {     int n = 0;     for (int num : nums) {       n ^= num;     }     return n == 0 || nums.length % 2 == 0;   }  }   결과  Link   설명          엘리스와 밥이 순차적으로 nums 내 임의 숫자를 제거하고 남은 숫자들의 XOR 비트 연산을 수행하다가 밥이 0이 되어 엘리스가 이기는 게임인지 검증하는 문제이다.            n은 XOR 비트 연산을 수행한 결과를 저장할 변수로, 0으로 초기화한다.       nums의 모든 숫자들을 num에 넣어 아래를 반복한다.            n에 n과 num의 XOR 비트 연산의 결과를 넣어준다.           n이 0이거나 nums의 길이가 짝수이면 true를, 아니면 false를 주어진 문제의 결과로 반환한다.            상대가 지게 만드는 경우는, 다음 턴에 nums의 길이가 홀수인 동일 숫자들을 남기는 것이다.       아래의 두 경우를 합치면 밥이 어떤 선택을 하던지 엘리스는 반드시 지지 않는 선택을 하여 이길 수 있다.                    nums 내 모든 숫자들이 같지 않다면, 상대는 절대 지지않는 숫자를 지울 수 있다.           숫자가 모두 같으며 nums 내 숫자의 개수가 짝수인 경우, 상대가 이기게 된다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/chalkboard-xor-game/",
        "teaser": null
      },{
        "title": "Leetcode Java Subdomain Visit Count",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; subdomainVisits(String[] cpdomains) {     Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();     for (String cpdomain : cpdomains) {       String[] split = cpdomain.split(\" \");       this.saveCpdomains(map, split[1], Integer.valueOf(split[0]));     }     List&lt;String&gt; result = new ArrayList&lt;&gt;();     for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {       result.add(entry.getValue() + \" \" + entry.getKey());     }     return result;   }    private void saveCpdomains(Map&lt;String, Integer&gt; map, String domain, int time) {     map.put(domain, map.getOrDefault(domain, 0) + time);     int index = domain.indexOf('.');     if (index != -1) {       this.saveCpdomains(map, domain.substring(index + 1, domain.length()), time);     }   }  }   결과  Link   설명          방문 횟수와 도메인이 이어진 Count-Paired Domain이 저장된 cpdomains의 서브 도메인 별 방문 횟수를 계산하여 동일한 형태로 반환하는 문제이다.            map은 서브 도메인 별 방문 횟수를 계산하기 위한 변수로, cpdomains의 모든 값들을 cpdomain으로 3번에서 정의한 saveCpdomains(Map&lt;String, Integer&gt; map, String domain, int time) 메서드를 수행하여 값을 채워준다.       서브 도메인 별 방문 횟수를 저장하기 위한 saveCpdomains(Map&lt;String, Integer&gt; map, String domain, int time) 메서드를 정의한다.            map의 domain이 키인 값에 time을 더해서 넣어준다.       index에 domain 내 ‘.’이 들어간 위치 값을 넣어준다.       index가 -1이 아닌 서브 도메인이 있는 경우, domain의 서브 도메인을 이용하여 재귀 호출을 수행한다.           결과를 저장하기 위한 result를 정의하여 map에 저장된 서브 도메인 별 방문 횟수를 Count-Paired Domain으로 저장 후 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/subdomain-visit-count/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Tree Pruning",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public TreeNode pruneTree(TreeNode root) {     if (root == null) {       return null;     }     root.left = this.pruneTree(root.left);     root.right = this.pruneTree(root.right);     if (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == 0) {       return null;     } else {       return root;     }   }  }   결과  Link   설명          root에서 하위 노드의 합이 1 이상인 노드만 남기는 문제이다.            root가 null 인 경우, 존재하지 않는 노드이므로 null을 반환한다.            root의 left TreeNode를 재귀 호출한 결과를 해당 TreeNode에, right TreeNode도 동일하게 수행하낟.            root의 left와 right TreeNode가 null이면서 val 값은 0이면 null을, 아니면 root를 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-tree-pruning/",
        "teaser": null
      },{
        "title": "Leetcode Java Ambiguous Coordinates",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; ambiguousCoordinates(String s) {     List&lt;String&gt; result = new ArrayList&lt;&gt;();     int length = s.length();     for (int idx = 1; idx &lt; length - 2; idx++) {       List&lt;String&gt; left = this.makeCoordinates(s.substring(1, idx + 1));       List&lt;String&gt; right = this.makeCoordinates(s.substring(idx + 1, length - 1));       for (String x : left) {         for (String y : right) {           result.add(\"(\" + x + \", \" + y + \")\");         }       }     }     return result;   }    private List&lt;String&gt; makeCoordinates(String s) {     List&lt;String&gt; list = new ArrayList&lt;&gt;();     for (int idx = 1; idx &lt;= s.length(); idx++) {       String left = s.substring(0, idx);       String right = s.substring(idx);       if ((left.length() &gt; 1 &amp;&amp; left.charAt(0) == '0') || (right.length() &gt; 0 &amp;&amp; right.charAt(right.length() - 1) == '0')) {         continue;       }       if (right.isEmpty()) {         list.add(left);       } else {         list.add(left + \".\" + right);       }     }     return list;   }  }   결과  Link   설명     s의 소괄호 내 숫자를 이용하여 x와 y축의 2차원 좌표를 만들 수 있는대로 모두 만드는 문제이다.            s의 첫 문자와 마지막 문자는 소괄호의 시작 문자(‘(‘)와 종료 문자(‘)’)이다.           문제 풀이에 필요한 변수를 정의한다.            result는 결과의 모든 좌표를 넣을 변수로, ArrayList로 초기화한다.       length는 s의 길이를 저장한 변수이다.           1부터 $length - 2$까지 idx를 증가시키며 아래를 수행한다.            left에 s의 1부터 $idx + 1$자리까지 문자열을 잘라 4번의 makeCoordinates(String s) 메서드를 수행한 결과를 넣어준다.       right에 left 이후의 s의 $idx + 1$부터 $length - 1$자리까지 문자열을 잘라 4번의 makeCoordinates(String s) 메서드를 수행한 결과를 넣어준다.       x와 y를 이용하여 “(x, y)” 형태의 문자열로 result에 넣어준다.           소수점인 좌표를 만들어줄 makeCoordinates(String s) 메서드를 정의한다.            list는 만들 수 있는 좌표를 모두 만들어줄 변수로, ArrayList로 초기화한다.       1부터 s의 길이 이하까지 idx를 반복하며 아래를 수행한다.                    left에 s의 처음부터 idx번째 문자까지 문자열을, right에 나머지 문자열을 넣어준다.           left의 길이가 1 초과이면서 첫 자리가 ‘0’이거나 right의 길이가 0 초과이면서 마지막 문자가 ‘0’인 경우 좌표를 생성하지 못하므로, 다음 반복을 수행한다.           right가 비어있는 경우, 정수 부분인 left만 list에 넣어준다.           right가 비어있지 않은 경우, 정수 부분인 left와 소수 부분인 right를 소수점(‘.’)으로 구분하여 list에 넣어준다.                       반복이 완료되면 list를 반환한다.           3번의 반복이 완료되면 모든 좌표를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/ambiguous-coordinates/",
        "teaser": null
      },{
        "title": "Leetcode Java Linked List Components",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public int numComponents(ListNode head, int[] nums) {     int max = 0;     for (int num : nums) {       max = Math.max(max, num);     }     int[] dp = new int[max + 1];     for (int num : nums) {       dp[num]++;     }     int connected = 0;     int result = 0;     while (head != null) {       if (head.val &lt;= max &amp;&amp; dp[head.val] == 1) {         connected++;       } else if (connected &gt; 0) {         result++;         connected = 0;       }       head = head.next;     }     if (connected &gt; 0) {       result++;     }     return result;   }  }   결과  Link   설명          head 내 nums에 포함된 노드들로 이어진 부분 ListNode의 개수를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            max는 nums 내 최대 값을 저장한다.       dp는 nums의 숫자가 포함되었는지 저장할 배열로, 위의 max 크기로 초기화하여 nums를 반복하여 숫자가 존재하는 경우 해당 위치의 값을 증가시킨다.       connected는 한 번에 연결되는 노드의 개수를 저장할 변수로, 0으로 초기화한다.       result는 부분 ListNode의 개수를 저장할 변수로, 0으로 초기화한다.           head가 null이 아닐 때 까지 아래를 반복한다.            head의 val 값이 max 이하이고 dp 내 앞의 값에 해당하는 위치의 값이 1인 경우, 연결된 노드의 연속이므로 connected를 증가시킨다.       위의 경우가 아니면서 connected가 0보다 큰 경우, 연결된 노드가 끝났으므로 result를 증가시키고 connected를 0으로 초기화한다.       head에 head의 next ListNode를 넣어주고 반복을 계속한다.                마지막으로 connected의 값이 0보다 큰 마지막 부분 ListNode가 존재하는 경우 result를 증가시킨다.       부분 ListNode의 개수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/linked-list-components/",
        "teaser": null
      },{
        "title": "Leetcode Java Most Common Word",
        "excerpt":"문제  Link   코드  class Solution {    public String mostCommonWord(String paragraph, String[] banned) {     Set&lt;String&gt; banList = new HashSet&lt;&gt;(Arrays.asList(banned));     String[] words = paragraph.replaceAll(\"\\\\W+\", \" \").toLowerCase().split(\"\\\\s+\");     Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();     for (String word : words) {       if (!banList.contains(word)) {         map.put(word, map.getOrDefault(word, 0) + 1);       }     }     return Collections.max(map.entrySet(), Map.Entry.comparingByValue()).getKey();   }  }   결과  Link   설명          paragraph에서 banned에 존재하는 문자열을 제외하고 가장 많이 발생한 문자열을 찾는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            banList는 banned를 중복을 제거하여 저장한 변수이다.       words는 paragraph를 특수 문자들을 제거한 문자 배열로 저장한 변수이다.       map은 words 내 문자열 개수를 세기 위한 변수로, HashMap으로 초기화하여 words를 반복하여 banList에 없는 word를 키 발생 횟수를 값으로 계산하여 넣어준다.           map에서 가장 많이 발생한 변수의 키를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/most-common-word/",
        "teaser": null
      },{
        "title": "Leetcode Java Short Encoding of Words",
        "excerpt":"문제  Link   코드  class Solution {    public int minimumLengthEncoding(String[] words) {     Set&lt;String&gt; set = new HashSet&lt;&gt;(Arrays.asList(words));     for (String word : words) {       for (int idx = 1; idx &lt; word.length(); idx++) {         set.remove(word.substring(idx));       }     }     int result = 0;     for (String word : set) {       result += word.length() + 1;     }     return result;   }  }   결과  Link   설명     words 내 문자열들로 아래의 규칙을 만족하는 인코딩의 최소 길이를 구하는 문제이다.            인코딩은 참조 문자열을 이용하여 각 문자열 뒤에 ‘#’ 문자열을 붙여 만드는 문자열 형식이다.       참조 문자열이란 words 내 특정 단어가 해당 문자열을 제외한 다른 문자열에 포함되지 않는 문자열이다.                set에 words의 중복된 단어를 제거하기 위해 HashSet으로 words의 문자열을 넣어준다.            words를 반복하여 각 문자열이 words 내 문자열들 중 하나라도 포함되는지 검증하여 set에서 제거해준다.       result에 set 내 각 문자열의 길이와 ‘#’ 문자열의 길이인 1을 더한 값을 누계하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/short-encoding-of-words/",
        "teaser": null
      },{
        "title": "Leetcode Java Shortest Distance to a Character",
        "excerpt":"문제  Link   코드  class Solution {    public int[] shortestToChar(String s, char c) {     int length = s.length();     int[] result = new int[length];     int prev = -length;     for (int idx = 0; idx &lt; length; idx++) {       if (s.charAt(idx) == c) {         prev = idx;       }       result[idx] = idx - prev;     }     for (int idx = prev - 1; idx &gt;= 0; idx--) {       if (s.charAt(idx) == c) {         prev = idx;       }       result[idx] = Math.min(result[idx], prev - idx);     }     return result;   }  }   결과  Link   설명          s의 각 문자에서 전후로 가장 가까운 c와의 거리를 모두 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 s의 길이를 저장한 변수이다.       result는 각 문자 별 거리를 저장하기 위한 변수로, length 길이의 정수 배열로 초기화한다.       prev는 이전 c가 발생한 위치를 저장할 변수로, 거리가 가장 긴 경우인 length를 음수로 전환하여 넣어준다.                s의 각 문자를 좌측에서 우측으로 탐색하며 거리를 측정한다.            s의 마지막 발생위치인 prev의 이전 위치부터 시작하여 우측에서 좌측으로 탐색하여 다시 거리를 확인한다.       반복이 완료되면 각 문자 별 거리가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/shortest-distance-to-a-character/",
        "teaser": null
      },{
        "title": "Leetcode Java Card Flipping Game",
        "excerpt":"문제  Link   코드  class Solution {    public int flipgame(int[] fronts, int[] backs) {     Set&lt;Integer&gt; set = new HashSet&lt;&gt;();     for (int idx = 0; idx &lt; fronts.length; idx++) {       if (fronts[idx] == backs[idx]) {         set.add(fronts[idx]);       }      }     int result = 2001;     for (int idx = 0; idx &lt; fronts.length; idx++) {       if (!set.contains(backs[idx])) {         result = Math.min(result, backs[idx]);       }       if (!set.contains(fronts[idx])) {         result = Math.min(result, fronts[idx]);       }     }     return result % 2001;   }  }   결과  Link   설명     카드들의 앞면의 숫자인 fronts와 뒷면의 숫자인 backs를 이용하여 카드를 뒤집었을 경우, 가능한 최소 크기의 좋은 정수를 반환하는 문제이다.            앞면과 뒷면의 숫자가 동일한 경우, 값의 변화가 없으므로 좋은 정수가 될 수 없다.       좋은 정수가 없을 경우, 0을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            set은 앞면과 뒤면의 숫자가 동일한 숫자를 저장할 변수로, fronts와 backs 내 동일한 숫자를 넣어준다.       result는 최소 가능한 좋은 정수를 저장할 변수로, 숫자의 최대 크기인 2000보다 큰 2001로 초기화한다.           0부터 fronts의 길이 미만까지 idx를 증가시키며 아래를 수행한다.            set에 backs의 idx번째 값이 없는 경우, result에 해당 값과 backs의 idx번째 값 중 작은 값을 넣어준다.       set에 fronts의 idx번째 값이 없는 경우, result에 해당 값과 fronts의 idx번째 값 중 작은 값을 넣어준다.           반복이 완료되면 result를 2001로 나눈 나머지 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/card-flipping-game/",
        "teaser": null
      },{
        "title": "Leetcode Java Goat Latin",
        "excerpt":"문제  Link   코드  class Solution {    public String toGoatLatin(String sentence) {     List&lt;Character&gt; vowels = Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U');     String[] words = sentence.split(\"\\\\s\");     StringBuilder sb = new StringBuilder();     StringBuilder temp = new StringBuilder();     for (int i = 0; i &lt; words.length; i++) {       String word = words[i];       if (vowels.contains(word.charAt(0))) {         temp.append(word);       } else {         temp.append(word.substring(1, word.length()));         temp.append(word.charAt(0));       }       temp.append(\"ma\");       for (int j = 0; j &lt;= i; j++) {         temp.append('a');       }       sb.append(temp);       if (i != words.length - 1) {         sb.append(' ');       }       temp.delete(0, sb.length());     }     return sb.toString();   }  }   결과  Link   설명          sentence 내 단어가 모음(‘a’, ‘e’, ‘i’, ‘o’ 또는 ‘u’)으로 시작하면 단어 끝에 ‘ma’를 추가하는 “Goat Latin”으로 변환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            vowels는 모음을 대소문자로 저장한 변수이다.       words는 sentence를 띄어쓰기 단위로 분리한 단어들이 저장된 배열이다.       sb는 결과 문자열을 넣을 변수로, StringBuilder로 초기화한다.       temp는 각 단어들을 “Goat Latin”으로 동적 구성하기 위한 변수로, StringBuilder로 초기화한다.           0부터 words의 길이 미만까지 i를 증가시키며 아래를 수행한다.            word에 words의 i번째 단어를 넣어 저장한다.       word의 첫 문자가 vowels에 포함되는 모음으로 시작한 경우, temp에 word를 넣어준다.       위의 경우가 아니라면 두 번째 문자부터 temp에 넣고 마지막에 첫 번째 문자를 넣어준다.       temp에 “ma” 문자열을 이어주고, $i + 1$개의 ‘a’를 이어준다.       sb에 temp를 이어주고, 마지막 문자가 아닌 경우 띄어쓰기 문자(‘ ‘)를 넣어준다.       temp를 0부터 sb의 길이만큼의 값들을 삭제하고 반복을 계속 수행한다.           반복을 통해 “Goat Latin”으로 저장된 sb를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/goat-latin/",
        "teaser": null
      },{
        "title": "Leetcode Java Friends Of Appropriate Ages",
        "excerpt":"문제  Link   코드  class Solution {    public int numFriendRequests(int[] ages) {     int[] dp = new int[121];     for (int age : ages) {       dp[age]++;     }     for (int idx = 1; idx &lt;= 120; idx++) {       dp[idx] += dp[idx - 1];     }     int result = 0;     for (int i = 120, j = 120; i &gt;= 1; i--) {       while (j &gt; ((0.5 * i) + 7)) {         j--;       }       if (++j &lt;= i) {         result += (dp[i] - dp[i - 1]) * (dp[i] - dp[j - 1] - 1);       }     }     return result;   }  }   결과  Link   설명     동일하지 않은 x와 y에 대해서 아래의 조건을 모두 만족하지 않는 경우 친구 요청을 수행할 수 있는데, ages를 이용하여 해당 요청의 수를 구하는 문제이다.            $ages[y] &lt;= \\frac{ages[x]}{2} + 7$       $ages[y] &gt; ages[x]$       $ages[y] &gt; 100$ &amp;&amp; $ages[x] &lt; 100$           문제 풀이에 필요한 변수를 정의한다.            dp는 친구 요청의 수를 계산하기 위한 배열로, 최대 나이인 120보다 큰 121의 크기로 초기화하고 아래를 수행한다.                    dp 내 ages의 각 나이 값에 해당하는 위치 값을 증가시켜준다.           1부터 120 이하까지 idx를 증가시키며 dp의 이전 값을 현재 위치의 값에 더해준다.                       result는 친구 요청의 수를 저장하기 위한 변수로, 0으로 초기화한다.           i와 j를 120부터 i가 1 이상일 때 까지 감소시키며 아래를 반복한다.            j가 첫 번째 기본 조건인 $j &lt;= \\frac{i}{2} + 7$를 만족할 때 까지 j를 감소시켜준다.       j를 증가시킨 후 해당 값이 i보다 큰 경우, result에 아래 두 수의 곱인 경우의 수를 더해준다.                    dp의 i번째 값에서 $i - 1$번째 값의 차잇값인 해당 위치에 해당하는 친구들의 숫자.           dp의 i번째 값에서 $j - 1$번째 값과 1을 뺀 값을 곱한 친구 요청을 수행할 수 있는 친구들의 숫자.                           3번의 반복이 완료되면 친구 요청의 수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/friends-of-appropriate-ages/",
        "teaser": null
      },{
        "title": "Leetcode Java Most Profit Assigning Work",
        "excerpt":"문제  Link   코드  class Solution {    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {     int[] dp = new int[100001];     for (int idx = 0; idx &lt; difficulty.length; idx++) {       dp[difficulty[idx]] = Math.max(dp[difficulty[idx]], profit[idx]);     }     for (int idx = 1; idx &lt; dp.length; idx++) {       dp[idx] = Math.max(dp[idx - 1], dp[idx]);     }     int result = 0;     for (int ability : worker) {       result += dp[ability];     }     return result;   }  }   결과  Link   설명     난이도에 해당하는 difficulty별 작업자인 worker를 배치하여 얻을 수 있는 수익인 profit을 이용하여 최대 이익을 구하는 문제이다.            작업자 별 최대 하나 이상의 작업을 할당할 수 있으며, 한 작업을 여러 번 수행할 수 있다.           dp는 이익을 계산하기 위한 배열로, 최대 정수 범위인 100000보다 1 큰 크기로 초기화하고 아래를 수행한다.            0부터 difficulty의 길이 미만까지 idx를 증가시키며, dp의 difficulty 내 idx번째 위치에 해당 값과 profix의 idx번째 값 중 큰 값을 넣어준다.                1부터 dp의 길이 미만까지 idx를 증가시키며, dp의 idx번째 값에 이전 위치의 값과 현재 값 중 큰 값을 넣어준다.       result는 최대 이익을 저장하기 위한 변수로, 0으로 초기화하고 worker의 모든 값을 이용하여 dp 내 각 작업자별 이익을 result에 더하고 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/most-profit-assigning-work/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Unique Characters of All Substrings of a Given String",
        "excerpt":"문제  Link   코드  class Solution {    public int uniqueLetterString(String s) {     int[] curr = new int[26];     Arrays.fill(curr, -1);     int[] last = new int[26];     Arrays.fill(last, -1);     int count = 0;     int result = 0;     for (int i = 0; i &lt; s.length(); i++) {       int j = s.charAt(i) - 'A';       count += i - curr[j] + last[j] - curr[j];       last[j] = curr[j];       curr[j] = i;       result += count;     }     return result;   }  }   결과  Link   설명          s의 연속된 부분 문자열들 내 고유 문자열의 개수를 모두 더하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            curr은 이전 문자열까지 계산된 부분 문자열의 수를 저장할 변수로, 영문자의 개수은 26 크기로 초기화하고 -1을 채워준다.       last는 curr 이전 문자열까지 계산된 부분 문자열의 수를 저장한 변수로, 영문자의 개수은 26 크기로 초기화하고 -1을 채워준다.       count는 부분 문자열의 수를 누계할 변수로, 0으로 초기화한다.       result는 연속된 부분 문자열들 내 고유 문자열의 개수를 저장할 변수로, 0으로 초기화한다.           0부터 s길이 미만까지 i를 증가시키며 아래를 수행한다.            j에 s의 i번째 문자의 영문자 순서를 넣어준다.       count에 i와 curr의 j번째 값의 차이와 last의 j번째 값에 curr의 j번째 값의 차이를 더하여 누계하여, 해당 위치에 해당하는 부분 문자열들의 고유 문자열 수를 count에 누계한다.       last의 j번째 위치에 curr의 j번째 값을 저장하여 값을 백업한다.       curr의 j번째 위치에 i를 넣어 현재 위치를 저장한다.       result에 현재 위치에 해당하는 부분 문자열들의 고유 문자열 수를 저장한 count를 더해준다.           반복이 완료되면 연속된 부분 문자열들 내 고유 문자열의 개수를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-unique-characters-of-all-substrings-of-a-given-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Consecutive Numbers Sum",
        "excerpt":"문제  Link   코드  class Solution {    public int consecutiveNumbersSum(int n) {     int result = 1;     while (n % 2 == 0) {       n /= 2;     }     for (int idx = 3; idx * idx &lt;= n; idx += 2) {       int count = 1;       while (n % idx == 0) {         n /= idx;         count++;       }       result *= count;     }     return n == 1 ? result : result * 2;   }   }   결과  Link   설명          연속된 숫자의 합으로 n을 만들 수 있는 경우의 수를 구하는 문제이다.            reulst는 결과를 저장할 변수로, 자기 자신의 개수를 포함한 1로 초기화한다.            n을 2로 나눈 나머지가 없을 때까지 나누어 상한선을 정의한다.       3부터 idx의 제곱이 n보다 작을 때 까지 2씩 증가하면서 아래를 반복한다.            count는 개수를 산정할 변수로, 1로 초기화한다.       n을 idx로 나눈 나머지가 0일 때 까지 n을 idx로 나누고 count를 증가시킨다.       result에 count를 곱해준다.           n이 1이면 result를, 아니면 result의 2배를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/consecutive-numbers-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Positions of Large Groups",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; largeGroupPositions(String s) {     List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();     char[] charArray = s.toCharArray();     int start = 0;     for (int idx = 1; idx &lt; s.length(); idx++) {       List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();       while (idx &lt; s.length() &amp;&amp; charArray[idx - 1] == charArray[idx]) {         idx++;       }       if (idx - start &gt;= 3) {         temp.add(start);         temp.add(idx - 1);         list.add(temp);       }       start = idx;     }     return list;   }  }   결과  Link   설명          s 내 3번 이상 반복된 문자열의 시작 위치와 종료 위치를 모아 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            list는 결과를 넣을 변수로, ArrayList로 초기화한다.       start는 문자열의 시작 위치를 임시 저장할 변수로, 첫 위치인 0으로 초기화한다.           1부터 s의 길이 미만까지 idx를 증가시키며 아래를 수행한다.            temp는 문자열의 시작 위치와 종료 위치를 저장할 변수로, ArrayList로 초기화한다.       idx가 s의 길이 미만이고, $idx - 1$번째 문자와 idx번째 문자가 동일하면 idx를 계속 증가시킨다.       $idx - start$가 3 이상인 세 번 이상 반복된 문자열인 경우, [start, $idx - 1$]을 list에 넣어준다.       start에 idx를 넣고 반복을 계속 수행한다.           반복이 완료되면 3번 이상 반복된 문자의 위치 값들이 저장된 list를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/positions-of-large-groups/",
        "teaser": null
      },{
        "title": "Leetcode Java Flipping an Image",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] flipAndInvertImage(int[][] image) {     for (int[] row : image) {       for (int left = 0, right = row.length - 1; left &lt;= right;) {         int temp = row[left];         row[left++] = 1 - row[right];         row[right--] = 1 - temp;       }     }     return image;   }  }   결과  Link   설명     $n \\times n$의 2차원 배열인 image를 수평으로 뒤집은 후 값을 반전시킨 결과를 반환하는 문제이다.            수평으로 뒤집는다는 의미는 임의 행인 [0, 1, 1]의 중간 위치를 기준으로 좌우의 값을 바꾸어 [1, 1, 0]이 된다는 의미이다.       값을 반전시킨다는 의미는 위의 [1, 1, 0]을 [0, 0, 1]로 1과 0을 바꾸어 준다는 의미이다.           image의 각 행을 row에 넣은 후 아래를 반복한다.            left는 0, right는 $row.length - 1$로 right가 left보다 크거나 같을 때 까지 아래를 반복한다.                    temp에 row의 left 값을 임시 보관하고 1에서 row의 right번째 값을 뺀 값을 해당 위치에 넣고 left를 증가시킨다.           row의 right의 위치에 1에서 temp를 뺀 값을 넣고 right를 감소시킨다.                           반복이 완료되면 결과가 저장된 image를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/flipping-an-image/",
        "teaser": null
      },{
        "title": "Leetcode Java Find And Replace in String",
        "excerpt":"문제  Link   코드  class Solution {    public String findReplaceString(String s, int[] indices, String[] sources, String[] targets) {     int[] dp = new int[s.length()];     for (int idx = 0; idx &lt; indices.length; idx++) {       if (s.startsWith(sources[idx], indices[idx])) {         dp[indices[idx]] = idx + 1;       }     }     StringBuilder sb = new StringBuilder();     int index = 0;     while (index &lt; s.length()) {       if (dp[index] &gt; 0) {         sb.append(targets[dp[index] - 1]);         index += sources[dp[index] - 1].length();       } else {         sb.append(s.charAt(index++));       }     }     return sb.toString();   }  }   결과  Link   설명          s에서 indices의 각 위치에서 sources로 시작하는지 검증하여 targets의 문자열로 변경하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            dp는 문자열 s의 각 시작 위치에 sources와 target의 위치 값을 저장할 배열로, s의 길이의 크기로 초기화하고 아래를 수행한다.                    0부터 indices의 길이 미만까지 idx를 증가시키며 s의 indices[idx]의 위치에서 sources[idx]의 문자열로 시작하는지 검증하여 dp의 indices[idx]번째 위치에 int의 초기값보다 크게 $idx + 1$을 넣어준다.                       sb는 결과 문자열을 저장할 변수로, StringBuilder로 초기화한다.       index는 s의 위치 값을 저장할 변수로, 0으로 초기화한다.           index가 s의 길이 미만까지 아래를 반복한다.            dp의 index번째 값이 1보다 큰 경우, sb에 targets의 $dp[index] - 1$번째 문자열을 넣어 변경된 문자열로 이어주고 index에 sources의 $dp[index] - 1$번째 문자열의 길이만큼 증가시켜 다음 위치로 이동시켜준다.                    int의 초기값 0이고, 위치의 시작 지점이 0이므로 위치 변수를 1씩 증가시켰다가 사용할 때 1씩 감소시켜 사용하는 것이다.                       위의 경우가 아니라면, sb에 s의 index번째 문자를 넣어 기존 문자로 이어주고 index를 증가시킨다.           반복이 완료되면 sb를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-and-replace-in-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Sum of Distances in Tree",
        "excerpt":"문제  Link   코드  class Solution {    public int[] sumOfDistancesInTree(int n, int[][] edges) {     int[] count = new int[n];     Arrays.fill(count, 1);     int[] result = new int[n];     List&lt;Integer&gt;[] graph = new ArrayList[n];     for (int i = 0; i &lt; n; i++) {       graph[i] = new ArrayList&lt;&gt;();     }     for (int[] edge : edges) {       graph[edge[0]].add(edge[1]);       graph[edge[1]].add(edge[0]);     }     this.postOrderDFS(graph, count, result, 0, -1);     this.preOrderDFS(graph, n, count, result, 0, -1);     return result;   }    private void postOrderDFS(List&lt;Integer&gt;[] graph, int[] count, int[] result, int a, int parent) {     for (int b : graph[a]) {       if (b != parent) {         this.postOrderDFS(graph, count, result, b, a);         count[a] += count[b];         result[a] += result[b] + count[b];       }     }   }    private void preOrderDFS(List&lt;Integer&gt;[] graph, int n, int[] count, int[] result, int a, int parent) {     for (int b : graph[a]) {       if (b != parent) {         result[b] = result[a] + (n - count[b]) - count[b];         this.preOrderDFS(graph, n, count, result, b, a);       }     }   }  }   결과  Link   설명          n개의 노드의 연결 정보가 담긴 edges를 이용하여 각 노드의 위치에서 다른 노드의 거리 합을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            count는 각 노드 위치에서 하위의 모든 노드의 개수를 저장하기 위한 배열로, n 크기의 정수 배열로 초기화하고 모든 위치에 1을 넣어준다.       result는 각 노드 위치에서 하위의 모든 노드의 거리의 합을 저장하기 위한 배열로, n 크기의 정수 배열로 초기화한다.       graph는 각 노드가 연결된 노드를 저장하기 위한 List 배열로, n 크기의 배열로 초기화하여 모든 위치에 새 ArrayList를 넣어준다.                edges의 모든 값을 반복하여 graph의 edge[0]번째 ArrayList에 edge[1]을, graph의 edge[1]번째 ArrayList에 edge[0]을 넣어 서로 연결된 노드로 설정한다.       Post Order 방식으로 DFS를 수행하여 count와 result의 값들을 넣어주기 위한 postOrderDFS(List[] graph, int[] count, int[] result, int a, int parent) 메서드를 정의한다.            graph의 a번째 위치의 값들을 각각 b에 넣어 아래를 반복한다.                    b가 상위 노드인 parent이면 반복을 계속 수행한다.           a의 위치에 b를, parent 위치에 a를 넣고 재귀 호출을 수행한다.           count의 a번째 위치에 count의 b번째 값을 더해 하위 노드의 숫자를 더해준다.           result의 a번째 위치에 b의 하위 노드들의 거리 합인 result의 b번째 값과 하위 노드의 개수인 count의 b번째 값을 더해준다.                           Pre Order 방식으로 DFS를 수행하여 result의 값을 결정하기 위한 preOrderDFS(List[] graph, int n, int[] count, int[] result, int a, int parent) 메서드를 정의한다.            graph의 a번째 위치의 값들을 각각 b에 넣어 아래를 반복한다.                    b가 상위 노드인 parent이면 반복을 계속 수행한다.           result의 b번째 위치에 result의 a번째 값과 n과 count의 b번째 값의 차이를 더한 후, count의 b번째 값을 뺀 결과를 넣어 root에 가까운 위치의 보정 값을 넣어준다.           $n - count[b]$는 a보다 b가 root에 1 더 가까운 값이며, count[b]는 b가 a보다 root에 1 더 가까운 값이다.                                4번에서 정의한 postOrderDFS(List[] graph, int[] count, int[] result, int a, int parent) 메서드를 수행하고, 5번에서 정의한 preOrderDFS(List[] graph, int n, int[] count, int[] result, int a, int parent) 메서드를 순차적으로 수행한다.       수행이 완료되면 각 노드의 위치에서 다른 노드의 거리 합이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sum-of-distances-in-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Image Overlap",
        "excerpt":"문제  Link   코드  class Solution {    public int largestOverlap(int[][] img1, int[][] img2) {     int length = img1.length;     int[][] count = new int[(2 * length) + 1][(2 * length) + 1];     for (int x1 = 0; x1 &lt; length; x1++) {       for (int y1 = 0; y1 &lt; length; y1++) {         if (img1[x1][y1] == 1) {           for (int x2 = 0; x2 &lt; length; x2++) {             for (int y2 = 0; y2 &lt; length; y2++) {               if (img2[x2][y2] == 1) {                 count[x1 - x2 + length][y1 - y2 + length]++;               }             }           }         }       }     }     int result = 0;     for (int[] row : count) {       for (int value : row) {         result = Math.max(result, value);       }     }     return result;   }  }   결과  Link   설명          $n \\times n$의 2차원 배열인 img1을 상하좌우 한 칸씩 이동하여 img2와 겹치는 칸의 개수가 가장 큰 값을 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 img1의 길이를 저장한 변수이다.       count는 img1과 img2를 이용하여 중첩된 칸의 개수를 계산하기 위한 변수로, $length \\times 2$보다 1 큰 크기의 2차원 배열로 초기화한다.           0부터 length 미만까지 x1과 y1을 증가시키며 img1[x1][y1]의 값이 1이면 아래를 수행한다.            0부터 length 미만까지 x2와 y2를 증가시키며 img2[x2][y2]의 값이 1이면 img1과 img2가 겹치는 구간이므로 아래를 수행한다.                    count의 [$x1 - x2 + length$][$y1 - y2 + length]번째 값을 증가시켜 겹치는 구간을 개수를 증가시킨다.                           result는 최대 개수를 저장하기 위한 변수로, count의 모든 값들을 확인하여 최댓 값을 넣고 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/image-overlap/",
        "teaser": null
      },{
        "title": "Leetcode Java Rectangle Overlap",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {     return rec1[0] &lt; rec2[2] &amp;&amp; rec2[0] &lt; rec1[2] &amp;&amp; rec1[1] &lt; rec2[3] &amp;&amp; rec2[1] &lt; rec1[3];   }  }   결과  Link   설명     두 사각형 좌표를 이용하여 겹치는 구간이 있는지 검증하는 문제이다.            rec는 [x1, y1, x2, y2]이며, 좌측 하단 모서리 좌표인 (x1, y1)과 우측 상단 모서리 좌표인 (x2, y2)로 구성되어 있다.           아래의 각 모서리 좌표를 이용하여 모두 만족하여 겹치는 구간이 존재하는지를 검증한 결과를 반환한다.            rec1의 첫 번째 값인 좌측 하단 모서리 x축 좌표보다 rec2의 세 번째 값인 우측 상단의 모서리 x축 좌표가 더 큰 경우.       rec2의 첫 번째 값인 좌측 하단 모서리 x축 좌표보다 rec1의 세 번째 값인 우측 상단의 모서리 x축 좌표가 더 큰 경우.       rec1의 두 번째 값인 좌측 하단 모서리 y축 좌표보다 rec2의 네 번째 값인 우측 상단의 모서리 y축 좌표가 더 큰 경우.       rec2의 두 번째 값인 좌측 하단 모서리 y축 좌표보다 rec1의 네 번째 값인 우측 상단의 모서리 y축 좌표가 더 큰 경우.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/rectangle-overlap/",
        "teaser": null
      },{
        "title": "Leetcode Java New 21 Game",
        "excerpt":"문제  Link   코드  class Solution {    public double new21Game(int n, int k, int maxPts) {     if (k == 0 || n &gt;= k + maxPts) {       return 1;     }     double[] dp = new double[n + 1];     dp[0] = 1;     double sum = 1;     double result = 0;     for (int idx = 1; idx &lt;= n; idx++) {       dp[idx] = sum / maxPts;       if (idx &lt; k) {         sum += dp[idx];       } else {         result += dp[idx];       }       if (idx &gt;= maxPts) {         sum -= dp[idx - maxPts];       }     }     return result;   }  }   결과  Link   설명          블랙잭(21 게임)을 기반으로 0점부터 시작하여 [1, maxPts] 범위의 균일한 확률의 정수를 추첨할 때, k점 이상 받아 멈출 경우 점수가 n 이하일 확률을 구하는 문제이다.            k가 0으로 시작과 동시에 끝나거나, n이 $k + maxPts$보다 크거나 같아 어떠한 값을 뽑아도 n 이하인 값이면 점수가 무조건 n 이하이므로 1을 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            dp는 각 위치인 점수에 따른 확률을 구하기 위한 배열로, $n + 1$ 크기로 초기화하여 첫 값을 1로 넣어준다.       sum은 dp의 마지막 값을 구하기 위한 누계 확률 값으로, 1로 초기화한다.       result는 점수가 n 이하일 확률을 저장할 변수로, 0으로 초기화한다.           1부터 n 이하까지 idx를 증가시키며 아래를 수행한다.            dp의 idx번째 위치에 $\\frac{sum}{maxPts}$를 넣어준다.       idx가 k보다 낮으면 sum에, 아니면 result에 dp의 idx번쨰 값을 더해준다.       idx가 maxPts 이상인 추첨의 점수를 벗어나는 경우, sum에 dp의 $idx - maxPts$번째 값을 빼서 확률을 계산한다.           반복이 완료되면 계산된 확률인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/new-21-game/",
        "teaser": null
      },{
        "title": "Leetcode Java Push Dominoes",
        "excerpt":"문제  Link   코드  class Solution {    public String pushDominoes(String dominoes) {     char[] charArray = dominoes.toCharArray();     int index = -1;     char c = '.';     for (int idx = 0; idx &lt; charArray.length; idx++) {       if (charArray[idx] == 'L') {         if (index == -1 || c == 'L') {           while (index &lt; idx - 1) {             charArray[++index] = 'L';           }         } else if (c == 'R') {           int left = index + 1;           int right = idx - 1;           while (left &lt; right) {             charArray[left++] = 'R';             charArray[right--] = 'L';           }         }         index = idx;         c = 'L';       } else if (charArray[idx] == 'R') {         if (c == 'R') {           while (index &lt; idx - 1) {             charArray[++index] = 'R';           }         }         index = idx;         c = 'R';       }     }     if (c == 'R') {       while (index &lt; charArray.length - 1) {         charArray[++index] = 'R';       }     }     return String.valueOf(charArray);   }  }   결과  Link   설명          일렬로 세워둔 dominoes를 이용하여 좌측인 ‘L’과 우측인 ‘R’로 밀었을 때, 도미노가 쓰러진 형태를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            charArray는 dominoes를 문자 배열로 변환하여 저장한 변수이다.       index와 c는 위치와 문자를 저장하기 위한 변수로, -1과 ‘.’으로 초기화한다.           0부터 charArray의 길이 미만까지 idx를 증가시키며 아래를 반복한다.            charArray의 idx번째 문자가 ‘L’인 경우, 아래를 수행한다.                    index가 -1이거나 c가 ‘L’인 경우, index가 $idx - 1$ 미만일 때 까지 index를 증가시키며 charArray의 index번째 위치에 ‘L’을 넣어 좌측으로 쓰러진 도미노의 값을 넣어준다.           c가 ‘R’이면 left에 $index + 1$을, right를 $idx - 1$을, left가 right 미만까지 left를 증가시키며 charArray의 left번째 위치에 ‘R’을, right를 감소시키며 charArray의 right번쨰 위치에 ‘L’을 넣어 좌우로 도미노가 넘어지는 값을 넣어준다.           index에 idx를 넣고, c에 ‘L’을 기록해준다.                       charArray의 idx번째 문자가 ‘R’인 경우, 아래를 수행한다.                    c가 ‘R’이면 index가 $idx - 1$ 미만까지 index를 증가시키며 charArray의 index번째 위치에 ‘R’을 넣어 오른쪽으로 쓰러진 도미노의 값을 넣어준다.           index에 idx르 넣고, c에 ‘R’을 기록해준다.                                c가 ‘R’인 경우, index가 charArray의 길이보다 1 작을 때 까지 반복하여 index를 증가시키며 charArray의 index번째 값에 ‘R’을 넣어 우측으로 쓰러진 도미노의 값을 넣어준다.       마지막으로 charArray를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/push-dominoes/",
        "teaser": null
      },{
        "title": "Leetcode Java Similar String Groups",
        "excerpt":"문제  Link   코드  class Solution {    public int numSimilarGroups(String[] strs) {     boolean[] visited = new boolean[strs.length];     int result = 0;     for (int i = 0; i &lt; strs.length; i++) {       if (!visited[i]) {         this.dfs(strs, i, visited);         result++;       }     }     return result;   }    private void dfs(String[] strs, int index, boolean[] visited) {     visited[index] = true;     for (int i = 0; i &lt; strs.length; i++) {       if (!visited[i] &amp;&amp; this.isSimilar(strs[index], strs[i])) {         this.dfs(strs, i, visited);       }     }   }    private boolean isSimilar(String s1, String s2) {     int count = 0;     for (int i = 0; i &lt; s1.length(); i++) {       if (s1.charAt(i) != s2.charAt(i)) {         count++;       }       if (count &gt; 2) {         return false;       }     }     return count == 0 || count == 2;   }  }   결과  Link   설명          strs 내 아나그램으로 두 글자까지 변경하여 동일한 글자로 만들 수 있는 문자열 그룹의 수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            visited는 strs의 각 문자열 별 검증하기위해 방문한 이력을 남기기 위한 배열로, strs의 길이의 부울 배열로 초기화한다.       result는 그룹의 수를 계산하기 위한 변수로, 0으로 초기화한다.           0부터 strs의 길이 미만까지 i를 증가시키며 아래를 수행한다.            visited의 i번째 값이 false인 검증하지 않은 문자열이면 4번에서 정의한 dfs(String[] strs, int index, boolean[] visited) 메서드를 수행하고, result를 증가시킨다.           DFS 방식으로 동일 집단 검증을 수행할 dfs(String[] strs, int index, boolean[] visited) 메서드를 정의한다.            visited의 index번째 값을 true로 바꾸어준다.       0부터 strs의 길이 미만까지 i를 증가시키며 아래를 수행한다.                    visited의 i번째 값이 false인 검증하지 않은 문자열이면서 5번에서 정의한 isSimilar(String s1, String s2) 메서드를 수행하여 strs의 index번째 문자와 i번째 문자가 유사한 경우, index에 i를 넣어 재귀 호출을 수행한다.                           두 문자열이 유사한지 검증하기 위한 isSimilar(String s1, String s2) 메서드를 정의한다.            count는 문자 변경에 대한 개수를 세기 위한 변수로, 0으로 초기화한다.       0부터 s1의 길이 미만까지 i를 증가시키며 s1과 s2의 각 위치 별 다른 문자 개수를 count에 저장하며, 2개를 넘으면 false를 반환한다.       반복이 완료되고 count가 0인 동일한 문자거나, 2인 두 문자의 위치를 변경했을 때 같은 문자가 되지를 검증한 결과를 반환한다.           3번의 반복이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/similar-string-groups/",
        "teaser": null
      },{
        "title": "Leetcode Java Magic Squares In Grid",
        "excerpt":"문제  Link   코드  class Solution {    public int numMagicSquaresInside(int[][] grid) {     int result = 0;     for (int i = 0; i &lt;  grid.length - 2; i++) {       for (int j = 0; j &lt; grid[0].length - 2; j++) {         if (this.isMagicSquare(grid, i, j)) {           result++;         }       }     }     return result;   }    private boolean isMagicSquare(int[][] grid, int row, int col) {     boolean[] visited = new boolean[10];     for (int i = row; i &lt; row + 3; i++) {       for (int j = col; j &lt; col + 3; j++) {         if (grid[i][j] &lt; 1 || grid[i][j] &gt; 9 || visited[grid[i][j]]) {           return false;         }         visited[grid[i][j]] = true;       }     }     int sum = grid[row][col] + grid[row + 1][col + 1] + grid[row + 2][col + 2];     if (sum != grid[row][col + 2] + grid[row + 1][col + 1] + grid[row + 2][col]) {       return false;     }     for (int i = 0; i &lt; 3; i++) {       if (sum != grid[row + i][col] + grid[row + i][col + 1] + grid[row + i][col + 2] ||           sum != grid[row][col + i] + grid[row + 1][col + i] + grid[row + 2][col + i]) {         return false;       }     }     return true;   }  }   결과  Link   설명     grid 내에서 $3 \\times 3$ 크기의 마법 사각형의 개수를 반환하는 문제이다.            마법 사각형은 [1, 9] 범위의 숫자들로 이루어진 $3 \\times 3$ 크기의 사각형의 두 대각선과 세 행과, 열의 합이 모두 같은 사각형을 의미한다.                result는 마법 사각형의 개수를 저장할 변수로, 0으로 초기화한다.       0부터 grid의 길이보다 2 작은 값 미만까지 i를, 0부터 grid 첫 행의 길이보다 2 작은 값 미만까지 j를 증가시키며 아래를 수행한다.            4번에서 정의한 isMagicSquare(int[][] grid, int row, int col) 메서드를 수행한 결과가 true면 result를 증가시킨다.           마법 사각형인지 검증하기 위한 isMagicSquare(int[][] grid, int row, int col) 메서드를 정의한다.            visited는 각 숫자를 체크했는지 검증하기 위한 배열로, 크기가 10인 부울 배열로 초기화한다.       row부터 우측 두 열까지, col부터 아래 두 행까지 [1, 9] 범위 내 값이면서 중복된 값이 있는지 검증하여 만족하지 않으면 false를 반환한다.       sum에 대각선 하나의 합을 넣고 다른 대각선과 세 행, 열의 합이 모두 동일한지 검증하여 동일하지 않으면 false를, 동일하면 true를 반환한다.           검증이 완료되면 마법 사각형의 개수인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/magic-squares-in-grid/",
        "teaser": null
      },{
        "title": "Leetcode Java Keys and Rooms",
        "excerpt":"문제  Link   코드  class Solution {    public boolean canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) {     boolean[] visited = new boolean[rooms.size()];     List&lt;Integer&gt; firstRoom = rooms.get(0);     for (int i = 0; i &lt; firstRoom.size(); i++) {       this.dfs(rooms, visited, firstRoom.get(i));     }     for (int i = 1; i &lt; visited.length; i++) {       if (!visited[i]) {         return false;       }     }     return true;   }    private void dfs(List&lt;List&lt;Integer&gt;&gt; rooms, boolean[] visited, int index) {     visited[index] = true;     List&lt;Integer&gt; room = rooms.get(index);     for (int i = 0; i &lt; room.size(); i++) {       if (!visited[room.get(i)]) {         this.dfs(rooms, visited, room.get(i));       }     }   }  }   결과  Link   설명          rooms의 첫 방을 제외한 나머지 방들이 잠길 때, 방 안에 열 수 있는 방의 키를 사용하여 모든 룸을 방문할 수 있는지 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            visited는 방의 방문 여부를 검증하기 위한 변수로, rooms의 방의 개수만큼의 크기로 초기화한다.       firstRoom은 rooms 내 첫 방을 저장한 변수이다.                firstRoom의 모든 키를 이용하여 4번에서 정의한 dfs(List&lt;List&gt; rooms, boolean[] visited, int index) 메서드의 index에 넣어 수행한다.       DFS 방식으로 모든 방을 검증하기 위한 dfs(List&lt;List&gt; rooms, boolean[] visited, int index) 메서드를 정의한다.            visited의 index번째 방을 방문했으므로, 해당 위치에 true를 넣어준다.       room에 rooms의 index번째 방의 값을 넣어준다.       room의 모든 키들을 이용하여 방문하지 않은 방인 경우, index에 room의 i번째 키를 이용하여 재귀 호출을 수행한다.           visited의 모든 값을 이용하여 방문하지 않은 방이 있으면 false를, 모두 방문했으면 true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/keys-and-rooms/",
        "teaser": null
      },{
        "title": "Leetcode Java Split Array into Fibonacci Sequence",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; splitIntoFibonacci(String num) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     if (this.dfs(num, result, 0)) {       return result;     }     return new ArrayList&lt;&gt;();   }    private boolean dfs(String num, List&lt;Integer&gt; result, int index) {     if (index == num.length()) {       return result.size() &gt; 2;     }     int n = 0;     for (int i = index; i &lt; num.length(); i++) {       n = (n * 10) + num.charAt(i) - '0';       if (n &lt; 0) {         return false;       }       if (result.size() &lt; 2 || result.get(result.size() - 2) + result.get(result.size() - 1) == n) {         result.add(n);         if (this.dfs(num, result, i + 1)) {           return true;         }         result.remove(result.size() - 1);       }       if (num.charAt(index) == '0') {         break;       }     }     return false;   }  }   결과  Link   설명     num을 이용하여 그룹으로 구성된 값들 간 아래의 구성과 같은 피보나치 수열과 같은 조건을 만족하는 그룹이 되도록 만드는 문제이다.            num이 “123456579”이면, $1 + 4 = 5$, $2 + 5 = 7$ $3 + 6 = 9$인 [123, 456, 579]으로 구성이 가능하다.       피보나치 수열과 동일하게 위의 구성을 만족하기 위해서는 그룹은 3개 이상으로 구성된다.                결과를 넣을 result를 ArrayList로 초기화한다.            4번에서 정의한 dfs(String num, List result, int index) 메서드를 수행한 결과가 true면 구성이 완료되었으므로 result를 주어진 문제의 결과로 반환한다.       DFS 방식으로 그룹을 만들 dfs(String num, List result, int index) 메서드를 정의한다.            index가 num의 길이와 동일하면 result의 길이가 2 이상인지 검증한 결과를 반환한다.       n은 숫자를 계산할 변수로, 0으로 초기화하고 index부터 num의 길이 미만까지 i를 증가시키며 아래를 수행한다.                    n에 기존 값의 자릿수를 증가시키고, num의 i번째 문자를 숫자로 변환한 값을 더해준다.           n이 0 미만인 경우, 만족하는 결과를 만들 수 없으므로 false를 반환한다.           result의 크기가 2개 미만이거나, result의 마지막 두 값의 합이 n인 경우 피보나치 수열과 같은 조건을 만족하므로 result에 n을 넣고, index에 $i + 1$을 넣어 재귀 호출을 수행한 결과가 true면 true를 반환하고 마지막 값을 제거한다.           num의 index번쨰 값이 0인 경우, 반복을 중지시킨다.                       반복이 정상적으로 완료되면 조건을 만족하지 않으므로 false를 반환한다.           3번의 재귀 호출이 정상적으로 종료되면 만족한 그룹을 생성하지 못하므로, 새 ArrayList를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/split-array-into-fibonacci-sequence/",
        "teaser": null
      },{
        "title": "Leetcode Java Split Backspace String Compare",
        "excerpt":"문제  Link   코드  class Solution {    public boolean backspaceCompare(String s, String t) {     int i = s.length() - 1;     int j = t.length() - 1;     int back = 0;     while (true) {       back = 0;       while (i &gt;= 0 &amp;&amp; (back &gt; 0 || s.charAt(i) == '#')) {         back += s.charAt(i--) == '#' ? 1 : -1;       }       back = 0;       while (j &gt;= 0 &amp;&amp; (back &gt; 0 || t.charAt(j) == '#')) {         back += t.charAt(j--) == '#' ? 1 : -1;       }       if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; s.charAt(i) == t.charAt(j)) {         i--;         j--;       } else {         break;       }     }     return i == -1 &amp;&amp; j == -1;   }  }   결과  Link   설명     s와 t를 텍스트 편집기에 한 문자씩 입력할 때, 동일한 문자열이 되는지 검증하는 문제이다.            ’#’ 문자는 백스페이스를 의미하며 앞의 문자를 제거한다.                i와 j는 s 문자와 t 문자의 위치를 마지막 위치를 저장한 변수이다.       아래의 반복을 종료하기 전까지 계속 반복한다.            back은 ‘#’의 개수를 저장하기 위한 변수로, i와 j를 뒤에서부터 #이 존재하는 개수만큼 앞의 문자를 차감하여 위치를 이동시킨다.       i와 j가 0보다 크거나 같으면서 i와 j가 동일하면 i와 j를 감소시키고, 아니면 반복을 그만한다.           검증된 문자열의 두 위치 변수인 i와 j가 -1인지 검증한 결과를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/backspace-string-compare/",
        "teaser": null
      },{
        "title": "Leetcode Java Hand of Straights",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isNStraightHand(int[] hand, int groupSize) {     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();     for (int card : hand) {       map.put(card, map.getOrDefault(card, 0) + 1);     }     Arrays.sort(hand);     for (int card : hand) {       if (map.get(card) &lt;= 0) {         continue;       }       for (int i = 0; i &lt; groupSize; i++) {         int count = map.getOrDefault(card + i, 0);         if (count &gt; 0) {           map.put(card + i, count - 1);         } else {           return false;         }       }     }     return true;   }  }   결과  Link   설명          hand의 각 숫자들을 증가하는 값으로 구성된 groupSize개의 그룹으로 구성할 수 있는지 검증하는 문제이다.            map에 카드 값 별 개수를 키와 값으로 모두 넣어준다.       hand를 오름차순으로 정렬하고, 각 값을 card에 너허 아래를 수행한다.            map의 card번째 값이 0 이하로 모두 사용한 경우, 다음 값으로 넘어간다.       0부터 groupSize 미만까지 i를 증가시키며 아래를 수행한다.                    count에 map의 $card + i$번째 카드의 개수를 넣어준다.           count가 0 초과라면 개수를 차감하여 다시 map에 넣어준다.           위의 경우가 아니라면 그룹 분할이 불가능하므로 false를 주어진 문제의 결과로 반환한다.                           반복이 완료되면 그룹 분할이 가능하므로 true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/hand-of-straights/",
        "teaser": null
      },{
        "title": "Leetcode Java Shifting Letters",
        "excerpt":"문제  Link   코드  class Solution {    public String shiftingLetters(String s, int[] shifts) {     char[] charArray = s.toCharArray();     int shift = 0;     for (int i = s.length() - 1; i &gt;= 0; i--) {       shift += shifts[i] % 26;       charArray[i] = (char) (((charArray[i] - 'a') + shift) % 26 + 'a');     }     return new String(charArray);   }  }   결과  Link   설명     문자열 s의 각 위치 별 문자를 shifts의 위치 별 숫자의 누계까지 영문자 기준으로 우측으로 이동하는 문제이다.            ‘a’를 우측으로 한 칸 이동하면 ‘b’가 되고, ‘z’를 우측으로 한 칸 이동하면 ‘a’가 된다.           문제 풀이에 필요한 변수를 정의한다.            charArray는 s를 문자별로 나눈 배열로 저장한 변수이다.       shift는 shifts를 이동하며 각 문자의 이동 횟수를 저장할 변수로, 0으로 초기화한다.           s의 마지막 위치에서 0까지 i를 감소시키며 우측에서 좌측으로 이동하며 아래를 계산한다.            shift에 shifts의 i번째 값을 영문자의 개수인 26으로 나눈 나머지 값을 더해준다.       charArray의 i번째 위치에 charArray의 i번째 문자를 우측으로 shift번 이동하고 26으로 나눈 나머지 값에 해당하는 위치의 영문자로 넣어준다.           반복이 완료되면 charArray를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/shifting-letters/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximize Distance to Closest Person",
        "excerpt":"문제  Link   코드  class Solution {    public int maxDistToClosest(int[] seats) {     int length = seats.length;     int result = 0;     int left = -1;     for (int right = 0; right &lt; length; right++) {       if (seats[right] == 1) {         if (left == -1) {           result = right;         } else {           result = Math.max(result, (right - left) / 2);         }         left = right;       }     }     return seats[length - 1] == 1 ? result : Math.max(result, length - 1 - left);   }  }   결과  Link   설명          좌석에 사람이 있으면 1, 없으면 0으로 표시된 seats에서 좌우 사람들 간 거리가 가장 먼 자리의 위치를 찾는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 seats의 길이를 저장한 변수이다.       result는 좌우 사람들 간 거리가 가장 먼 거리의 위치를 저장할 변수로, 0으로 초기화한다.       left는 좌측 사람과의 거리를 저장하기 위한 변수로, 최소 위치보다 작은 -1로 초기화한다.           right를 0부터 length 미만까지 right를 증가시키며 아래를 반복한다.            seats의 right번째 위치에 사람이 존재하는 1인 경우, 아래를 수행한다.                    left가 -1인 초기 위치인 경우, result에 right를 넣어준다.           위의 경우가 아니라면 result에 result와 $\\frac{right - left}{2}$의 중간 위치를 넣어준다.           left에 right를 넣어 마지막 사람 위치를 저장한다.                           마지막으로 seats의 마지막 위치인 $length - 1$ 뻔째 값이 1이면 result를, 0인 빈 자리이면 left와의 거리 차이와 right 중 큰 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximize-distance-to-closest-person/",
        "teaser": null
      },{
        "title": "Leetcode Java Loud and Rich",
        "excerpt":"문제  Link   코드  class Solution {    public int[] loudAndRich(int[][] richer, int[] quiet) {     int[] result = new int[quiet.length];     for (int i = 0; i &lt; quiet.length; i++) {       result[i] = i;     }     while (true) {       boolean change = false;       for (int[] rich : richer) {         if (quiet[result[rich[0]]] &lt; quiet[result[rich[1]]]) {           result[rich[1]] = result[rich[0]];           change = true;         }       }       if (!change) {         break;       }     }     return result;   }  }   결과  Link   설명     [0, $n - 1$]까지 7명의 그룹이 존재하는 richer를 이용하여 아래를 만족하는 사람들의 배열을 반환하는 문제이다.            richer[i] = [ai, bi]일 때, bi보다 ai가 더 많은 돈을 가지고 있다는 의미이다.       quiet는 i번째 사람의 정숙함의 정도를 나타낸다.       answer[x] = y일 때, x보다 같거나 더 많은 돈을 가진 사람들 중에 quiet[y]의 값이 가장 작은 사람 y를 의미한다.                result는 결과를 저장할 배열로, quiet의 길이 크기의 정수 배열로 초기화하고 각 위치에 배열의 위치 값을 넣어준다.       아래의 반복을 계속 수행한다.            change는 변경되었는지 여부를 저장할 변수로, false로 초기화한다.       richer의 값을 rich에 순서대로 넣어 아래를 수행한다.                    result 내 rich의 돈 많은 사람인 첫 번째 순서에 해당하는 위치 값인 result[rich[0]]의 조용함 정도가 보다 적은 돈을 가진 사람인 두 번째 순서에 해당하는 위치 값인 result[rich[1]]의 조용함 정도보다 작은 경우, result[rich[1]]에 result[rich[0]]의 값을 넣어준다.           변경 이력이 있으므로 change를 true로 바꾸어준다.                       변경 이력이 없는 change가 false인 경우, 조건에 맞는 사람의 번호가 result에 저장되었으므로 반복을 종료한다.           반복이 종료되면 조건을 만족하는 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/loud-and-rich/",
        "teaser": null
      },{
        "title": "Leetcode Java Peak Index in a Mountain Array",
        "excerpt":"문제  Link   코드  class Solution {    public int peakIndexInMountainArray(int[] arr) {     int left = 0;     int right = arr.length - 1;     while (left &lt; right) {       int mid = left + ((right - left) / 2);       if (arr[mid] &gt; arr[mid + 1]) {         right = mid;       } else {         left = mid + 1;       }     }     return left;   }  }   결과  Link   설명     산의 높이가 저장된 arr을 이용하여 산꼭대기를 찾는 문제이다.            단, O(logN)의 시간 복잡성으로 문제를 풀어야 한다.       0 &lt; i &lt; $arr.length - 1$일 때, 아래를 만족한다.                    arr[0] &lt; arr[1] &lt; … &lt; arr[i - 1] &lt; arr[i]           arr[i] &gt; arr[$i + 1$] &gt; … &gt; arr[$arr.length - 1$]                       산꼭대기는 arr[0] &lt; arr[1] &lt; … &lt; arr[$i - 1$] &lt; arr[i] &gt; arr[$i + 1$] &gt; … &gt; arr[$arr.length - 1$]를 만족한다.                left와 right는 좌측과 우측 기준으로 탐색할 변수로, 0과 $arr.length - 1$로 초기화한다.       left가 right 미만일 때 까지 아래를 수행한다.            mid에 $left + \\frac{right - left}{2}$를 넣어준다.       arr의 mid번째 값이 $mid + 1$번째 값보다 큰 경우, 우측으로 탐색해야하므로 right에 mid를 넣어준다.       위를 만족하지 않으면, 좌측으로 탐색해야하므로 left에 $mid + 1$을 넣어준다.           반복이 완료되면 산꼭대기의 위치가 저장된 left를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/peak-index-in-a-mountain-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Car Fleet",
        "excerpt":"문제  Link   코드  class Solution {    public int carFleet(int target, int[] position, int[] speed) {     float[] times = new float[target];     for (int i = 0; i &lt; position.length; i++) {       times[position[i]] = (float) (target - position[i]) / speed[i];     }     int result = 0;     float prev = 0;     for (int i = target - 1; i &gt;= 0; i--) {       float curr = times[i];       if (curr &gt; prev) {         prev = curr;         result++;       }     }     return result;   }  }   결과  Link   설명     1차선 도로 내 차의 위치인 position와 해당 차량의 속도인 speed를 이용하여 target까지 도착할 때 까지 동일하게 도착하는 그룹의 수를 구하는 문제이다.            단, 1차선 도로이므로 추월이 불가능하므로 앞에 위치한 차량보다 빨라도 동일한 속도로 이동한다.       동일하게 도착하는 차량의 수가 둘 이상이어도 하나로 취급한다.           문제 풀이에 필요한 변수를 정의한다.            cars는 남은 위치에 도달하기 위한 시간을 저장할 배열로, target 크기로 초기화하여 모든 차량을 이용하여 times 내 position에 해당하는 위치에 $\\frac{target - position}{speed}$를 넣어준다.       result는 target에 동일하게 도착하는 그룹의 수를 저장할 변수로, 0으로 초기화한다.       prev는 이전의 가장 느린 시간을 저장할 변수로, 0으로 초기화한다.           times를 역순으로 $target - 1$부터 0 이상까지 i를 감소시키며 아래를 반복한다.            curr에 times의 i번째 값을 넣어준다.       curr이 prev보다 큰 경우, prev에 curr을 넣고 result를 증가시켜 그룹을 분리해준다.           반복이 완료되면 그룹의 수를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/car-fleet/",
        "teaser": null
      },{
        "title": "Leetcode Java K-Similar Strings",
        "excerpt":"문제  Link   코드  class Solution {    private int result;   private int length;    public int kSimilarity(String s1, String s2) {     this.result = Integer.MAX_VALUE;     this.length = s1.length();     this.dfs(s1.toCharArray(), s2.toCharArray(), 0, 0);     return this.result;   }    private void dfs(char[] s1CharArray, char[] s2CharArray, int start, int curr) {     if (curr &gt;= this.result) {       return;     }     for (int i = start; i &lt; this.length; i++) {       if (s1CharArray[i] != s2CharArray[i]) {         for (int j = i + 1; j &lt; this.length; j++) {           if (s1CharArray[i] == s2CharArray[j] &amp;&amp; s1CharArray[j] != s2CharArray[j]) {             this.swap(s2CharArray, i, j);             this.dfs(s1CharArray, s2CharArray, i + 1, curr + 1);             this.swap(s2CharArray, i, j);             if (s1CharArray[j] == s2CharArray[i]) {               break;             }           }         }         return;       }     }     this.result = Math.min(curr, this.result);   }    private void swap(char[] charArray, int i, int j) {     char c = charArray[i];     charArray[i] = charArray[j];     charArray[j] = c;   }  }   결과  Link   설명     s1을 s2로 변환하기 위한 최소 스왑 횟수를 구하는 문제이다.            단, 모든 문자는 [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’]로 이루어져있다.       s1은 s2의 Anagram이다.           문제 풀이에 필요한 전역 변수를 정의한다.            result는 스왑 횟수를 계산하기 위한 변수이다.       length는 문자열의 길이을 저장하기 위하 변수이다.                result에 정수의 최댓값을, length에 s1의 길이를 저장하고 4번에서 정의한 dfs(char[] s1CharArray, char[] s2CharArray, int start, int curr) 메서드를 s1과 s2를 문자 배열로 변환하고 start와 curr에 0을 넣어 수행한다.       DFS 방식으로 문자를 스왑하며 탐색할 dfs(char[] s1CharArray, char[] s2CharArray, int start, int curr) 메서드를 정의한다.            curr이 result보다 크거나 같은 경우, 현재 위치에서 수행 가능한 스왑 횟수를 넘어섰으므로 수행을 그만한다.       start부터 length 미만까지 i를 증가시키며 아래를 수행한다.                    s1CharArray와 s2CharArray의 i번째 문자가 같으면 반복을 계속한다.           그렇지 않으면 $i + 1$부터 length미만까지 j를 증가시키며 s1CharArray의 i번째 문자와 s2CharArray의 j번째 문자가 같고 두 배열의 j번째 문자가 동일하지 않는 경으면 해당 문자를 바꿔서 start에 $i + 1$, curr에 $curr + 1$을 이용하여 재귀 호출을 수행하고 바꾼 문자를 원 위치로 돌린 후, s1CharArray의 j번째 문자와 s2CharArray의 i번째 문자가 같으면 반복을 중지하고 i에 대한 반복 위치에서 다음 반복을 수행한다.                       반복이 완료되면 result에 curr과 result 중 작은 값을 넣어준다.           반복이 완료되면 최소 스왑 횟수인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/k-similar-strings/",
        "teaser": null
      },{
        "title": "Leetcode Java Score of Parentheses",
        "excerpt":"문제  Link   코드  class Solution {    public int scoreOfParentheses(String s) {     Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();     int result = 0;     for (int i = 0; i &lt; s.length(); i++) {       if (s.charAt(i) == '(') {         stack.push(result);         result = 0;       } else {         result = stack.pop() + Math.max(2 * result, 1);       }     }     return result;   }  }   결과  Link   설명     소괄호를 이용한 아래의 규칙대로 계산된 점수를 반환하는 문제이다.            ”()” 1점이며, “AB”는 A + B의 점수를 가지며 A와 B는 균형잡힌 괄호 문자열이다.       “(A)”는 $2 \\times A$의 점수를 가지며 A는 균형잡힌 괄호 문자열이다.           문제 풀이에 필요한 변수를 정의한다.            stack은 점수를 계산하기 위한 변수로, stack으로 초기화한다.       result는 점수를 저장할 변수로, 0으로 초기화한다.           0부터 s의 길이 미만까지 i를 증가시키며 아래를 수행한다.            s의 i번쨰 문자가 괄호의 시작인 ‘(‘ 문자인 경우, stack에 result를 넣어주고, result를 0으로 초기화한다.       위의 경우가 아니라면 result에 stack에서 점수를 꺼내서 $2 \\times result$와 1 중 큰 값과 더한 결과를 넣어준다.           반복이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/score-of-parentheses/",
        "teaser": null
      },{
        "title": "Leetcode Java Mirror Reflection",
        "excerpt":"문제  Link   코드  class Solution {    public int mirrorReflection(int p, int q) {     while (p % 2 == 0 &amp;&amp; q % 2 == 0) {       p /= 2;       q /= 2;     }     return 1 - (p % 2) + (q % 2);   }  }   결과  Link   설명     한 변의 길이가 p인 거울로 이루어진 사면체 내에서 남서쪽에서 발사된 레이저가 아래의 수용체 중 먼저 도달하는 지점을 구하는 문제이다.            레이저가 발사되는 남서쪽의 모서리를 제외하고 우측부터 위, 좌측 순으로 0, 1, 2의 수용체가 존재한다.       레이저는 남서쪽 모서리에서 남동쪽 0 수용체 위의 q 거리로 발사된다.           p와 q를 가자 2로 나눈 값이 모두 0일 때까지 아래를 수행한다.            p와 q를 각자 2로 나눈 값을 넣어준다.           2번이 반복이 완료되면 1에서 p에서 2를 나눈 나머지를 빼고 q에서 2를 나눈 나머지를 더한 결과를 주어진 문제의 결과로 반환한다.            p가 홀수이고 q가 짝수인 경우 한 바퀴 돌아서, 0 수용체에 도달한다.       p가 짝수이고 q가 홀수인 경우 좌우 벽에 반사되어, 2 수용체에 도달한다.       p와 q가 홀수인 경우 좌우 벽에 반사되어, 1 수용체에 도달한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/mirror-reflection/",
        "teaser": null
      },{
        "title": "Leetcode Java Lemonade Change",
        "excerpt":"문제  Link   코드  class Solution {    public boolean lemonadeChange(int[] bills) {     int[] changes = new int[] { 0, 0 };     for (int bill : bills) {       if (bill == 5) {         changes[0]++;       } else if (bill == 10) {         changes[0]--;         changes[1]++;       } else if (changes[1] &gt; 0) {         changes[1]--;         changes[0]--;       } else {         changes[0] -= 3;       }       if (changes[0] &lt; 0) {         return false;       }     }     return true;   }  }   결과  Link   설명     한 잔에 5달러인 레모네이드를 bills 순서대로 판매할 때, 거스름돈이 없이 판매하여 순차적으로 거스름돈을 반환할 수 있는지 검증하는 문제이다.            고객은 한 번에 한 잔의 레모네이드를 구매하며 5, 10, 20 달러 지폐를 지불한다.                changes는 5달러와 10달러의 거스름돈의 수를 저장할 배열로, 두 값을 0으로 초기화한다.       bills를 bill에 넣어 아래를 반복한다.            bill이 5인 경우, 5달러의 거스름돈이 생겼으므로 5달러의 개수를 증가시킨다.       위가 아니면서 bill이 10인 경우, 5달러의 거스름돈을 제공하고 10 달러의 거스름돈이 생겼으므로 5달러의 개수를 증가시키고 10달러의 수를 감소시킨다.       위가 아니면서 changes의 두 번째 값인 10달러의 거스름돈이 1개 이상인 경우, 20달러 지폐를 받았으므로 5달러와 10달러를 하나씩 감소시킨다.       위가 아니면 10달러의 거스름돈이 없으므로, 5달러의 수를 3개 감소시킨다.       5달러의 수가 0 미만인 경우 거스름돈 한도를 초과하였으므로, false를 주어진 문제의 결과로 반환한다.           반복이 완료되면 순차적으로 거스름돈을 반환하였으므로 true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/lemonade-change/",
        "teaser": null
      },{
        "title": "Leetcode Java Score After Flipping Matrix",
        "excerpt":"문제  Link   코드  class Solution {    public int matrixScore(int[][] grid) {     int row = grid.length;     int col = grid[0].length;     int result = (1 &lt;&lt; (col - 1)) * row;     for (int j = 1; j &lt; col; j++) {       int same = 0;       for (int i = 0; i &lt; row; i++) {         if (grid[i][j] == grid[i][0]) {           same++;         }       }       result += Math.max(same, row - same) * (1 &lt;&lt; (col - 1 - j));     }     return result;   }  }   결과  Link   설명     grid의 값을 이용하여 행과 열의 값을 반전시켜 얻을 수 있는 최대 점수를 구하는 문제이다.            각 행의 값은 이진법으로 점수를 계산한다.           문제 풀이에 필요한 변수를 정의한다.            row와 col은 grid 내 행과 열의 길이를 저장한 변수이다.       result는 결과를 저장하기 위한 변수로, 행의 마지막 위치 값이 모두 1인 경우 가질 수 있는 값을 넣어준다.           1부터 col 미만까지 j를 증가시키며 아래를 수행한다.            same은 현재 위치까지 동일한 값의 수를 저장할 변수로, 0으로 초기화한다.       0부터 row 미만까지 i를 증가시키며 아래를 수행한다.                    grid의[i][j]의 값과 grid의[i][0]의 값이 동일하면 same을 증가시켜 동일한 값의 수를 저장한다.                       result에 same 혹은 $row - same$ 중 큰 값인 1로 만들 값의 수와 이진수의 값을 계산하기 위한 $col - 1 - j$의 비트를 좌측으로 한 칸 이동시킨 값의 곱을 더해준다.           반복이 완료되면 계산된 최대 점수인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/score-after-flipping-matrix/",
        "teaser": null
      },{
        "title": "Leetcode Java Shortest Subarray with Sum at Least K",
        "excerpt":"문제  Link   코드  class Solution {    public int shortestSubarray(int[] nums, int k) {     int length = nums.length;     long[] sum = new long[length + 1];     for (int i = 0; i &lt; length; i++) {       sum[i + 1] = sum[i] + nums[i];     }     int left = 0;     int right = -1;     int[] dp = new int[length + 1];     int result = length + 1;     for (int i = 0; i &lt;= length; i++) {       while (right - left + 1 &gt; 0 &amp;&amp; sum[i] - sum[dp[left]] &gt;= k) {         result = Math.min(result, i - dp[left]);         left++;       }       while (right - left + 1 &gt; 0 &amp;&amp; sum[dp[right]] &gt;= sum[i]) {         right--;       }       dp[++right] = i;     }     return result == length + 1 ? -1 : result;   }  }   결과  Link   설명     nums 내 연속된 숫자의 합이 k인 부분 배열이 존재하는지 검증하여 해당 길이를 반환하는 문제이다.            단, 부분 배열이 존재하지 않으면 -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       sum은 nums의 점층적인 값의 합을 저장할 배열로, length 크기보다 하나 더 큰 크기의 배열로 초기화한다.       left와 right는 부분 배열의 구간을 찾기 위한 위치 변수로, 0과 -1로 초기화한다.       dp는 부분 배열의 시작 위치를 위치 별 저장하기 위한 배열로, length 크기보다 하나 더 큰 크기의 배열로 초기화한다.       result는 부분 배열의 길이를 저장할 변수로, 나올 수 없는 길이인 length보다 하나 더 큰 크기의 값으로 초기화한다.           0부터 length 이하까지 i를 증가시키며 아래를 수행한다.            $right - left + 1$의 값이 0보다 크고, sum의 i번째 값과 dp[left]번째 값의 차이가 k 이상인 경우, result에 result와 $i - dp[left]$ 중 작은 길이를 저장하고 left를 증가시킨다.       $right - left + 1$의 값이 0보다 크고, sum의 dp[right]번째 값이 i번째 값보다 크거나 같은 경우, right를 감소시키며 부분 배열의 범위를 축소시킨다.       right를 증가시키고 dp의 right번째 위치에 i를 넣어준다.           반복이 완료되면 result가 초기 값인 $length + 1$인지 검증하여 동일하면 -1을, 아니면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/shortest-subarray-with-sum-at-least-k/",
        "teaser": null
      },{
        "title": "Leetcode Java All Nodes Distance K in Binary Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode(int x) { val = x; }  * }  */ class Solution {    public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int k) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     if (k == 0) {       result.add(target.val);     } else {       this.dfs(root, target.val, k, 0, result);     }     return result;   }    private int dfs(TreeNode node, int target, int k, int depth, List&lt;Integer&gt; result) {     if (node == null) {       return 0;     } else if (depth == k) {       result.add(node.val);       return 0;     }     int correction = node.val == target || depth &gt; 0 ? 1 : 0;     int left = this.dfs(node.left, target, k, depth + correction, result);     int right = this.dfs(node.right, target, k, depth + correction, result);     if (node.val == target) {       return 1;     } else if (left == k || right == k) {       result.add(node.val);       return 0;     } else if (left &gt; 0) {       this.dfs(node.right, target, k, left + 1, result);       return left + 1;     } else if (right &gt; 0) {       this.dfs(node.left, target, k, right + 1, result);       return right + 1;     } else {       return 0;     }   }  }   결과  Link   설명          root에서 target과 거리가 k인 모든 노드의 값을 반환하는 문제이다.            result는 target과 거리가 k인 모든 노드의 값을 저장할 변수로, ArrayList로 초기화한다.            k가 0이면 자기 자신만 포함되므로, result에 target의 값을 넣어주고 아니면 4번에서 정의한 dfs(TreeNode node, int target, int k, int depth, List result) 메서드를 depth에 0을 넣고 수행한다.       DFS 방식으로 target과의 거리를 탐색할 dfs(TreeNode node, int target, int k, int depth, List result) 메서드를 정의한다.            node가 null이면 0을, depth가 k와 동일하면 result에 node의 val 값을 넣어주고 0을 반환한다.       correction에 node의 값과 target 이 동일하거나 depth가 0보다 크면 1을, 아니면 0을 넣어 거리를 초기화한다.       left에 node의 left TreeNode를 넣고, depth에 correction을 더해서 재귀 호출한 값을 넣어준다.       right에 node의 right TreeNode를 넣고, depth에 correction을 더해서 재귀 호출한 값을 넣어준다.       아래의 각 경우를 순차적으로 검증하여 거리에 대한 값을 반환한다.                    node의 val 값이 target과 동일하면 1을 반환한다.           left 혹은 right가 k이면 result에 node의 값을 넣어주고 0을 반환하여 초기화한다.           left가 0보다 큰 경우, node의 right TreeNode와 depth에 $right + 1$을 넣어 재귀 호출한 이후 $left + 1$을 반환하여 거리를 증가시킨다.           right가 0보다 큰 경우, node의 left TreeNode와 depth에 $left + 1$을 넣어 재귀 호출한 이후 $right + 1$을 반환하여 거리를 증가시킨다.           위의 모든 경우가 아니면 0을 반환하여 처음부터 계산을 수행한다.                           수행이 완료되면 모든 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/all-nodes-distance-k-in-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Smallest Subtree with all the Deepest Nodes",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public TreeNode subtreeWithAllDeepest(TreeNode root) {     if (root == null) {       return null;     }     int left = this.getDepth(root.left);     int right = this.getDepth(root.right);     if (left &gt; right) {       return this.subtreeWithAllDeepest(root.left);     } else if (left &lt; right) {       return this.subtreeWithAllDeepest(root.right);     } else {       return root;     }   }    private int getDepth(TreeNode root) {     if (root == null) {       return 0;     } else {       return Math.max(this.getDepth(root.left), this.getDepth(root.right)) + 1;     }   }  }   결과  Link   설명          root에서 가장 깊은 길이를 가진 TreeNode를 모두 포함한 가장 작은 하위 TreeNode를 반환하는 문제이다.            root가 null이면 null을 반환한다.            left와 right에 4번에서 정의한 getDepth(TreeNode root) 메서드를 각각 left와 right TreeNode를 이용하여 수행한 결과를 넣어준다.       깊이를 계산할 getDepth(TreeNode root) 메서드를 정의한다.            root가 null이면 0을, 아니면 root의 left와 right TreeNode를 이용하여 재귀 호출 한 결과 중 큰 값을 반환한다.           left와 right의 값에 따라 아래를 주어진 문제의 결과로 반환한다.            left가 right보다 크면 left TreeNode에만 가장 깊은 노드가 존재하므로, root의 left TreeNode를 이용하여 재귀 호출한 결과를 반환한다.       right가 left보다 크면 right TreeNode에만 가장 깊은 노드가 존재하므로, root의 right TreeNode를 이용하여 재귀 호출한 결과를 반환한다.       left와 right가 동일한 경우 모두 포함되는 경우는 root밖에 없으므로 root를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/smallest-subtree-with-all-the-deepest-nodes/",
        "teaser": null
      },{
        "title": "Leetcode Java Transpose Matrix",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] transpose(int[][] matrix) {     int row = matrix.length;     int col = matrix[0].length;     int[][] result = new int[col][row];     for (int j = 0; j &lt; col; j++) {       for (int i = 0; i &lt; row; i++) {         result[j][i] = matrix[i][j];       }     }     return result;   }  }   결과  Link   설명          matrix의 행과 열의 인덱스를 전환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            row는 matrix의 행의 개수를 저장한 변수이다.       col은 matrix의 열의 개수를 저장한 변수이다.       result는 matrix의 행과 열의 인덱스를 전환하여 저장할 배열로, $col \\times row$ 크기의 2차원 정수 배열로 초기화한다.                0부터 col미만까지 j를 증가시키고, 0부터 row미만까지 i를 증가시키며, result[j][i]의 위치에 matrix[i][j]의 값을 넣어준다.       반복이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/transpose-matrix/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Gap",
        "excerpt":"문제  Link   코드  class Solution {    public int binaryGap(int n) {     int result = 0;     for (int i = -32; n &gt; 0; n /= 2, i++) {       if (n % 2 == 1) {         result = Math.max(result, i);         i = 0;       }     }     return result;   }  }   결과  Link   설명     양의 정수 n을 이진 표현식으로 변환하였을 때, 1 사이가 가장 긴 거리를 반환하는 문제이다.            예를 들어 “1001”의 경우, 두 1 사이의 거리는 3이다.                result는 1 사이가 가장 긴 거리를 저장할 변수로, 0으로 초기화한다.       int를 이진 표현식으로 변환할 때 최대 가능한 자릿수인 32를 이용하여 i를 -32부터 n이 0 이상일 때 까지 n에 2로 나눈 몫을 넣어주고 i를 증가시키며 아래를 반복한다.            n을 2로 나눈 나머지가 1인 경우, result에 result와 i 중 큰 값을 넣어 기존 계산된 거리와 새로 계산된 거리를 비교하여 넣어주고 i를 0으로 초기화하여 다시 1 사이의 거리를 계산한다.           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-gap/",
        "teaser": null
      },{
        "title": "Leetcode Java Reordered Power of 2",
        "excerpt":"문제  Link   코드  class Solution {    public boolean reorderedPowerOf2(int n) {     long count = this.getCount(n);     for (int i = 0; i &lt; 32; i++) {       if (this.getCount(1 &lt;&lt; i) == count) {         return true;       }     }     return false;   }    private long getCount(int n) {     long count = 0;     while (n &gt; 0) {       count += (int) Math.pow(10, n % 10);       n /= 10;     }     return count;   }  }   결과  Link   설명          앞의 자리가 0이 되지 않도록 순서를 변경하여 2의 거듭 제곱이 될 수 있도록 할 수 있는지 검증하는 문제이다.            count에 3번에서 정의한 getCount(int n) 메서드에 n을 넣어 수행한 결과를 넣어준다.       주어진 숫자의 0 ~ 9 까지 숫자의 개수를 계산할 getCount(int n) 메서드를 정의한다.            count는 숫자의 개수를 계산할 변수로, overflow를 방지하기 위해서 long 타입의 0으로 초기화한다.       n이 0 초과일 때 까지 아래를 수행한다.                    count에 n을 10으로 나눈 값의 나머지를 이용하여 10의 제곱수를 더해준다.           n에 n을 10으로 나눈 몫을 넣어준다.                       반복이 완료되면 계산된 count를 반환한다.           0부터 32 미만까지 i를 증가시키며 아래를 반복한다.            1의 비트를 좌측으로 i만큼 이동한 값을 이용하여 3번에서 정의한 getCount(int n) 메서드를 수행한 결과가 count와 동일하면 거듭 제곱이 가능하므로, true를 주어진 문제의 결과로 반환한다.           반복이 완료되면 거듭 제곱을 만들 수 없으므로, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reordered-power-of-2/",
        "teaser": null
      },{
        "title": "Leetcode Java Advantage Shuffle",
        "excerpt":"문제  Link   코드  class Solution {    public int[] advantageCount(int[] nums1, int[] nums2) {     int length = nums1.length;     Integer[] position = new Integer[length];     for (int i = 0; i &lt; length; i++) {       position[i] = i;     }     int result[] = new int[length];     Arrays.sort(position, (i, j) -&gt; nums2[i] - nums2[j]);     Arrays.sort(nums1);     int low = 0;     int high = length - 1;     for (int i = length - 1; i &gt;= 0; i--) {       int index = position[i];       if (nums2[index] &lt; nums1[high]) {         result[index] = nums1[high--];       } else {         result[index] = nums1[low++];       }     }     return result;   }  }   결과  Link   설명     길이가 같은 nums과 nums2를 이용하여 nums2의 장점을 최대화하는 nums1의 순열을 반환하는 문제이다.            nums2의 장점은 nums1[i] &gt; nums2[i]인 인덱스의 개수이다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums1의 길이를 저장한 변수이다.       position은 각 위치 별 위치 값을 저장할 변수로, 모든 자리에 자신의 위치 값을 넣어준다.       result는 nums2의 장점을 최대화 하는 num1의 순열을 저장할 변수로, length 길이의 정수 배열로 초기화한다.                position은 result의 값 기준에 대한 위치 값을 오름차순으로 넣어주고, num1을 오름차순으로 정렬한다.            nums1의 값의 탐색에 사용할 low에 0을, high에 $length - 1$을 넣어 위치 변수를 초기화한다.       $length - 1$부터 0 이상까지 i를 감소시키며 아래를 반복한다.            index에 position의 i번째 값을 꺼내 넣어준다.       nums2의 index번째 값이 nums1의 high번째 값보다 작은 경우, result의 index번째 위치에 nums1의 high번째 값을 넣어주고 high를 감소시킨다.       위의 경우가 아니라면 result의 index번째 위치에 nums1의 low번째 값을 넣어주고 low를 증가시킨다.           반복이 완료되면 결과를 저장한 nums2를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/advantage-shuffle/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Number of Refueling Stops",
        "excerpt":"문제  Link   코드  class Solution {    public int minRefuelStops(int target, int startFuel, int[][] stations) {     Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();     int i = 0;     int result = 0;     while (startFuel &lt; target) {       while (i &lt; stations.length &amp;&amp; stations[i][0] &lt;= startFuel) {         queue.offer(-stations[i++][1]);       }       if (queue.isEmpty()) {         return -1;       }       startFuel -= queue.poll();       result++;     }     return result;   }  }   결과  Link   설명     startFuel만큼 주유된 차량으로 stations의 주유소를 거쳐 target까지 도착하기까지 최소 주유 횟수를 구하는 문제이다.            target까지 도착할 수 없는 경우, -1을 주어진 문제의 결과로 반환한다.       stations[i] = [positioni, fueli]로, positioni는 주유소의 위치 fueli는 주유 용량을 의미한다.       1의 거리를 이동하기 위해 1의 주유 용량을 소모한다.           문제 풀이에 필요한 변수를 정의한다.            queue는 현재 주유된 용량 내 도착할 수 있는 주유소의 주유 용량을 저장하기 위한 변수로, 주유 용량을 오름차순으로 정렬해서 저장하기 위해 PriorityQueue로 초기화한다.       i는 stations의 탐색 위치를 저장할 변수로, 처음 위치인 0으로 초기화한다.       result는 최소 주유 횟수를 저장하기 위한 변수로, 0으로 초기화한다.           startFuel이 target이 되기 전까지 아래를 반복한다.            i가 stations의 길이 미만으로 모두 탐색한 상태가 아니면서 stations[i][0]가 startFuel이하인 도착 가능한 주유소인 경우, queue에 해당 주유소의 주유 용량인 stations[i][1]을 음수로 넣어주고 i를 증가시킨다.       queue가 비어있는 경우 target까지 도착하기 전에 주유된 용량을 모두 소모하므로, -1을 주어진 문제의 결과로 반환한다.       startFuel에 queue에서 가장 작은 값을 꺼내 빼주고 result를 증가시킨다.           반복이 완료되면 최소 주유 횟수가 계산된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-number-of-refueling-stops/",
        "teaser": null
      },{
        "title": "Leetcode Java Leaf-Similar Trees",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public boolean leafSimilar(TreeNode root1, TreeNode root2) {     List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();     List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();     this.dfs(root1, list1);     this.dfs(root2, list2);     if (list1.size() != list2.size()) {       return false;     }     for (int i = 0; i &lt; list1.size(); i++) {       if (!list1.get(i).equals(list2.get(i))) {         return false;       }     }     return true;   }    private void dfs(TreeNode root, List&lt;Integer&gt; list) {     if (root != null) {       if (root.left == null &amp;&amp; root.right == null) {         list.add(root.val);       } else {         this.dfs(root.left, list);         this.dfs(root.right, list);       }     }   }  }   결과  Link   설명          root1과 root2의 리프 노드의 값의 순서가 동일한지 검증하는 문제이다.            list1과 list2는 리프 노드들을 저장할 변수로, 3번에서 정의한 dfs(TreeNode root, List list) 메서드를 이용하여 root1의 리프 노드들을 list1에 root2의 리프 노드들을 list2에 저장한다.       DFS 방식으로 리프 노드를 순차적으로 저장할 dfs(TreeNode root, List list) 메서드를 정의한다.            root가 null이 아닌 경우, 아래를 수행한다.                    root의 left TreeNode와 right TreeNode가 null인 리프 노드인 경우, list에 root의 val 값을 넣어준다.           위의 경우가 아니라면 root의 left TreeNode를 이용하여 재귀 호출 후 right TreeNode로 다시 재귀 호출을 수행 한다.                                root1과 root2의 리프 노드들이 list1과 list2에 저장되었으면, list1과 list2의 길이가 같은지 여부를 우선 검증하여 길이가 다르면, false를 주어진 문제의 결과로 반환한다.       list1과 list2의 값의 순서가 동일한지 검증하여 동일하지 않으면 false를, 동일하면 true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/leaf-similar-trees/",
        "teaser": null
      },{
        "title": "Leetcode Java Length of Longest Fibonacci Subsequence",
        "excerpt":"문제  Link   코드  class Solution {    public int lenLongestFibSubseq(int[] arr) {     int length = arr.length;     int[][] dp = new int[length][length];     int result = 0;     for (int i = 2; i &lt; length; i++) {       int left = 0;       int right = i - 1;       while (left &lt; right) {         int val = arr[left] + arr[right] - arr[i];         if (val &lt; 0) {           left++;         } else if (val &gt; 0) {           right--;         } else {           dp[right][i] = dp[left][right] + 1;           result = Math.max(result, dp[right][i]);           left++;           right--;         }       }     }     return result == 0 ? 0 : result + 2;   }  }   결과  Link   설명          최소 3개 이상의 값이 존재하는 arr의 값들을 이용하여 만들 수 있는 피보나치 수열의 최대 길이를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 arr의 길이를 저장한 변수이다.       dp는 만들 수 있는 피보나치 수열의 최대 길이를 저장하기 위한 배열로, $length \\times length$ 크기의 배열로 정의한다.       result는 최대 길이를 저장할 변수로, 0으로 초기화한다.           피보나치 수열의 최소 위치인 2부터 length 미만까지 i를 증가시키며 아래를 반복한다.            left와 right는 위치 탐색에 필요한 변수로, 0과 $i - 1$로 초기화한다.       left가 right 미만일 때 까지 아래를 반복한다.                    val에 arr의 left번째 값과 right번째 값을 더하고, i번째 값을 빼준다.           val 값이 0 미만이면 left를 증가시키고 0 초과이면 right를 감소시켜 범위를 좁혀준다.           val 값이 0이면 피보나치 수열을 만족하므로, dp[right][i]의 위치에 dp[left][right]의 값보다 1 큰 값으로 넣어준 후 left를 증가시키고 right를 감소시킨다.                           반복이 완료되면 result가 0이면 0을, 아니면 피보나치 수열을 만족하는 숫자의 갯수가 존재하므로 2를 더해서 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/length-of-longest-fibonacci-subsequence/",
        "teaser": null
      },{
        "title": "Leetcode Java Walking Robot Simulation",
        "excerpt":"문제  Link   코드  class Solution {    private static final int[][] DIRECTIONS = new int[][] {     { 0, 1 },     { 1, 0 },     { 0, -1 },     { -1, 0 }   };    public int robotSim(int[] commands, int[][] obstacles) {     Set&lt;Integer&gt; set = new HashSet&lt;&gt;();     for (int[] obstacle : obstacles) {       set.add(obstacle[0] + obstacle[1] * 40000);     }     int[] coordinate = new int[] { 0, 0 };     int direction = 0;     int result = 0;     for (int command : commands) {       if (command == -1) {         direction = (direction + 1) % 4;       } else if (command == -2) {         direction = (direction - 1 + 4) % 4;       } else {         while (command-- &gt; 0) {           if (!set.contains((coordinate[0] + DIRECTIONS[direction][0]) + (coordinate[1] + DIRECTIONS[direction][1]) * 40000)) {             coordinate[0] += DIRECTIONS[direction][0];             coordinate[1] += DIRECTIONS[direction][1];             result = Math.max(result, coordinate[0] * coordinate[0] + coordinate[1] * coordinate[1]);           } else {             break;           }         }       }     }     return result;   }  }   결과  Link   설명     [0, 0]에서 출발하여 아래의 세 명령이 존재하는 commands를 이용하여 얻을 수 있는 최대 Euclidean distance를 반환하는 문제이다.            -2는 90도로 좌회전한다.       -1은 90도로 우회전한다.       1 ~ 9는 각 거리만큼 앞으로 이동한다.                DIRECTIONS는 이동 방향을 저장할 변수로, 위쪽 방향부터 시계 방향으로 이동 방향을 넣어준다.       문제 풀이에 필요한 변수를 정의한다.            set은 obstacle의 장애물 위치를 넣을 변수로, obstacle의 y 위치 값에 값 범위 밖의 수인 40,000을 곱한 값과 y 위치 값을 더해서 넣어준다.       coordinate는 현재 위치를 저장할 변수로, x와 y의 위치가 [0, 0]으로 시작하므로 해당 값으로 초기화한 정수 배열로 정의한다.       direction은 방향을 저장할 변수로, 0으로 초기화한다.       result는 최대 유클리안 거리를 계산하여 저장할 변수로, 0으로 초기화한다.           commands의 모든 값들을 순차적으로 command에 넣어 아래를 수행한다.            command가 -1인 경우, direction에 자신의 값을 증가시키고 overflow를 방지하기 위하여 4로 나눈 나머지 값을 넣어준다.       command가 -2인 경우, direction에 자신의 값을 감소시키고 4를 더한 후 overflow를 방지하기 위하여 4로 나눈 나머지 값을 넣어준다.       그 외의 값인 경우, command를 감소시키며 0 초과일 때 까지 아래를 반복한다.                    현재 위치에서 이동한 위치에 장애물이 존재하지 않는 경우, coordinate의 값에 이동하는 방향의 값을 더하고 result에 현재까지 최대 유클리안 거리를 저장한 result와 현재 위치에서의 유클리안 거리를 계산한 값 중 큰 값을 넣어준다.           현재 위치에서 이동한 위치에 장애물이 존재하는 경우 더 이상 이동이 불가능하기 때문에 반복을 중단한다.                           수행이 완료되면 최대 유클리안 거리가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/walking-robot-simulation/",
        "teaser": null
      },{
        "title": "Leetcode Java Koko Eating Bananas",
        "excerpt":"문제  Link   코드  class Solution {    public int minEatingSpeed(int[] piles, int h) {     int left = 1;     int right = 1000000000;     while (left &lt; right) {       int mid = (left + right) / 2;       int times = 0;       for (int pile : piles) {         times += (pile + mid - 1) / mid;       }       if (times &gt; h) {         left = mid + 1;       } else {         right = mid;       }     }     return left;   }  }   결과  Link   설명     바나나의 갯수가 저장된 piles를 h 시간동안 다 먹을 수 있는 시간당 바나나의 수를 구하는 문제이다.            단, 시간 당 먹을 수 있는 바나나의 수가 piles에서 고른 바나나의 수보다 크다면 선택한 바나나의 갯수까지 먹고 다음 시간에 piles 내 바나나를 선택하여 먹을 수 있다.                left와 right는 시간 별 먹을 수 있는 바나나의 수를 탐색하기 위한 위치 변수로, 최소 갯수인 1과 최대 갯수인 1,000,000,000으로 초기화한다.       left가 right 미만까지 아래를 수행한다.            mid는 left와 right의 중앙 값으로, $\\frac{left + right}{2}$를 넣어준다.       times는 piles의 값을 이용하여 시간 당 mid개를 먹을 때, 소요되는 시간을 저장한다.       times가 h보다 큰 경우, left에 $mid + 1$을 넣어 시간 당 먹을 수 있는 바나나의 갯수를 증가시켜 범위을 좁힌다.       times가 h보다 크지 않는 경우, right에 mid를 넣어 시간 당 먹을 수 있는 바나나의 갯수를 감소시켜 범위를 좁힌다.           반복이 완료되면 piles를 h 시간동안 다 먹을 수 있는 시간당 바나나의 수를 탐색한 left를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/koko-eating-bananas/",
        "teaser": null
      },{
        "title": "Leetcode Java Middle of the Linked List",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode middleNode(ListNode head) {     ListNode slow = head;     ListNode fast = head;     while (fast != null &amp;&amp; fast.next != null) {       slow = slow.next;       fast = fast.next.next;     }     return slow;   }  }   결과  Link   설명     head의 중앙에 있는 ListNode를 반환하는 문제이다.            중앙에 두 ListNode가 존재하면 두 번째 ListNode를 반환한다.                slow는 한 단계 씩 이동하기 위한 ListNode이고, fast는 두 단계 씩 이동하기 위한 ListNode로 둘 다 head로 초기화한다.            fast와 fast의 다음 ListNode가 null이 아닐 때 까지 slow에 slow의 다음 ListNode를, fast에 fast의 다다음 ListNode를 넣어준다.       반복이 완료되면 head의 중앙에 위치한 slow를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/middle-of-the-linked-list/",
        "teaser": null
      },{
        "title": "Leetcode Java Stone Game",
        "excerpt":"문제  Link   코드  class Solution {    public boolean stoneGame(int[] piles) {     int sum = 0;     int total = 0;     for (int pile : piles) {       total += pile;     }     int left = 0;     int right = piles.length - 1;     while (left &lt;= right) {       if (piles[left] &gt; piles[right]) {         sum += piles[left++];       } else {         sum += piles[right--];       }     }     return sum &gt; total / 2;   }  }   결과  Link   설명          piles에 저장된 돌의 수를 앞과 뒤에서 번갈아가며 가져갈 때 처음 시작하는 사람이 이길 수 있는지 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            sum은 처음 시작하는 사람이 가져간 돌의 숫자를 저장할 변수로, 0으로 초기화한다.       total은 piles의 모든 돌의 수를 저장할 변수로, piles를 반복하여 모든 값을 더해준다.       left와 right는 piles의 앞과 뒤의 위치를 저장할 변수로, piles의 처음과 끝의 위치를 넣어 초기화한다.           left가 right 이하일 때 까지 아래를 반복한다.            piles의 left번째 돌의 수가 right번째 돌의 수보다 큰 경우, sum에 piles의 left번째 돌의 수를 더해주고 left를 증가시킨다.       위의 경우가 아니라면, sum에 piles의 right번째 돌의 수를 더해주고 right를 감소시킨다.           sum이 total의 절반 이상의 돌을 가졌는지 검증한 결과를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/stone-game/",
        "teaser": null
      },{
        "title": "Leetcode Java Nth Magical Number",
        "excerpt":"문제  Link   코드  class Solution {    public int nthMagicalNumber(int n, int a, int b) {     long A = a;     long B = b;     long mod = 1000000007L;     long left = Math.min(a, b);     long right = (long) n * left;     while (B &gt; 0) {       long temp = A;       A = B;       B = temp % B;     }     long lcm = (a * b) / A;     while (left &lt; right) {       long mid = left + (right - left) / 2;       if ((mid / a) + (mid / b) - (mid / lcm) &lt; n) {         left = mid + 1;       } else {         right = mid;       }     }     return (int) (left % mod);   }  }   결과  Link   설명     a 혹은 b로 나눌 수 있는 n번째 정수를 찾는 문제이다.            단, 값이 매우 클 수 있으므로 모듈러 $10^9 + 7$를 이용한 값으로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            A와 B는 주어진 a와 b를 long 형으로 변경한 변수이다.       mod는 모듈러 $10^9 + 7$ 값을 저장한 변수이다.       left와 right는 결과 탐색을 수행할 위치 변수로, a와 b 중 가장 작은 값과 해당 값에 n을 더한 값을 각각 넣어준다.                B가 0 초과일 때 까지 temp에 A를 임시 보관 후, A에 B를 B에 temp의 B를 나눈 나머지를 넣어준다.            lcm은 a와 b의 최소 공배수를 넣을 변수로, $\\frac{a \\times b}{A}$의 결과를 넣어준다.       left가 right보다 작을 때 까지 아래를 반복한다.            mid는 중앙값을 넣어줄 변수로, $left + \\frac{right - left}{2}$를 넣어준다.       $\\frac{mid}{a} + \\frac{mid}{b} - \\frac{mid}{lcm}$의 결과가 n 미만인 경우, left에 $mid + 1$을 아니면 right에 mid를 넣어 값의 범위를 좁혀준다.           반복이 완료되면 left를 mod로 나눈 값을 int 형으로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/nth-magical-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Profitable Schemes",
        "excerpt":"문제  Link   코드  class Solution {    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {     int[][] dp = new int[minProfit + 1][n + 1];     dp[0][0] = 1;     int mod = 1000000007;     for (int k = 0; k &lt; group.length; k++) {       int g = group[k];       int p = profit[k];       for (int i = minProfit; i &gt;= 0; i--) {         for (int j = n; j &gt;= g; j--) {           dp[i][j] = (dp[i][j] + dp[Math.max(0, i - p)][j - g]) % mod;         }       }     }     int result = 0;     for (int num : dp[minProfit]) {       result = (result + num) % mod;     }     return result;   }  }   결과  Link   설명     최소 minProfit의 이익을 낼 수 있는 구성원의 경우의 수를 구하는 문제이다.            구성원은 최대 n명까지 설정이 가능하다.       group[i]는 profix[i]의 이익을 창출한다.       경우의 수가 매우 클 수 있으므로 모듈러 $10^9 + 7$을 이용하여 결과를 반환한다.           문제 풀이에 필요한 변수를 정의한다.            dp는 경우의 수를 구하기 위한 변수로, $(minProfit + 1) \\times (n + 1)$ 크기의 2차원 배열로 초기화하고 dp[0][0]에 1을 넣어준다.       mod는 결과 반환에 사용할 모듈러 값으로, $10^9 + 7$로 초기화한다.           k를 0부터 group의 크기까지 k를 증가시키며 아래를 수행한다.            g에 group의 k번째 값을, p에 profit의 k번째 값을 넣어준다.       minProfit부터 0 이상까지 i를 감소시키고, n부터 g 이상까지 j를 감소시키며 아래를 수행한다.                    dp[i][j]번째 위치에 dp[i][j]의 값과 dp 내 0과 $i - p$ 중 큰 값의 행의 $j - g$ 열의 값을 더해서 mod를 나눈 나머지 값을 넣어준다.                           반복이 완료되면 경우의 수를 넣을 result에 dp[minProfit] 행의 모든 열 값들을 이용하여 result에 result와 num의 합을 mod로 나눈 나머지 값을 순차적으로 넣어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/profitable-schemes/",
        "teaser": null
      },{
        "title": "Leetcode Java Decoded String at Index",
        "excerpt":"문제  Link   코드  class Solution {    public String decodeAtIndex(String s, int k) {     int i = 0;     long n = 0;     for (; n &lt; k; i++) {       if (Character.isDigit(s.charAt(i))) {         n *= s.charAt(i) - '0';       } else {         n++;       }     }     while (--i &gt; 0) {       if (Character.isDigit(s.charAt(i))) {         n /= s.charAt(i) - '0';         k %= n;       } else {         if (k % n == 0) {           break;         } else {           n--;         }       }     }     return Character.toString(s.charAt(i));   }  }   결과  Link   설명     아래의 규칙대로 만들어진 암호화된 문자열 s를 복호화 하였을 때, k번째 문자를 찾는 문제이다.            문자열 + 숫자의 반복으로 이루어진 s는, 앞의 문자열이 숫자만큼 반복되는 문자라는 의미이다.       예를 들어, “ab2cd3”를 복호화하면 “ababcdcdcd”가 된다.           문제 풀이에 필요한 변수를 정의한다.            i는 문자열 s를 복호화 하였을 때 k번째 문자가 위치한 암호화된 문자의 위치를 저장할 변수로, 0으로 초기화한다.       n은 k번째 문자를 탐색하기 위한 변수로, overflow를 방지하기 위해 long 형의 0으로 초기화한다.           n이 k 미만일 때 까지 i를 증가시키며 아래를 반복한다.            s의 i번째 문자가 숫자인 경우, n에 n과 해당 자리의 숫자를 곱한 값을 넣어준다.       위의 경우가 아니라면 문자이므로, n을 증가시킨다.           3번의 반복이 완료되면 i를 감소시키며 0 초과일 때까지 아래를 반복한다.            s의 i번째 문자가 숫자인 경우, n에 n과 해당 자리의 숫자를 나눈 값을 넣어주고 k에 k와 n을 나눈 나머지 값을 넣어 반복된 문자열의 수만큼 감소시킨다.       위의 경우가 아니라면 k를 n으로 나눈 나머지가 0이면 위치 탐색이 완료되었으므로 반복을 중지하고, 아니면 n을 감소시킨다.           반복이 완료되면 문자열 s의 i번째 문자를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/decoded-string-at-index/",
        "teaser": null
      },{
        "title": "Leetcode Java Boats to Save People",
        "excerpt":"문제  Link   코드  class Solution {    public int numRescueBoats(int[] people, int limit) {     Arrays.sort(people);     int i = 0;     int j = people.length - 1;     int result = 0;     while (i &lt;= j) {       result++;       if (people[i] + people[j--] &lt;= limit) {         i++;       }     }     return result;   }  }   결과  Link   설명          사람의 몸무게가 담긴 people을 이용하여 limit 이하인 사람들의 그룹을 만드는 문제이다.            people을 오름차순으로 정렬하여 작은 몸무게인 사람들을 앞으로 모아준다.       문제 풀이에 필요한 변수를 정의한다.            i와 j는 몸무게 조합을 생성하기 위한 변수로, people의 처음 위치와 마지막 위치를 넣어준다.       result는 그룹의 수를 저장하기 위한 변수로, 0으로 초기화한다.           i가 j 이하일 때 까지 아래를 반복한다.            하나의 군집을 생성할 수 있으므로 result를 증가시킨다.       i번쨰 사람과 j번째 사람이 limit 이하인 경우, i를 증가시켜 범위를 좁혀주고 j를 감소시킨다.           반복이 완료되면 그룹의 수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/boats-to-save-people/",
        "teaser": null
      },{
        "title": "Leetcode Java Projection Area of 3D Shapes",
        "excerpt":"문제  Link   코드  class Solution {    public int projectionArea(int[][] grid) {     int result = 0;     int length = grid.length;     for (int i = 0; i &lt; length; i++) {       int x = 0;       int y = 0;       for (int j = 0; j &lt; length; j++) {         x = Math.max(x, grid[i][j]);         y = Math.max(y, grid[j][i]);         if (grid[i][j] &gt; 0) {           result++;         }       }       result += x + y;     }     return result;   }  }   결과  Link   설명          크기의 3차원 공간에서 위치 별 $1 \\times 1 \\times 1$ 큐브를 쌓은 수가 저장된 $n \\times n$ 크기의 grid를 이용하여 x, y, z 축 기준으로 볼 때 면적의 합을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 면적의 합을 저장할 변수로, 0으로 초기화한다.       length는 grid의 길이를 저장한 변수이다.           0부터 length 미만까지 i를 증가시키며 아래를 수행한다.            x와 y는 x축과 y축에서 본 면적을 저장하기 위한 변수로, 모두 0으로 초기화한다.       0부터 length 미만까지 j를 증가시키며 아래를 수행한다.                    x에 해당 값과 grid[i][j]의 값 중 큰 값을 넣어, x축에서 본 i번째 큐브의 최대 면적을 찾는다.           y에 해당 값과 grid[j][i]의 값 중 큰 값을 넣어, y축에서 본 j번째 큐브의 최대 면적을 찾는다.           grid[i][j]의 값이 0보다 큰 경우, result를 증가시켜 z축에서 본 면적을 증가시킨다.                       반복이 완료되면 result에 x와 y 값을 더해준다.           모든 반복이 완료되면 면적이 계산된 result를 주어진 문제의 결과를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/projection-area-of-3d-shapes/",
        "teaser": null
      },{
        "title": "Leetcode Java Uncommon Words from Two Sentences",
        "excerpt":"문제  Link   코드  class Solution {    public String[] uncommonFromSentences(String s1, String s2) {     Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();     for (String word : s1.split(\" \")) {       map.put(word, map.getOrDefault(word, 0) + 1);     }     for (String word : s2.split(\" \")) {       map.put(word, map.getOrDefault(word, 0) + 1);     }     List&lt;String&gt; result = new ArrayList&lt;&gt;();     for (String word : map.keySet()) {       if (map.get(word) == 1) {         result.add(word);       }     }     return result.toArray(new String[result.size()]);   }  }   결과  Link   설명          s1과 s2의 단어 중 중복되지 않은 단어를 찾는 문제이다.            map은 단어 별 반복 횟수를 저장할 변수로, s1과 s2를 공백(“ “) 문자를 기준으로 분리하여 횟수를 계산한다.            result는 결과를 저장할 변수로, map을 반복하여 한 번만 사용된 문자를 넣어 배열로 전환하여 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/uncommon-words-from-two-sentences/",
        "teaser": null
      },{
        "title": "Leetcode Java Spiral Matrix III",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {     int[][] result = new int[rows * cols][2];     int row = 0;     int col = 1;     int n = 0;     for (int j = 0; j &lt; rows * cols; n++) {       for (int i = 0; i &lt; (n / 2) + 1; i++) {         if (0 &lt;= rStart &amp;&amp; rStart &lt; rows &amp;&amp; 0 &lt;= cStart &amp;&amp; cStart &lt; cols) {           result[j++] = new int[] { rStart, cStart };         }         rStart += row;         cStart += col;       }       int temp = row;       row = col;       col = -temp;     }     return result;   }  }   결과  Link   설명     $rows \\times cols$ 크기의 2차원 배열의 [rStart, cStart]에서 시작하여 오른쪽 -&gt; 아래쪽 -&gt; 왼쪽 -&gt; 위쪽으로 시계 방향의 나선형으로 이동하는 위치를 반환하는 문제이다.            배열 밖으로 벗어나는 경우, 나선형으로 이동하여 배열 안으로 들어오는 위치로 이어진다.           문제 풀이에 필요한 변수를 정의한다.            result는 결과를 넣을 배열로, $rows \\times cols$ 크기의 2차원 정수 배열로 초기화한다.       row와 col은 방향을 결정할 변수로, 오른쪽으로 이동하므로 0과 1로 초기화한다.       n은 같은 방향으로 이동 횟수를 계산 할 변수로, 0으로 초기화한다.           j가 0부터 $rows \\times cols$ 미만까지 n을 증가시키며 아래를 반복한다.            0부터 $\\frac{n}{2} + 1$까지 i를 증가시키며 아래를 반복한다.                    [rStart, cStart]가 배열 내 위치인 경우, result의 j번쨰 위치에 [rStart, cStart]를 넣어주고 j를 증가시킨다.           rStart에 row를, cStart의 col을 더해 다음 위치로 이동한다.                       나선 방향으로 변환하기 위하여 row에 col을, col을 -row 값으로 바꾸어준다.           반복이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/spiral-matrix-iii/",
        "teaser": null
      },{
        "title": "Leetcode Java Super Egg Drop",
        "excerpt":"문제  Link   코드  class Solution {    public int superEggDrop(int k, int n) {     int[][] dp = new int[n + 1][k + 1];     int i = 0;     while (dp[i][k] &lt; n) {       i++;       for (int j = 1; j &lt;= k; j++) {         dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] + 1;       }     }     return i;   }  }   결과  Link   설명     k개 달걀을 이용하여 [1, n] 높이의 건물에서 달걀이 깨지지 않는 높이인 f를 찾는 최소 단계를 구하는 문제이다.            0 &lt;= f &lt;= n 인 바닥 f보다 높은 위치에서 떨어트린 달걀은 깨지며, f보다 낮은 위치에서 떨어트린 달걀은 깨지지 않는다.       계란이 깨지지 않은 경우, 다음 시도에 다시 사용할 수 있다.           문제 풀이에 필요한 변수를 정의한다.            dp는 최소 단계를 찾기 위한 배열로, $(n + 1) \\times (k + 1)$ 크기의 2차원 정수 배열로 초기화한다.       i는 최소 단계를 찾을 변수로, 0으로 초기화한다.           dp[i][k]의 값이 n 미만일 때까지 아래를 반복한다.            i를 증가시키고, 1부터 k 이하까지 j를 증가시키며 아래를 반복한다.                    dp[i][j]의 위치에 dp[$i - 1$][$j - 1$] 층을 탐색한 값과 dp[$i - 1$][j] 층을 탐색한 값의 합에 1을 더한 값을 넣어 단계를 증가시킨다.                           반복이 완료되면 최소 단계인 i를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/super-egg-drop/",
        "teaser": null
      },{
        "title": "Leetcode Java Fair Candy Swap",
        "excerpt":"문제  Link   코드  class Solution {    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {     int diff = 0;     Set&lt;Integer&gt; set = new HashSet&lt;&gt;();     for (int aliceSize : aliceSizes) {       diff += aliceSize;       set.add(aliceSize);     }     for (int bobSize : bobSizes) {       diff -= bobSize;     }     diff /= 2;     for (int bobSize : bobSizes) {       if (set.contains(bobSize + diff)) {         return new int[] { bobSize + diff, bobSize };       }     }     return new int[0];   }  }   결과  Link   설명          엘리스와 밥이 가진 사탕 상자 내 들어있는 사탕의 수인 aliceSizes와 bobSizes를 이용하여 서로 사탕 상자를 교환하여 사탕의 총량이 같아지기 위한 엘리스와 밥의 교환할 상자에 담긴 사탕의 수를 배열로 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            diff는 엘리스의 사탕과 밥의 사탕의 갯수 차이를 저장할 변수로, 0으로 초기화한다.       set은 엘리스가 가진 사탕 상자의 갯수를 저장할 변수로, 중복을 배제하여 저장하기 위해 HashSet으로 초기화한다.                aliceSizes를 반복하여 diff에 엘리스가 가진 사탕 갯수를 더하고, set에는 각 사탕의 갯수를 저장해준다.            bobSizes를 반복하여 diff의 밥이 가진 사탕 갯수를 빼주고, diff의 값을 반으로 나누어 저장한다.       bobSizes의 상자 별 사탕의 수를 bobSize에 넣어 아래를 반복한다.            엘리스가 가진 사탕의 수가 저장된 set 내 $bobSize + diff$ 값이 존재한다면, [$bobSize + diff$, bobSize]를 주어진 문제의 결과로 반환한다.           적어도 한 가지의 정답이 있으므로, 반복이 완료되면 임의의 결과를 반환한다.   풀이     엘리스가 가진 사탕의 수와 밥이 가진 사탕의 수가 동일하기 위해선 아래의 공식이 성립한다.            $aliceCandies - aliceSizes[i] + bobSizes[j] = bobCandies - bobSizes[j] + aliceSizes[i]$           위 공식을 정리하면 아래가 성립한다.            $aliceCandies - bobCandies = 2 \\times (aliceSizes[i] - bobSizes[j])$       $aliceSizes[i] - bobSizes[j] = \\frac{aliceCandies - bobCandies}{2}$           이를 이용하여 두 상자의 사탕 차이는 엘리스가 가진 사탕의 수에서 밥이 가진 사탕의 수를 뺀 절반이 된다.   해당 공식을 이용하여 $diff = \\frac{aliceCandies - bobCandies}{2}$일 때, $diff + bobSizes[j] = aliceSizes[i]$가 성립하게 된다.   위를 이용하여 밥이 가진 사탕의 수에 diff을 더한 값이 엘리스가 가진 사탕의 수에 존재하면, 해당 값을 주어진 문제의 결과로 반환하는 것이다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/fair-candy-swap/",
        "teaser": null
      },{
        "title": "Leetcode Java Find and Replace Pattern",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; findAndReplacePattern(String[] words, String pattern) {     List&lt;String&gt; result = new ArrayList&lt;&gt;();     for (String word : words) {       if (this.match(word, pattern)) {         result.add(word);       }     }     return result;   }    private boolean match(String word, String pattern) {     for (int i = 0; i &lt; word.length(); i++) {       if (word.indexOf(word.charAt(i)) != pattern.indexOf(pattern.charAt(i))) {         return false;       }     }     return true;   }  }   결과  Link   설명          words 내 단어들 중 pattern의 문자 패턴과 일치하는 문자를 찾는 문제이다.            result는 패턴과 일치하는 문자를 넣을 변수로, ArrayList로 초기화한다.            words를 반복하여 4번에서 정의한 match(String word, String pattern)를 만족하는지 검증하여 result에 넣어준다.       문자열 검증을 위한 match(String word, String pattern) 메서드를 정의한다.            0부터 word의 길이 미만까지 i를 증가시키며 문자 별 위치가 동일한지 검증하여, 만족하지 않는 경우 false를 반환한다.       반복이 완료되어 패턴과 일치하면 true를 반환한다.           반복이 완료되어 패턴과 일치하는 문자열만 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-and-replace-pattern/",
        "teaser": null
      },{
        "title": "Leetcode Java Sum of Subsequence Widths",
        "excerpt":"문제  Link   코드  class Solution {    public int sumSubseqWidths(int[] nums) {     Arrays.sort(nums);     long c = 1;     long result = 0;     long mod = 1000000007L;     for (int i = 0, j = nums.length - 1; i &lt; nums.length; i++, j--) {       result = (result + (nums[i] * c) - (nums[j] * c)) % mod;       c = (c * 2) % mod;     }     return (int) ((result + mod) % mod);   }  }   결과  Link   설명     nums 배열 내 값들의 부분 배열의 모든 너비의 합을 계산하는 문제이다.            너비는 최대 요소와 최소 요소의 차이 값을 의미한다.       값이 매우 클 수 있으므로 모듈러 $10^9 +7$로 결과를 반환한다.                nums를 오름차순으로 정렬해준다.       문제 해결에 필요한 변수를 정의한다.            c는 2배수를 저장할 변수로, 1로 초기화한다.       result는 너비의 합을 저장할 변수로 0으로 초기화한다.       mod는 모듈러를 적용할 변수로, $10^9 +7$로 초기화한다.           0부터 nums의 길이 미만까지 i를 증가시키고, j는 nums의 길이보다 1 작은 값부터 j를 감소시키며 아래를 반복한다.            result에 result와 $nums[i] \\times c$와 $nums[j] \\times c$의 차이를 더해서 mod로 나눈 나머지 값을 넣어준다.       c에 $c \\times 2$에 mod로 나눈 값을 넣어준다.           반복이 완료되면 result와 mod의 합을 mod로 나눈 나머지 값을 주어진 문제의 결과로 반환한다.   풀이     nums의 i번째 위치에서 좌측으로 $2^i$개의 부분 배열이 존재하므로, result에 $nums[i] \\times 2^i$를 더해준다.   nums의 i번째 위치에서 우측으로 $2^j$개의 부분 배열이 존재하므로, result에 $nums[j] \\times 2&amp;j$의 값을 빼준다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sum-of-subsequence-widths/",
        "teaser": null
      },{
        "title": "Leetcode Java Surface Area of 3D Shapes",
        "excerpt":"문제  Link   코드  class Solution {    public int surfaceArea(int[][] grid) {     int result = 0;     int length = grid.length;     for (int i = 0; i &lt; length; i++) {       for (int j = 0; j &lt; length; j++) {         if (grid[i][j] &gt; 0) {           result += (grid[i][j] * 4) + 2;         }         if (i &gt; 0) {           result -= Math.min(grid[i][j], grid[i - 1][j]) * 2;         }         if (j &gt; 0) {           result -= Math.min(grid[i][j], grid[i][j - 1]) * 2;         }       }     }     return result;   }  }   결과  Link   설명          정육면체의 큐브의 갯수가 담긴 $n \\times n$ 크기인 grid를 3차원으로 구성할 때 면적을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 면적을 계산할 변수로, 0으로 초기화한다.       length는 grid의 길이를 저장한 변수이다.           0부터 length 미만까지 i를 증가시키고, 다시 0부터 length 미만까지 j를 증가시키며 아래를 수행한다.            grid[i][j]의 값이 존재하면 result에 grid[i][j]를 4로 곱한 전후좌우의 네 변의 값에 위와 아래인 2를 더해서 넣어준다.       i가 0보다 큰 경우, result에 grid[i][j]와 grid[$i - 1$][j] 중 작은 겹친 면적에 2를 곱해서 빼준다.       j도 0보다 큰 경우, result에 grid[i][j]와 grid[i][$j - 1$] 중 작은 겹친 면적에 2를 곱해서 빼준다.           반복이 완료되면 면적이 계산된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/surface-area-of-3d-shapes/",
        "teaser": null
      },{
        "title": "Leetcode Java Groups of Special-Equivalent Strings",
        "excerpt":"문제  Link   코드  class Solution {    public int numSpecialEquivGroups(String[] words) {     Set&lt;String&gt; set = new HashSet&lt;&gt;();     for (String word : words) {       int length = word.length();       char[] even = new char[(length + 1) / 2];       char[] odd = new char[length / 2];       for (int i = 0; i &lt; length; i++) {         if (i % 2 == 0) {           even[i / 2] = word.charAt(i);         } else {           odd[i / 2] = word.charAt(i);         }       }       Arrays.sort(even);       Arrays.sort(odd);       set.add(Arrays.toString(odd) + Arrays.toString(even));     }     return set.size();   }  }   결과  Link   설명          길이가 같은 문자열의 배열인 words를 이용하여 홀수 위치, 혹은 짝수 위치 끼리 문자를 변환하여 동일하게 맞출 수 있는 고유 문자열의 수를 구하는 문제이다.            set은 고유 문자열을 저장하기 위한 변수로, 중복을 배제하기 위해 HashSet으로 초기화한다.       words의 모든 문자열을 word에 넣어 아래를 반복한다.            고유 문자열의 수를 구하기 위한 변수를 정의한다.                    length는 word의 기링을 저장한 변수이다.           even은 짝수 위치의 문자를 저장할 변수로, $\\frac{length + 1}{2}$ 크기의 문자 배열로 초기화한다.           odd는 홀수 위치의 문자를 저장할 변수로, $\\frac{length}{2}$ 크기의 문자 배열로 초기화한다.                       0부터 length 미만까지 i를 증가시키며 홀수 위치의 문자는 odd에, 짝수 위치의 문자는 even에 순차적으로 넣어준다.       문자를 다 넣었으면 even과 odd를 오름차순 정렬 후 odd와 event을 문자열로 변환하여 합친 문자를 set에 넣어준다.           반복이 완료되면 고유 문자열의 갯수가 저장된 set의 크기를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/groups-of-special-equivalent-strings/",
        "teaser": null
      },{
        "title": "Leetcode Java All Possible Full Binary Trees",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public List&lt;TreeNode&gt; allPossibleFBT(int n) {     return this.dfs(n, new HashMap&lt;&gt;());   }    private List&lt;TreeNode&gt; dfs(int n, Map&lt;Integer, List&lt;TreeNode&gt;&gt; map) {     if (!map.containsKey(n)) {       List&lt;TreeNode&gt; nodeList = new ArrayList&lt;TreeNode&gt;();       if (n == 1) {         TreeNode node = new TreeNode(0);         nodeList.add(node);       } else if (n % 2 == 1) {         for (int x = 0; x &lt; n; x++) {           int y = n - 1 - x;           for (TreeNode left : this.dfs(x, map)) {             for (TreeNode right : this.dfs(y, map)) {               TreeNode node = new TreeNode(0);               node.left = left;               node.right = right;               nodeList.add(node);             }           }         }       }       map.put(n, nodeList);     }     return map.get(n);   }  }   결과  Link   설명     노드가 n개인 가능한 모든 이진 TreeNode를 반환하는 문제이다.            단, 각 노드의 값은 0이어야 한다.                3번에서 정의한 dfs(int n, Map&lt;Integer, List&gt; map) 메서드에 n과 새 HashMap을 넣어 수행한 결과를 주어진 문제의 결과로 반환한다.       DFS 방식으로 TreeNode의 모든 조합을 만들 dfs(int n, Map&lt;Integer, List&gt; map) 메서드를 완성한다.            map에 n이 키인 값이 존재하는 경우, 아래를 수행한다.                    n이 1인 경우, 조합의 결과를 넣을 nodeList에 root인 TreeNode를 정의하여 키가 1인 값으로 넣어준다.           n이 홀수인 경우 자녀 노드를 이어야 하므로, 0부터 n 미만까지 x를 증가시키며 아래를 계속 수행한다.           y에 $n - 1 - x$를 넣고, x와 map을 이용하여 모든 값에 left를 y와 map을 이용하여 모든 값에 right를 넣어 새 TreeNode의 left TreeNode와 right TreeNode에 차례대로 넣어 noeList에 넣어준다.                       map의 n번째 값을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/all-possible-full-binary-trees/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Frequency Stack",
        "excerpt":"문제  Link   코드  class FreqStack {    private int max;   private Map&lt;Integer, Integer&gt; frequencyMap;   private List&lt;Deque&lt;Integer&gt;&gt; valList;    public FreqStack() {     this.max = 0;     this.frequencyMap = new HashMap&lt;&gt;();     this.valList = new ArrayList&lt;&gt;();   }    public void push(int val) {     int frequency = this.frequencyMap.getOrDefault(val, 0) + 1;     this.frequencyMap.put(val, frequency);     this.max = Math.max(this.max, frequency);     if (frequency &gt; this.valList.size()) {       this.valList.add(new ArrayDeque&lt;&gt;());     }     this.valList.get(frequency - 1).push(val);   }    public int pop() {     int val = this.valList.get(this.valList.size() - 1).pop();     if (this.max == 1) {       this.frequencyMap.remove(val);     } else {       this.frequencyMap.replace(val, this.max - 1);     }     if (this.valList.get(this.valList.size() - 1).isEmpty()) {       this.valList.remove(this.valList.size() - 1);       this.max--;     }     return val;   }  }  /**  * Your FreqStack object will be instantiated and called as such:  * FreqStack obj = new FreqStack();  * obj.push(val);  * int param_2 = obj.pop();  */   결과  Link   설명     주어진 값을 스택에 넣고, 스택에서 가장 많이 발생한 값을 반환하는 FreqStack 클래스를 완성하는 문제이다.            생성자인 FreqStack()는 주어진 데이터 구조를 초기화하는 역할을 수행한다.       메서드인 push(int val)는 주어진 값을 스택에 값을 넣는 역할을 수행한다.       메서드인 pop()은 스택에서 가장 많이 발생한 값을 스택에서 제거하고 반환하고, 동일하게 발생한 값이 여럿일 경우 먼저 들어온 스택의 top에 가까운 값을 제거하면서 반환한다.           문제 풀이에 필요한 전역 변수를 정의한다.            max은 최대 발생 횟수를 저장할 변수이다.       frequencyMap은 숫자 별 발생 횟수를 키와 값으로 저장할 변수이다.       valList는 발생 횟수에 해당하는 값을 저장할 변수이다.           생성자인 FreqStack()을 정의한다.            max에 초기 횟수인 0을 넣어 초기화한다.       frequencyMap은 키와 값으로 저장하기 위해 HashMap으로 초기화한다.       valList는 발생 횟수 별 값을 저장하기 위해 ArrayList로 초기화한다.           메서드인 push(int val)를 정의한다.            frequency에 frequencyMap에서 val에 해당하는 발생 횟수를, 없으면 0을 가져와 1을 더해서 넣어준다.       frequencyMap에 val에 해당하는 발생 횟수인 frequency로 바꿔준다.       max에 max와 frequency 중 큰 값을 넣어 많이 발생한 횟수를 갱신한다.       frequency가 valList의 크기보다 큰 경우, valList에 ArrayDeque를 새로 생성하여 넣어준다.       valList의 $frequency - 1$번째의 ArrayDeque에 val을 넣어준다.           메서드인 메서드인 pop()을 정의한다.            val에 valList에서 가장 많이 발생한 위치의 값 중 top에 가까운 값을 꺼내준다.       max가 1인 한 번만 발생한 값인 경우, frequencyMap에서 해당 값의 발생 횟수를 제거한다.       max가 1이 아니면 frequencyMap에서 해당 값의 발생 횟수를 차감한다.       valList의 가장 많이 발생한 위치의 ArrayDeque가 비어있는 경우, 해당 ArrayDeque를 제거하고 max를 차감한다.       마지막으로 임시 저장한 val을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-frequency-stack/",
        "teaser": null
      },{
        "title": "Leetcode Java Monotonic Array",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isMonotonic(int[] nums) {     if (nums.length &gt; 2) {       boolean increase = true;       boolean decrease = true;       for (int i = 1; i &lt; nums.length; i++) {         if (nums[i - 1] &gt; nums[i]) {           increase = false;         } else if (nums[i - 1] &lt; nums[i]) {           decrease = false;         }         if (!decrease &amp;&amp; !increase) {           return false;         }       }     }     return true;   }  }   결과  Link   설명     배열이 단조롭게 증가하거나 감소하는지 검증하는 문제이다.            배열의 모든 값이 점층적으로 증가하면 단조롭게 증가하는 배열이고, 점층적으로 감소하면 단조롭게 감소하는 배열이다.                nums의 길이가 2 이하인 경우 무조건 단조로운 배열이므로, true를 주어진 문제의 결과로 반환한다.            increase와 decrease는 단조롭게 증가하고 감소하는지 검증하는 변수로, true로 초기화한다.       1부터 nums의 길이 미만까지 i를 증가시키며 아래를 검증한다.            nums의 $i - 1$번째 값이 i번째 값보다 큰 경우, 단조롭게 증가하지 않으므로 increase를 false로 변경한다.       nums의 $i - 1$번째 값보다 i번째 값이 큰 경우, 단조롭게 감소하지 않으므로 decrease를 false로 변경한다.       decrease와 increase 값이 둘 다 false인 경우, 단조로운 배열이 될 수 없으므로 false를 주어진 문제의 결과로 반환한다.           반복이 완료되면 단조로운 배열로 검증되었으므로, true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/monotonic-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Increasing Order Search Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public TreeNode increasingBST(TreeNode root) {     return this.dfs(root, null);   }    private TreeNode dfs(TreeNode root, TreeNode tail) {     if (root == null) {       return tail;     } else {       TreeNode temp = this.dfs(root.left, root);       root.left = null;       root.right = this.dfs(root.right, tail);       return temp;     }   }  }   결과  Link   설명          이진 트리 노드인 root를 이용하여 우측 자식 노드로 값이 증가하는 TreeNode를 만드는 문제이다.            3번에서 정의한 dfs 메서드에 root와 null을 넣고 수행한 결과를 주어진 문제의 결과로 반환한다.            DFS 방식으로 TreeNode를 만들 dfs(TreeNode root, TreeNode tail) 메서드를 정의한다.             root가 null인 경우, tail을 반환한다.       root가 null이 아니면 아래를 수행한다.                    temp에 root의 left TreeNode와 root를 이용한 재귀 호출 결과를 넣어준다.           temp의 left TreeNode에 null을 넣고, right TreeNode에 root의 right TreeNode와 tail을 이용한 재귀 호출 결과를 넣어준다.           만들어진 TreeNode인 temp를 반환한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/increasing-order-search-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Bitwise ORs of Subarrays",
        "excerpt":"문제  Link   코드  class Solution {    public int subarrayBitwiseORs(int[] arr) {     Set&lt;Integer&gt; result = new HashSet&lt;&gt;();     for (int i = 0; i &lt; arr.length; i++) {       result.add(arr[i]);       for (int j = i - 1; j &gt;= 0; j--) {         int curr = arr[i] | arr[j];         if (curr == arr[j]) {           break;         }         arr[j] = curr;         result.add(arr[j]);       }     }     return result.size();   }  }   결과  Link   설명          arr을 이용하여 만들 수 있는 부분 배열들의 모든 값을 이용해 OR 비트 연산을 수행한 결과의 중복되지 않은 값의 수를 구하는 문제이다.            result는 결과를 넣을 변수로, 중복을 제거하고 넣을 HashSet으로 초기화한다.       0부터 arr의 길이 미만까지 i를 증가시키며 아래를 수행한다.            result에 i의 값을 추가하고, $i - 1$부터 0 이상까지 j를 감소시키며 아래를 검증한다.                    curr에 arr[i]의 값과 arr[j]의 값의 OR 비트 연산의 결과를 넣어준다.           curr과 arr[j]의 값이 동일하면 결과는 arr[j]의 값에 수렴하므로, 반복을 중단한다.           arr[j]의 위치에 curr을 넣고, result에 해당 값을 넣어준다.                           반복이 완료되면 고유 값들만 저장된 result의 크기를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/bitwise-ors-of-subarrays/",
        "teaser": null
      },{
        "title": "Leetcode Java Orderly Queue",
        "excerpt":"문제  Link   코드  class Solution {    public String orderlyQueue(String s, int k) {     if (k &gt; 1) {       char[] charArray = s.toCharArray();       Arrays.sort(charArray);       return new String(charArray);     } else {       String result = s;       for (int i = 1; i &lt; s.length(); i++) {         String temp = s.substring(i) + s.substring(0, i);         if (result.compareTo(temp) &gt; 0) {           result = temp;         }       }       return result;     }   }  }   결과  Link   설명          s의 처음 k개의 문자 중 하나를 선택하여 문자열 끝에 추가할 때, 사전적인 순서가 낮은 문자열을 탐색하는 문제이다.            k가 1보다 큰 경우 문자열의 모든 문자는 차례대로 정렬이 가능하므로, s를 문자 배열로 번환하여 오름차순 정렬한 결과를 문자열로 변환하여 주어진 문제의 결과로 반환한다.            k가 1인 경우, 아래를 수행한다.             result에 s를 넣어주고, 1부터 s의 길이 미만까지 i를 증가시키며 아래를 반복한다.                    temp에 s의 i번째 이후의 문자와 처음부터 i번째 미만까지 문자를 합친 결과를 넣어준다.           result와 비교하여 사전적 순서가 낮은 문자열을 result에 넣어준다.                       반복이 완료되어 사전적 순서가 낮은 문자열이 저장된 result를 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/orderly-queue/",
        "teaser": null
      },{
        "title": "Leetcode Java RLE Iterator",
        "excerpt":"문제  Link   코드  class RLEIterator {    private int[] encoding;   private int index;    public RLEIterator(int[] encoding) {     this.encoding = encoding;     this.index = 0;   }    public int next(int n) {     while (this.index &lt; this.encoding.length) {       if (n &gt; this.encoding[this.index]) {         n -= this.encoding[this.index];         this.index += 2;       } else {         this.encoding[this.index] -= n;         return this.encoding[this.index + 1];       }     }     return -1;   }  }  /**  * Your RLEIterator object will be instantiated and called as such:  * RLEIterator obj = new RLEIterator(encoding);  * int param_1 = obj.next(n);  */   결과  Link   설명     i번째 위치에 반복되는 횟수와 $i + 1$번째 위치에 반복되는 숫자를 연속해서 RLE(run-length encoding)로 인코딩된 값을 이용하여 앞의 값들을 제거하고 남은 값들을 반환하는 RLEIterator 클래스를 구현하는 문제이다.            생성자인 RLEIterator(int[] encoding)는 encoding 배열의 값을 이용하여 객체를 초기화한다.       메서드인 next(int n)는 RLE로 인코딩된 배열을 숫자로 변환하여 앞 n개의 요소를 제거한 값을 저장 후 배열의 시작 값을 반환한다. 단, 반환할 값이 없는 경우 -1을 반환한다.           RLE로 인코딩에 사용할 전역 변수를 정의한다.            encoding은 RLE 인코딩으로 변환된 값을 저장할 변수이다.       index는 encoding을 복호화 하여 제거되지 않은 값의 시작 위치를 저장할 변수이다.           생성자인 RLEIterator(int[] encoded)를 정의한다.            encoding에 주어진 encoding을 넣어주고 index를 0으로 초기화한다.           메서드인 next(int n)를 정의한다.            index가 encoding의 길이 미만이 될 때까지 아래를 반복한다.                    n이 encoding의 index번째 값보다 큰 경우 해당 값을 모두 소모하므로, n에 앞의 값을 빼주고 index를 2 증가시켜 다음 반복 횟수로 이동한다.           n이 encoding의 index번째 값보다 작거나 같은 경우 해당 위치의 숫자를 소모하고 다음 값을 반환해야 하므로, encoding의 index번째 값에 n을 뺀 후 encoding의 $index + 1$번째 값을 반환한다.                       반복이 완료되면 반환할 값이 없으므로, -1을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/rle-iterator/",
        "teaser": null
      },{
        "title": "Leetcode Java Online Stock Span",
        "excerpt":"문제  Link   코드  class StockSpanner {    private Stack&lt;int[]&gt; stack;    public StockSpanner() {     this.stack = new Stack&lt;&gt;();   }    public int next(int price) {     int span = 1;     while (!this.stack.isEmpty() &amp;&amp; price &gt;= this.stack.peek()[0]) {       span += this.stack.pop()[1];     }     this.stack.push(new int[] { price, span });     return span;   }  }  /**  * Your StockSpanner object will be instantiated and called as such:  * StockSpanner obj = new StockSpanner();  * int param_1 = obj.next(price);  */   결과  Link   설명     일부 주식에 대한 일일 가격을 수집하고, 해당 주식의 현재 가격 범위를 반환하는 StockSpanner 클래스를 완성하는 문제이다.            생성자인 StockSpanner()는 StockSpanner 객체를 초기화한다.       메서드인 next(int price)는 주식의 오늘의 가격이 price와 동일한 경우, 현재 가격 범위를 반환한다.                stack은 일일 가격 범위를 저장하기 위한 변수이다.       생성자인 StockSpanner()를 완성한다.            stack을 새 Stack으로 초기화한다.           메서드인 next(int price)를 완성한다.            span은 주식의 가격 범위를 저장할 변수로, 1로 초기화한다.       stack이 비어있지 않으면서 price가 stack의 마지막 값의 가격보다 크거나 같으면 span에 stack의 마지막 값의 범위를 넣어준다.       반복이 완료되면 price와 span을 배열로 stack에 넣어 범위를 저장해주고 span을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/online-stock-span/",
        "teaser": null
      },{
        "title": "Leetcode Java Numbers At Most N Given Digit Set",
        "excerpt":"문제  Link   코드  class Solution {    public int atMostNGivenDigitSet(String[] digits, int n) {     String str = String.valueOf(n);     int length = str.length();     int[] dp = new int[length + 1];     dp[length] = 1;     for (int i = length - 1; i &gt;= 0; i--) {       int num = str.charAt(i) - '0';       for (String digit : digits) {         if (Integer.parseInt(digit) &lt; num) {           dp[i] += Math.pow(digits.length, length - i - 1);         } else if (Integer.parseInt(digit) == num) {           dp[i] += dp[i + 1];         }       }     }     for (int i = 1; i &lt; length; i++) {       dp[0] += Math.pow(digits.length, i);     }     return dp[0];   }  }   결과  Link   설명          작은 값 순으로 저장된 digits 배열을 이용하여 n보다 같거나 작은 값의 갯수를 계산하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            str은 n을 문자열로 변환한 변수이고, length는 str의 길이를 저장한 변수이다.       dp는 값의 탐색에 필요한 변수로, $length + 1$ 크기의 정수 배열로 초기화하고 마지막 위치에 1을 넣어준다.           $length - 1$부터 0 이상까지 i를 증가시키며 아래를 반복한다.            num에 str의 i번째 문자를 숫자로 변환하여 digits의 모든 값을 차례대로 digit에 넣어 아래를 반복한다.                    digit이 num보다 작은 경우 해당 값 아래로 만들 수 있는 모든 값의 갯수를 저장해야 하므로, dp의 i번째 위치에 digits의 길이의 $length - i - 1$승 값을 넣어준다.           digit이 num과 동일한 경우, dp의 i번째 위치에 이전에 계산된 숫자의 갯수인 $i + 1$번째 값을 넣어준다.                           1부터 length까지 i를 증가시키며 dp의 처음 위치에 digits의 길이의 i승 결과를 더해주고, 해당 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/numbers-at-most-n-given-digit-set/",
        "teaser": null
      },{
        "title": "Leetcode Java Valid Permutations for DI Sequence",
        "excerpt":"문제  Link   코드  class Solution {    public int numPermsDISequence(String s) {     int length = s.length();     int mod = 1000000007;     int[] dp1 = new int[length + 1];     int[] dp2 = new int[length];     for (int i = 0; i &lt;= length; i++) {       dp1[i] = 1;     }     for (int i = 0; i &lt; length; i++) {       int curr = 0;       if (s.charAt(i) == 'I') {         for (int j = 0; j &lt; length - i; j++) {           dp2[j] = curr = (curr + dp1[j]) % mod;         }       } else {         for (int j = length - i - 1; j &gt;= 0; j--) {           dp2[j] = curr = (curr + dp1[j + 1]) % mod;         }       }       dp1 = Arrays.copyOf(dp2, length);     }     return dp1[0];   }  }   결과  Link   설명     아래의 규칙으로 이루어진 문자열 s를 이용하여 유효 순열의 수를 구하는 문제이다.            유효 순열은 [0, s.length] 범위에 있는 모든 정수의 $s.length + 1$ 정수 순열이다.       s[i] == ‘D’인 경우 값의 감소를 의미하며, 순열의 i번째 값이 $i + 1$번째 값보다 크다.       s[i] == ‘I’인 경우 값의 증가를 의미하며, 순열의 i번째 값이 $i + 1$번째 값보다 작다.       단, 유효 순열의 수가 매우 많을 수 있으므로, 모듈러 $10^9 + 7$를 이용하여 값을 반환한다.           문제 풀이에 필요한 변수를 정의한다.            length는 s의 길이를 저장한 변수이다.       mod는 모듈러를 적용할 변수로, $10^9 +7$로 초기화한다.       dp1과 dp2는 유효 순열의 수를 계산하기 위한 변수로, $length + 1$크기와 length 크기의 정수 배열로 초기화하고 dp1의 모든 위치에 1을 넣어준다.           0부터 length 미만까지 i를 증가시키며 아래를 수행한다.            curr은 현재 값을 임시 저장할 변수로, 0으로 초기화한다.       s의 i번째 문자가 ‘I’인 경우, 아래를 수행한다.                    0부터 $length - i$까지 j를 증가시키며, dp2의 j번째 위치와 curr에 $\\frac{curr + dp1[j]}{mod}$ 값을 넣어 값의 증가시켜준다.                       s의 i번째 문자가 ‘D’인 경우, 아래를 수행한다.                    $length - i - 1$부터 0 이상까지 j를 감소시키며, dp2의 j번째 위치와 curr에 $\\frac{curr + dp1[j + 1]}{mod}$ 값을 넣어 값을 역순으로 증가시켜준다.                       dp1에 dp2의 length 길이까지의 배열을 복사하여 넣어준다.           반복이 완료되면 계산도니 유효 순열의 수인 dp1의 첫 번째 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/valid-permutations-for-di-sequence/",
        "teaser": null
      },{
        "title": "Leetcode Java Fruit Into Baskets",
        "excerpt":"문제  Link   코드  class Solution {    public int totalFruit(int[] fruits) {     int length = fruits.length;     int start = 0;     int mid = 0;     int max = 0;     int[] baskets = new int[] { -1, -1 };     for (int end = 0; end &lt; length; end++) {       int curr = fruits[end];       if (curr != baskets[1]) {         if (curr != baskets[0]) {           max = Math.max(max, end - start);           start = mid;         }         mid = end;         baskets[0] = baskets[1];         baskets[1] = curr;       }     }     return Math.max(max, length - start);   }  }   결과  Link   설명     한 줄로 서있는 과일 나무의 과일 수를 담은 fruits를 이용하여 아래의 규칙대로 가장 많이 담은 과일의 수를 반환하는 문제이다.            제한 없이 담을 수 있는 두 바구니만 가지고 시작하여 한 바구니에는 같은 과일만 담을 수 있다.           문제 풀이에 필요한 변수를 정의한다.            length는 fruits의 길이를 저장한 변수이다.       start와 mid는 과일 나무의 시작 위치와 end 사이의 위치를 저장할 변수로, 둘 다 0으로 초기화한다.       max는 최대와 과일의 수를 담을 변수로, 0으로 초기화한다.       baskets는 제한 없이 담을 수 있는 두 바구니에 담긴 과일의 수를 넣을 변수로, 두 바구니에 담긴 과일의 수를 -1로 초기화한다.           0부터 length 미만까지 마지막 과일 나무의 위치인 end를 증가시키며 아래를 수행한다.            curr는 현재 과일의 갯수를 담을 변수로, fruits의 end번째 값을 넣어준다.       curr이 baskets의 두 번째 값인 현재 바구니의 과일 수가 같지 않으면, 바구니의 과일 수를 갱신해야 하므로 아래를 수행한다.                    curr이 baskets의 첫 번째 값인 이전 바구니의 과일 수가 같지 않으면, max에 max와 $end - start$ 중 큰 값을 넣고 start에 mid를 넣어준다.           mid에 end를 넣어 마지막 위치를 저장한다.           baskets의 첫 번째 위치에 두 번째 값을 넣고, baskets의 두번 째 값에 curr 값을 넣어 두 바구니의 과일 수를 갱신해준다.                           반복이 완료되면 max와 $length - start$ 중 큰 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/fruit-into-baskets/",
        "teaser": null
      },{
        "title": "Leetcode Java Fruit Into Baskets",
        "excerpt":"문제  Link   코드  class Solution {    public int[] sortArrayByParity(int[] nums) {     for (int i = 0, j = 0; j &lt; nums.length; j++) {       if (nums[j] % 2 == 0) {         int temp = nums[i];         nums[i++] = nums[j];         nums[j] = temp;       }     }     return nums;   }  }   결과  Link   설명          정수 배열인 nums의 앞 부분에는 짝수, 뒷 부분에는 홀수로 아무 순서로 정렬 후 반환하는 문제이다.       0부터 nums의 길이 미만까지 j를 증가시키고, i를 0으로 초기화하여 아래를 반복한다.            nums의 j번째 값이 짝수인 경우, i번째 값과 j번째 값을 바꾸고 i를 증가시킨다.           반복이 완료되어 정렬된 nums를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sort-array-by-parity/",
        "teaser": null
      },{
        "title": "Leetcode Java Super Palindromes",
        "excerpt":"문제  Link   코드  class Solution {    public int superpalindromesInRange(String left, String right) {     int result = 9 &gt;= Long.parseLong(left) &amp;&amp; 9 &lt;= Long.parseLong(right) ? 1 : 0;     for (int i = 1; i &lt; 19684; i++) {       String num = Integer.toString(i, 3);       if (this.isPalindrome(num)) {         long square = Long.parseLong(num) * Long.parseLong(num);         if (square &gt; Long.parseLong(right)) {           return result;         }         if (square &gt;= Long.parseLong(left) &amp;&amp; this.isPalindrome(Long.toString(square))) {           result++;         }       }     }     return result;   }    private boolean isPalindrome(String str) {     for (int i = 0, j = str.length() - 1; i &lt; j; i++, j--) {       if (str.charAt(i) != str.charAt(j)) {         return false;       }     }     return true;   }  }   결과  Link   설명          left와 right가 주어지면 그 사이의 숫자들 중 자기 자신과 제곱한 값이 앞 뒤가 같은 숫자(이하 회문)인 슈퍼 회문의 수를 계산하는 문제이다.            result에 left와 right가 9을 포함하는 경우이면 1을, 아니면 0을 넣어준다.       1부터 최대 검증해야 하는 값인 $3^9 = 19684$까지 i를 증가시키며 아래를 수행한다.            num에 i의 3진수 값을 넣어준다.       num이 회문인 경우 아래를 수행한다.                    square에 num의 제곱 값을 넣어준다.           square가 right를 초과하는 경우 범위를 벗어나 더 이상 검증할 필요가 없으므로, result를 주어진 문제의 결과로 반환한다.           square가 left 이상이고, 회문인 겨우 result를 증가시킨다.                           반복이 완료되면 [left, right] 범위 내 슈퍼 회문의 수가 저장된 result를 주어진 문제의 결과로 반환한다.   해설     left와 right는 최대 18 자리로, 회문의 구성의 절반은 9까지 존재한다.   자기 자신과 자기 자신의 제곱 수가 회문이 되기 위한 값들은 아래와 같다.            1, 2, 3, 11, 22, 101, 111, 121, 202, 212, 1001, 1111, 2002, 10001, 10101, …           위의 값들 중, 3을 제외하면 [0, 1, 2]로 구성이 되었으므로, 초기 result에 3의 제곱인 9가 존재하면 1로 아니면 0으로 초기화한다.   반복의 임계값이 19684인 이유는, 회문의 절반인 9자리까지 [0, 1, 2]의 세 값이 구성 가능하므로 $3^9$의 경우의 수를 사용하기 때문이다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/super-palindromes/",
        "teaser": null
      },{
        "title": "Leetcode Java Sum of Subarray Minimums",
        "excerpt":"문제  Link   코드  class Solution {    public int sumSubarrayMins(int[] arr) {     int length = arr.length;     int index = 0;     int[] dp = new int[length];     int[] stack = new int[length + 1];     long result = dp[0] = arr[0];     for (int i = 1; i &lt; length; i++) {       while (index &gt;= 0 &amp;&amp; arr[stack[index]] &gt;= arr[i]) {         index--;       }       dp[i] = index &lt; 0 ? arr[i] * (i + 1) : dp[stack[index]] + arr[i] * (i - stack[index]);       result += dp[i];       stack[++index] = i;     }     return (int) (result % 1000000007);   }  }   결과  Link   설명     arr의 연속된 값들로 이루어진 모든 경우의 부분 배열 내 최소값 합을 계산하는 문제이다.            값이 매우 클 수 있으므로 모듈러 $10^9 +7$로 결과를 반환한다.           문제 풀이에 필요한 변수를 정의한다.            length는 arr의 길이를 저장한 변수이다.       index는 부분 배열을 산정하기 위한 위치를 계산할 변수로, 0으로 초기화한다.       dp는 i번째 값까지 최소값 합을 저장할 변수로, length 크기의 정수 배열로 초기화하고 첫 값에 arr의 첫 값을 넣어준다.       stack은 이전까지 계산한 위치 값을 저장할 변수로, $length + 1$ 크기의 정수 배열로 초기화한다.       result는 최소값 합을 계산하기 위한 변수로, arr의 첫 값을 넣어준다.           1부터 length 미만까지 i를 증가시키며 아래를 수행한다.            index가 0 이상이고, arr의 stack[index]번째 값이 i번째 값보다 클 때까지 index를 감소시킨다.       dp의 i번째 위치에 아래를 검증하여 값을 넣어준다.                    index가 0보다 작으면 처음부터 지금까지 가장 작은 값이므로, $arr[i] \\times (i + 1)$ 값을 넣어준다.           위가 아니라면 기존 값에 더해서 추가로 저장해야 하므로, $dp[stack[index]] + arr[i] \\times (i - stack[index])$값을 넣어준다.                       result에 dp의 i번째 값을 넣어주고, index를 증가시키고 stack의 index번째 값에 i를 넣어 저장해준다.           반복이 완료되면 result를 모듈러 $10^9 +7$을 적용한 값으로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sum-of-subarray-minimums/",
        "teaser": null
      },{
        "title": "Leetcode Java Smallest Range I",
        "excerpt":"문제  Link   코드  class Solution {    public int smallestRangeI(int[] nums, int k) {     int max = nums[0];     int min = nums[0];     for (int num : nums) {       max = Math.max(max, num);       min = Math.min(min, num);     }     return Math.max(0, max - min - (k * 2));   }  }   결과  Link   설명          nums의 최소 하나의 값에 [-k, k] 범위의 값을 더했을 때, 최댓값과 최솟값의 차이가 가장 작은 값을 구하는 문제이다.            max와 min에 nums의 최댓값과 최솟값을 찾아 넣어준다.            둘의 차이가 가장 작은 임계치는 0이므로, 0과 $(max - k) - (min + k) = max - min - (k \\times 2)$ 중 큰 값을 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/smallest-range-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Smallest Range II",
        "excerpt":"문제  Link   코드  class Solution {    public int smallestRangeII(int[] nums, int k) {     Arrays.sort(nums);     int length = nums.length;     int max = nums[length - 1];     int min = nums[0];     int result = max - min;     for (int i = 0; i &lt; length - 1; i++) {       max = Math.max(max, nums[i] + (k * 2));       min = Math.min(nums[i + 1], nums[0] + (k * 2));       result = Math.min(result, max - min);     }     return result;   }  }   결과  Link   설명          지난 번 Smallest Range I과 유사하지만 이번에는 nums의 모든 값에 -k 혹은 k 값을 더했을 때, 최댓값과 최솟값의 차이가 가장 작은 값을 구하는 문제이다.       nums를 오름차순으로 정렬하고, 문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       max와 min은 최댓값과 최솟값을 저장할 변수로, 정렬된 nums의 마지막 값인 가장 큰 값과 첫 값이 가장 작은 값으로 초기화한다.       result는 결과를 저장할 변수로, 차이가 가장 큰 값인 max와 min의 차이로 초기화한다.           0부터 $length - 1$까지 i를 증가시키며 아래를 수행한다.            max에 이전 값까지 가장 큰 값인 max와 nums의 i번째 값에 -k 혹은 k를 더했을 때 발생 가능한 최대 차이인 $k \\times 2$를 더한 값 중 큰 값을 넣어준다.       min에 다음 값인 nums의 $i + 1$번째 값과 nums의 첫 값에 위와 동일하게 $k \\times 2$를 더한 값 중 작은 값을 넣어준다.       result에 result와 $max - min$의 결과 중 작은 값을 넣어준다.           반복이 완료되면 최댓값과 최솟값의 차이가 가장 작은 값이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/smallest-range-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Online Election",
        "excerpt":"문제  Link   코드  class TopVotedCandidate {    private int[] lead;   private int[] times;    public TopVotedCandidate(int[] persons, int[] times) {     int length = persons.length;     int[] votes = new int[length];     this.lead = new int[length];     this.times = times;     int max = 0;     for (int i = 0; i &lt; length; i++) {       int person = persons[i];       votes[person]++;       if (votes[person] &gt;= max) {         max = votes[person];         this.lead[i] = person;       } else {         this.lead[i] = this.lead[i - 1];       }     }   }    public int q(int t) {     int num = Arrays.binarySearch(this.times, t);     if (num &lt; 0) {       num = -num - 2;     }     return this.lead[num];   }  }  /**  * Your TopVotedCandidate object will be instantiated and called as such:  * TopVotedCandidate obj = new TopVotedCandidate(persons, times);  * int param_1 = obj.q(t);  */   결과  Link   설명     선거자와 시간을 입력하여 해당 시간에 승리하는 사람을 구하는 TopVotedCandidate 클래스를 완성하는 문제이다.            생성자인 TopVotedCandidate(int[] persons, int[] times)는 선거인과 시간을 초기화하는 역할을 수행한다.       메서드인 int q(int t)는 t시간에 가장 최고 득표한 사람을 반환하는 역할을 수행한다.           문제 풀이에 필요한 전역 변수를 정의한다.            lead는 각 시간 별 최고 득표하고 있는 사람을 저장하기 위한 변수이다.       times는 주어진 시간을 저장하기 위한 변수이다.           생성자인 TopVotedCandidate(int[] persons, int[] times)를 정의한다.            객체 초기화에 필요한 변수를 정의한다.                    length는 persons의 길이를 저장하기 위한 변수이다.           votes는 선거자 별 투표 수를 계산하기 위한 변수로, length 크기의 정수 배열로 초기화한다.           lead에는 에는 length 크기의 정수 배열로, times에는 주어진 times를 넣어 초기화한다.           max는 최대 득표 수를 저장하기 위한 변수로, 0으로 초기화한다.                       0부터 length 미만까지 i를 증가시키며 아래를 수행한다.                    person에 persons의 i번째 선거자를 넣고, votes의 person번째 값을 증가시킨다.           votes의 person번째 값이 max보다 크거나 같으면 max에 해당 값을 넣고 lead의 i번째 값에 person을 넣어준다.           위의 경우가 아니라면 lead에 이전까지 득표 수가 많았던 선거자를 넣어준다.                           메서드인 int q(int t)를 정의한다.            num에 times에서 t에 해당하는 값 혹은 인접한 위치의 값을 찾아 넣어준다.                    Arrays.binarySearch(int[] a, int key) 메서드는 배열 내 값이 없을 경우, 인접한 두 값 사이의 위치보다 하나 작은 값을 반환한다.                       num이 0보다 작은 경우, 위의 설명과 같으므로 num에 num을 양수로 전환하여 2를 뺀 값을 넣어준다.       lead의 num번째 선거자를 찾아 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/online-election/",
        "teaser": null
      },{
        "title": "Leetcode Java Sort an Array",
        "excerpt":"문제  Link   코드  class Solution {    public int[] sortArray(int[] nums) {     this.mergeSort(nums, 0, nums.length - 1);     return nums;   }    private void mergeSort(int[] nums, int left, int right) {     if (left &gt;= right) {       return;     }     int mid = left + (right - left) / 2;     this.mergeSort(nums, left, mid);     this.mergeSort(nums, mid + 1, right);     int[] temp = new int[right - left + 1];     int i = left;     int j = mid + 1;     int k = 0;     while (i &lt;= mid || j &lt;= right) {       if (i &gt; mid || (j &lt;= right &amp;&amp; nums[i] &gt; nums[j])) {         temp[k++] = nums[j++];       } else {         temp[k++] = nums[i++];       }     }     System.arraycopy(temp, 0, nums, left, right - left + 1);   }  }   결과  Link   설명          nums를 내장 함수를 사용하지 않고  O(nlogn) 시간 복잡도로 정렬하는 문제이다.            O(nlogn) 시간 복잡도를 사용하는 병합 정렬을 수행하는 mergeSort(int[] nums, int left, int right) 메서드를 정의한다.             left가 right와 같거나 큰 경우, 수행을 그만한다.       mid에 $left + \\frac{right - left}{2}$를 넣어준다.       left와 mid 범위로 재귀 호출을 수행한 후, $mid + 1$과 right 범위로 다시 재귀 호출을 수행한다.       temp는 정렬에 사용할 변수로, $right - left + 1$ 크기의 정수 배열로 초기화한다.       정렬에 필요한 변수를 정의한다.                    i는 [left, mid] 범위의 값을 정렬할 변수로, 첫 위치인 left로 초기화한다.           j는 [$mid + 1$, right] 범위의 값을 정렬할 변수로, 첫 위치인 $mid + 1$로 초기화한다.           k는 temp의 위치 변수로, 0으로 초기화한다.                       i가 mid 이하이거나 j가 right 이하일 때 까지 아래를 반복한다.                    i가 mid보다 크거나 j가 right 이하이고 nums의 i번째 값이 j번째 값보다 큰 경우, temp의 k번째 위치에 더 작은 nums의 j번째 값을 넣어주고 j와 k를 증가시켜 다음 위치로 이동시킨다.           위의 경우가 아니라면 temp의 k번째 위치에 nums의 i번째 값을 넣어주고, i와 k를 증가시킨다.                       반복이 완료되면 nums의 left번째 위치부터 차례대로 temp의 첫 번째 값부터 $right - left + 1$번째 위치의 값까지 넣어준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sort-an-array/",
        "teaser": null
      },{
        "title": "Leetcode Java X of a Kind in a Deck of Card",
        "excerpt":"문제  Link   코드  class Solution {    public boolean hasGroupsSizeX(int[] deck) {     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();     for (int num : deck) {       map.put(num, map.getOrDefault(num, 0) + 1);     }     int result = 0;     for (int num : map.values()) {       result = this.getGcd(num, result);     }     return result &gt; 1;   }    private int getGcd(int m, int n) {     if (n == 0) {       return m;     } else {       return this.getGcd(n, m % n);     }   }  }   결과  Link   설명     정수 배열인 deak을 이용하여 크기의 같은 값으로 이루어진 동일한 크기의 그룹으로 구성할 수 있는지 검증하는 문제이다.            단, 그룹의 크기는 한 개 초과여야 한다.                map은 deck의 숫자 별 발생 횟수를 저장할 변수로, key가 deck[i]인 num으로 발생 횟수를 value에 넣어준다.       result는 최소 공약수를 저장할 변수로, map의 값들인 발생 횟수를 반복하여 최대 공약수를 넣어 1 초과인지 여부를 주어진 문제의 결과로 반환한다.   해설     deak의 숫자들을 같은 값끼리 동일한 크기 그룹으로 지어야 하는 조건은, 간단히 이야기하면 한 개의 값으로 구성된 그룹은 존재하면 안 된다는 의미이다.   또한 두 개 이상의 동일한 값으로 구성해야 한다는 것은 최대 공약수 크기로 분배 가능하면 구성 가능하다고 볼 수 있다.   [1, 1, 1, 2, 2, 2, 3, 3]을 예를 들어보자.            1과 2는 세 개, 3은 두 개이지만, 두 개 이상의 크기의 그룹을 지어야 하므로 1과 2가 1개씩 남게된다.       이는 3, 3, 2의 최대 공약수가 1이므로 구성이 불가능하다.           [1, 1, 1, 1, 2, 2, 3, 3]을 예를 들어보자.            1은 네 개, 2와 3은 두 개로, 1로 구성된 두 그룹과 2와 3의 그룹으로 이루어질 수 있다.       이는 4, 2, 2의 최대 공약수가 2이므로 구성이 가능하다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/x-of-a-kind-in-a-deck-of-cards/",
        "teaser": null
      },{
        "title": "Leetcode Java Partition Array into Disjoint Intervals",
        "excerpt":"문제  Link   코드  class Solution {    public int partitionDisjoint(int[] nums) {     int index = 0;     int prev = nums[0];     int max = prev;     for (int i = 1; i &lt; nums.length; i++) {       if (prev &gt; nums[i]) {         prev = max;         index = i;       } else {         max = Math.max(max, nums[i]);       }     }     return index + 1;   }  }   결과  Link   설명     정수 배열인 nums를 이용하여 아래의 규칙을 만족하는 부분 배열로 분리하였을 때, 왼쪽 배열의 길이를 반환하는 문제이다.            두 배열은 한 지점에서 갈라진 두 배열로, 빈 배열이 없다.       왼쪽 배열의 모든 값은 오른쪽 배열의 모든 값들보다 작거나 같다.       왼쪽 배열은 가능한 가장 작은 크기를 가진다.           문제 풀이에 필요한 변수를 정의한다.            index는 좌측 배열의 마지막 위치를 저장하기 위한 변수로, 0으로 초기화한다.       prev는 이전 위치까지 max는 현재까지 큰 값을 저장하기 위한 변수로, 둘 다 nums의 첫 값으로 초기화한다.           1부터 nums의 길이 미만까지 i를 증가시키며 아래를 수행한다.            prev가 현재 위치 값인 nums의 i번째 값보다 큰 경우, prev에 가장 큰 값인 max를 넣고 index에 i를 넣어준다.       위가 아니라면 max에 현재까지 가장 큰 값을 넣어준다.           반복이 완료되면 $index + 1$인 좌측 배열의 길이를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/partition-array-into-disjoint-intervals/",
        "teaser": null
      },{
        "title": "Leetcode Java Word Subsets",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; wordSubsets(String[] words1, String[] words2) {     int[] charArray = new int[26];     for (String word : words2) {       int[] temp = new int[26];       for (char c : word.toCharArray()) {         int num = c - 'a';         temp[num]++;         if (charArray[num] &lt; temp[num]) {           charArray[num] = temp[num];         }       }     }     List&lt;String&gt; result = new ArrayList&lt;&gt;();     for (String word : words1) {       int[] temp = new int[26];       for (char c : word.toCharArray()) {         temp[c - 'a']++;       }       if (this.isSubset(charArray, temp)) {         result.add(word);       }     }     return result;   }    private boolean isSubset(int[] charArray, int[] temp) {     for (int i = 0; i &lt; 26; i++) {       if (charArray[i] &gt; temp[i]) {         return false;       }     }     return true;   }  }   결과  Link   설명          words2의 각 단어 별 가장 많이 발생한 문자와 갯수가 포함된 words1의 문자열을 탐색하는 문제이다.            charArray는 words2의 모든 문자를 포함할 변수로, words2를 반복하여 문자별 가장 큰 문자의 수를 넎어준다.            result는 만족하는 문자열을 넣을 변수로, words1을 반복하여 각 문자 별 charArray의 문자와 갯수가 포함되는 문자열만 넣어준다.            모든 반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/word-subsets/",
        "teaser": null
      },{
        "title": "Leetcode Java Reverse Only Letters",
        "excerpt":"문제  Link   코드  class Solution {    public String reverseOnlyLetters(String s) {     char[] charArray = s.toCharArray();     int left = 0;     int right = charArray.length - 1;     while (left &lt; right) {       if (!Character.isAlphabetic(charArray[left])) {         left++;       } else if (!Character.isAlphabetic(charArray[right])) {         right--;       } else {         char temp = charArray[left];         charArray[left++] = charArray[right];         charArray[right--] = temp;       }     }     return new String(charArray);   }  }   결과  Link   설명     문자열 s의 영문자만 앞뒤 순서를 변경하는 문제이다.            영문자가 아닌 다른 문자들은 위치를 그대로 유지해야 한다.           문제 풀이에 필요한 변수를 정의한다.            charArray는 s를 문자 배열로 변환한 변수이다.       left와 right는 문자열의 좌측과 우측의 위치 변수로, 0과 $charArray.length - 1$로 초기화한다.           left가 right보다 작을 때 까지 아래를 반복한다.            charArray의 left번째 문자가 알파벳이 아닌 경우, left를 증가시켜 다음 위치로 이동시킨다.       charArray의 right번째 문자가 알파벳이 아닌 경우, right를 감소시켜 다음 위치로 이동시킨다.       둘 다 알파벳인 경우, charArray의 left번째 문자와 right번째 문자를 교환한다.           반복이 완료되면 charArray를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reverse-only-letters/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Sum Circular Subarray",
        "excerpt":"문제  Link   코드  class Solution {    public int maxSubarraySumCircular(int[] nums) {     int max1 = this.getMaximumSubarray(nums);     int sum = 0;     for (int i = 0; i &lt; nums.length; i++) {       sum += nums[i];       nums[i] = -nums[i];     }     int max2 = sum + this.getMaximumSubarray(nums);     if (max2 == 0) {       return max1;     } else {       return Math.max(max1, max2);     }   }    private int getMaximumSubarray(int[] nums) {     int sum = nums[0];     int max = nums[0];     for (int i = 1; i &lt; nums.length; i++) {       sum = Math.max(sum + nums[i], nums[i]);       max = Math.max(max, sum);     }     return max;   }  }   결과  Link   설명          원형으로 이어진 숫자들이 저장된 nums를 이용하여 비어있지 않은 부분 배열의 최대 합을 반환하는 문제이다.            max1에 nums를 이용하여 원형이 아닌 상태에서 부분 배열의 최대 합을 3번에서 정의한 getMaximumSubarray(int[] nums) 메서드 수행한 결과를 넣어준다.       Kadane’s Algorithm을 이용하여 부분 배열의 최대 합을 구하기 위한 getMaximumSubarray(int[] nums)를 정의한다.            부분 배열의 최대 합을 구하기 위한 변수를 정의한다.                    sum은 부분 배열의 최대 합을 계산하기 위한 변수로, nums의 첫 번째 값으로 초기화한다.           max는 부분 배열의 최대 합이 가장 큰 값을 구하기 위한 변수로, nums의 첫 번째 값을 초기화한다.                       1부터 nums의 길이 미만까지 i를 증가시키며 아래를 수행한다.                    sum에 sum에 nums의 i번째 값을 더한 값과 nums의 i번째 값 중 큰 값을 넣어준다.           max에는 max와 sum 중 큰 부분 배열의 합을 넣어준다.                       구해진 부분 배열의 최대 합이 저장된 max를 반환한다.                sum을 0으로 초기화하고 nums의 모든 값을 이용하여 합을 넣고, 모든 값을 음수/양수로 반전시킨다.            max2에 nums를 이용하여 원현인 상태에서 부분 배열의 최대 합을 3번에서 정의한 getMaximumSubarray(int[] nums) 메서드 수행한 결과에 sum을 더해서 넣어준다.       max2가 0인 경우, max1을 아니면 max1과 max2 중 큰 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-sum-circular-subarray/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Music Playlists",
        "excerpt":"문제  Link   코드  class Solution {    public int numMusicPlaylists(int n, int goal, int k) {     int mod = 1000000007;     long[][] dp = new long[goal + 1][n + 1];     dp[0][0] = 1;     for (int i = 1; i &lt;= goal; i++) {       for (int j = 1; j &lt;= n; j++) {         dp[i][j] = (dp[i - 1][j - 1] * (n - (j - 1))) % mod;         if (j &gt; k) {           dp[i][j] = (dp[i][j] + (dp[i - 1][j] * (j - k)) % mod) % mod;         }       }     }     return (int) dp[goal][n];   }  }   결과  Link   설명     n개의 서로 다른 노래를 이용하여 아래의 규칙을 만족하는 goal개의 노래로 이루어진 재생 목록을 만들 경우, 만들 수 있는 재생 목록의 수를 구하는 문제이다.            모든 노래는 최소 한 번 이상 재생된다.       이미 재생된 노래는 k개의 다른 노래들을 재생해야 다시 재생할 수 있다.       단, 재생 목록의 수가 매우 클 수 있으므로 모듈러 $10^9 + 7$을 이용해 계산한다.           문제 풀이에 필요한 변수를 정의한다.            mod는 모듈러를 적용할 변수로, $10^9 +7$로 초기화한다.       dp는 재생 목록의 수를 계산하기 위한 변수로, $(goal + 1) \\times (n + 1)$ 크기의 숫자가 매우 클 수 있으므로 long 배열로 초기화하고 맨 처음 위치에 1을 넣어준다.           1부터 goal 이하까지 i를 증가시키고, 1부터 n 이하까지 j를 증가시키며 아래를 수행한다.            dp[i][j] 위치에 $dp[i - 1][j - 1] \\times (n - (j - 1))$의 값을 mod로 나눈 나머지 값을 넣어준다.       j가 k보다 큰 경우 k개의 다른 노래를 재생하여 재생된 곡을 다시 재생 가능하므로, dp[i - 1][j]의 경우의 수에 $j - k$를 곱한 값을 dp[i][j]에 각 단계 별로 mod를 나눈 나머지를 넣어준다.           반복이 완료되면 모듈러 $10^9 + 7$을 적용하여 경우의 수를 구한 dp[goal][n]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-music-playlists/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Add to Make Parentheses Valid",
        "excerpt":"문제  Link   코드  class Solution {    public int minAddToMakeValid(String s) {     int left = 0;     int right = 0;     for (int i = 0; i &lt; s.length(); i++) {       if (s.charAt(i) == '(') {         right++;       } else if (right &gt; 0) {         right--;       } else {         left++;       }     }     return left + right;   }  }   결과  Link   설명     문자열 s가 유효한 문자열이 되기 위해서 모든 위치에 괄호의 시작 문자인 ‘(‘와 종료 문자인 ‘)’를 삽입하여 유효한 문자열이 되기 위한 최소 횟수를 구하는 문제이다.            유효한 문자열이 되기 위해서는 괄호의 시작 문자인 ‘(‘와 종료 문자인 ‘)’의 짝이 맞거나 존재하지 않아야 한다.                left와 right는 괄호의 시작 문자인 ‘(‘와 종료 문자인 ‘)’의 갯수를 계산할 변수로, 둘 다 0으로 초기화한다.       0부터 s의 길이 미만까지 i를 증가시키며 아래를 수행한다.            s의 i번째 문자가 ‘(‘인 경우, 우측에 ‘)’ 문자가 필요하므로 right를 증가시킨다.       위의 경우가 아니면서 right가 0 초과인 경우, ‘)’문자로 이어지므로 right를 감소시킨다.       위 모든 경우가 아니라면 ‘(‘ 문자를 현재의 ‘)’ 문자 이전에 넣어야 하므로, left를 증가시킨다.           반복이 완료되면 추가한 괄호 문자의 수인 $left + right$를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-add-to-make-parentheses-valid/",
        "teaser": null
      },{
        "title": "Leetcode Java Sort Array By Parity II",
        "excerpt":"문제  Link   코드  class Solution {    public int[] sortArrayByParityII(int[] nums) {     int even = 0;     int odd = 1;     while (even &lt; nums.length &amp;&amp; odd &lt; nums.length) {       if (nums[even] % 2 == 0) {         even += 2;       } else {         int temp = nums[even];         nums[even] = nums[odd];         nums[odd] = temp;         odd += 2;       }     }     return nums;   }  }   결과  Link   설명     지난 번 Sort Array By Parity와 비슷한 문제로, 짝수 번째 위치에 짝수 값을 홀수 번째 위치에 홀수 값으로 정렬하는 문제이다.            단, 각 홀수와 짝수 위치들 간 값의 크기에 대한 정렬은 상관 없다.                even과 odd는 짝수와 홀수 위치를 저장할 변수로, 시작 위치인 0과 1로 초기화한다.       even 혹은 odd가 nums의 길이 미만일 때 까지 아래를 반복한다.            nums의 even번째 위치의 값이 짝수인 경우, even을 2 증가시킨다.       위가 아니라면 nums의 even번째 값과 odd번째 값을 바꾸고 odd를 2 증가시킨다.           반복이 완료되면 주어진 조건대로 정렬된 nums 배열을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sort-array-by-parity-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Solving Questions With Brainpower",
        "excerpt":"문제  Link   코드  class Solution {    public long mostPoints(int[][] questions) {     int length = questions.length;     long[] dp = new long[length + 1];     for (int i = length - 1; i &gt;= 0; i--) {       dp[i] = Math.max(questions[i][0] + dp[Math.min(questions[i][1] + i + 1, length)], dp[i + 1]);     }     return dp[0];   }  }   결과  Link   설명     아래의 구성으로 이루어진 questions를 이용하여 최대 얻을 수 있는 시험 점수를 구하는 문제이다.            questions[i] = [pointi, brainpoweri]로, i번째 문제를 맞출 경우 얻을 수 있는 점수와 다음의 문제를 풀 수 없는 수를 의미한다.           문제 풀이에 필요한 변수를 정의한다.            length는 questions의 길이를 저장한 변수이다.       dp는 최대 점수를 계산하기 위한 변수로, $length + 1$ 크기의 long 배열로 초기화한다.           $length - 1$부터 0 이상까지 i를 감소시키며 아래를 수행한다.            dp의 i번째 값에 아래의 두 값 중 큰 값인 최대 시험 점수를 넣어준다.                    dp에서 무시해야 하는 문제의 수인 questions[i][1]의 값에 현재 위치의 다음 값인 $i + 1$을 더한 값과 length 중 작은 값에 해당하는 위치의 값과 questions[i][0]인 점수를 더한 값.           dp의 이전까지 최대 값인 $i + 1$번째 값.                           반복이 완료되면 최대 점수가 계산된 dp[0]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/solving-questions-with-brainpower/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Ways To Build Good Strings",
        "excerpt":"문제  Link   코드  class Solution {    public int countGoodStrings(int low, int high, int zero, int one) {     int result = 0;     int mod = 1000000007;     int dp[] = new int[high + 1];     dp[0] = 1;     for (int i = 1; i &lt;= high; i++) {       if (i &gt;= zero) {         dp[i] = (dp[i] + dp[i - zero]) % mod;       }       if (i &gt;= one) {         dp[i] = (dp[i] + dp[i - one]) % mod;       }       if (i &gt;= low) {         result = (result + dp[i]) % mod;       }     }     return result;   } }   결과  Link   설명     zero, one, low, high를 이용하여 아래의 하나를 수행하여 만들어진 문자열들 중 양호한 문자열의 수를 계산하는 문제이다.            양호한 문자열이란 아래 수행을 이용하여 low와 high 사이의 길이를 갖는 문자열이다.                    문자 ‘0’을 zero번 이어준다.           문자 ‘1’을 one번 이어준다.           이 작업은 여러 번 수행 가능하다.                       단, 답이 매우 클 수 있으므로 모듈러 $10^9 + 7$을 이용해 계산한다.           문제 풀이에 필요한 변수를 정의한다.            result는 결과를 넣을 변수로, 0으로 초기화한다.       mod는 모듈러를 적용할 변수로, $10^9 +7$로 초기화한다.       dp는 양호한 문자열의 수를 계산하기 위한 변수로, $high + 1$ 크기의 정수 배열로 초기화하고 첫 값을 1로 초기화한다.           1부터 high 미만까지 i를 증가시키며 아래를 수행한다.            i가 zero보다 큰 경우, dp[i]에 dp[i]의 값과 dp[$i - zero$]의 값인 $i - zero$번째 양호한 문자열의 수를 더한 값에 mod를 나눈 나머지 값을 넣어준다.       i가 one보다 큰 경우, dp[i]에 dp[i]의 값과 dp[$i - one$]의 값인 $i - one$번째 양호한 문자열의 수를 더한 값에 mod를 나눈 나머지 값을 넣어준다.       i가 low보다 큰 경우 양호한 문자열의 수 범위에 포함되므로, 결과를 저장할 result에 result와 dp[i]의 값을 더한 후 mod를 나눈 나머지 값을 넣어준다.           반복이 완료되면 양호한 문자열의 수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-ways-to-build-good-strings/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximize Score After N Operations",
        "excerpt":"문제  Link   코드  class Solution {    public int maxScore(int[] nums) {     int length = nums.length;     int[][] gcd = new int[length][length];     for (int i = 0; i &lt; length; i++) {       for (int j = 0; j &lt; length; j++) {         gcd[i][j] = this.getGcd(nums[i], nums[j]);       }     }     int[] dp = new int[1 &lt;&lt; length];     for (int i = 0; i &lt; (1 &lt;&lt; length); i++) {       int bits = Integer.bitCount(i);       if (bits % 2 != 0) {         continue;       }       for (int j = 0; j &lt; length; j++) {         int jBit = 1 &lt;&lt; j;         if ((i &amp; jBit) &gt; 0) {           continue;         }         for (int k = j + 1; k &lt; length; k++) {           int kBit = 1 &lt;&lt; k;           if ((i &amp; kBit) &gt; 0) {             continue;           }           dp[i | jBit | kBit] = Math.max(dp[i] + gcd[j][k] * ((bits / 2) + 1), dp[i | jBit | kBit]);         }       }     }     return dp[(1 &lt;&lt; length) - 1];   }    private int getGcd(int m, int n) {     if (n == 0) {       return m;     } else {       return this.getGcd(n, m % n);     }   }  }   결과  Link   설명     $2 \\times n$ 크기의 정수 배열인 nums를 이용하여 i번째 작업(1-인덱스)에서 아래를 수행하여 최대 점수를 반환하는 문제이다.            x와 y 두 원소를 골라서 $i \\times gcd(x, y)$의 점수를 받는다.       nums에서 x와 y를 제거한다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       gcd는 각 조합에 대한 최대 공약수를 저장할 변수로, $length \\times length$ 크기로 초기화 하여 모든 값에 대한 최대 공약수를 넣어준다.       dp는 최대 점수를 구하기 위한 변수로, 1의 비트를 length번 좌측으로 이동시킨 크기로 초기화한다.           0부터 dp의 길이 미만까지 i를 증가시키며 아래를 수행한다.            bits에 i의 1 비트 수를 넣어주고, 해당 비트가 짝수가 아니라면 다음 반복을 수행한다.       0부터 length 미만까지 j를 증가시키며 다음을 수행한다.       jBit에 1의 비트를 j번 좌측으로 이동시킨 이동시킨 값을 넣어준다.       i와 jBit의 AND 비트 연산 결과가 0보다 큰 경우, 다음 반복을 수행한다.       $j + 1$부터 length 미만까지 k를 증가시키며 아래를 수행한다.                    kBit에 1의 비트를 k번 좌측으로 이동시킨 이동시킨 값을 넣어준다.           i와 kBit의 AND 비트 연산 결과가 0보다 큰 경우, 다음 반복을 수행한다.           dp의 i, jBit, kBit의 OR 비트 연산 결과의 위치에 대한 값에 해당 값과 $dp[i] + gcd[j][k] \\times (\\frac{bits}{2} + 1)$인 i번째 작업 결과 중 큰 값을 넣어준다.                           반복이 완료되면 dp의 마지막 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximize-score-after-n-operations/",
        "teaser": null
      },{
        "title": "Leetcode Java Swapping Nodes in a Linked List",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode swapNodes(ListNode head, int k) {     ListNode first = null;     ListNode last = null;     for (ListNode listNode = head; listNode != null; listNode = listNode.next) {       if (last != null) {         last = last.next;       }       if (--k == 0) {         first = listNode;         last = head;       }     }     int temp = first.val;     first.val = last.val;     last.val = temp;     return head;   }  }   결과  Link   설명          head의 앞과 뒤에서 k번째 ListNode의 값을 바꾸는 문제이다.            first와 last는 앞과 뒤에서 k번째 ListNode를 담을 변수로, 들 다 null로 초기화한다.       head부터 null까지 listNode를 다음 ListNode로 이동하면서 아래를 반복한다.            last가 null이 아니면 last를 다음 ListNode로 이동시킨다.       k를 감소시키고 k가 0인 경우, first에 listNode를 last에 head를 넣어준다.           반복이 완료되면 temp와 last의 값을 바꾸고 head를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/swapping-nodes-in-a-linked-list/",
        "teaser": null
      },{
        "title": "Leetcode Java 3Sum With Multiplicity",
        "excerpt":"문제  Link   코드  class Solution {    public int threeSumMulti(int[] arr, int target) {     long[] count = new long[101];     for (int num : arr) {       count[num]++;     }     long result = 0;     for (int i = 0; i &lt;= 100; i++)       for (int j = i; j &lt;= 100; j++) {         int k = target - i - j;         if (k &gt; 100 || k &lt; 0) {           continue;         }         if (i == j &amp;&amp; j == k) {           result += (count[i] * (count[i] - 1) * (count[i] - 2)) / 6;         } else if (i == j &amp;&amp; j != k) {           result += ((count[i] * (count[i] - 1)) / 2) * count[k];         } else if (j &lt; k) {           result += count[i] * count[j] * count[k];         }       }     return (int) (result % 1000000007);   }  }   결과  Link   설명     정수 배열인 arr을 이용하여 아래의 규칙을 만족하는 경우의 수를 구하는 문제이다.            i &lt; j &lt; k일때, $rr[i] + arr[j] + arr[k] = target$를 만족한다.       단, 답이 매우 클 수 있으므로 모듈러 $10^9 + 7$을 이용해 계산한다.           문제 풀이에 필요한 변수를 정의한다.            count는 숫자의 갯수를 계산할 변수로, 숫자의 최댓값인 100을 이용하여 101 크기로 초기화하고 arr의 모든 값의 수를 넣어준다.       result는 조건을 만족하는 경우의 수를 저장하기 위한 변수로, 0으로 초기화한다.           0부터 100 이하까지 i를, i부터 100 이하까지 j를 증가시키며 아래를 반복한다.            k에 $target - i - j$를 넣어준다.       k가 100보다 크거나 0보다 작은 경우, 숫자 범위에서 벗어나므로 다음 반복을 수행한다.       i와 j가 같고 j와 k가 같은 경우 세 값이 동일하므로, result에 동일한 세 값을 이용한 경우의 수인 $\\frac{count[i] \\times (count[i] - 1) \\times (count[i] - 2)}{6}$의 값을 더해준다.       위의 경우가 아니면서 i와 j의 값이 같고 k만 값이 다른 경우, result에 동일한 두 값과 다른 한 값을 이용한 경우의 수인 $\\frac{count[i] * (count[i] - 1)}{2} \\times count[k]$의 값을 더해준다.       마지막으로 모든 값이 다르면서 j가 k보다 작은 경우, 다른 세 값을 이용한 경우의 수인 $count[i] \\times count[j] \\times count[k]$의 값을 더해준다.           반복이 완료되면 result에 모듈러 $10^9 + 7$을 적용한 결과를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/3sum-with-multiplicity/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Twin Sum of a Linked List",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public int pairSum(ListNode head) {     ListNode fast = head;     ListNode slow = head;     ListNode curr = head;     ListNode prev = null;     while (fast != null) {       fast = fast.next.next;       curr = slow;       slow = slow.next;       curr.next = prev;       prev = curr;     }     int result = 0;     while (slow != null) {       result = Math.max(result, prev.val + slow.val);       slow = slow.next;       prev = prev.next;     }     return result;   }  }   결과  Link   설명     짝수 길이의 head를 이용하여 최대 쌍둥이 합을 구하는 문제이다.            길이가 n일 경우, 0 &lt;= i &lt;= $\\frac{n}{2} - 1$이면 i번째 노드는 $n - 1 - i$번째 노드의 쌍둥이다.           문제 풀이에 필요한 변수를 정의한다.            fast와 slow는 ListNode인 head의 중앙 지점을 slow에 위치하게 하기 위한 변수로, 둘 다 head로 초기화한다.       curr과 prev는 ListNode인 head의 중앙 이전 값을 prev에 역순으로 저장하기 위한 변수로, curr은 head prev는 null로 초기화한다.                fast가 null일 때 까지 slow에 head의 $\\frac{n}{2} + 1$ 위치에 위치시키고, prev에 $\\frac{n}{2}$ 이전까지 역순으로 저장시킨다.            result는 최대 쌍둥이 합을 저장하기 위한 변수로, 0으로 초기화한다.            slow가 null이지 않을 때 까지 slow와 prev의 값들인 중앙 위치의 두 쌍둥이 합을 계산하여 result에 최댓값을 넣어준다.       반복이 완료되면 최대 쌍둥이 합이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-twin-sum-of-a-linked-list/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Number of Vertices to Reach All Nodes",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; findSmallestSetOfVertices(int n, List&lt;List&lt;Integer&gt;&gt; edges) {     boolean[] visited = new boolean[n];     for (List&lt;Integer&gt; edge : edges) {       visited[edge.get(1)] = true;     }     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     for (int i = 0; i &lt; n; i++) {       if (!visited[i]) {         result.add(i);       }     }     return result;   }  }   결과  Link   설명     n개의 꼭짓점이 존재하는 비순환 그래프인 edges를 이용하여 아래의 조건을 만족하면서 그래프의 모든 노드에 도달할 수 있는 가장 작은 수의 시작 노드를 찾는 문제이다.            edges[i] = [fromi, toi]로, fromi 노드에서 toi로 이동할 수 있음을 나타낸다.           문제 풀이에 필요한 변수를 정의한다.            visited는 노드의 방문 여부를 저장하기 위한 변수로, n 크기의 부울 배열로 정의하고 edges를 이용하여 도착 노드의 번호에 true를 넣어준다.       result는 시작 노드를 저장할 변수로, ArrayList로 초기화하고 0부터 n 미만까지 반복하여 도착 노드가 없는 노드들을 넣어준다.           반복이 완료되면 가장 작은 수의 시작 노드들이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-number-of-vertices-to-reach-all-nodes/",
        "teaser": null
      },{
        "title": "Leetcode Java Long Pressed Name",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isLongPressedName(String name, String typed) {     int i = 0;     int j = 0;     while (j &lt; typed.length()) {       if (i &lt; name.length() &amp;&amp; name.charAt(i) == typed.charAt(j)) {         i++;       } else if (j == 0 || typed.charAt(j - 1) != typed.charAt(j)) {         return false;       }       j++;     }     return i == name.length();   }  }   결과  Link   설명          typed의 중복 문자를 제거하고 name이 될 수 있는지 검증하는 문제이다.            i와 j는 name과 typed를 검증하기 위한 위치 변수로, 둘 다 0으로 초기화한다.       j가 typed의 길이 미만일 때 까지 아래를 반복한다.            i가 name의 길이 미만이면서 name의 i번째 문자와 typed의 j번째 문자가 동일한 경우, i를 증가시킨다.       위가 아니면서 j가 0이거나 typed의 $j - 1$번째 문자와 j번째 문자가 동일하지 않은 경우 name과 다른 값이 입력되었으므로, 주어진 문제의 결과로 false를 반환한다.       j를 증가시키고 다음 반복을 계속 한다.           반복이 완료되면 i가 nmae의 길이와 동일한지 검증한 결과를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/long-pressed-name/",
        "teaser": null
      },{
        "title": "Leetcode Java Flip String to Monotone Increasing",
        "excerpt":"문제  Link   코드  class Solution {    public int minFlipsMonoIncr(String s) {     int flip0 = 0;     int flip1 = 0;     for (char c : s.toCharArray()) {       int num = c - '0';       flip0 += num;       flip1 = Math.min(flip0, flip1 + 1 - num);     }     return flip1;   }  }   결과  Link   설명          0과 1로 구성된 s를 이용하여 점층적으로 증가하는 문자열로 변환하는데 필요한 최소 변환 횟수를 구하는 문제이다.            flip0과 flip1는 값을 변환한 횟수를 저장할 변수로, 둘 다 0으로 초기화한다.       s의 처음부터 끝까지 각 문자를 c에 넣어 아래를 반복한다.            num에 c를 숫자로 변환하여 넣어준다.       flip0에 1 -&gt; 0으로 변환한 횟수인 num을 더해준다.       flip1에는 0 -&gt; 1로 변환한 횟수인 $flip1 + 1 - num$의 값과 flip0 중 작은 값을 넣어준다.           반복이 완료되면 최소 변환 횟수가 저장된 flip1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/flip-string-to-monotone-increasing/",
        "teaser": null
      },{
        "title": "Leetcode Java Three Equal Parts",
        "excerpt":"문제  Link   코드  class Solution {    public int[] threeEqualParts(int[] arr) {     int count = 0;     for (int num : arr) {       if (num == 1) {         count++;       }     }     if (count == 0) {       return new int[] { 0, 2 };     }     if (count % 3 != 0) {       return new int[] { -1, -1 };     }     int index = 0;     for (int i = arr.length - 1, oneThird = count / 3; i &gt;= 0; i--) {       if (arr[i] == 1 &amp;&amp; --oneThird == 0) {         index = i;         break;       }     }     int first = this.findIndex(arr, 0, index);     if (first &lt; 0) {       return new int[] { -1, -1 };     }     int second = this.findIndex(arr, first + 1, index);     if (second &lt; 0) {       return new int[] { -1, -1 };     }     return new int[] { first, second + 1 };   }    private int findIndex(int[] arr, int left, int right) {     while (arr[left] == 0) {       left++;     }     while (right &lt; arr.length) {       if (arr[left++] != arr[right++]) {         return -1;       }     }     return left - 1;   }  }   결과  Link   설명     0과 1로 구성된 arr의 이진 표현법의 값이 동일한 세 부분 배열로 나누기 위한 위치를 찾는 문제이다.            단, 나눌 수 없는 경우는 [-1, -1]을 주어진 문제의 결과로 반환한다.       부분 배열로 나누는 위치가 [i, j]인 경우 $i + 1$ &lt; j를 만족한다.                count는 1의 수를 저장할 변수로, arr 내 1의 갯수를 저장한다.            count가 0이면 아무 위치로 분할해도 1의 갯수는 같으므로, 조건에 맞도록 [0, 2]를 주어진 문제의 결과로 반환한다.            count가 3의 배수가 아닌 경우 1의 수가 동일한 세 부분 배열로 나눌 수 없으므로, [-1, -1]을 주어진 문제의 결과로 반환한다.            index는 1의 수가 $\\frac{1}{3}$인 위치를 저장하기 위한 변수로, arr을 역순으로 탐색하여 해당 위치를 index에 저장한다.       arr의 부분 배열로 나누기 위한 findIndex(int[] arr, int left, int right) 메서드를 정의한다.            arr의 left번째 값이 0인 경우 left를 계속 증가시켜 1의 위치로 이동시킨다.       right가 arr의 길이 미만까지 arr의 left번째 갑솨 right번째 값이 동일한지 검증하여, 동일하지 않으면 -1을 반환한다.       반복이 완료되면 나누기 위한 위치 값인 $left - 1$을 반환한다.                first에 0부터 index까지 6번의 findIndex(int[] arr, int left, int right) 메서드를 수행한 결과를 넣고, 해당 값이 0보다 작은 위치 값을 탐색하지 못한경우 [-1, -1]을 주어진 문제의 결과로 반환한다.            second에 $fisrt + 1$부터 index까지 6번의 findIndex(int[] arr, int left, int right) 메서드를 수행한 결과를 넣고, 해당 값이 0보다 작은 위치 값을 탐색하지 못한경우 [-1, -1]을 주어진 문제의 결과로 반환한다.       위치 탐색이 완료되면 [first, $second + 1$]을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/three-equal-parts/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Subsequence Score",
        "excerpt":"문제  Link   코드  class Solution {    public long maxScore(int[] nums1, int[] nums2, int k) {     int length = nums1.length;     int[][] pairs = new int[length][2];     for (int i = 0; i &lt; length; i++) {       pairs[i] = new int[] { nums1[i], nums2[i] };     }     Arrays.sort(pairs, (a, b) -&gt; b[1] - a[1]);     Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(k, (a, b) -&gt; a - b);     long result = 0;     long sum = 0;     for (int[] pair : pairs) {       queue.offer(pair[0]);       sum += pair[0];       if (queue.size() &gt; k) {         sum -= queue.poll();       }       if (queue.size() == k) {         result = Math.max(result, sum * pair[1]);       }     }     return result;   }  }   결과  Link   설명          num1의 k개 값과 동일한 위치의 nums2의 k개 값 중 작은 값과의 곱한 값이 가장 큰 결과를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 nums1의 길이를 저장할 변수이다.       pairs는 nums1과 nums2의 공통된 위치 값을 저장할 변수로, $length \\times 2$ 크기로 초기화하고 두 배열을 반복하여 pairs에 동일한 위치 값끼리 넣어준 후 nums2 값 기준으로 내림차순 정렬한다.       queue는 k개의 값을 오름차순 정렬된 값을 저장할 변수로, PriorityQueue를 k 초기 크기로 초기화한다.       result는 결과를 넣을 변수로, 0으로 초기화한다.       sum은 세 값의 합을 저장할 변수로, 0으로 초기화한다.           pairs의 모든 값들을 pair에 넣어 아래를 수행한다.            queue에 pair의 첫 값을 넣고, 해당 값을 sum에 더해준다.       queue의 크기가 k 초과인 경우 queue에서 가장 작은 값을 꺼내 제거한다.       queue의 크기가 k와 동일한 경우, result에 result와 $sum \\times pair[1]$의 결과 중 큰 값을 넣어준다.           반복이 완료되면 가장 큰 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-subsequence-score/",
        "teaser": null
      },{
        "title": "Leetcode Java Stone Game II",
        "excerpt":"문제  Link   코드  class Solution {    public int stoneGameII(int[] piles) {     int length = piles.length;     for (int i = length - 2; i &gt;= 0; i--) {       piles[i] += piles[i + 1];     }     return this.dfs(piles, new int[length][length], 1, 0);   }    private int dfs(int[] piles, int[][] dp, int m, int p) {     if (p + 2 * m &gt;= piles.length) {       return piles[p];     } else if (dp[p][m] &gt; 0) {       return dp[p][m];     } else {       int result = 0;       for (int i = 1; i &lt;= 2 * m; i++) {         result = Math.max(result, piles[p] - this.dfs(piles, dp, Math.max(i, m), p + i));       }       dp[p][m] = result;       return result;     }   }  }   결과  Link   설명     지난 번 Stone Game과 비슷하게, 아래 규칙대로 돌을 빼앗는 게임을 수행하여 얻을 수 있는 엘리스의 돌의 최대 갯수를 구하는 문제이다.            일렬로 정렬된 여러 개의 말뚝의 각 위치에 piles[i]개의 돌이 있다.       m은 1로 엘리스와 밥 순서대로 서로 번갈아 시작한다.       1 &lt;= X &lt;= 2M를 만족하는 말뚝에 존재하는 X개의 돌을 가져가고 M에 M과 X 중 큰 값을 넣어준다.                length는 piles의 길이를 저장한 변수로, $length - 2$부터 0 이상까지 i를 감소시키며 piles의 i번째 위치에 $i + 1$번째 값을 더해준다.            4번에서 정의한 dfs(int[] piles, int[][] dp, int m, int p) 메서드를 dp에 $length \\times length$ 크기의 정수 배열과 m과 p에 1과 0을 이용하여 수행한 결과를 주어진 문제의 결과로 반환한다.       DFS 방식으로 돌의 수를 탐색할 dfs(int[] piles, int[][] dp, int m, int p) 메서드를 수행한다.            $p + 2 \\times m$의 결과가 piles의 길이보다 크거나 같은 경우, piles의 p의 위치에 해당하는 값을 반환한다.       위의 경우가 아니면서 dp[p][m]의 값이 0보다 큰 경우, 이미 수행된 결과이므로 해당 값을 반환한다.       위의 모든 경우가 아니라면 아래를 수행한다.                    result는 돌의 수를 저장하기 위한 변수로 0으로 초기화한다.           1부터 $2 \\times m$ 이하까지 i를 증가시키며 result에 result와 piles[p]에 m에 i와 m 중 큰 값과 p에 $p + i$를 이용하여 재귀 호출한 결과를 넣어준다.           dp[p][m]의 위치에 result를 넣고, result를 반환한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/stone-game-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Design Parking System",
        "excerpt":"문제  Link   코드  class ParkingSystem {    private int[] count;    public ParkingSystem(int big, int medium, int small) {     this.count = new int[] { big, medium, small };   }    public boolean addCar(int carType) {     return this.count[carType - 1]-- &gt; 0;   }  }  /**  * Your ParkingSystem object will be instantiated and called as such:  * ParkingSystem obj = new ParkingSystem(big, medium, small);  * boolean param_1 = obj.addCar(carType);  */   결과  Link   설명     각 차의 크기 별 주차할 수 있는 공간을 관리하는 ParkingSystem 객체를 정의하는 문제이다.            생성자인 ParkingSystem(int big, int medium, int small)은 big, medium, small의 주차 대수를 이용하여 객체를 초기화한다.       메서드인 addCar(int carType)는 carType별 주차 가능 여부를 관리하는 메서드로, big은 1을 medium은 2를 small은 3을 의미한다.           주차 공간을 관리하기 위한 전역 변수를 정의한다.            count는 각 차량의 크기 별 주차 가능 대수를 저장할 변수이다.           생성자인 ParkingSystem(int big, int medium, int small)를 완성한다.            count에 [big, medium, small] 순으로 주차 가능 공간을 저장한다.           메서드인 addCar(int carType)를 완성한다.            count의 $carType - 1$번째 값을 감소시키고, 주차가 가능한지 여부인 해당 값이 0보다 큰지 검증한 결과를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/design-parking-system/",
        "teaser": null
      },{
        "title": "Leetcode Java Unique Email Addresses",
        "excerpt":"문제  Link   코드  class Solution {    public int numUniqueEmails(String[] emails) {     Set&lt;String&gt; set = new HashSet&lt;&gt;();     for (String email : emails) {       int length = email.length();       StringBuilder sb = new StringBuilder(length);       for (int i = 0; i &lt; length; i++) {         char c = email.charAt(i);         switch (c) {           case '.':             break;           case '+':             while (c != '@') {               c = email.charAt(++i);             }             sb.append(email.substring(i));             i = length;             break;           case '@':             sb.append(email.substring(i));             i = length;             break;           default:             sb.append(c);         }       }       set.add(sb.toString());     }     return set.size();   }  }   결과  Link   설명     이메일 정보가 담긴 emails은 아래의 규칙을 만족한 고유한 이메일로 발송이 되는데, 발송되는 이메일의 수를 구하는 문제이다.            emails[i]는 local명과 domain명을 ‘@’로 구분한 값을 담고 있다.       local명에서는 ‘.’ 문자는 무시하고 ‘+’ 문자 이후는 제거한 local명으로 변환한 문자열로 변환하여 발송된다.                set은 고유한 이메일의 수를 저장할 변수로, 중복을 배제하기 위해서 HashSet으로 초기화한다.       emails를 차례대로 email에 넣고 아래를 반복한다.            조건을 만족하는 이메일로 변환하기 위한 변수를 정의한다.                    length는 email의 길이를 저장한 변수이다.           sb는 동적으로 변환한 이메일을 저장할 변수로, email 크기의 StringBuilder로 초기화한다.                       0부터 length까지 i를 증가시키며 아래를 반복한다.                    c의 email의 i번째 문자를 넣어준다.           c가 ‘.’인 경우, 무시하고 다음 반복을 수행한다.           c가 ‘+’인 경우, 해당 문자부터 ‘@’ 이전까지 문자들을 무시하고 모든 문자들을 sb에 넣어 set에 완성된 이메일을 넣고 i에 length를 넣어 다음 반복을 중단시킨다.           c가 ‘@’인 경우, sb에 남은 문자열을 넣고 i에 length를 넣어 다음 반복을 중단시킨다.           위의 경우가 아니라면 sb에 c를 넣어준다.                       반복이 완료되면 set에 완성된 이메일인 sb를 문자열을 변환하여 넣어준다.           반복이 완료되면 고유 이메일의 수가 저장된 set의 크기를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/unique-email-addresses/",
        "teaser": null
      },{
        "title": "Leetcode Java Design Underground System",
        "excerpt":"문제  Link   코드  import java.util.AbstractMap;  class UndergroundSystem {    private Map&lt;Integer, Map.Entry&lt;String, Integer&gt;&gt; travel;   private Map&lt;Map.Entry&lt;String, String&gt;, Map.Entry&lt;Double, Integer&gt;&gt; averageTime;    public UndergroundSystem() {     this.travel = new HashMap&lt;&gt;();     this.averageTime = new HashMap&lt;&gt;();   }    public void checkIn(int id, String stationName, int t) {     this.travel.putIfAbsent(id, new AbstractMap.SimpleEntry&lt;&gt;(stationName, t));   }    public void checkOut(int id, String stationName, int t) {     if (!this.travel.containsKey(id)) {       return;     }     Map.Entry&lt;String, Integer&gt; prev = this.travel.remove(id);     Map.Entry&lt;String, String&gt; station = new AbstractMap.SimpleEntry&lt;&gt;(prev.getKey(), stationName);     double time = t - prev.getValue();     if (this.averageTime.containsKey(station)) {       Map.Entry&lt;Double, Integer&gt; curr = this.averageTime.get(station);       this.averageTime.put(station, new AbstractMap.SimpleEntry&lt;&gt;(curr.getKey() + time, curr.getValue() + 1));     } else {       this.averageTime.put(station, new AbstractMap.SimpleEntry&lt;&gt;(time, 1));     }   }    public double getAverageTime(String startStation, String endStation) {     Map.Entry&lt;Double, Integer&gt; curr = this.averageTime.get(new AbstractMap.SimpleEntry&lt;&gt;(startStation, endStation));     return curr.getKey() / curr.getValue();   }  }  /**  * Your UndergroundSystem object will be instantiated and called as such:  * UndergroundSystem obj = new UndergroundSystem();  * obj.checkIn(id,stationName,t);  * obj.checkOut(id,stationName,t);  * double param_3 = obj.getAverageTime(startStation,endStation);  */   결과  Link   설명     역에서 다른 역까지 이동하는데 걸리는 평균 시간을 계산하는 UndergroundSystem 클래스를 완성하는 문제이다.            메서드인 checkIn(int id, String stationName, int t)은 고객 id로 t시간에 stationName에서 체크인한다.       메서드인 checkOut(int id, String stationName, int t)은 고객 id로 t시간에 stationName에서 체크아웃한다.       메서드인 getAverageTime(String startStation, String endStation)은 지금까지 고객들 중 startStation에서 endStation까지 걸린 평균 시간을 반환한다. 단, startStation의 시간인 t1은 endStation의 시간인 t2보다 커야 startStation에서 endStation으로 이동한 것으로 간주한다.           문제 풀이에 필요한 전역 변수를 정의한다.            travel은 고객이 이동한 기록을 저장하는 변수이다.       averageTime은 한 역에서 다른 역으로 이동한 총 시간과 횟수를 저장하기 위한 변수이다.                생성자인 UndergroundSystem()를 이용하여 travel과 averageTime을 HashMap으로 초기화한다.       메서드인 checkIn(int id, String stationName, int t)을 정의한다.            travel에 id에 해당하는 값이 없는 경우, id가 key인 값에 stationName과 t를 AbstractMap.SimpleEntry를 이용하여 쌍으로 넣어준다.           메서드인 checkOut(int id, String stationName, int t)을 정의한다.            travel에 id에 해당하는 값이 없는 경우, 체크인한 기록이 없으므로 수행을 멈춘다.       prve에 travel에서 id에 해당하는 값인 이전 출입한 기록을 제거하여 넣어준다.       station에 prev의 key인 체크인한 역의 이름과 체크아웃한 주어진 stationName을 쌓으로 넣어준다.       time에 t와 prev의 값인 체크인한 시간의 차이를 실수 형태로 넣어준다.       averageTime에 station에 해당하는 값이 존재하면 averageTime의 station에 해당하는 값에 걸린 시간인 time을 더하고 횟수를 증가시켜 넣어준다.       averageTime에 station에 해당하는 값이 존재하지 않으면 averageTime의 station에 해당하는 값에 time과 1을 쌍으로 넣어준다.           메서드인 getAverageTime(String startStation, String endStation)을 정의한다.            averageTime에서 startStation에서 endStation까지의 총 걸린 시간과 이동 횟수를 가져와 두 값을 나눈 결과를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/design-underground-system/",
        "teaser": null
      },{
        "title": "Leetcode Java Shortest Path in Binary Matrix",
        "excerpt":"문제  Link   코드  class Solution {    private static final int[][] DIRECTIONS = new int[][] {     { 0, 1 },     { 1, 0 },     { -1, 0 },     { 0, -1 },     { 1, 1 },     { -1, 1 },     { 1, -1 },     { -1, -1 }   };    public int shortestPathBinaryMatrix(int[][] grid) {     if (grid[0][0] == 0) {       int length = grid.length;       Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();       queue.add(new int[] { 0, 0, 0 });       while (!queue.isEmpty()) {         int[] curr = queue.poll();         if (curr[0] == length - 1 &amp;&amp; curr[1] == length - 1) {           return curr[2] + 1;         }         for (int[] direction : DIRECTIONS) {           int x = curr[0] + direction[0];           int y = curr[1] + direction[1];           if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; length &amp;&amp; y &lt; length &amp;&amp; grid[x][y] == 0) {             grid[x][y] = -1;             queue.add(new int[] { x, y, curr[2] + 1 });           }         }       }     }     return -1;   }  }   결과  Link   설명     $n \\times n$ 크기의 이차원 배열인 grid를 이용하여 가장 짧은 확실한 길을 찾는 문제이다.            확실한 길은 [0, 0] 위치에서 [$n - 1$, $n - 1$] 위치까지 이동하는 길이다.       이동 방향은 셀의 인접한 모든 방향 중 0인 값으로 이동 가능하다.                시작 위치인 grid[0][0]이 0인 경우만 아래를 수행하고 아닌 경우, -1을 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            length는 grid의 길이를 저장한 변수이다.       queue는 이동 방향에 대한 위치 별 이동 횟수를 순차적으로 모두 탐색하기 위한 큐로, LinkedList로 초기화하고 첫 위치와 이동 횟수를 [0, 0, 0] 배열로 넣어준다.       queur가 비어있지 않을 때 까지 아래를 반복한다.                    curr은 queue에 있는 값을 꺼내 넣어준다.           [x, y]인 curr의 두 값이 $length - 1$인 경우, 이동 횟수인 curr[2]의 값에 마지막 위치로 이동하기 위한 이동 횟수인 1을 더해서 반환한다.           위가 아니라면 DIRECTIONS의 8방향을 순차적으로 direction에 넣고 반복할 때, x와 y에 더해서 x와 y가 0 ~ $length - 1$ 사이 값이면서 이동 가능한 값이 0인 경우 이동 할 위치에 -1을 넣고 queue에 앞의 위치에 이동 횟수를 추가하여 다시 넣어준다.                           반복이 완료되면 가장 짧은 확실한 길이 존재하지 않는다는 의미이므로, -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/shortest-path-in-binary-matrix/",
        "teaser": null
      },{
        "title": "Leetcode Java Time Needed to Inform All Employees",
        "excerpt":"문제  Link   코드  class Solution {    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {     int result = 0;     for (int i = 0; i &lt; n; i++) {       result = Math.max(result, this.dfs(manager, informTime, i));     }     return result;   }    private int dfs(int[] manager, int[] informTime, int i) {     if (manager[i] != -1) {       informTime[i] += this.dfs(manager, informTime, manager[i]);       manager[i] = -1;     }     return informTime[i];   }  }   결과  Link   설명     [0, $n - 1$] 범위의 직원 ID가 존재하는데 사장 ID는 headID이며, 관리자들의 ID를 담은 manager와 전파하는데 걸리는 시간을 담은 informTime을 이용하여 사장이 모든 직원에게 전파하는데 걸리는 시간을 반환하는 문제이다.            단, manager[headID] = -1 이다.                result는 모든 직원에게 전파하는데 걸리는 시간을 담을 변수로, 0으로 초기화한다.       0부터 n 미만까지 i를 증가시키며 아래를 수행한다.            result에 result와 4번에서 정의한 dfs(int[] manager, int[] informTime, int i)를 수행한 결과 중 큰 값을 넣어준다.           DFS 방식으로 전파하는데 걸리는 시간을 구하기 위한 dfs(int[] manager, int[] informTime, int i) 메서드를 정의한다.            manager의 i번째 값이 아닌 경우, 아래를 수행한다.                    infromTime의 i번째 위치에 i번째 manager의 ID를 i에 넣어 재귀 호출한 결과를 넣어준다.           전파 시간을 informTime에 넣었으므로, manager의 i번째 위치에 -1을 넣어 다음 호출에 무시하도록 처리한다.                       informTime의 i번째 값을 반환한다.           전파하는데 걸리는 시간을 담은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/time-needed-to-inform-all-employees/",
        "teaser": null
      },{
        "title": "Leetcode Java Check If It Is a Straight Line",
        "excerpt":"문제  Link   코드  class Solution {    public boolean checkStraightLine(int[][] coordinates) {     int x = coordinates[1][0];     int y = coordinates[1][1];     int dx = x - coordinates[0][0];     int dy = y - coordinates[0][1];     for (int[] coordinate : coordinates) {       if (dx * (coordinate[1] - y) != dy * (coordinate[0] - x)) {         return false;       }     }     return true;   }  }   결과  Link   설명          점의 위치를 넣은 coordinates가 직선으로 위치하는지를 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            x와 y에 coordinates의 두 번째 값의 좌표를 순서대로 넣어준다.       dx와 dy에 x와 coordinates의 첫 뻔째 값의 좌표의 차잇값을 넣어준다.           coordinates의 모든 값을 이용하여 아래를 반복한다.            dx와 coordinate의 두 번째 값에 y를 뺀 값을 곱한 결과와 dy에 coordinate의 첫 번째 값에 x를 뺀 값을 곱한 결과가 같지 않으면 기울기가 달라졌으므로 false를 반환한다.           반복이 완료되면 일자로 이어져 있으므로, true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/check-if-it-is-a-straight-line/",
        "teaser": null
      },{
        "title": "Leetcode Java Can Make Arithmetic Progression From Sequence",
        "excerpt":"문제  Link   코드  class Solution {    public boolean canMakeArithmeticProgression(int[] arr) {     int length = arr.length;     int min = Integer.MAX_VALUE;     int max = Integer.MIN_VALUE;     for (int num : arr) {       min = Math.min(min, num);       max = Math.max(max, num);     }     int diff = max - min;     if (diff % (length - 1) != 0) {       return false;     }     diff /= length - 1;     for (int i = 0; i &lt; length;) {       int num = arr[i] - min;       if (num == diff * i) {         i++;       } else if (num % diff != 0) {         return false;       } else {         int position = num / diff;         if (position &lt; i || arr[position] == arr[i]) {           return false;         }         int temp = arr[position];         arr[position] = arr[i];         arr[i] = temp;       }     }     return true;   }  }   결과  Link   설명     arr의 숫자들을 정렬하여 산술 급수를 만들 수 있는지 검증하는 문제이다.            두 개 이상의 연속된 숫자의 차이가 동일한 경우, 산술 급수라고 한다.           문제 풀이에 필요한 변수를 정의한다.            length는 arr의 길이를 저장한 변수이다.       min과 max는 arr의 최솟값과 최댓값을 넣을 변수로, arr을 반복하여 최솟값과 최댓값을 넣어준다.       diff는 max와 min의 차이를 저장한 변수이다.                diff를 $length - 1$로 나눈 나머지가 0이 아닌 경우, arr의 모든 값들이 균등하게 증가할 수 없으므로 false를 주어진 문제의 결과로 반환한다.            diff에 $length - 1$로 나눈 값인 숫자들 간 차이를 넣어준다.       i가 0부터 length 미만까지 아래를 수행한다.            num에 arr의 i번째 값과 min의 차이 값을 넣어준다.       num이 diff와 i를 곱한 값과 같으면 점층적으로 증가하므로 i를 증가시켜준다.       위가 경우가 아니면서 num을 diff로 나눈 나머지가 0이 아닌 경우, 증가하는 값이 다르므로 false를 주어진 문제의 결과로 반환한다.       위의 경우가 아니면 아래를 수행한다.                    position에 $\\frac{num}{diff}$을 넣어준다.           position이 i보다 작거나 arr의 i번째 값과 position번째 값이 동일하면, 증가하는 경우가 아니므로 false를 주어진 문제의 결과로 반환한다.           arr의 i번째 값과 position번째 값을 바꾸어준다.                           반복이 정상적으로 종료되면 arr의 값들로 산술 급수를 만들 수 있으므로, true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/can-make-arithmetic-progression-from-sequence/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Flips to Make a OR b Equal to c",
        "excerpt":"문제  Link   코드  class Solution {    public int minFlips(int a, int b, int c) {     int result = 0;     while (a &gt; 0 || b &gt; 0 || c &gt; 0) {       if ((c &amp; 1) == 0) {         result += (a &amp; 1) + (b &amp; 1);       } else if ((a &amp; 1) == 0 &amp;&amp; (b &amp; 1) == 0) {         result++;       }       a &gt;&gt;= 1;       b &gt;&gt;= 1;       c &gt;&gt;= 1;     }     return result;   }  }   결과  Link   설명     a와 b의 OR 비트 연산의 결과가 c가 되기 위한 최소 플립 횟수를 구하는 문제이다.            플립은 비트가 0인 경우 1로, 1인 경우 0으로 바꾸는 행위이다.                result는 최소 플립 횟수를 저장할 변수로, 0으로 초기화 한다.       a와 b, c 하나라도 0 초과일 때 까지 아래를 반복한다.            c와 1의 AND 비트 연산의 결과가 0인 경우, result에 a와 1의 AND 비트 연산 결과인 a를 플립하는 경우와 b와 1의 AND 비트 연산 결과인 b를 플립하는 경우의 합을 넣어준다.       위가 아니라 a와 1의 AND 비트 연산 결과가 0이고 b와 1의 AND 비트 연산 결과가 0인 경우, a와 b 둘 중 하나만 플립하면 되므로 result를 증가시켜준다.       현재 위치에서 플립 횟수를 계산했으므로 a와 b, c의 비트 값들을 우측으로 한 칸씩 이동시켜준다.           반복이 완료되면 최소 플립 횟수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-flips-to-make-a-or-b-equal-to-c/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Negative Numbers in a Sorted Matrix",
        "excerpt":"문제  Link   코드  class Solution {    public int countNegatives(int[][] grid) {     int result = 0;     int row = grid.length;     int col = grid[0].length;     for (int i = 0, right = col - 1; i &lt; row; i++) {       int left = 0;       while (left &lt;= right) {         int mid = left + ((right - left) / 2);         if (grid[i][mid] &lt; 0) {           right = mid - 1;         } else {           left = mid + 1;         }       }       result += col - left;       right = left - 1;     }     return result;   }  }   결과  Link   설명          행과 열 별로 감소하는 추세인 $m \\times n$ 크기의 grid 내 음수인 값의 갯수를 계산하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 grid 내 음수인 값의 갯수를 저장할 변수로, 0으로 초기화한다.       row와 col은 행과 열의 길이를 저장한 변수이다.           0부터 row 미만까지 i를 증가하며, right에 $col - 1$을 넣고 아래를 반복한다.            left를 0으로 초기화 하고 left가 right 미만일 때 까지 아래를 반복한다.                    mid에 $left + \\frac{right - left}{2}$인 중앙값을 넣어준다.           grid[i][mid]의 값이 음수인 경우, right에 $mid - 1$을 넣어 범위를 좁혀준다.           grid[i][mid]의 값이 양수인 경우, left에 $mid + 1$을 넣어 범위를 좁혀준다.                       반복이 종료되면 result에 $col - left$인 음수의 갯수를 넣어준다.       아래로 내려갈수록 값은 감소하므로, right에 $left - 1$을 넣어 다음 탐색 범위를 좁혀준다.           모든 반복이 완료되면 grid 내 음수의 갯수를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-negative-numbers-in-a-sorted-matrix/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Subarrays With Sum",
        "excerpt":"문제  Link   코드  class Solution {    public int numSubarraysWithSum(int[] nums, int goal) {     int sum = 0;     int result = 0;     int[] count = new int[nums.length + 1];     count[0] = 1;     for (int num : nums) {       sum += num;       if (sum &gt;= goal) {         result += count[sum - goal];       }       count[sum]++;     }     return result;   }  }   결과  Link   설명          0과 1로 이루어진 nums의 연속된 값들의 합이 goal이 되는 부분 배열의 수를 구하는 문제다.       문제 풀이에 필요한 변수를 정의한다.            sum은 합을 계산하기 위한 임시 변수로, 0으로 초기화한다.       result는 하위 부분 배열의 수를 구하기 위한 변수로, 0으로 초기화한다.       count는 연속된 값의 합계인 위치의 갯수를 계산할 변수로, nums의 길이보다 1 큰 크기로 초기화하여 첫 값에 1로 초기화한다.           nums의 모든 값을 num에 넣어 순차적으로 반복한다.            sum에 num을 더해준다.       sum이 goal보다 큰 경우, result에 count의 $sum - goal$ 위치의 값을 더해준다.       count의 sum번째 값을 증가시킨다.           nums의 연속된 값들의 합이 goal이 되는 부분 배열의 수를 계산한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-subarrays-with-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Falling Path Sum",
        "excerpt":"문제  Link   코드  class Solution {    public int minFallingPathSum(int[][] matrix) {     return this.dfs(matrix, matrix.length - 2);   }    private int dfs(int[][] matrix, int index) {     int length = matrix.length;     if (index &lt; 0) {       int result = matrix[0][0];       for (int i = 1; i &lt; length; i++) {         result = Math.min(result, matrix[0][i]);       }       return result;     } else {       for (int i = 0; i &lt; length; i++) {         int min = matrix[index + 1][i];         if (i &gt; 0) {           min = Math.min(min, matrix[index + 1][i - 1]);         }         if (i &lt; length - 1) {           min = Math.min(min, matrix[index + 1][i + 1]);         }         matrix[index][i] += min;       }       return this.dfs(matrix, index - 1);     }   }  }   결과  Link   설명          matrix의 맨 위 행의 임의 열에서 시작하여 대각선 아래를 포함한 아래 방향으로 이동할 때, 숫자들의 합이 최소가 되는 값을 구하는 문제이다.            3번에서 정의한 dfs(int[][] matrix, int index) 메서드를 수행한 결과를 주어진 문제의 결과로 반환한다.            DFS 방식으로 값을 탐색할 dfs(int[][] matrix, int index) 메서드를 정의한다.             length는 matrix의 길이를 저장할 변수이다.       index가 음수인 경우, 탐색이 완료되었으므로 matrix의 첫 행의 값들 중 가장 작은 값을 반환한다.       index가 양수이면 0부터 length 미만까지 i를 증가시키며 아래를 수행한다.                    min에 matrix[$index + 1$][i]의 값을 넣어준다.           i가 0보다 큰 경우, min에 min과 대각선 좌측 아래 값인 matrix[$index + 1$][$i - 1$]의 값 중 작은 값을 넣어준다.           i가 $length - 1$보다 작은 경우, min에 min과 대각선 우측 아래 값인 matrix[$index + 1$][$i + 1$]의 값 중 작은 값을 넣어준다.           matrix[index][i]의 위치에 아래로 이동할 때 최소 값인 min을 더해준다.                       반복이 완료되면 index위치에 $index - 1$을 넣어 재귀 호출한 결과를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-falling-path-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Equal Row and Column Pairs",
        "excerpt":"문제  Link   코드  class Solution {    public int equalPairs(int[][] grid) {     int result = 0;     int length = grid.length;     for (int i = 0; i &lt; length; i++) {       for (int j = 0; j &lt; length; j++) {         int k = 0;         while (k &lt; length) {           if (grid[i][k] != grid[k][j]) {             break;           }           k++;         }         result += k == length ? 1 : 0;       }     }     return result;   }  }   결과  Link   설명          $n \\times n$ 크기의 grid 내 [ri, ci] 지점에서 행과 열의 시작부터 끝까지 값의 조합이 동일하게 되는 위치의 갯수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 행과 열의 시작부터 끝까지 값의 조합이 동일하게 되는 위치의 갯수를 계산할 변수로, 0으로 초기화한다.       length는 grid의 길이를 저장한 변수이다.           0부터 length 미만까지 i를 증가시키고, 0부터 length 미만까지 j를 증가시키며 아래를 반복한다.            k에 0을 넣고, k가 length 미만까지 아래를 반복한다.                    grid[i][k]의 값이 grid[k][j]의 값과 다른 경우, 행과 열의 동일한 순번의 값이 다르게 되므로 반복을 멈춘다.           k를 증가시키고 다음 자리를 검증한다.                       k와 length가 동일한 위의 경우를 만족하는 위치인 경우에 result에 1을 더해준다.           반복이 모두 완료되면 위치의 갯수가 계산된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/equal-row-and-column-pairs/",
        "teaser": null
      },{
        "title": "Leetcode Java Beautiful Array",
        "excerpt":"문제  Link   코드  class Solution {    public int[] beautifulArray(int n) {     return this.dfs(new HashMap&lt;&gt;(), n);   }    private int[] dfs(Map&lt;Integer, int[]&gt; map, int n) {     if (map.containsKey(n)) {       return map.get(n);     } else {       int[] result = new int[n];       if (n == 1) {         result[0] = 1;       } else {         int index = 0;         for (int num : this.dfs(map, (n + 1) / 2)) {           result[index++] = (2 * num) - 1;         }         for (int num : this.dfs(map, n / 2)) {           result[index++] = 2 * num;         }       }       map.put(n, result);       return result;     }   }  }   결과  Link   설명     아래의 규칙을 만족하는 n 길이인 임의의 아름다운 배열인 nums를 만드는 문제이다.            nums는 [1, n] 범위의 정수로 이루어진 배열이다.       0 &lt;= i &lt; j &lt; n일때, $2 \\times nums[k] = nums[i] + nums[j]$를 만족하는 i &lt; k &lt; j인 k가 존재하지 않는다.                3번에서 정의한 dfs(Map&lt;Integer, int[]&gt; map, int n) 메서드를 수행한 결과를 주어진 문제의 결과로 반환한다.       DFS 방식으로 아름다운 배열을 만들기 위한 dfs(Map&lt;Integer, int[]&gt; map, int n) 메서드를 정의한다.            map에 키가 n인 배열이 존재하면 해당 배열을 반환한다.       위가 아니라면 result에 n 크기의 배열을 만들어준다.       n이 1인 경우, result의 첫 위치에 1을 넣어준다.       n이 1이 아니면 아래를 수행한다.                    index는 result의 위치 값을 저장할 변수로, 0으로 초기화한다.           n의 위치에 $\\frac{n + 1}{2}$을 넣고 재귀 호출을 수행한 결과의 모든 값을 num에 넣고, result의 index번째 위치에 $(2 \\times num) - 1$을 넣고 index를 증가시켜 앞 부분에 아름다운 배열이 되기 위한 조건의 값을 넣어준다.           n의 위치에 $\\frac{n}{2}$을 넣고 재귀 호출을 수행한 결과의 모든 값을 num에 넣고, result의 index번째 위치에 $2 \\times num$을 넣고 index를 증가시켜 뒷 부분에 아름다운 배열이 되기 위한 조건의 값을 넣어준다.                       map의 n에 해당하는 값에 result를 넣고 result를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/beautiful-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Recent Calls",
        "excerpt":"문제  Link   코드  class RecentCounter {    private Deque&lt;Integer&gt; time;    public RecentCounter() {     this.time = new LinkedList&lt;&gt;();   }    public int ping(int t) {     this.time.addLast(t);     while (this.time.getFirst() &lt; t - 3000) {       this.time.removeFirst();     }     return this.time.size();   }  }  /**  * Your RecentCounter object will be instantiated and called as such:  * RecentCounter obj = new RecentCounter();  * int param_1 = obj.ping(t);  */   결과  Link   설명     일정 시간 범위 내 최근 요청 수를 계산하는 RecentCounter 클래스를 완성하는 문제이다.            생성자인 RecentCounter()는 최근 요청이 0인 카운터를 초기화한다.       메서드인 ping(int t)은 시간 t를 새 요청으로 추가하고, 최근 3000 밀리초 내인 [$t - 3000$, t] 사이의 요청 횟수를 반환한다. 단, 모든 ping의 호출에 이전 호출보다 더 큰 t 값을 사용한다.           최근 요청 수를 계산하기 위한 전역 변수를 정의한다.            time은 최근 요청 시간을 저장할 변수이다.           생성자인 RecentCounter()를 정의한다.            time을 LinkedList로 초기화한다.           메서드인 ping(int t)을 정의한다.            time의 마지막에 t를 넣어준다.       time의 앞의 값들 중 $t - 3000$보다 작은 값들은 모두 제거한다.       최근 3000 밀리초 내 요청 수가 저장된 time의 크기를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-recent-calls/",
        "teaser": null
      },{
        "title": "Leetcode Java Make Array Strictly Increasing",
        "excerpt":"문제  Link   코드  class Solution {    public int makeArrayIncreasing(int[] arr1, int[] arr2) {     Arrays.sort(arr2);     Map&lt;Integer, Integer&gt; dp = new HashMap&lt;&gt;();     dp.put(-1, 0);     for (int num : arr1) {       Map&lt;Integer, Integer&gt; temp = new HashMap&lt;&gt;();       for (Map.Entry&lt;Integer, Integer&gt; entry : dp.entrySet()) {         if (num &gt; entry.getKey()) {           temp.put(num, Math.min(temp.getOrDefault(num, Integer.MAX_VALUE), entry.getValue()));         }         int index = Arrays.binarySearch(arr2, entry.getKey() + 1);         if (index &lt; 0) {           index = -index - 1;         }         if (index &lt; arr2.length) {           temp.put(arr2[index], Math.min(entry.getValue() + 1, temp.getOrDefault(arr2[index], Integer.MAX_VALUE)));         }       }       dp = temp;     }     return dp.isEmpty() ? -1 : Collections.min(dp.values());   }  }   결과  Link   설명     arr1의 값들을 arr2의 값으로 대체하여 순차적으로 증가시키는 배열로 변환하는 문제이다.            순차적으로 증가하는 배열로 변환하지 못하는 경우, -1을 반환한다.                arr2의 값을 오름차순으로 정렬한다.            dp는 값을 바꾼 값을 저장할 변수로, HashMap으로 초기화하여 key와 value가 -1과 0인 초기 값을 넣어준다.       arr1의 모든 값을 num에 순차적으로 넣고 아래를 수행한다.            temp는 dp를 이용하여 대체할 값을 저장할 변수로, HashMap으로 초기화한다.       dp의 값들을 순차적으로 entry에 넣고 아래를 수행한다.                    num이 entry의 key 값보다 큰 경우, temp의 num번째 값을 꺼내되 값이 없으면 정수의 최대값을 가져와 그 값과 entry의 value 값 중 작은 값을 넣어준다.           index에 arr2에서 entry의 key 값보다 1 큰 숫자의 다음 위치를 찾아 넣어준다.           만일 index가 0보다 작은 경우, index를 양수로 변환하여 1을 빼준다.           index가 arr2의 길이보다 작은 경우, temp의 arr2[index] 값의 위치에 entry의 value 값보다 1 큰 값과 temp의 arr2[index]번째 값을 꺼내되 값이 없으면 정수의 최댓 값을 가져와 두 값 중 작은 값을 넣어준다.                       dp에 변환된 값이 저장된 temp를 넣어준다.           dp가 비어으면 변환이 되지 않으므로 -1을, 비어있지 않으면 dp 내 value 중 가장 작은 값을 꺼내서 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/make-array-strictly-increasing/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Increasing Paths in a Grid",
        "excerpt":"문제  Link   코드  class Solution {    private int mod = 1000000007;   private int[][] directions = new int[][] {     { 1, 0 },     { 0, -1 },     { -1, 0 },     { 0, 1 }   };    public int countPaths(int[][] grid) {     int row = grid.length;     int col = grid[0].length;     int count = 0;     int[][] dp = new int[row][col];     for (int i = 0; i &lt; row; i++) {       for (int j = 0; j &lt; col; j++) {         count = (count + this.getCount(grid, dp, row, col, i, j, 0)) % this.mod;       }     }     return count;   }    private int getCount(int[][] grid, int[][] dp, int row, int col, int i, int j, int prev) {     if (i &lt; 0 || i &gt;= row || j &lt; 0 || j &gt;= col || grid[i][j] &lt;= prev) {       return 0;     } else if (dp[i][j] != 0) {       return dp[i][j];     } else {       int count = 1;       for (int[] direction : this.directions) {         count = (count + this.getCount(grid, dp, row, col, i + direction[0], j + direction[1], grid[i][j])) % this.mod;       }       dp[i][j] = count;       return count;     }   }  }   결과  Link   설명     $m \\times n$ 크기의 grid를 이용하여 임의의 위치에서 시작하고 종료하여 각 셀의 값이 점층적으로 증가하는 모든 경로의 수를 구하는 문제이다.            단, 답이 매우 클 수 있으므로 모듈러 $10^9 + 7$을 이용해 계산한다.           문제 풀이에 필요한 전역 변수를 정의한다.            mod는 모듈러를 적용할 변수로, $10^9 +7$로 초기화한다.       directions는 셀의 상하좌우를 계산하기 위한 배열로, 2차원 정수 배열로 초기화하여 상하좌우에 대한 x와 y축에 대한 가감값으로 이루어진 값들을 넣어준다.           문제 풀이에 필요한 변수를 정의한다.            row와 col은 grid의 행과 열의 수를 저장한 변수이다.       count는 시작과 종료가 점층적으로 증가하는 형태의 경로의 수를 계산하기 위한 변수로, 0으로 초기화한다.       dp는 탐색 지점 별 경로의 수를 계산하기 위한 변수로, $row \\times col$ 크기의 2차원 정수 배열로 초기화한다.                0부터 row까지 i를, 0부터 col까지 j를 순차적으로 증가시키며 count에 count와 5번에서 정의한 getCount(int[][] grid, int[][] dp, int row, int col, int i, int j, int prev) 메서드를 수행한 결과를 더한 후 mod를 나눈 나머지 값을 넣어준다.       이전 값이 prev인 위치에서 [i, j] 로 이동했을 때 증가하는 경로의 수를 계산하기 위한 getCount(int[][] grid, int[][] dp, int row, int col, int i, int j, int prev) 메서드를 정의한다.            i가 [0, $row - 1$] j가 [0, $col - 1$] 범위를 벗어나거나 grid[i][j]의 값이 prev보다 같거나 작은 경우, 이어지는 경로가 없으므로 0을 반환한다.       위가 아니면서 dp[i][j]의 값이 0이 아닌 탐색된 경로의 경우, 해당 값을 반환한다.       위의 모든 경우가 아니라면 아래를 수행한다.                    count는 경로를 계산할 변수로, 현재 위치까지 경로가 이어졌으므로 1을 넣어 초기화한다.           directions의 모든 값을 direction에 순차적으로 넣고 재귀 호출을 수행할 때 i, j, prev에 $i + direction[0]$, $j + direction[1]$, grid[i][j]의 값들을 순차적으로 수행한 결과에 count를 더한 후 mod를 나눈 나머지 값을 count에 더해준다.                       dp[i][j] 위치에 count를 넣어 저장한 후, count를 반환한다.           반복이 완료되면 계산된 경로의 수인 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-increasing-paths-in-a-grid/",
        "teaser": null
      },{
        "title": "Leetcode Java Find the Highest Altitude",
        "excerpt":"문제  Link   코드  class Solution {    public int largestAltitude(int[] gain) {     int max = 0;     int sum = 0;     for (int num : gain) {       sum += num;       if (sum &gt; max) {         max = sum;       }     }     return max;   }  }   결과  Link   설명          고도가 0인 위치에서 순차적으로 고도의 낙폭이 들어있는 gain을 이용하여 가장 높은 고도를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            max은 최대 고도를 저장할 변수로, 0으로 초기화한다.       sum은 고도 변화를 누계할 변수로, 0으로 초기화한다.           gain의 모든 값을 num에 순차적으로 넣고 아래를 수행한다.            sum에 num을 넣고, sum이 max보다 큰 경우 max에 sum을 넣어준다.           반복이 완료되면 최고 고도인 max를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-the-highest-altitude/",
        "teaser": null
      },{
        "title": "Leetcode Java K Radius Subarray Averages",
        "excerpt":"문제  Link   코드  class Solution {    public int[] getAverages(int[] nums, int k) {     int length = nums.length;     int size = (2 * k) + 1;     int[] result = new int[length];     Arrays.fill(result, -1);     if (length &lt; size) {       return result;     }     long sum = 0;     for (int i = 0; i &lt; length; i++) {       sum += nums[i];       if (i - size &gt;= 0) {         sum -= nums[i - size];       }       if (i &gt;= size - 1) {         result[i - k] = (int) (sum / size);       }     }     return result;   }  }   결과  Link   설명     nums에서 임의 위치 i의 좌우가 k개로 이루어진 부분 배열 내 값들의 평균을 배열로 만들어 반환하는 문제이다.            좌우가 k개가 되지 않는 위치의 값은 -1을 넣는다.       평균은 소수점을 절사하여 계산한다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       size는 좌우가 k개로 이루어진 부분 배열의 크기를 저장할 변수로, 중심을 기준으로 $(2 \\times k) + 1$로 초기화한다.       result는 각 위치 별 부분 배열의 평균을 저장할 변수로, length 길이로 초기화하고 모든 값을 -1로 넣어준다.                length가 size보다 작은 경우, 구성할 수 있는 경우가 없으므로 result를 주어진 문제의 결과로 반환한다.            sum은 부분 배열의 합계를 저장할 변수로, 0으로 초기화한다.       0부터 length 미만까지 i를 증가시키며 아래를 반복한다.            sum에 nums의 i번째 값을 넣어주고, $i - size$가 0보다 큰 경우, sum에 부분 배열 범위를 벗어나는 값인 nums의 $i - size$번째 값을 빼준다.       i가 $size - 1$보다 크거나 같은 경우, 조건을 만족하므로 result의 $i - k$번째 위치에 $\\frac{sum}{size}$의 값을 정수로 변환하여 넣어준다.           반복이 완료되면 조건에 맞는 평균 값이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/k-radius-subarray-averages/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Cost to Make Array Equal",
        "excerpt":"문제  Link   코드  class Solution {    public long minCost(int[] nums, int[] cost) {     int left = Integer.MAX_VALUE;     int right = Integer.MIN_VALUE;     for (int num : nums) {       left = Math.min(num, left);       right = Math.max(num, right);     }     long result = 0;     while (left &lt; right) {       int mid = left + ((right - left) / 2);       long cost1 = this.getCost(nums, cost, mid);       long cost2 = this.getCost(nums, cost, mid + 1);       result = Math.min(cost1, cost2);       if (cost1 &lt; cost2) {         right = mid;       } else {         left = mid + 1;       }     }     return result;   }    private long getCost(int[] nums, int[] cost, long num) {     long sum = 0L;     for (int i = 0; i &lt; nums.length; i++) {       sum += Math.abs(nums[i] - num) * cost[i];     }     return sum;   }  }   결과  Link   설명          nums[i]의 값을 1씩 증가시킬 때 드는 비용이 cost[i]일 때, nums의 모든 값을 동일한 값으로 맞출 경우 드는 최소 비용을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            left와 right는 nums의 최소 값인 좌측 탐색 위치와 최대 값인 우측 탐색 위치를 넣을 변수로, nums를 반복하여 최솟값과 최댓값을 넣어준다.       result는 nums의 모든 값을 동일한 값으로 맞출 경우 드는 최소 비용을 저장할 변수로, 0으로 초기화한다.           left가 right 미만일 때까지 아래를 반복한다.            mid에 $left + \\frac{right - left}{2}$의 중앙값을 넣어준다.       cost1에 4번에서 정의한 getCost(int[] nums, int[] cost, long index)를 index에 mid를 넣어 수행한 결과를 넣어준다.       cost2에 4번에서 정의한 getCost(int[] nums, int[] cost, long index)를 index에 $mid + 1$을 넣어 수행한 결과를 넣어준다.       cost1이 cost2보다 작은 경우, right에 mid를 넣어 범위를 좁혀준다.       cost1이 cost2보다 작지 않은 경우, left에 $mid + 1$을 넣어 범위를 좁혀준다.           index를 기준으로 비용의 합을 계산할 getCost(int[] nums, int[] cost, long index) 메서드를 정의한다.            sum은 비용의 합계를 넣을 변수로, nums의 값을 num을 뺀 변경 횟수에 cost의 비용을 곱한 값을 넣어 반환한다.           반복이 완료되면 최소 비용이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-cost-to-make-array-equal/",
        "teaser": null
      },{
        "title": "Leetcode Java Knight Dialer",
        "excerpt":"문제  Link   코드  class Solution {    public int knightDialer(int n) {     if (n == 1) {       return 10;     }     int mod = 1000000007;     int[][] graph = {       { 4, 6 },       { 6, 8 },       { 7, 9 },       { 4, 8 },       { 3, 9, 0 },       {},       { 1, 7, 0 },       { 2, 6 },       { 1, 3 },       { 2, 4 }     };     int[] dp = new int[10];     Arrays.fill(dp, 1);     while (n-- &gt; 1) {       int[] temp = new int[10];       for (int i = 0; i &lt; graph.length; i++) {         for (int j = 0; j &lt; graph[i].length; j++) {           int position = graph[i][j];           temp[position] = (temp[position] + dp[i] % mod) % mod;         }       }       dp = temp;     }     int result = 0;     for (int num : dp) {       result = (result + num % mod) % mod;     }     return result;   }  }   결과  Link   설명     체스의 나이트의 이동 경로를 활용하여 숫자 다이얼의 임의 지점에서 시작하여 n길이의 고유한 전화 번호의 수를 구하는 문제이다.            단, 답이 매우 클 수 있으므로 모듈러 $10^9 + 7$을 이용해 계산한다.                n이 1인 경우, 다이얼의 수인 10을 주어진 문제의 결과로 반환한다.       문제를 풀기 위한 변수를 정의한다.            mod는 모듈러를 적용할 변수로, $10^9 +7$로 초기화한다.       graph는 출발 숫자의 위치 별 도착 숫자를 저장할 배열로, 0부터 9까지 위치에서 도착 가능한 위치를 모두 넣어 초기화한다.       dp는 각 위치 별 전화 번호의 수를 계산할 배열로, 다이얼 수인 10 크기로 정의하고 모든 값을 1로 초기화한다.           n이 1 초과일 때 까지 아래를 반복하고 n을 감소시킨다.            temp는 현재 위치에서 도착 가능한 위치를 저장할 배열로, 다이얼 수인 10 크기로 정의한다.       0부터 graph의 길이 미만까지 i를 증가시키고, 0부터 graph의 i번째 길이 미만까지 j를 증가시키며 아래를 반복한다.                    position에 graph[i][j] 값을 저장한다.           temp[position] 위치에 dp[i] 값을 mod로 나눈 값에 temp[position]의 값을 더한 값에 mod로 다시 나눈 값을 넣어준다.                       dp에 temp를 넣고 반복을 계속한다.           result는 고유 전화번호의 수를 저장할 변수로, dp의 모든 값을 반복하여 result에 num을 mod로 나눈 나머지와 result를 더한 값에 mod를 나눈 값을 넣어주고 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/knight-dialer/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Arithmetic Subsequence",
        "excerpt":"문제  Link   코드  class Solution {    public int longestArithSeqLength(int[] nums) {     int result = 0;     int max = Integer.MIN_VALUE;     int min = Integer.MAX_VALUE;     for (int num : nums) {       max = Math.max(max, num);       min = Math.min(min, num);     }     for (int i = 0; i &lt;= max - min; i++) {       if (i * result &gt; max - min) {         break;       }       int[] first = new int[501];       int[] second = new int[501];       for (int num : nums) {         first[num] = (num + i &lt;= 500) ? (first[num + i] + 1) : 1;         second[num] = (num - i &gt;= 0) ? (second[num - i] + 1) : 1;         result = Math.max(result, Math.max(first[num], second[num]));       }     }     return result;   }  }   결과  Link   설명          nums 배열 내 순서 변경 없이, 임의 숫자를 제외하면서 동일한 값의 변화가 이루어지는 최대 길이를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 최대 길이를 저장할 변수로, 0으로 초기화한다.       max와 min은 nums에서 최댓값과 최솟값을 저장할 변수로, nums를 반복하여 최댓값과 최솟값을 넣어준다.           0부터 $max - min$까지 i를 감소시키며 아래를 반복한다.            $i \\times result$의 값이 $max - min$의 값보다 큰 경우, 값의 범위를 벗어나므로 다음 반복을 수행한다.       first와 second는 값의 차이를 순차적으로 저장할 변수로, nums 내 값의 최댓값인 500보다 1 큰 크기의 정수 배열로 초기화한다.       nums의 모든 값을 num에 순차적으로 넣고 아래를 반복한다.                    first의 num번째 위치에 $num + i$가 500보다 같거나 작으면 first의 $num + i$번째 값에 1을 더해서, 아니면 1을 넣어준다.           second의 num번째 위치에 $num - i$가 0보다 같거나 크면 second의 $num - i$번째 값에 1을 더해서, 아니면 1을 넣어준다.           result에 result와 first와 seconde의 num번쨰 위치의 값들 중 큰 값을 넣어준다.                           반복이 완료되면 최대 길이를 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-arithmetic-subsequence/",
        "teaser": null
      },{
        "title": "Leetcode Java Tallest Billboard",
        "excerpt":"문제  Link   코드  class Solution {    public int tallestBillboard(int[] rods) {     int length = rods.length;     int sum = 0;     for (int rod : rods) {       sum += rod;     }     int[][] dp = new int[length + 1][sum + 1];     for (int i = 0; i &lt; length; i++) {       for (int j = 0; j &lt;= sum; j++) {         if (dp[i][j] &lt; j) {           continue;         }         dp[i + 1][j] = Math.max(dp[i + 1][j], dp[i][j]);         int k = j + rods[i];         dp[i + 1][k] = Math.max(dp[i + 1][k], dp[i][j] + rods[i]);         k = Math.abs(j - rods[i]);         dp[i + 1][k] = Math.max(dp[i + 1][k], dp[i][j] + rods[i]);       }     }     return dp[length][0] / 2;   }  }   결과  Link   설명     rods를 이용하여 광고판의 양 쪽을 이어줄 두 지지대를 만들 수 있는 최대 높이를 구하는 문제이다.            단, 광고판을 설치할 수 없으면 0을 반환한다.           문제 풀이에 필요한 변수를 정의한다.            length는 rods의 길이를 저장한 변수이다.       sum은 rods를 모두 이었을 때 최대 길이를 저장할 변수로, rods의 모든 값을 더해서 넣어준다.       dp는 최대 높이를 구하기 위한 경우의 수를 저장할 변수로, $(length + 1) \\times (sum + 1)$ 크기의 정수 배열로 초기화한다.           0부터 length 미만까지 i를 증가시키고, 0부터 sum 이하까지 j를 증가시키며 아래를 수행한다.            dp[i][j]의 값이 j 미만인 경우, 현재까지 길이보다 짧으므로 다음 반복을 수행한다.       dp[$i + 1$][j]의 위치에 현재 값과 이전 값인 dp[i][j] 중 큰 값을 넣어준다.       k에 $j + rods[i]$인 i번째 로드를 이었을 때 길이를 저장하여, dp[$i + 1$][k] 위치에 현재 위치의 값과 이전 위치의 값에 i번째 로드를 더한 값 중 큰 값을 넣어준다.       k에 $j - rods[i]$인 i번째 로드를 뺀 길이를 넣어 양수로 전환한 값을 저장하고, 위와 동일하게 dp[$i + 1$][k] 위치에 현재 위치의 값과 이전 위치의 값에 i번째 로드를 더한 값 중 큰 값을 넣어준다.           반복이 완료되면 최대 길이가 저장된 dp[length][0]의 값에서 하나의 지지대 길이인 절반을 나누어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/tallest-billboard/",
        "teaser": null
      },{
        "title": "Leetcode Java Total Cost to Hire K Workers",
        "excerpt":"문제  Link   코드  class Solution {    public long totalCost(int[] costs, int k, int candidates) {     long result = 0;     if (candidates * 2 &gt; costs.length - k || costs.length == k) {       Arrays.sort(costs);       for (int i = 0; i &lt; k; i++) {         result += costs[i];       }       return result;     }     int left = 0;     int right = costs.length - 1;     Queue&lt;Integer&gt; queue1 = new PriorityQueue&lt;&gt;();     Queue&lt;Integer&gt; queue2 = new PriorityQueue&lt;&gt;();     while (queue1.size() &lt; candidates &amp;&amp; left &lt;= right) {       queue1.offer(costs[left++]);       queue2.offer(costs[right--]);     }     while (k-- &gt; 0) {       if (queue1.peek() &lt;= queue2.peek()) {         result += queue1.poll();         queue1.offer(costs[left++]);       } else {         result += queue2.poll();         queue2.offer(costs[right--]);       }     }     return result;   }  }   결과  Link   설명          costs의 값들 중 좌우의 candidates개 값들 중 가장 작은 값을 꺼내는 행위를 k번 반복했을 때, 꺼낸 값들의 합을 계산하는 문제이다.            result는 꺼낸 값들의 합을 저장할 변수로, 0으로 초기화한다.       아래의 경우를 하나라도 만족하면 costs를 오름차순 정렬하여 앞의 k개의 값들을 result에 넣고 주어진 문제의 결과로 반환한다.            candidates에 2를 곱한 결과가 cost의 길이에 k를 뺀 값보다 큰 경우, k번 수행하면서 모든 숫자를 다 검색하므로 가장 작은 값을 k개 꺼낸 것과 같다.       costs의 길이가 k와 동일한 경우, 위와 유사하게 모든 값을 탐색하는 것과 같다,           문제 풀이에 필요한 변수를 정의한다.            left와 right는 좌측과 우측의 candidates개의 값을 유지하기 위한 위치 변수로, 0과 $costs.length - 1$로 초기화한다.       queue1과 queue2는 좌측과 우측의 candidates개의 값을 저장하기 위한 변수로, 작은 값 순으로 정렬하여 보관하기 위해 PriorityQueue로 초기화한다.           queue1의 길이가 candidates보다 작고, left가 right보다 작거나 같을 때 까지 아래를 수행한다.            queue1에 costs의 처음부터 candidates개의 값들을 차례대로 넣어준다.       queue2에 costs의 마지막부터 candidates개의 값들을 차례대로 넣어준다.           k가 0보다 클 때 까지 아래를 수행하고 k를 감소시킨다.            queue1의 가장 작은 값이 queue2의 가장 작은 값보다 작거나 같은 경우, 아래를 수행한다.                    result에 queue1의 가장 작은 값을 꺼내 넣어준다.           queue1에 costs의 left번째 값을 넣어 candidates 크기로 유지하고, left를 증가시킨다.                       위의 경우가 아니라면 아래를 수행한다.                    result에 queue2의 가장 작은 값을 꺼내 넣어준다.           queue2에 costs의 right번째 값을 넣어 candidates 크기로 유지하고, right를 감소시킨다.                           반복이 완료되어 계산된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/total-cost-to-hire-k-workers/",
        "teaser": null
      },{
        "title": "Leetcode Java Reorder Data in Log Files",
        "excerpt":"문제  Link   코드  class Solution {    public String[] reorderLogFiles(String[] logs) {     Arrays.sort(logs, (s1, s2) -&gt; {       int index1 = s1.indexOf(\" \") + 1;       int index2 = s2.indexOf(\" \") + 1;       boolean isLetter1 = Character.isLetter(s1.charAt(index1));       boolean isLetter2 = Character.isLetter(s2.charAt(index2));       if (isLetter1 &amp;&amp; isLetter2) {         int compare = s1.substring(index1).compareTo(s2.substring(index2));         if (compare != 0) {           return compare;         } else {           return s1.compareTo(s2);         }       } else if (isLetter1 &amp;&amp; !isLetter2) {         return -1;       } else if (!isLetter1 &amp;&amp; isLetter2) {         return 1;       } else {         return 0;       }     });     return logs;   }  }   결과  Link   설명     아래의 두 형식의 로그로 이루어진 logs를 아래에서 명시한 순서대로 정렬하여 반환하는 문제이다.            각 로그의 첫 단어는 식별자이다.       문자 로그는 영어 소문자로만 구성된 로그이다.       숫자 로그는 숫자로만 구성된 로그이다.       문자 로그는 모든 숫자 로그 앞에 위치한다.       문자 로그는 사전 순으로 정렬하고 내용이 동일한 경우, 식별자의 사전순으로 정렬한다.       숫자 로그는 기존 순서를 유지하여 차례대로 유지한다.           logs의 임의 두 값을 s1과 s2에 넣어 아래를 수행한 결과에 따라 정렬한다.            index1과 index2는 s1과 s2의 식별자 이후 내용의 위치를 넣을 변수로, s1과 s2의 첫 띄어쓰기(“ “) 다음 위치로 넣어준다.       isLetter1과 isLetter2는 s1과 s2가 문자 로그인지 검증하기 위한 변수로, s1과 s2의 내용 시작 단어가 문자인지를 검증한 결과를 넣어준다.       s1과 s2가 문자 로그인 경우, 내용이 같지 않은 경우 s1의 내용과 s2의 내용을 비교한 값을 아니면 식별자까지 포함한 s1과 s2을 비교한 값을 반환한다.       s1만 문자 로그이면 -1을, s2만 문자 로그이면 1을, 둘 다 숫자 로그이면 0을 반환한다.           위를 통해 정렬된 logs를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reorder-data-in-log-files/",
        "teaser": null
      },{
        "title": "Leetcode Java Range Sum of BST",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public int rangeSumBST(TreeNode root, int low, int high) {     if (root == null) {       return 0;     } else if (root.val &gt; high) {       return this.rangeSumBST(root.left, low, high);     } else if (root.val &lt; low) {       return this.rangeSumBST(root.right, low, high);     } else {       return root.val + this.rangeSumBST(root.left, low, high) + this.rangeSumBST(root.right, low, high);     }   }  }   결과  Link   설명          root에서 [low, high] 범위 내 값들의 합을 구하는 문제이다.            아래의각 경우에 따라서 값을 반환한다.             root가 null인 경우, 값이 없으므로 0을 반환한다.       root의 val 값이 high보다 큰 경우, 더 작은 값이 존재하는 root의 left TreeNode를 이용하여 재귀 호출을 수행한 결과를 반환한다.       root의 val 값이 low보다 작은 경우, 더 큰 값이 존재하는 root의 right TreeNode를 이용하여 재귀 호출을 수행한 결과를 반환한다.       위의 모든 경우가 아니라면 범위 내 속하는 값이므로, root의 val 값과 left TreeNode를 이용하여 재귀 호출을 수행한 값과 right TreeNode를 이용하여 재귀 호출을 수행한 결과를 합쳐서 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/range-sum-of-bst/",
        "teaser": null
      },{
        "title": "Leetcode Java Distinct Subsequences II",
        "excerpt":"문제  Link   코드  class Solution {    public int distinctSubseqII(String s) {     int sum = 0;     int[] count = new int[26];     int mod = 1000000007;     for (char c : s.toCharArray()) {       int index = c - 'a';       int curr = (sum + 1 - count[index] + mod) % mod;       sum = (sum + curr) % mod;       count[index] = (count[index] + curr) % mod;     }     return sum;   }  }   결과  Link   설명     s의 비어있지 않은 고유 부분 수열의 수를 반환하는 문제이다.            고유 부분 수열은 일부 문자를 삭제하여 새로 만들 수 있는 문자열이다.       단, 답이 매우 클 수 있으므로 모듈러 $10^9 + 7$을 이용해 계산한다.           문제 풀이에 필요한 변수를 정의한다.            sum은 고유 부분 수열의 수를 저장할 변수로, 0으로 초기화한다.       count는 해당 문자열까지 부분 수열을 계산하기 위한 배열로, 알파벳의 수인 26 크기의 정수 배열로 초기화한다.       mod는 모듈러를 적용할 변수로, $10^9 +7$로 초기화한다.           s의 모든 문자를 c에 순차적으로 넣어 아래를 반복한다.            index에 c의 알파벳 순번을 넣어준다.       curr은 현재 위치에서 고유 부분 수열의 수를 저장할 변수로, $sum + 1 - count[index]$에 mod를 더한 후 mod를 나눈 나머지를 넣어준다.       sum에 sum과 curr을 더한 값을 mod로 나누어 넣어준다.       count의 index번째 위치에 해당 값과 curr을 더한 값을 mod로 나누어 저장하고 다음 반복을 수행한다.           반복이 완료되면 sum을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/distinct-subsequences-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Valid Mountain Array",
        "excerpt":"문제  Link   코드  class Solution {    public boolean validMountainArray(int[] arr) {     if (arr.length &lt; 3 || arr[0] &gt;= arr[1]) {       return false;     }     boolean decrease = false;     for (int i = 2; i &lt; arr.length; i++) {       if (arr[i - 1] &gt; arr[i]) {         decrease = true;       } else if (arr[i - 1] == arr[i] || decrease) {         return false;       }     }     return decrease;   }  }   결과  Link   설명     산의 높이로 이루어진 arr의 값들이 아래의 조건을 만족하는 산 모양으로 이루어져 있는지 검증하는 문제이다.            arr의 길이가 3 이상이어야 산 모양을 유지할 수 있다.       산 정상인 i번째 위치 이전과 이후는 점층적인 값의 증가와 감소로만 이루어져야 한다.                arr의 길이가 3 미만이거나 arr의 첫 값이 다음 값보다 크거나 같으면, 산 모양을 이룰 수 없으므로 false를 주어진 문제의 결과로 반환한다.            decrease는 점층적으로 감소하는 추세로 변환되었는지 저장하기 위한 변수로, 처음은 점층적으로 증가해야 하므로 false를 넣어준다.       2부터 arr의 길이 미만까지 i를 증가시키며 아래를 검증한다.            arr의 $i - 1$번째 값이 i번째 값보다 크면, 감소하는 추세로 변화하였으므로 decrease에 true를 넣어준다.       arr의 $i - 1$번째 값과 i번째 값이 동일하거나 decrease가 true이면, 조건을 만족하는 산의 모양을 유지하지 않으므로 false를 주어진 문제의 결과로 반환한다.           반복이 완료되면 감소하는 추세가 계속 유지했는지 여부인 decrease의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/valid-mountain-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Subarray of 1's After Deleting One Element",
        "excerpt":"문제  Link   코드  class Solution {    public int longestSubarray(int[] nums) {     int i = 0;     int j = 0;     for (int k = 1; j &lt; nums.length; j++) {       if (nums[j] == 0) {         k--;       }       if (k &lt; 0 &amp;&amp; nums[i++] == 0) {         k++;       }     }     return j - i - 1;   }  }   결과  Link   설명     0과 1로 이루어진 nums를 이용하여 하나의 요소를 삭제했을 때 1로만 이루어진 가장 긴 길이를 구하는 문제이다.            단, 0으로만 구성되는 경우, 0을 반환한다.                i와 j는 하나의 요소를 삭제했을 경우 가장 긴 길이를 구하기 위해 시작과 종료 위치를 구하기 위한 위치 변수로, 둘 다 0으로 초기화한다.       k는 제거할 요소의 횟수를 저장할 변수로 1로 초기화하고, j는 nums이 길이 미만까지 j를 증가시키며 아래를 반복한다.            nums의 j번째 값이 0인 경우 k를 감소시켜 횟수를 차감시킨다.       k가 0 미만이고 nums의 i번째 값이 0이면 i를 증가시키고다시 최대 길이를 계산해야 하므로, k를 증가시킨다.                    단 k가 0 이상인 경우, i를 감소시키지 않는다.                           반복이 완료되면 계산된 위치의 차이인 $j - i - 1$인 길이를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-subarray-of-1s-after-deleting-one-element/",
        "teaser": null
      },{
        "title": "Leetcode Java DI String Match",
        "excerpt":"문제  Link   코드  class Solution {    public int[] diStringMatch(String s) {     int length = s.length();     int left = 0;     int right = length;     int[] result = new int[length + 1];     for (int i = 0; i &lt; length; i++) {       result[i] = s.charAt(i) == 'I' ? left++ : right--;     }     result[s.length()] = left;     return result;   }  }   결과  Link   설명     s를 이용하여 아래의 규칙을 만족하는 0부터 s의 길이까지 범위의 값으로 구성된 배열을 구성하는 문제이다.            s의 i번째 문자가 ‘I’인 경우, perm[i] &lt; perm[i + 1]을 만족한다.       s의 i번째 문자가 ‘D’인 경우, perm[i] &gt; perm[i + 1]을 만족한다.           문제 풀이에 필요한 변수를 정의한다.            length는 s의 길이를 저장한 변수이다.       left와 right는 문자열의 탐색에 필요한 변수로, 0과 length로 초기화한다.       result는 규칙을 만족하는 배열을 구성하기 위한 변수로, $length + 1$ 크기의 정수 배열로 초기화한다.           0부터 length 미만까지 i를 증가시키며 아래를 수행한다.            s의 i번째 문자가 ‘I’인 경우, result의 i번째 위치에 left를 넣고 left를 증가신다.       s의 i번째 문자가 ‘D’인 경우, result의 i번째 위치에 right를 넣고 right를 감소시킨다.           result의 마지막 위치에 left를 넣어주고, 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/di-string-match/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximize the Confusion of an Exam",
        "excerpt":"문제  Link   코드  class Solution {    public int maxConsecutiveAnswers(String answerKey, int k) {     int max = 0;     int i = 0;     char[] charArray = answerKey.toCharArray();     int length = charArray.length;     int[] count = new int[26];     for (int j = 0; j &lt; length; j++) {       max = Math.max(max, ++count[charArray[j] - 'A']);       if (j - i + 1 &gt; max + k) {         --count[charArray[i++] - 'A'];       }     }     return length - i;   }  }   결과  Link   설명          ‘T’와 ‘F’로 이루어진 answerKey의 문자열 중 k개의 문자의 값을 변환하여 만들 수 있는 동일한 문자열로 구성된 최대 길이를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            max는 최댓값을 저장시키기 위한 변수로, 0으로 초기화한다.       i는 연속된 문자열을 나열했을 경우 길이를 측정하기 위한 위치 변수로, 0으로 초기화한다.       charArray는 answerKey를 문자 배열로 변환한 변수이다.       length는 charArray의 길이를 저장한 변수이다.       count는 각 문자 별 갯수를 저장할 변수이다.           0부터 length 미만까지 j를 증가시키며 아래를 수행한다.            max에 max와 count의 j번째 문자의 길이를 증가시킨 값 중 큰 값을 넣어준다.       $j - i + 1$인 연속된 문자의 길이가 $max + k$인 최대 문자 길이에 k번 변경했을 경우보다 큰 경우, count의 i번째 문자의 위치의 값을 감소시킨다.           반복이 완료되면 length에 i를 뺀 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximize-the-confusion-of-an-exam/",
        "teaser": null
      },{
        "title": "Leetcode Java Delete Columns to Make Sorted",
        "excerpt":"문제  Link   코드  class Solution {    public int minDeletionSize(String[] strs) {     int result = 0;     for (int i = 0; i &lt; strs[0].length(); i++) {       char prev = strs[0].charAt(i);       for (int j = 1; j &lt; strs.length; j++) {         char c = strs[j].charAt(i);         if (c &lt; prev) {           result++;           break;         }         prev = c;       }     }     return result;   }  }   결과  Link   설명          동일한 길이의 문자열로 이루어진 strs를 이용하여 각 문자열의 동일한 위치의 문자들을 순차적으로 묶었을 때 사전 순으로 이루어지지 않는 위치의 갯수를 구하는 문제이다.            result는 사전 순으로 이루어지지 않는 위치의 갯수를 계산할 변수로, 0으로 초기화한다.       0부터 strs의 문자 길이 미만까지 i를 증가시키며 아래를 반복한다.            prev는 이전 문자를 순차적으로 저장할 변수로, 첫 문자열의 i번째 문자를 넣어 초기화한다.       1부터 strs의 길이 미만까지 j를 증가시키며 아래를 반복한다.                    c는 각 위치 별 문자를 저장할 변수로, strs의 j번째 문자열의 i번째 문자를 넣어준다.           c가 prev보다 작은 경우, result를 증가시키고 반복을 중지한다.           위의 경우가 아니라면 prev에 c를 넣고 반복을 계속한다.                           반복이 완료되면 조건에 대한 갯수인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/delete-columns-to-make-sorted/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Increment to Make Array Unique",
        "excerpt":"문제  Link   코드  class Solution {    public int minIncrementForUnique(int[] nums) {     Arrays.sort(nums);     int result = 0;     int need = 0;     for (int num : nums) {       result += Math.max(need - num, 0);       need = Math.max(num, need) + 1;     }     return result;   }  }   결과  Link   설명          nums의 값이 모두 고유한 값이 되기 위하여 변경하는 값의 합을 구하는 문제이다.            nums를 오름차순으로 정렬한다.       문제 풀이에 필요한 변수를 정의한다.            result는 변경하는 값의 합을 저장할 변수로, 0으로 초기화한다.       need는 다음에 필요한 값을 저장할 변수로, 0으로 초기화한다.           nums의 모든 값을 num에 순차적으로 넣고 아래를 반복한다.            result에 $need - num$의 값과 0 중 큰 값인 차이 값을 넣어준다.       need는 num과 need 중 큰 값보다 1 큰 숫자를 넣어준다.           반복이 완료되면 값의 차이가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-increment-to-make-array-unique/",
        "teaser": null
      },{
        "title": "Leetcode Java Validate Stack Sequences",
        "excerpt":"문제  Link   코드  class Solution {    public boolean validateStackSequences(int[] pushed, int[] popped) {     Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();     int i = 0;     for (int value : pushed) {       stack.push(value);       while (!stack.isEmpty() &amp;&amp; stack.peek() == popped[i]) {         stack.pop();         i++;       }     }     return stack.isEmpty();   }  }   결과  Link   설명          초기화된 스택에서 순차적으로 pushed의 값을 넣고 popped의 값을 꺼낼 수 있는지 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            stack은 검증에 필요한 변수로, Stack으로 초기화한다.       i는 popped의 위치 변수로, 0으로 초기화한다.           pushed의 모든 값을 value에 순차적으로 넣고 아래를 수행한다.            stack에 value를 넣어준다.       stack이 비어있지 않으면서 stack에서 꺼낸 값이 popped의 i번째 값과 동일할 때까지 반복하여, stack에서 값을 꺼내 제거하고 i를 증가시켜 다음 위치로 이동시킨다.           반복이 완료되면 stack이 비어있는지 검증된 결과를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/validate-stack-sequences/",
        "teaser": null
      },{
        "title": "Leetcode Java Bag of Tokens",
        "excerpt":"문제  Link   코드  class Solution {    public int bagOfTokensScore(int[] tokens, int power) {     Arrays.sort(tokens);     int result = 0;     int points = 0;     int left = 0;     int right = tokens.length - 1;     while (left &lt;= right) {       if (tokens[left] &lt;= power) {         power -= tokens[left++];         result = Math.max(result, ++points);       } else if (points &gt; 0) {         points--;         power += tokens[right--];       } else {         break;       }     }     return result;   }  }   결과  Link   설명     아래의 두 방법을 이용하여 얻을 수 있는 최대 점수를 반환하는 문제이다.            현재 power가 i번째 토큰 이상이면, 해당 토큰의 값을 power에서 빼고 1점을 얻게된다.       현재 점수가 1점 이상이면, 토큰의 값을 power에 저장하고 1점을 잃게된다.       토큰은 임의의 순서대로 수행할 수 있으며, 모든 토큰을 수행할 필요는 없다.                tokens의 값을 오름차순으로 정렬한다.       문제 풀이에 필요한 변수를 정의한다.            result는 결과를 저장할 변수로, 0으로 초기화한다.       points는 포인트를 계산할 변수로, 0으로 초기화한다.       left와 right는 좌측과 우측의 위치를 저장할 변수로, 0과 tokens의 길이보다 1 작은 값으로 초기화한다.           left가 right 미만일 때 까지 아래를 반복한다.            tokens의 left번째 값이 power보다 작거나 같은 경우, 아래를 수행한다.                    power에 tokens의 left번째 값을 빼고 left를 감소시킨다.           points를 증가시키고 result에 result와 points 중 큰 값을 넣어준다.                       위의 경우가 아니면서 points의 값이 0보다 큰 경우, 아래를 수행한다.                    points의 값을 감소시키고, power에 tokens의 right번째 값을 더해주고 right를 감소시킨다.                       위의 모든 경우가 아니라면 반복을 중지하여 계산을 그만둔다.           반복이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/bag-of-tokens/",
        "teaser": null
      },{
        "title": "Leetcode Java Reveal Cards In Increasing Order",
        "excerpt":"문제  Link   코드  class Solution {    public int[] deckRevealedIncreasing(int[] deck) {     int length = deck.length;     Arrays.sort(deck);     Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();     for (int i = 0; i &lt; length; i++) {       queue.add(i);     }     int[] result = new int[length];     for (int i = 0; i &lt; length; i++) {       result[queue.poll()] = deck[i];       queue.add(queue.poll());     }     return result;   }  }   결과  Link   설명     정수 배열인 deck의 값들을 아래의 규칙대로 제거할 수 있는 순서로 값을 정렬하는 문제이다.            deck의 첫 값을 제거하면 다음 값을 deck의 맨 뒤로 이동시킨다.       가장 작은 값을 deck의 맨 앞에 위치시켜 값이 커지는 순으로 마지막 값까지 오름차순으로 제거한다.           문제 풀이에 필요한 변수를 정의한다.            length는 deck의 길이를 저장한 변수이다.       queue는 순차적으로 값을 제거하기 위한 순서를 정의하기 위해 필요한 변수로, LinkedList로 초기화하고 deck를 정렬 후 0부터 length까지 순차적으로 queue에 넣어준다.       result는 결과를 저장할 변수로, length 길이의 정수 배열로 초기화한다.           0부터 length 미만까지 i를 증가시키며 아래를 수행한다.            result의 queue의 맨 앞 값을 꺼내 해당 위치에 deck의 i번째 값을 넣어준다.       queue에 queue의 값을 꺼내서 뒤로 넣어준다.           반복이 완료되면 조건에 만족하도록 정렬된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reveal-cards-in-increasing-order/",
        "teaser": null
      },{
        "title": "Leetcode Java Flip Equivalent Binary Trees",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public boolean flipEquiv(TreeNode root1, TreeNode root2) {     if (root1 == null &amp;&amp; root2 == null) {       return true;     } else if (root1 == null || root2 == null || root1.val != root2.val) {       return false;     } else if ((root1.left != null ? root1.left.val : -1) != (root2.left != null ? root2.left.val : -1)) {       TreeNode temp = root1.left;       root1.left = root1.right;       root1.right = temp;     }     return this.flipEquiv(root1.left, root2.left) &amp;&amp; this.flipEquiv(root1.right, root2.right);   }  }   결과  Link   설명          root1의 각 노드의 위치에서 두 자식 노드 위치를 바꿔서 root2를 만들 수 있는지 검증하는 문제이다.            root1과 root2가 null인 경우, 동일하게 없는 노드의 위치이므로 true를 반환한다.            2번의 경우가 아니면서 root1 혹은 root2가 null이거나 root1과 root2의 val값이 다른 경우, 노드가 다르므로 false를 반환한다.            2, 3번의 경우가 아니면서 root1의 left과 right가 존재하는 경우 해당 값이 동일한 경우, root1의 left 노드와 right 노드의 위치를 변경한다.            모든 경우가 수행되면 root1과 root2의 left 노드로 재귀 호출한 결과와 right 노드로 재귀 호출한 결과의 AND 조건의 값을 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/flip-equivalent-binary-trees/",
        "teaser": null
      },{
        "title": "Leetcode Java Verifying an Alien Dictionary",
        "excerpt":"문제  Link   코드  class Solution {    private int[] point = new int[26];    public boolean isAlienSorted(String[] words, String order) {     for (int i = 0; i &lt; order.length(); i++) {       this.point[order.charAt(i) - 'a'] = i;     }     for (int i = 1; i &lt; words.length; i++) {       if (this.compare(words[i - 1], words[i])) {         return false;       }     }     return true;   }    private boolean compare(String s1, String s2) {     int s1Lenth = s1.length();     int s2Lenth = s2.length();     for (int i = 0; i &lt; s1Lenth &amp;&amp; i &lt; s2Lenth; i++) {       if (s1.charAt(i) != s2.charAt(i)) {         return this.point[s1.charAt(i) - 'a'] &gt; this.point[s2.charAt(i) - 'a'];       }     }     return s1Lenth &gt; s2Lenth;   }  }   결과  Link   설명          words의 붙어있는 두 문자열의 문자들이 order에 해당하는 사전 정렬 순으로 되어 있는지 검증하는 문제이다.            전역 변수인 point는 order의 각 문자열 순서를 저장하기 위한 변수로, order의 모든 문자들을 반복하여 각 문자의 순서를 넣어준다.       1부터 words의 길이 미만까지 i를 증가시키면서 아래를 반복한다.            4번에서 정의한 compare(String s1, String s2) 메서드에 words의 $i - 1$번째 문자와 i번째 문자의 결과가 true이면, 두 문자열의 오름차순 정렬이 아니므로 false를 주어진 문제의 결과로 반환한다.           두 문자열의 비교를 위한 compare(String s1, String s2) 메서드를 정의한다.            s1Length와 s2Length는 s1과 s2의 문자열 길이를 저장한 변수이다.       0부터 s1Length와 s2Length 미만일 때 까지 i를 증가시키며 아래를 반복한다.                    s1과 s2의 i번째 문자의 값이 다른 경우 s1의 i번째 문자가 s2의 i번째 문자보다 order 내 순서가 뒤에 위치하는지 결과를 반환한다.                       반복이 완료되면 s1의 길이가 s2의 길이보다 긴지 검증한 결과를 반환한다.           반복이 완료되면 주어진 조건을 만족하므로 true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/verifying-an-alien-dictionary/",
        "teaser": null
      },{
        "title": "Leetcode Java Prison Cells After N Days",
        "excerpt":"문제  Link   코드  class Solution {    public int[] prisonAfterNDays(int[] cells, int n) {     for (n = ((n - 1) % 14) + 1; n &gt; 0; n--) {       int[] temp = new int[8];       for (int i = 1; i &lt; 7; i++) {         temp[i] = cells[i - 1] == cells[i + 1] ? 1 : 0;       }       cells = temp;     }     return cells;   }  }   결과  Link   설명     8칸의 cells를 아래의 규칙대로 n번 수행하였을 때 결과를 반환하는 문제이다.            cells 내 각 셀의 좌측과 우측 위치의 값이 같은 경우, 다음 수행의 해당 위치 값은 1로 채워진다.       위의 경우가 아니라면 0으로 값이 채워진다.       첫 셀과 마지막 셀은 첫 수행 이후로는 0으로 채워진다.           $n - 1$을 14로 나눈 나머지 값에 1을 더한 값부터 0 이상일 때 까지 n을 감소시키며 아래를 수행한다.            temp는 규칙을 수행한 다음 값을 넣어줄 변수로, cells와 동일한 8 크기의 정수 배열로 초기화한다.       1부터 7 미만까지 i를 증가시키며 cells의 각 위치 별 전후 값이 동일하면 1을, 아니면 0을 넣어준다.       cells에 temp를 넣어준다.           반복이 완료되면 규칙대로 수행한 결과인 cells를 주어진 문제의 결과로 반환한다.   해설     cells가 [0, 1, 0, 1, 1, 0, 0, 1]일때, 기본 규칙대로 계속 반복하면 아래와 같다.     1: [0, 1, 1, 0, 0, 0, 0, 0] 2: [0, 0, 0, 0, 1, 1, 1, 0] ... 중략 ... 6: [0, 0, 1, 0, 1, 1, 0, 0] 7: [0, 0, 1, 1, 0, 0, 0, 0] 8: [0, 0, 0, 0, 0, 1, 1, 0] ... 중략 ... 14: [0, 0, 0, 0, 1, 1, 0, 0] 15: [0, 1, 1, 0, 0, 0, 0, 0]           이 결과를 통해 1, 14번 수행한 결과가 동일한 결과가 나오는 것을 알 수 있다.   이 패턴을 파악하였으므로 이용하여 n번 반복하는 것이 아니라 $n - 1$을 14로 나눈 나머지 값에 1을 더한 값만큼 반복하여 수행한 배열이 주어진 문제의 결과임을 유추할 수 있다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/prison-cells-after-n-days/",
        "teaser": null
      },{
        "title": "Leetcode Java Check Completeness of a Binary Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public boolean isCompleteTree(TreeNode root) {     boolean lastNode = false;     Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();     queue.add(root);     while (!queue.isEmpty()) {       TreeNode curr = queue.poll();       if (curr == null) {         lastNode = true;       } else if (lastNode) {         return false;       } else {         queue.add(curr.left);         queue.add(curr.right);       }     }     return true;   }  }   결과  Link   설명          root가 완벽한 이진 트리인지 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            lastNode는 이진 트리의 마지막 노드인지 검증하기 위한 변수로, false로 초기화한다.       queue는 TreeNode를 순차적으로 넣고 검증하기 위한 변수로, LinkedList로 초기화하고 root를 넣어준다.           queue가 비어있지 않을 때 까지 아래를 반복한다.            curr에 queue의 첫 TreeNode를 꺼내 넣어준다.       curr이 null인 경우 TreeNode의 마지막 노드이므로, lastNode를 true로 바꾸어준다.       위의 경우가 아니라 lastNode가 true인 경우, 노드간 빈 노드가 존재하여 완벽한 이진 트리가 아니므로 false를 주어진 문제의 결과로 반환한다.       위의 모든 경우가 아니라면 curr의 left와 right TreeNode를 순차적으로 queue에 넣어준다.           반복이 완료되면 root는 완벽한 이진 트리이므로, true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/check-completeness-of-a-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Speed to Arrive on Time",
        "excerpt":"문제  Link   코드  class Solution {    public int minSpeedOnTime(int[] dist, double hour) {     int length = dist.length;     int min = 1;     int max = 10000001;     while (min &lt; max) {       int mid = min + (max - min) / 2;       double sum = 0;       for (int i = 0; i &lt; length - 1; i++) {         sum += Math.ceil(((double) dist[i]) / mid);       }       sum += ((double) dist[length - 1]) / mid;       if (sum &gt; hour) {         min = mid + 1;       } else {         max = mid;       }     }     return min == 10000001 ? -1 : min;   }  }   결과  Link   설명     dist의 각 거리를 hour시간 내 도착하기 위한 공통된 속도를 반환하는 문제이다.            hour시간 내 도착할 수 없는 경우, -1을 반환한다.       dist의 각 거리를 출발하기 위해서는 정수에 해당하는 시간에 출발 가능하다.       속도는 $10^7$을 초과할 수 없고, 소수점 뒤 최대 두 자리까지만 가능하다.           문제 풀이에 필요한 변수를 정의한다.            length는 dist의 길이를 저장한 변수이다.       min과 max는 최소 속도와 최대 속도를 저장할 변수로, 1과 최대 가능한 값보다 1 큰 10000001으로 초기화한다.           min이 max 미만일 때까지 아래를 수행한다.            mid에 $min + \\frac{max - min}{2}$의 중앙값을 넣어준다.       sum에 0부터 $length - 1$까지 i를 증가시키며 각 시작은 정수에 해당하는 시간에 출발 가능하므로, $\\frac{dist[i]}{mid}$의 결과를 올림 처리하여 sum에 더해준다.       마지막으로 도착하는 시간인 dist의 $length - 1$번째 값을 mid로 나눈 값을 더해준다.       sum이 hour보다 큰지 검증하여 아래를 수행한다.                    큰 경우, min에 $mid + 1$을 넣어 범위를 좁혀준다.           크지 않은 경우, max에 mid를 넣어 범위를 좁혀준다.                           반복이 완료되면 min이 10000001이면 속도 제한을 초과하므로 -1을, 아니면 min을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-speed-to-arrive-on-time/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Running Time of N Computers",
        "excerpt":"문제  Link   코드  class Solution {    public long maxRunTime(int n, int[] batteries) {     long sum = 0;     for (int battery : batteries) {       sum += battery;     }     long min = 1;     long max = (sum / n) + 1;     while (min &lt; max) {       long mid = min + ((max - min) / 2);       sum = 0;       for (int battery : batteries) {         sum += Math.min(battery, mid);       }       if (sum &gt;= mid * n) {         min = mid + 1;       } else {         max = mid;       }     }     return min - 1;   }  }   결과  Link   설명     batteries는 컴퓨터를 실행할 수 있는 시간을 넣은 변수로, n개의 컴퓨터를 동시에 실행할 수 있는 최대 시간을 구하는 문제이다.            처음에는 각 컴퓨터에 최대 한 개의 배터리를 삽입하고, 그 이후 교체 시간 없이 임의의 배터리를 교체한다.           문제 풀이에 필요한 변수를 정의한다.            sum은 batteries의 합을 더하기 위한 변수로, batteries의 모든 값을 더해준다.       min과 max는 시간 탐색에 필요한 변수로, 최소 가능한 시간인 1과 최대 가능한 시간인 $\\frac{sum}{n} + 1$로 초기화한다.           min이 max 미만일 때까지 아래를 수행한다.            mid에 $min + \\frac{max - min}{2}$의 중앙값을 넣어준다.       sum을 0으로 초기화하고 batteries의 각 값과 mid 중 작은 값 기준으로 sum에 더해준다.       sum이 $mid \\times n$보다 크거나 같은지 검증하여 아래를 수행한다.                    크거나 같으면, min에 $mid + 1$을 넣어 하한 범위를 좁혀준다.           작으면, max에 mid를 넣어 상한 범위를 좁혀준다.                           반복이 완료되면 시간이 계산된 min에 1을 빼서 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-running-time-of-n-computers/",
        "teaser": null
      },{
        "title": "Leetcode Java Regions Cut By Slashes",
        "excerpt":"문제  Link   코드  class Solution {    public int regionsBySlashes(String[] grid) {     int length = grid.length;     int size = length * 3;     int regions = 0;     int[][] dp = new int[size][size];     for (int i = 0; i &lt; length; i++) {       int row = i * 3;       for (int j = 0; j &lt; length; j++) {         int col = j * 3;         if (grid[i].charAt(j) == '/') {           dp[row][col + 2] = dp[row + 1][col + 1] = dp[row + 2][col] = 1;         } else if (grid[i].charAt(j) == '\\\\') {           dp[row][col] = dp[row + 1][col + 1] = dp[row + 2][col + 2] = 1;         }       }     }     for (int i = 0; i &lt; size; i++) {       for (int j = 0; j &lt; size; j++) {         regions += this.dfs(dp, i, j) &gt; 0 ? 1 : 0;       }     }     return regions;   }    private int dfs(int[][] dp, int i, int j) {     if (Math.min(i, j) &lt; 0 || dp.length &lt;= Math.max(i, j) || dp[i][j] != 0) {       return 0;     } else {       dp[i][j] = 1;       return 1 + this.dfs(dp, i - 1, j) + this.dfs(dp, i, j - 1) + this.dfs(dp, i + 1, j) + this.dfs(dp, i, j + 1);     }   }  }   결과  Link   설명          grid는 정사각형의 값을 저장한 변수로, ‘/’과 ‘' 문자열을 이용하여 분리된 사각형 내 영역의 수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 gird의 길이를 저장한 변수이다.       size는 영역을 계산하기 위한 dp의 크기를 저장할 변수로, $length \\times 3$ 크기로 초기화한다.       regions는 결과인 영역의 수를 계산하기 위한 변수로, 0으로 초기화한다.       dp는 regions를 계산하기 위해 구성할 배열로, $size \\times size$ 크기의 2차원 정수 배열로 초기화한다.           0부터 length 미만까지 i를 증가시키면서 아래를 수행한다.            dp 내 행의 시작 위치인 row에 $i \\times 3$를 넣어준다.       0부터 length 미만까지 j를 증가시키면서 아래를 수행한다.                    dp 내 열의 시작 위치인 col에 $j \\times 3$를 넣어준다.           grid의 i번째 행의 j번째 문자가 ‘/’인 경우, $3 \\times 3$크기의 영역 내 좌측 하단부터 우측 상단까지 1을 넣어 구분 선을 그어준다.           위가 아니면서 해당 문자가 ‘'인 경우, $3 \\times 3$크기의 영역 내 좌측 상단부터 우측 하단까지 1을 넣어 구분 선을 그어준다.                                반복이 완료되면 0부터 size까지 i를 증가시키고, 0부터 size까지 j를 증가시키며 regions에 5번에서 정의한 dfs(int[][] dp, int i, int j) 메서드의 수행 결과가 0 초과이면 1 아니면 0을 넣어준다.       DFS 방식으로 사각형 내 영역 구분이 이루어지는지 검증하기 위한 dfs(int[][] dp, int i, int j) 메서드를 정의한다.            i와 j 중 작은 값이 0 미만 혹은 dp의 길이 이상으로 사각형의 범위를 벗어나거나 dp[i][j]의 값이 0이 아닌 값의 경우, 0을 반환한다.       위의 경우가 아니라면 dp[i][j]에 1을 넣어주고, 1에 아래의 재귀 호출 결과를 모두 더해 반환한다.                    $i - 1$과 j를 이용하여 좌측 위치에서 재귀 호출.           i와 $j - 1$을 이용하여 하단 위치에서 재귀 호출.           $i + 1$과 j를 이용하여 우측 위치에서 재귀 호출.           i와 $j + 1$를 이용하여 상단 위치에서 재귀 호출.                           모든 반복이 완료되면 영역이 계산된 regions를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/regions-cut-by-slashes/",
        "teaser": null
      },{
        "title": "Leetcode Java Delete Columns to Make Sorted III",
        "excerpt":"문제  Link   코드  class Solution {    public int minDeletionSize(String[] strs) {     int max = 1;     int length = strs[0].length();     int[] dp = new int[length];     for (int i = 0; i &lt; length; i++) {       dp[i] = 1;       for (int j = 0; j &lt; i; j++) {         if (this.isLexicographicOrder(strs, i, j)) {           dp[i] = Math.max(dp[i], dp[j] + 1);         }       }       max = Math.max(max, dp[i]);     }     return length - max;   }    private boolean isLexicographicOrder(String[] strs, int i, int j) {     for (String str : strs) {       if (str.charAt(i) &lt; str.charAt(j)) {         return false;       }     }     return true;   }  }   결과  Link   설명          동일한 길이의 문자열이 들어있는 strs의 문자열들이 사전적 순서로 정렬된 최대 길이의 문자열이 되기 위해서 동일한 위치의 문자를 삭제할 때, 최소 삭제 횟수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            max는 문자열의 최대 길이를 저장할 변수로, 1로 초기화한다.       length는 문자열의 길이를 저장할 변수로, strs의 첫 문자열의 길이를 넣어준다.       dp는 문자열 최대 길이를 저장하기 위한 변수로, length 길이의 정수 배열로 초기화한다.           0부터 length 미만까지 i를 증가시키며 아래를 수행한다.            dp의 i번째 위치에 1을 넣어준다.       0부터 i미만까지 j를 증가시키며 아래를 수행한다.                    4번에서 정의한 isLexicographicOrder(String[] strs, int i, int j) 메서드를 수행하여 사전적 순서가 되는 경우, dp의 i번째 위치에 dp[i]와 $dp[j] + 1$ 중 큰 값을 넣어준다.                       max에 max와 dp[i]의 값 중 큰 값을 넣어 저장한다.           sts의 모든 문자열들의 i번째 문자와 j번째 문자가 사전적 순서인지 검증하기 위한 isLexicographicOrder(String[] strs, int i, int j) 메서드를 정의한다.            sts의 모든 문자열의 i번째 문자가 j번째 문자보다 작은 경우, false를 모두 수행되는 경우 true를 반환한다.           반복이 완료되면 length에서 문자열의 최대 길이인 max를 뺀 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/delete-columns-to-make-sorted-iii/",
        "teaser": null
      },{
        "title": "Leetcode Java N-Repeated Element in Size 2N Array",
        "excerpt":"문제  Link   코드  class Solution {    public int repeatedNTimes(int[] nums) {     int length = nums.length;     int n = length / 2;     for (int i = 0; i &lt; length; i++) {       int count = 1;       for (int j = i + 1; j &lt; length; j++) {         if (nums[i] == nums[j]) {           count++;         }       }       if (count == n) {         return nums[i];       }     }     return 0;   }  }   결과  Link   설명          $2 \\times n$ 크기로 구성된 정수 배열 nums 내 정확히 n번 반복되는 숫자를 찾는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       n은 반복 횟수를 저장할 변수로, $\\frac{length}{2}$로 초기화한다.           0부터 length 미만까지 i를 증가시키며 아래를 반복한다.            count는 반복 횟수를 저장할 변수로, 현재 위치까지 반복 횟수인 1로 초기화한다.       $i + 1$부터 length 미만까지 아래를 수행한다.                    nums의 i번째 숫자와 j번째 숫자가 같은 경우, count를 증가시킨다.                       반복이 완료되고 count가 n인 경우는 해당 숫자를 주어진 문제의 결과로 반환한다.           반복이 완료되면 해당 조건을 만족하는 경우가 없으므로 0을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/n-repeated-element-in-size-2n-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Width Ramp",
        "excerpt":"문제  Link   코드  class Solution {    public int maxWidthRamp(int[] nums) {     int length = nums.length;     Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();     for (int i = 0; i &lt; length; i++) {       if (stack.empty() || nums[i] &lt; nums[stack.peek()]) {         stack.push(i);       }     }     int result = 0;     for (int i = length - 1; i &gt;= 0; i--) {       while (!stack.empty() &amp;&amp; nums[stack.peek()] &lt;= nums[i]) {         result = Math.max(i - stack.pop(), result);       }     }     return result;   }  }   결과  Link   설명     아래의 조건을 만족하는 최대 길이를 구하는 문제이다.            두 위치 i &lt; j에서 nums[i] &lt;= nums[j]의 최대 길이는 $j - 1$이다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       stack은 최대 길이를 계산하기 위한 변수로, stack으로 초기화하고 아래를 이용하여 값을 넣어준다.                    0부터 length 미만까지 i를 증가시키며, stack이 비어있거나 nums의 i번째 값이 nums에서 stack의 첫 값보다 작을 경우 stack에 i를 넣어준다.                       result는 최대 길이를 저장할 변수로, 0으로 초기화한다.           $length - 1$부터 0 이상까지 i를 증가시키며 아래를 수행한다.            stack이 비어있지 않고 nums의 stack의 첫 값이 nums의 i번째 값보다 작거나 같은 경우, result에 i에서 stack의 값을 뺀 값과 result 중 큰 값인 최대 길이를 넣어준다.           반복이 완료되면 최대 길이가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-width-ramp/",
        "teaser": null
      },{
        "title": "Leetcode Java Least Operators to Express Number",
        "excerpt":"문제  Link   코드  class Solution {    public int leastOpsExpressTarget(int x, int target) {     int[] nums = new int[2];     int i = 0;     while (target &gt; 0) {       int curr = target % x;       target /= x;       if (i &gt; 0) {         nums = new int[] {           Math.min((curr * i) + nums[0], ((curr + 1) * i) + nums[1]),           Math.min(((x - curr) * i) + nums[0], ((x - curr - 1) * i) + nums[1])         };       } else {         nums[0] = curr * 2;         nums[1] = (x - curr) * 2;       }       i++;     }     return Math.min(nums[0], i + nums[1]) - 1;   }  }   결과  Link   설명          x로 target이 되기 위한 사칙 연산자의 최소 갯수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            nums은 target이 되기 위한 사칙 연산자의 최소 갯수를 두 경우로 저장할 변수로, 크기가 2인 정수 배열로 초기화한다.                    처음 값은 target을 초과하지 않는 최대 횟수를, 마지막 값은 연산하는 총 횟수를 계산한다.                       i는 연산 횟수를 저장할 변수로, 0으로 초기화한다.           target이 0 초과일 때까지 아래를 반복한다.            curr은 target을 x로 나눈 나머지를 저장하고, target에는 x를 나눈 몫을 저장한다.       i가 0보다 큰 경우, nums에 아래를 순차적으로 계산하여 넣어준다.                    nums의 첫 위치에 $(curr \\times i) + nums[0]$와의 값과 $((curr + 1) \\times i) + nums[1]$의 값 중 작은 값을 넣어준다.           nums의 다음 위치에 $((x - curr) \\times i) + nums[0]$와의 값과 $((x - curr - 1) \\times i) + nums[1]$의 값 중 작은 값을 넣어준다.                       위의 경우가 아니라면 nums에 $curr \\times 2$와 $(x - curr) \\times 2$를 순차적으로 넣어준다.       i를 증가시키고 다음 반복을 수행한다.           반복이 완료되면 nums[0]과 $i + nums[1]$ 중 작은 값에 1을 뺀 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/least-operators-to-express-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Univalued Binary Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public boolean isUnivalTree(TreeNode root) {     return this.isUnivalTree(root.left, root.val) &amp;&amp; this.isUnivalTree(root.right, root.val);   }    private boolean isUnivalTree(TreeNode root, int value) {     if (root != null) {       return root.val == value &amp;&amp; this.isUnivalTree(root.left, value) &amp;&amp; this.isUnivalTree(root.right, value);     } else {       return true;     }   }  }   결과  Link   설명          이진 트리인 root를 이용하여 모든 트리의 값이 동일한지 검증하는 문제이다.            3번의 isUnivalTree(TreeNode root, int value) 메서드를 root의 left TreeNode와 val로 수행한 결과와 root의 right TreeNode와 val로 수행한 결과가 모두 충족하는지 여부를 주어진 문제의 결과로 반환한다.            DFS 방식으로 문제를 풀기 위한 isUnivalTree(TreeNode root, int value) 메서드를 정의한다.             root가 null이 아니라면 아래 모두 만족하는지 여부를 반환한다.                    root의 값이 value와 같은 값.           root의 left TreeNode를 이용해서 재귀 호출한 결과.           root의 right TreeNode를 이용해서 재귀 호출한 결과.                       위의 경우가 아니라면 노드가 없으므로 true를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/univalued-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Numbers With Same Consecutive Differences",
        "excerpt":"문제  Link   코드  class Solution {    public int[] numsSameConsecDiff(int n, int k) {     List&lt;Integer&gt; list = new ArrayList&lt;&gt;();     for (int i = 1; i &lt;= 9; i++) {       this.dfs(list, i, 1, n, k);     }     int length = list.size();     int[] result = new int[length];     for (int i = 0; i &lt; length; i++) {       result[i] = list.get(i);     }     return result;   }    private void dfs(List&lt;Integer&gt; list, int item, int i, int n, int k) {     if (i == n) {       list.add(item);     } else {       int a = item % 10;       if (k == 0) {         this.dfs(list, (item * 10) + a, i + 1, n, k);       } else {         if ((a + k) &lt;= 9) {           this.dfs(list, (item * 10) + (a + k), i + 1, n, k);         }         if ((a - k) &gt;= 0) {           this.dfs(list, (item * 10) + (a - k), i + 1, n, k);         }       }     }   }  }   결과  Link   설명          n 길이의 숫자 중 앞뒤 자리가 k인 숫자들을 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            list는 해당 조건에 맞는 숫자들을 저장할 변수로, ArrayList로 초기화하고 3번에서 정의한 dfs(List list, int item, int i, int n, int k) 메서드를 1부터 9까지 i를 증가시키며 수행한 결과를 넣어준다.       length는 위에서 수행된 list의 길이를 저장한 변수이다.       result는 결과를 저장할 변수로, length 길이의 정수 배열로 초기화하고 list의 결과를 그대로 넣어 주어진 문제의 결과로 반환한다.           DFS 방식으로 값을 탐색하기 위한 dfs(List list, int item, int i, int n, int k) 메서드를 메서드를 정의한다.            i가 n인 자릿수가 맞는 경우, list에 item을 넣어준다.       위의 경우가 아니라면 a에 item을 10으로 나눈 나머지를 넣어주고 아래를 수행한다.                    k가 0인 차이가 없을 경우 item에 $(item \\times 10) + a$와 i에 1을 증가시켜 재귀 호출을 수행한다.           위의 경우가 아니고 $a + k$가 9 이하인 경우, item에 $(item \\tiems 10) + (a + k)$와 i에 1을 증가시켜 재귀 호출을 수행한다.           위의 경우가 아니고 $a + k$가 0 이상인 경우, item에 $(item \\tiems 10) + (a - k)$와 i에 1을 증가시켜 재귀 호출을 수행한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/numbers-with-same-consecutive-differences/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Tree Cameras",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    private int result;    public int minCameraCover(TreeNode root) {     this.result = 0;     return (this.dfs(root) &lt; 1 ? 1 : 0) + this.result;   }    public int dfs(TreeNode root) {     if (root == null) {       return 2;     }     int left = this.dfs(root.left);     int right = this.dfs(root.right);     if (left == 0 || right == 0) {       this.result++;       return 1;     } else {       return left == 1 || right == 1 ? 2 : 0;     }   }  }   결과  Link   설명     이진 트리인 root를 전체 확인하기 위한 카메라의 최소 갯수를 구하는 문제이다.            카메라는 자신으로부터 부모와 자식 노드를 탐색할 수 있다.                result는 최소 카메라의 수를 저장하기 위한 변수이다.            result를 0으로 초기화하고, 4번에서 정의한 dfs(TreeNode root) 메서드를 수행한 결과가 1보다 작으면 1, 아니면 0에 result를 더해서 주어진 문제의 결과로 반환한다.       DFS 방식으로 카메라의 최소 갯수를 탐색하기 위한 dfs(TreeNode root) 메서드를 정의한다.            root가 null인 경우, 2를 반환한다.       left에 root의 left TreeNode를 이용하여 재귀 호출을 수행한 값을 넣어준다.       right에 root의 right TreeNode를 이용하여 재귀 호출을 수행한 값을 넣어준다.       left가 0이거나 right가 0인 경우, result를 증가시키고 1을 반환한다.       위의 경우가 아니라면 left가 1이거나 right가 1인 경우, 2를 아니면 0을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-tree-cameras/",
        "teaser": null
      },{
        "title": "Leetcode Java Pancake Sorting",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; pancakeSort(int[] arr) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     for (int i = arr.length, j; i &gt; 0; i--) {       for (j = 0; arr[j] != i; j++);       this.reverse(arr, j + 1);       result.add(j + 1);       this.reverse(arr, i);       result.add(i);     }     return result;   }    private void reverse(int[] arr, int k) {     for (int i = 0, j = k - 1; i &lt; j; i++, j--) {       int temp = arr[i];       arr[i] = arr[j];       arr[j] = temp;     }   }  }   결과  Link   설명     arr을 팬케이크 플립하여 오름차순 정렬하기 위해 선택한 숫자들을 반환하는 문제이다.            팬케이크 플립은 1 &lt;= k &lt;= arr.length을 만족하는 k를 선택하여 [0, $k - 1$] 범위의 값들을 반전시킨다.                result는 결과를 저장할 변수로, ArrayList로 초기화한다.       arr의 길이부터 0 초과일 때 까지 i를 감소시키고, j를 정의하여 아래를 반복한다.            0부터 arr[j]의 값이 i가 아닐 때 까지 j를 증가시켜준다.       arr의 [0, $j + 1$] 범위의 값을 반전시키고 선택한 $j + 1$을 result에 넣어준다.       arr의 [0, i] 범위의 값을 반전시키고 선택한 i를 result에 넣어준다.           반복이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/pancake-sorting/",
        "teaser": null
      },{
        "title": "Leetcode Java Powerful Integers",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; powerfulIntegers(int x, int y, int bound) {     Set&lt;Integer&gt; result = new HashSet&lt;&gt;();     for (int i = 1; i &lt; bound; i *= x) {       for (int j = 1; i + j &lt;= bound; j *= y) {         result.add(i + j);         if (y == 1) {           break;         }       }       if (x == 1) {         break;       }     }     return new ArrayList&lt;&gt;(result);   }  }   결과  Link   설명     아래의 조건을 만족하는 [0, bound] 범위 내 숫자들을 반환하는 문제이다.            i와 j가 0 이상일 때 $x^i + y^j$로 표현 가능해야한다.                result는 결과에 해당하는 숫자들을 저장할 변수로, 중복을 제거하기 위해 HashSet으로 초기화한다.       1부터 bound 미만까지 i에 x를 곱하면서 아래를 반복한다.            1부터 $i + j$가 bound 이하일 때까지 j에 y를 곱해서 아래를 반복한다.                    result에 $i + j$를 넣어준다.           y가 1인 경우, 증가폭이 없으므로 반복을 그만둔다.                       x가 1인 경우, 위와 동일하게 증가폭이 없으므로 반복을 그만둔다.           반복이 완료되면 result를 ArrayList로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/powerful-integers/",
        "teaser": null
      },{
        "title": "Leetcode Java Flip Binary Tree To Match Preorder Traversal",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    private int index;    public List&lt;Integer&gt; flipMatchVoyage(TreeNode root, int[] voyage) {     this.index = 0;     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     return this.dfs(root, voyage, result) ? result : Arrays.asList(-1);   }    private boolean dfs(TreeNode node, int[] voyage, List&lt;Integer&gt; result) {     if (node == null) {       return true;     } else if (node.val != voyage[index++]) {       return false;     } else if (node.left != null &amp;&amp; node.left.val != voyage[index]) {       result.add(node.val);       return this.dfs(node.right, voyage, result) &amp;&amp; this.dfs(node.left, voyage, result);     } else {       return this.dfs(node.left, voyage, result) &amp;&amp; this.dfs(node.right, voyage, result);     }   }  }   결과  Link   설명     root를 자식 노드의 순서만 바꾸며 Preorder로 voyage와 비교할 때, 변경한 노드의 값들을 반환하는 문제이다.            단, Preorder 구성이 불가능한 경우에는 -1을 넣어 반환한다.           문제 풀이에 필요한 변수를 정의한다.            전역 변수인 index는 voyage 내 위치를 저장할 변수로, 0으로 초기화한다.       result는 변경하는 노드의 값을 저장할 변수로, ArrayList로 초기화한다.                4번에서 정의한 dfs(TreeNode node, int[] voyage, List result) 메서드를 수행한 결과가 true이면 result를, 아니면 -1을 List로 변환하여 주어진 문제의 결과로 반환한다.       DFS 방식으로 root를 탐색할 dfs(TreeNode node, int[] voyage, List result) 메서드를 정의한다.            node가 null인 경우, true를 반환한다.       node의 값이 voyage의 index번째 값과 동일하지 않으면 일치하지 않으므로, false를 반환하고 결과와 무관하게 index를 증가시킨다.       node의 left TreeNode가 null이 아니면서 val 값이 voyage의 index번째 노드와 같지 않은 경우, 아래를 수행한다.                    result에 node의 val 값을 넣고, node의 right TreeNode로 재귀 호출을 수행한 결과와 left TreeNode로 재귀 호출을 수행한 결과의 AND 연산을 수행한 값을 반환한다.                       위의 모든 경우가 아니라면 node의 left TreeNode로 재귀 호출을 수행한 결과와 right TreeNode로 재귀 호출을 수행한 결과의 AND 연산을 수행한 값을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/flip-binary-tree-to-match-preorder-traversal/",
        "teaser": null
      },{
        "title": "Leetcode Java Equal Rational Numbers",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isRationalEqual(String s, String t) {     return this.parse(s) == this.parse(t);   }    private double parse(String str) {     int index = str.indexOf('(');     if (index &gt; 0) {       StringBuilder base = new StringBuilder(str.substring(0, index));       String num = str.substring(index + 1, str.length() - 1);       for (int i = 1; i &lt; 18; i++) {         base.append(num);       }       return Double.valueOf(base.toString());     } else {       return Double.valueOf(str);     }   }  }   결과  Link   설명     아래의 규칙을 만족하는 s와 t를 이용하여 동일한지 검증하는 문제이다.            s의 괄호 안 문자열을 앞의 문자열에 연속해서 생성한다.           문자열을 실수형으로 변환하기위한 parse(String str) 메서드를 정의한다.            index는 str의 문자열을 자르기 위한 위치 변수로, 내 괄호 시작 문자의 위치를 찾아 넣어준다.       index가 0보다 큰 경우 아래를 수행한다.                    base에 str의 처음부터 index까지 문자열을 잘라 새 StringBuilder에 넣어준다.           num에 str의 $index + 1$번째 위치에서 마지막 이전 문자열까지 반복 숫자열을 잘라 넣어준 후 1부터 18 미만까지 i를 증가시키며 base에 num을 이어준다.           반복이 완료되면 완성된 문자열인 base를 실수형으로 변환하여 반환한다.                       위의 경우가 아니라면 정수이므로, str을 실수형으로 넣어준다.           2번에서 정의한 parse(String str) 메서드를 이용하여 s와 t를 실수형으로 변환한 값이 동일한지 여부를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/equal-rational-numbers/",
        "teaser": null
      },{
        "title": "Leetcode Java K Closest Points to Origin",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] kClosest(int[][] points, int k) {     Queue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;((a, b) -&gt; ((a[0] * a[0]) + (a[1] * a[1])) - ((b[0] * b[0]) + (b[1] * b[1])));     int[][] result = new int[k][2];     for (int[] point : points) {       queue.add(point);     }     for (int i = 0; i &lt; k; i++) {       result[i] = queue.poll();     }     return result;   }  }   결과  Link   설명          (0, 0) 좌표에서 가장 가까운 k개의 points를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            queue는 좌표의 거리를 저장할 변수로, PriorityQueue로 거리에 대한 오름차순으로 정렬하여 points의 모든 좌표값을 저장한다.                    길이의 비교는 제곱근을 수행하지 않아도 알 수 있으므로 제곱근을 수행하지 않은 값으로 비교한다.                       result는 k개의 좌표를 저장할 변수로, $k \\times 2$ 크기의 배열로 초기화한다.           0부터 k까지 queue의 좌표를 result에 넣어주고 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/k-closest-points-to-origin/",
        "teaser": null
      },{
        "title": "Leetcode Java Subarray Sums Divisible by K",
        "excerpt":"문제  Link   코드  class Solution {    public int subarraysDivByK(int[] nums, int k) {     int result = 0;     int prefix = 0;     int[] count = new int[k];     count[0] = 1;     for (int num : nums) {       prefix = (prefix + (num % k) + k) % k;       result += count[prefix];       count[prefix]++;     }     return result;   }  }   결과  Link   설명          연속된 값이 k의 배수가 되는 부분 배열의 수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 부분 배열의 수를 계산할 변수로, 0으로 초기화한다.       prefix는 값들을 더한 후 k로 나눈 나머지를 저장할 변수로, 0으로 초기화한다.       count는 k로 나눈 나머지 값의 갯수를 저장할 변수로, k 크기의 정수 배열로 초기화하고 첫 값에 1을 넣어준다.           nums의 모든 값을 순차적으로 num에 넣어 아래를 반복한다.            prefix에 prefix와 num을 k로 나눈 나머지 값과 더한 후 k로 나눈 나머지 값을 넣어준다.       result에 count의 prefix번째 값에 대한 갯수를 꺼내 더해주고, count의 prefix번째 값을 증가시킨다.           반복이 완료되면 부분 배열의 수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/subarray-sums-divisible-by-k/",
        "teaser": null
      },{
        "title": "Leetcode Java Odd Even Jump",
        "excerpt":"문제  Link   코드  class Solution {    public int oddEvenJumps(int[] arr) {     int length = arr.length;     boolean[] higher = new boolean[length];     boolean[] lower = new boolean[length];     higher[length - 1] = true;     lower[length - 1] = true;     TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;();     map.put(arr[length - 1], length - 1);     for (int i = length - 2; i &gt;= 0; i--) {       Map.Entry&lt;Integer, Integer&gt; next = map.ceilingEntry(arr[i]);       if (next != null) {         higher[i] = lower[next.getValue()];       }       next = map.floorEntry(arr[i]);       if (next != null) {         lower[i] = higher[next.getValue()];       }       map.put(arr[i], i);     }     int result = 0;     for (int i = 0; i &lt; length; i++) {       if (higher[i]) {         result++;       }     }     return result;   }  }   결과  Link   설명     arr의 임의 위치에서 아래를 만족하는 이동이 가능한 위치들의 갯수를 계산하는 문제이다.            이동은 홀수 혹은 짝수 점프를 이용한다.       홀수 점프는 arr[i] &lt;= arr[j]를 만족할 때, arr[j]가 가장 작은 값이 되는 점프이다.       짝수 점프는 arr[i] &gt;= arr[j]를 만족할 때, arr[j]가 가장 큰 값이 되는 점프이다.       두 점프 모두 여러 개의 j가 존재할 경우, 가장 작은 j로만 점프할 수 있다.       시작 위치부터 배열의 끝에 도달할 수 있는 경우만 계산한다.           문제 풀이에 필요한 변수를 정의한다.            length는 arr의 길이를 저장한 변수이다.       higher는 점층적으로 증가하는 추세를 저장하기 위한 변수로, 변수의 최대 수인 length 크기인 부울 배열로 초기화하고 마지막 위치에 true를 넣어준다.       lower는 점층적으로 증가하는 추세를 저장하기 위한 변수로, 변수의 최대 수인 length 크기인 부울 배열로 초기화한다 마지막 위치에 true를 넣어준다.       map은 arr의 값과 위치를 트리 형태로 저장하기 위한 변수로, TreeMap으로 초기화하고 arr의 마지막 값과 위치를 쌍으로 넣어준다.           $length - 2$부터 0까지 i를 감소시키며 아래를 반복한다.            map에서 arr[i]보다 크거나 같은 키가 존재하는 경우, higher[i]에 lower 내 찾은 값에 해당하는 위치의 부울 값을 꺼내 넣어준다.       map에서 arr[i]보다 작거나 같은 키가 존재하는 경우, lower[i]에 higher 내 찾은 값에 해당하는 위치의 부울 값을 꺼내 넣어준다.       map에 arr[i]와 i를 넣어 TreeMap에 현재 값을 저장한다.           반복이 완료되면 위치의 갯수를 저장할 result에 higher 내 true인 조건을 만족하는 위치의 갯수를 계산하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/odd-even-jump/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximal Network Rank",
        "excerpt":"문제  Link   코드  class Solution {    public int maximalNetworkRank(int n, int[][] roads) {     boolean[][] connect = new boolean[n][n];     int[] count = new int[n];     for (int[] road : roads) {       count[road[0]]++;       count[road[1]]++;       connect[road[0]][road[1]] = true;       connect[road[1]][road[0]] = true;     }     int result = 0;     for (int i = 0; i &lt; n; i++) {       for (int j = i + 1; j &lt; n; j++) {         result = Math.max(result, count[i] + count[j] - (connect[i][j] ? 1 : 0));       }     }     return result;   }  }   결과  Link   설명     n개의 도시에 도시 간 이어주는 roads를 이용하여 가장 많은 도로가 이어진 도로의 수를 찾는 문제이다.            단, a와 b 두 도시가 이어있을 때 b에 연결된 도시들은 a와 연결되어 있는 것으로 취급한다.           문제 풀이에 필요한 변수를 정의한다.            connect는 도시 간 이어진 정보를 저장하기 위한 변수로, $n \\times n$ 크기의 2차원 부울 배열로 초기화한다.       count는 도시 간 직접 이어진 도로의 수를 저장하기 위한 변수로, n 크기의 정수로 초기화한다.                    roads의 모든 값을 이용하여 count와 connect를 초기화한다.                       result는 최대 연결된 도시의 수를 저장하기 위한 변수로, 0으로 초기화한다.           0부터 n 미만까지 i를 증가시키고, $i + 1$부터 n 미만까지 j를 증가시키며 아래를 반복한다.            result에 result와 count 내 i와 j번째 값의 합에 i와 j의 연결 되었으면 1을 더한 값 중 큰 값을 넣어준다.           반복이 완료되면 최대 연결된 도로의 수인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximal-network-rank/",
        "teaser": null
      },{
        "title": "Leetcode Java Largest Perimeter Triangle",
        "excerpt":"문제  Link   코드  class Solution {    public int largestPerimeter(int[] nums) {     Arrays.sort(nums);     for (int i = nums.length - 1; i &gt; 1; i--) {       if (nums[i - 2] + nums[i - 1] &gt; nums[i]) {         return nums[i - 2] + nums[i - 1] + nums[i];       }     }     return 0;   }  }   결과  Link   설명     nums의 세 값을 이용하여 만들 수 있는 최대 크기의 삼각형의 세 변에 대한 합을 구하는 문제이다.            단, 만들 수 있는 삼각형이 없는 경우 0을 주어진 문제의 결과로 반환한다.                nums의 값들을 오름차순으로 정렬한다.       $nums.length - 1$부터 1 초과일 때 까지 i를 감소시키며 아래를 수행한다.            nums의 $i - 2$번째 값과 $i - 1$ 값의 합이 i번째 값보다 큰 경우, 현재 위치에서 만들 수 있는 최대 크기의 삼각형이므로 세 값의 합을 주어진 문제의 결과로 반환한다.           반복이 완료되면 nums의 값으로 삼각형을 만들 수 없으므로, 0을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/largest-perimeter-triangle/",
        "teaser": null
      },{
        "title": "Leetcode Java Squares of a Sorted Array",
        "excerpt":"문제  Link   코드  class Solution {    public int[] sortedSquares(int[] nums) {     int length = nums.length;     int[] result = new int[length];     int i = 0;     int j = length - 1;     int k = length - 1;     while (i &lt;= j) {       if (Math.abs(nums[i]) &gt; Math.abs(nums[j])) {         result[k] = nums[i] * nums[i];         i++;       } else {         result[k] = nums[j] * nums[j];         j--;       }       k--;     }     return result;   }  }   결과  Link   설명          nums의 모든 값을 제곱으로 변환하여 오름차순 정렬하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       result는 결과인 제곱으로 변환한 값을 오름차순으로 넣어줄 변수로, length 길이의 정수 배열로 초기화한다.       i와 j는 nums의 시작과 종료 위치를 저장할 변수로, 0과 $length - 1$로 초기화한다.       k는 result의 위치를 저장할 변수로, 역순으로 넣기 위해 $length - 1$로 초기화한다.           i가 j 이하일 때 까지 아래를 반복한다.            nums[i]를 제곱한 값이 nums[j]를 제곱한 값보다 큰 경우, result[k]에 nums[i]를 제곱한 값을 넣고 i를 증가시킨다.       위의 경우가 아니라면, result[k]에 nums[j]를 제곱한 값을 넣고 j를 감소시킨다.       다음 위치로 이동하기 위해 k를 감소시킨다.           반복이 완료되면 조건에 만족하는 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/squares-of-a-sorted-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Turbulent Subarray",
        "excerpt":"문제  Link   코드  class Solution {    public int maxTurbulenceSize(int[] arr) {     int result = 0;     for (int i = 0, count = 0; i &lt; arr.length - 1; i++, count *= -1) {       if (arr[i] &gt; arr[i + 1]) {         count = count &gt; 0 ? count + 1 : 1;       } else if (arr[i] &lt; arr[i + 1]) {         count = count &lt; 0 ? count - 1 : -1;       } else {         count = 0;       }       result = Math.max(result, Math.abs(count));     }     return result + 1;   }  }   결과  Link   설명          arr 내 이어진 값이 높았다가 낮아지는 구간의 길이를 구하는 문제이다.            result는 길이를 저장할 변수로, 0으로 초기화한다.       count는 0으로, 0부터 $arr.length - 1$ 미만까지 i를 증가시키고 count에 -1을 곱해주면서 아래를 반복한다.            arr[i]의 값이 arr[$i + 1$]의 값보다 큰 경우, count가 0보다 크면 1을 증가시키고 아니면 count를 1로 초기화한다.       위의 경우가 아니면서 arr[i]의 값이 arr[$i + 1$]보다 작은 경우, count가 0보다 작으면 count를 감소시키고 아니면 -1로 초기화한다.       그 외인 두 값이 같으면 count를 0으로 초기화한다.       result에 result와 count의 절댓값 중 큰 값을 저장한다.           반복이 완료되면 자기 자신을 포함한 $result + 1$을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-turbulent-subarray/",
        "teaser": null
      },{
        "title": "Leetcode Java Distribute Coins in Binary Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    private int result;    public int distributeCoins(TreeNode root) {     this.result = 0;     this.dfs(root);     return this.result;   }    private int dfs(TreeNode root) {     if (root == null) {       return 0;     } else {       int left = this.dfs(root.left);       int right = this.dfs(root.right);       this.result += Math.abs(left) + Math.abs(right);       return root.val + left + right - 1;     }   }  }   결과  Link   설명     root 내 모든 노드들이 정확히 하나의 val 값을 가지도록 분배하는데 소모되는 횟수를 구하는 문제이다.            한 번에 인접한 한 노드로 코인을 이동할 수 있다.                result는 횟수를 구하기 위한 변수이다.            result를 0으로 초기화하고 4번에서 정의한 dfs(TreeNode root) 메서드를 수행한다.       DFS 방식으로 이동 횟수를 계산할 dfs(TreeNode root) 메서드를 정의한다.            root가 null인 경우, 이동이 불가능하므로 0을 반환한다.       그 외의 경우 아래를 수행한다.                    left에 root의 left TreeNode를 이용하여 수행한 결과를 넣어준다.           right에 root의 right TreeNode를 이용하여 수행한 결과를 넣어준다.           result에 left와 right의 절댓값을 더한 값을 더해 이동 횟수를 계산한다.           root의 val 값과 left, right를 더한 후 이동횟수인 1을 뺀 값을 반환한다.                           4번의 수행이 완료되면 이동 횟수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/distribute-coins-in-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Unique Paths III",
        "excerpt":"문제  Link   코드  class Solution {    public int uniquePathsIII(int[][] grid) {     int count = 0;     int x = 0;     int y = 0;     for (int i = 0; i &lt; grid.length; i++) {       for (int j = 0; j &lt; grid[0].length; j++) {         if (grid[i][j] == 0) {           count++;         } else if (grid[i][j] == 1) {           x = i;           y = j;         }       }     }     return this.dfs(grid, x, y, count);   }    private int dfs(int[][] grid, int x, int y, int count) {     if (x &lt; 0 || y &lt; 0 || x &gt;= grid.length || y &gt;= grid[0].length || grid[x][y] == -1) {       return 0;     } else if (grid[x][y] == 2) {       return count == -1 ? 1 : 0;     } else {       grid[x][y] = -1;       count--;       int total = this.dfs(grid, x + 1, y, count) + this.dfs(grid, x, y + 1, count) + this.dfs(grid, x - 1, y, count) + this.dfs(grid, x, y - 1, count);       grid[x][y] = 0;       count++;       return total;     }   }  }   결과  Link   설명          grid 내 1의 위치에서 2의 위치까지 -1이 있는 칸을 피해 0이 존재하는 칸을 모두 지나갈 수 있는 경우의 수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            count는 0의 갯수를 계산하기 위한 변수로, 0으로 초기화한다.       x와 y는 시작 위치를 저장할 변수로, 0으로 초기화한다.                grid의 모든 값을 이용하여 count에 0인 칸의 갯수를, x와 y에 1의 위치를 넣어준다.            5번에서 정의한 dfs(int[][] grid, int x, int y, int count) 메서드를 수행한 결과를 주어진 문제의 결과로 반환한다.       DFS 방식으로 경우의 수를 계산하기 위한 dfs(int[][] grid, int x, int y, int count) 메서드를 정의한다.            x와 y가 grid 범위를 넘어가거나, -1인 방해물인 경우 0을 반환한다.       위의 경우가 아니면서 grid[x][y]의 값이 2인 도착지인 경우, count가 -1이면 1을 아니면 0을 반환한다.       위의 모든 경우가 아니라면 아래르 수행한다.                    grid[x][y]에 -1을 넣어 지나간 기록을 남기고 count를 감소시킨다.           total에 [x, y]의 우측, 위, 좌측, 아래 순으로 재귀 호출을 수행한 결과를 더해서 넣어준다.           grid[x][y]에 0을 넣어 초기화하고 count를 증가시킨 후 total을 반환한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/unique-paths-iii/",
        "teaser": null
      },{
        "title": "Leetcode Java Time Based Key-Value Store",
        "excerpt":"문제  Link   코드  class TimeMap {    private Map&lt;String, List&lt;Pair&gt;&gt; map;    public TimeMap() {     this.map = new HashMap&lt;&gt;();   }    public void set(String key, String value, int timestamp) {     if (!this.map.containsKey(key)) {       this.map.put(key, new ArrayList&lt;&gt;());     }     this.map.get(key).add(new Pair(value, timestamp));   }    public String get(String key, int timestamp) {     if (!this.map.containsKey(key)) {       return \"\";     } else {       return this.binarySearch(this.map.get(key), timestamp);     }   }    protected String binarySearch(List&lt;Pair&gt; list, int timestamp) {     int left = 0;     int right = list.size() - 1;     while (left &lt; right) {       int mid = (left + right + 1) &gt;&gt; 1;       if (list.get(mid).timestamp &lt;= timestamp) {         left = mid;       } else {         right = mid - 1;       }     }     return list.get(left).timestamp &lt;= timestamp ? list.get(left).value : \"\";   }  }  class Pair {    String value;   int timestamp;    public Pair(String value, int timestamp) {     this.value = value;     this.timestamp = timestamp;   }  }  /**  * Your TimeMap object will be instantiated and called as such:  * TimeMap obj = new TimeMap();  * obj.set(key,value,timestamp);  * String param_2 = obj.get(key,timestamp);  */   결과  Link   설명     서로 다른 타임스탬프에서 동일한 키에 대해 여러 값을 저장하고 특정 타임스탬프에서 키의 값을 검색할 수 있는 키-값 데이터 구조인 TreeMap을 정의하는 문제이다.            생성자인 TimeMap()는 데이터 구조를 초기화한다.       메서드인 set(String key, String value, int timestamp)은 key와 value를 주어진 timestamp에 저장한다.       메서드인 get(String key, int timestamp)은 timestamp 이전에 저장한 값들 중 key에 해당하는 값을 찾아 반환한다.                    조건을 만족하는 여러 값이 존재하는 경우, 가장 큰 timestamp의 값을 반환한다.           해당 값이 존재하지 않으면 ““을 반환한다.                                value와 timestamp를 쌍으로 엮어서 저장할 Pair 클래스를 정의한다.            전역 변수인 map은 key와 Pair를 저장할 변수이다.       생성자인 TimeMap()을 정의한다.            전역 변수인 map을 HashMap으로 초기화한다.           메서드인 set(String key, String value, int timestamp)을 정의한다.            map에 key가 존재하지 않는다면, key에 ArrayList를 새로 초기화하여 넣어준다.       map에 key의 List를 꺼내 value와 timestamp로 Pair를 정의하여 넣어준다.           메서드인 get(String key, int timestamp)을 정의한다.            map에 key가 존재하지 않으면 ““을 반환한다.       위의 경우가 아니라면 map에서 key의 값을 꺼내 7번에서 정의한 binarySearch(List list, int timestamp) 메서드를 수행한 결과를 넣어준다.           이진 탐색을 수행할 binarySearch(List list, int timestamp) 메서드를 정의한다.            left와 right는 탐색을 수행할 위치 변수로, 0과 list의 마지막 위치 값을 넣어준다.       left가 right보다 작을 때까지 아래를 수행한다.                    mid에 $left + right + 1$의 비트를 우측으로 한 칸 이동한 값을 넣어준다.           list에 mid번째 Pair의 timestamp가 timestamp보다 작거나 같은 경우, left에 mid를 아니면 right에 $mid - 1$을 넣어준다.                       반복이 완료되면 list의 left번째 Pair의 timestamp가 timestamp보다 작거나 같으면 해당 값을, 아니면 ““을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/time-based-key-value-store/",
        "teaser": null
      },{
        "title": "Leetcode Java Triples with Bitwise AND Equal To Zero",
        "excerpt":"문제  Link   코드  class Solution {    public int countTriplets(int[] nums) {     int[] count = new int[1 &lt;&lt; 16];     for (int num1 : nums) {       for (int num2 : nums) {         count[num1 &amp; num2]++;       }     }     int result = 0;     for (int num : nums) {       for (int i = 0; i &lt; count.length; i++) {         if ((num &amp; i) == 0) {           result += count[i];         } else {           i += (num &amp; i) - 1;         }       }     }     return result;   }  }   결과  Link   설명     아래의 조건을 만족하는 nums의 AND 배수의 수를 구하는 문제이다.            AND의 삼중항인 (i, j, k)가 0 &lt;= i, j, k &lt; nums.length일 때, nums[i] &amp; nums[j] &amp; nums[k] == 0을 만족한다.           문제 풀이에 필요한 변수를 정의한다.            count는 문제 범위 내 만족하기 위한 기본 정수 배열을 저장할 변수로, 주어진 정수 범위 크기만큼 초기화하고 nums의 모든 값을 서로 반복하여 &amp; 조건을 수행한 결과의 갯수를 count에 넣어준다.       result는 조건에 만족하는 수를 계산할 변수로, 0으로 초기화한다.           nums의 모든 값을 num에 순차적으로 넣고 아래를 반복한다.            0부터 count의 길이 미만까지 i를 증가시키며 아래르 반복한다.                    num과 i의 &amp; 조건이 0인 경우, result에 해당 조건에 만족하는 갯수인 count[i]를 더해준다.           그 외의 경우 i에 num과 i의 &amp; 조건의 결과에 1을 뺀 값을 더해 만족할만한 위치로 i를 이동시켜준다.                           반복이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/triples-with-bitwise-and-equal-to-zero/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Cost For Tickets",
        "excerpt":"문제  Link   코드  class Solution {    public int mincostTickets(int[] days, int[] costs) {     int last = days[days.length - 1];     boolean[] planned = new boolean[last + 1];     for (int day : days) {       planned[day] = true;     }     int[] dp = new int[last + 1];     for (int i = 1; i &lt;= last; i++) {       if (!planned[i]) {         dp[i] = dp[i - 1];         continue;       }       dp[i] = dp[i - 1] + costs[0];       dp[i] = Math.min(dp[i], dp[Math.max(i - 7, 0)] + costs[1]);       dp[i] = Math.min(dp[i], dp[Math.max(i - 30, 0)] + costs[2]);     }     return dp[last];   }  }   결과  Link   설명     days에 해당하는 날자만큼 여행을 하려고 할 때, 각 패스권의 가격이 담긴 costs를 활용하여 최소 여행 경비를 반환하는 문제이다.            패스권은 1, 7, 30일권으로 해당 가격은 순차적으로 costs에 들어있다.           문제 풀이에 필요한 변수를 정의한다.            last는 여행의 마지막 날을 저장할 변수로, days의 마지막 값을 넣어준다.       planned는 여행 계획을 세운 날을 저장할 변수로, 여행 날자에 해당하는 위치의 값을 true로 저장해준다.       dp는 최소 여행 경비를 계산하기 위한 변수로, $last + 1$ 크기의 정수 배열로 초기화한다.           1부터 last 이하까지 i를 증가시키며 아래를 반복한다.            planned[i]의 값이 false인 여행 일정이 아닌 경우, dp[i]에 $i - 1$번째 값을 넣고 다음 반복을 수행한다.       dp[i]에 아래의 값들 중 가장 작은 값을 넣어준다.                    어제까지 경비와 1일 패스권 가격을 더한 값.           7일 전 경비 혹은 처음부터 7일 패스권 가격을 더한 값.           30일 전 경비 혹은 처음부터 30일 패스권 가격을 더한 값.                           반복이 완료되면 dp의 last번째 값인 최소 경비를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-cost-for-tickets/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Penalty for a Shop",
        "excerpt":"문제  Link   코드  class Solution {    public int bestClosingTime(String customers) {     int max = 0;     int score = 0;     int time = -1;     for (int i = 0; i &lt; customers.length(); i++) {       if (customers.charAt(i) == 'Y') {         score++;       } else {         score--;       }       if (score &gt; max) {         max = score;         time = i;       }     }     return time + 1;   }  }   결과  Link   설명     ‘Y’와 ‘N’로 이루어진 고객 방문 기록인 customers를 이용하여 최소 벌금을 부과하기 위해 가장 빨리 폐점하는 시간을 반환하는 문제이다.            i번째 문자가 ‘Y’인 경우, 고객이 i번째 시간에 도착한다는 의미이다.       i번째 문자가 ‘N’인 경우, 고객이 i번째 시간에 오지 않는다는 의미를 나타낸다.       0 &lt;= j &lt;= n인 j 시간에 상점이 닫을 때 까지 아래와 같이 벌금이 부과된다.                    매장이 문을 열고 손님이 오는 경우.           매장이 문을 닫고 손님이 오는 경우.                           문제 풀이에 필요한 변수를 정의한다.            max는 최대 값을 저장할 변수로, 0으로 초기화한다.       score는 벌금을 저장할 변수로, 0으로 초기화한다.       time은 가장 빨리 폐점하는 시간을 저장할 변수로, -1로 초기화한다.           0부터 customers의 길이 미만까지 i를 증가시키며 아래를 반복한다.            customers의 i번째 값이 ‘Y’인 경우, 벌금을 부과하지 않았으므로 score를 증가시키고 아니면 score를 감소시켜 벌금을 부과한다.       score가 max보다 큰 경우, max에 최대 값을 저장하고 time에 현재까지 영업한 시간인 i를 넣어준다.           반복이 완료되면 최소 벌금을 부과하는 시간인 $time + 1$을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-penalty-for-a-shop/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Replacements to Sort the Array",
        "excerpt":"문제  Link   코드  class Solution {    public long minimumReplacement(int[] nums) {     int length = nums.length;     int last = nums[length - 1];     long result = 0;     for (int i = length - 2; i &gt;= 0; i--) {       int time = nums[i] / last;       if (nums[i] % last != 0) {         last = nums[i] / ++time;       }       result += time - 1;     }     return result;   }  }   결과  Link   설명          nums의 값들을 $a = b + c$를 만족하는 b와 c의 두 값으로 분리하여 감소하지 않는 배열을 만드는데 필요한 최소 횟수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 nums의 값을 저장한 변수이다.       last는 감소하지 않는 추세로 변환하기 위해 이전 값을 저장할 변수로, nums의 마지막 값을 넣어준다.       result는 분리 횟수를 저장할 변수이다.           $length - 2$부터 0 이상까지 i를 증가시키며 역순으로 아래를 반복한다.            time에 last의 값을 넘지 않는 수준까지 나눠야 할 횟수인 $\\frac{nums[i]}{last}$ 값을 저장한다.       nums[i]를 last로 나눈 나머지가 0이 아닌 경우, last에 time을 증가시킨 값으로 nums[i]를 나눈 값을 넣어준다.       result의 분리 횟수인 $time - 1$을 더해준다.           반복이 완료되면 최소 분리 횟수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-replacements-to-sort-the-array/",
        "teaser": null
      },{
        "title": "Leetcode Java String Without AAA or BBB",
        "excerpt":"문제  Link   코드  class Solution {    public String strWithout3a3b(int a, int b) {     StringBuilder sb = new StringBuilder(a + b);     char ca = 'a';     char cb = 'b';     if (b &gt; a) {       ca = 'b';       cb = 'a';       int temp = a;       a = b;       b = temp;     }     while (a-- &gt; 0) {       sb.append(ca);       if (a &gt; b) {         sb.append(ca);         a--;       }       if (b-- &gt; 0) {         sb.append(cb);       }     }     return sb.toString();   }  }   결과  Link   설명     a와 b를 아래의 규칙대로 수행한 문자열로 반환하는 문제이다.            문자열의 길이는 $a + b$이며, a는 ‘a’문자 b는 ‘b’ 문자를 의미한다.       ‘aaa’, ‘bbb’와 같은 세 번 연속된 문자열은 s에 존재하지 않는다.           문제 풀이에 필요한 변수를 정의한다.            sb는 결과 문자열을 동적으로 만들기 위한 변수로, $a + b$ 크기의 StringBuilder로 정의한다.       ca와 cb는 a와 b를 문자열로 저장한 변수로, a와 b를 넣고 b가 a보다 큰 경우 a와 b, ca와 cb의 값을 바꿔준다.           a가 0보다 큰 경우 아래를 수행하고 a를 감소시킨다.            sb에 ca를 넣고 a가 b보다 큰 경우, sb에 ca를 이어주고 a를 감소시킨다.       b가 0보다 큰 경우, sb에 cb를 넣어 a가 3번 연속되는걸 방지해준다.       b를 감소시켜 b의 수를 감소시킨다.           반복이 완료되어 완성된 sb를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/string-without-aaa-or-bbb/",
        "teaser": null
      },{
        "title": "Leetcode Java Extra Characters in a String",
        "excerpt":"문제  Link   코드  class Solution {    public int minExtraChar(String s, String[] dictionary) {     int length = s.length();     int[] dp = new int[length + 1];     for (int i = length - 1; i &gt;= 0; i--) {       String str = s.substring(i);       dp[i] = dp[i + 1] + 1;       for (int j = 0; j &lt; dictionary.length; j++) {         if (str.startsWith(dictionary[j])) {           dp[i] = Math.min(dp[i], dp[i + dictionary[j].length()]);         }       }     }     return dp[0];   }  }   결과  Link   설명          문자열 s에서 dictionary에 존재하는 문자열을 겹치지 않도록 최적의 방법으로 제거하고 남은 문자열의 수를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 문자열 s의 길이를 저장한 변수이다.       dp는 최적의 방법으로 제거하고 남은 문자열의 수를 계산하기 위한 변수로, $length + 1$ 크기의 정수 배열로 초기화한다.           $length - 1$ 부터 0 이상까지 i를 감소시키며 아래를 반복한다.            str에 s의 i번째 자리 이후의 문자열을 잘라 넣어준다.       dp[i]에 이전 횟수인 dp[$i + 1$]에 1을 더해서 넣어준다.       0부터 dictionary의 길이 미만까지 dictionary의 문자열 중 str의 시작 부분과 일치하는 문자열이 있는 경우, dp[i]에 현재 값과 dp의 일치하는 문자열의 길이에 i를 더한 위치의 값 중 작은 값을 넣어준다.           반복이 완료되면 남은 문자열의 수가 저장된 dp[0]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/extra-characters-in-a-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Sum of Even Numbers After Queries",
        "excerpt":"문제  Link   코드  class Solution {    public int[] sumEvenAfterQueries(int[] nums, int[][] queries) {     int sum = 0;     for (int num : nums) {       if (num % 2 == 0) {         sum += num;       }     }     int[] result = new int[queries.length];     for (int i = 0; i &lt; queries.length; i++) {       int[] query = queries[i];       if (nums[query[1]] % 2 == 0) {         sum -= nums[query[1]];       }       nums[query[1]] += query[0];       if (nums[query[1]] % 2 == 0) {         sum += nums[query[1]];       }       result[i] = sum;     }     return result;   }  }   결과  Link   설명     nums의 값들을 이용해 queries로 값을 변경한 순서대로 짝수의 값들의 합을 반환하는 문제이다.            queries[i] = [value, index]로 구성이 되며, i번째 query는 nums[index]의 값에 value를 더해준다.           문제 풀이에 필요한 변수를 정의한다.            sum은 짝수의 합을 저장할 변수로, nums의 모든 값들 중 짝수만 찾아 더해준다.       result는 query 수행 후 짝수의 합을 저장할 변수로, query의 수행 횟수인 queries의 길이만큼의 크기로 초기화한다.           0부터 queries의 길이 미만까지 i를 증가시키며 아래를 반복한다.            query에 queries의 i번째 배열을 넣어준다.       nums에서 query[1]의 값인 위치에 해당하는 값이 짝수이면 sum에서 해당 값을 빼준다.       nums에서 query[1]의 값인 위치에 해당하는 값에 query[0]의 값을 더해준다.       nums에서 query[1]의 값인 위치에 해당하는 값이 짝수인지 다시 검증하여 sum에 해당 값을 더해준다.       result[i]에 위를 수행하여 저장된 짝수의 합인 sum을 넣어준다.           반복이 완료되어 저장된 결과인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sum-of-even-numbers-after-queries/",
        "teaser": null
      },{
        "title": "Leetcode Java Sum of Even Numbers After Queries",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {     List&lt;int[]&gt; result = new ArrayList&lt;&gt;();     for (int i = 0, j = 0; i &lt; firstList.length &amp;&amp; j &lt; secondList.length;) {       int start = Math.max(firstList[i][0], secondList[j][0]);       int end = Math.min(firstList[i][1], secondList[j][1]);       if (start &lt;= end) {         result.add(new int[] { start, end });       }       if (firstList[i][1] &lt; secondList[j][1]) {         i++;       } else {         j++;       }     }     return result.toArray(new int[0][0]);   }  }   결과  Link   설명          [start, end]로 이루어진 firstList와 secondList를 이용하여 겹치는 지점을 찾는 문제이다.            result는 겹치는 구간을 저장할 변수로, ArrayList로 초기화한다.       i와 j는 두 배열의 위치 변수로, 0부터 둘 중 하나라도 마지막까지 수행할 때 까지 아래를 반복한다.            start에 각 배열의 시작 위치인 firstList[i][0], secondList[j][0] 중 큰 값을 넣어준다.       end에 각 배열의 종료 위치인 firstList[i][1], secondList[j][1] 중 작은 값을 넣어준다.       만일 start가 end보다 같거나 작은 경우, result에 [start, end]로 넣어준다.       종료 위치인 firstList[i][1]가 secondList[j][1] 보다 작은 경우, i를 증가시키고 크면 j를 증가시킨다.           반복이 완료되면 result를 2차원 배열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/interval-list-intersections/",
        "teaser": null
      },{
        "title": "Leetcode Java Smallest String Starting From Leaf",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    private String str;    public String smallestFromLeaf(TreeNode root) {     this.str = null;     this.dfs(root, new StringBuilder());     return this.str;   }    public void dfs(TreeNode root, StringBuilder sb) {     if (root != null) {       char c = (char) (root.val + 97);       sb.append(c);       if (root.left == null &amp;&amp; root.right == null) {         String s = sb.reverse().toString();         if (this.str == null || this.str.compareTo(s) &gt; 0) {           this.str = s;         }         sb.reverse();       }       this.dfs(root.left, sb);       this.dfs(root.right, sb);       sb.deleteCharAt(sb.length() - 1);     }   }  }   결과  Link   설명          영문자 순서 val에 저장된 이진 트리인 root를 이용하여 가장 마지막인 리프 노드부터 루트 노드까지 사전적인 순서가 가장 작은 단어를 구하는 문제이다.            전역변수인 str은 결과를 저장할 변수이다.            str을 null로 초기화하고 4번에서 정의한 dfs(TreeNode root, StringBuilder sb) 메서드에 새 StringBuilder를 초기화하여 넣고 수행한다.       DFS 방식으로 단어를 완성할 dfs(TreeNode root, StringBuilder sb) 메서드를 정의한다.            root가 null인 경우, 수행하지 않는다.       c에 root의 val 값에 영소문자 ‘a’의 값인 97을 더해 문자로 변환하여 넣어준다.       sb에 c를 넣고, root의 left와 right가 null인 리프 노드인 경우, 아래를 수행한다.                    s에 sb의 순서를 역순으로 반전시켜 문자열로 변환한 값을 넣어준다.           전역 변수인 str이 null이거나 str이 s보다 길이가 더 긴 경우, str에 s를 넣어준다.           sb를 다시 반전시켜 원래 순서로 전환시켜준다.                       root의 left TreeNode로 재귀 호출을 수행한 후 right TreeNode로 다시 재귀 호출을 수행한다.       위의 수행이 완료되면 sb에서 마지막 문자를 제거하여 수행 전 문자열로 전환한다.           반복이 완료되면 결과가 저장된 str을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/smallest-string-starting-from-leaf/",
        "teaser": null
      },{
        "title": "Leetcode Java Add to Array-Form of Integer",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; addToArrayForm(int[] num, int k) {     LinkedList&lt;Integer&gt; result = new LinkedList&lt;&gt;();     int length = num.length - 1;     while (length &gt;= 0 || k != 0) {       if (length &gt;= 0) {         k += num[length--];       }       result.addFirst(k % 10);       k /= 10;     }     return result;   }  }   결과  Link   설명          숫자로 이루어진 배열인 num을 이은 숫자와 k의 합을 한 숫자씩 잘라 반환하는 문제이다.       문제 풀이에 필요한 변수이다.            result는 결과를 한 숫자씩 이어 저장할 변수로, 값을 앞으로 넣어주기 위해 LinkedList로 초기화한다.       length는 num의 길이를 저장한 변수이다.           length가 0 이상이거나 k가 0이 아닐 때 까지 아래를 반복한다.            length가 0 이상인 경우, k에 num[length] 값을 더해주고 length를 감소시킨다.       result의 맨 앞에 k를 10으로 나누었을 때 나머지 값을, k에 몫 값을 넣어준다.           반복이 완료되면 두 값을 더해서 숫자 하나씩 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/add-to-array-form-of-integer/",
        "teaser": null
      },{
        "title": "Leetcode Java Satisfiability of Equality Equations",
        "excerpt":"문제  Link   코드  class Solution {    public boolean equationsPossible(String[] equations) {     int[] parent = new int[26];     for (int i = 0; i &lt; 26; i++) {       parent[i] = i;     }     for (String equation : equations) {       if (equation.charAt(1) == '=') {         parent[this.find(parent, equation.charAt(0) - 'a')] = this.find(parent, equation.charAt(3) - 'a');       }     }     for (String equation : equations) {       if (equation.charAt(1) == '!' &amp;&amp; this.find(parent, equation.charAt(0) - 'a') == this.find(parent, equation.charAt(3) - 'a')) {         return false;       }     }     return true;   }    private int find(int[] parent, int i) {     if (parent[i] == i) {       return i;     } else {       return parent[i] = this.find(parent, parent[i]);     }   }  }   결과  Link   설명     아래의 규칙을 만족하는 방정식들이 담긴 equations에 동일한 숫자를 대입하여 만족할 수 있는지 검증하는 문제이다.            equations[i] = xi==yi 혹은 equations[i] = xi!=yi의 4 글자로 이루어져있다.       x와 y의 자리에는 영어 소문자 임의 문자가 들어갈 수 있다.                parent는 값을 유추하여 넣을 변수로, 영문자의 수인 각 위치에 위치 값을 임시로 넣어 초기화한다.       Union Find 방식으로 값을 탐색하기 위한 find(int[] parent, int i) 메서드를 정의한다.            parent[i]의 값과 i가 동일한 경우, i를 반환한다.       위의 경우가 아니라면 parent[i]의 값과 parent와 parent[i]를 이용해 재귀 호출한 결과가 동일한지 여부를 반환한다.           equations의 모든 값을 equation으로 아래를 반복한다.            equation의 두 번째 문자가 ‘=’인 동등 연산의 경우, 3번에서 정의한 find 메서드를 활용하여 parent내 equation의 첫 번째 문자로 수행한 위치에 equation의 네 번째 문자로 수행한 결과를 넣어 값을 매칭시킨다.           equations의 모든 값을 equation으로 아래를 반복한다.            아래의 경우를 모두 만족하면, 동등 연산을 만족하는 경우이므로 false를 주어진 문제의 결과로 반환한다.                    equation의 두 번째 문자가 ‘!’인 부등 연산인 경우.           3번에서 정의한 find 메서드를 활용하여 equation의 첫 번째 문자로 수행한 결과와 equation의 네 번째 문자로 수행한 결과가 동일한 경우.                           반복이 완료되면 모든 연산을 만족하였으므로 true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/satisfiability-of-equality-equations/",
        "teaser": null
      },{
        "title": "Leetcode Java Broken Calculator",
        "excerpt":"문제  Link   코드  class Solution {    public int brokenCalc(int startValue, int target) {     int result = 0;     while (target &gt; startValue) {       if (target % 2 &gt; 0) {         target++;       } else {         target /= 2;       }       result++;     }     return result + startValue - target;   }  }   결과  Link   설명     처음 값이 startValue인 계산기를 이용하여 target이 될 때까지 아래의 연산을 이용하여 수행할 경우 최소 작업 횟수를 구하는 문제이다.            보이는 숫자에 2를 곱해준다.       보이는 숫자에 1을 뺴준다.                result는 최소 작업 횟수를 저장할 변수로, 0으로 초기화한다.       target이 startValue가 될 때까지 아래를 반복한다.            target이 홀수인 경우, target을 증가시켜준다.       target이 짝수인 경우, target에 target을 2로 나눈 값을 넣어준다.       위를 수행하였으므로 result를 증가시켜 횟수를 증가시킨다.           반복이 완료되면 result에 $startValue - target$인 오차 값을 더해 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/broken-calculator/",
        "teaser": null
      },{
        "title": "Leetcode Java Group the People Given the Group Size They Belong To",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; groupThePeople(int[] groupSizes) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     Map&lt;Integer, List&lt;Integer&gt;&gt; groups = new HashMap&lt;&gt;();     for (int i = 0; i &lt; groupSizes.length; i++) {       List&lt;Integer&gt; list = groups.computeIfAbsent(groupSizes[i], k -&gt; new ArrayList&lt;&gt;());       list.add(i);       if (list.size() == groupSizes[i]) {         result.add(list);         groups.put(groupSizes[i], new ArrayList&lt;&gt;());       }     }     return result;   }  }   결과  Link   설명     groupSizes를 이용하여 아래의 규칙을 만족하도록 구성하여 반환하는 문제이다.            groupSizes[i]의 값은 i번째 사람이 정확히 해당 값만큼의 크기의 그룹에 속해야 한다.       각 사람은 한 집단에 속하며, 여러 개의 답이 있으면 그 중 하나를 반환하면 된다.           문제 풀이에 필요한 변수를 정의한다.            result는 그룹 별 인원들을 담을 변수로, ArrayList로 초기화한다.       groups는 각 그룹을 저장할 변수로, HashMap으로 초기화한다.           0부터 groupSizes의 길이 미만까지 i를 증가시키며 아래를 반복한다.            list에 groups 내 키가 groupSizes[i] 번째 값을 꺼내 넣어주고, 해당 값이 존재하지 않으면 새 ArrayList를 넣어준다.       list에 i를 넣어 그룹을 지어준다.       list의 길이가 groupSizes[i]의 값과 동일한 경우, result에 list를 넣고 gruops에 gruopSizes[i]번째 위치에 ArrayList를 넣어 새 그룹으로 초기화한다.           반복이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/group-the-people-given-the-group-size-they-belong-to/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Deletions to Make Character Frequencies Unique",
        "excerpt":"문제  Link   코드  class Solution {    public int minDeletions(String s) {     int[] count = new int[26];     for (char c : s.toCharArray()) {       count[c - 'a']++;     }     Set&lt;Integer&gt; set = new HashSet&lt;&gt;();     int result = 0;     for (int i = 0; i &lt; count.length; i++) {       int freq = count[i];       while (freq &gt; 0) {         if (!set.contains(freq)) {           set.add(freq);           break;         }         freq--;         result++;       }     }     return result;   }  }   결과  Link   설명          문자열 s 내 동일한 문자의 갯수가 유일한 문자열이 되기 위해 삭제할 문자의 갯수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            count는 문자열 s의 각 문자의 갯수를 저장할 변수로, 각 문자 별 갯수를 계산하여 넣어준다.       set은 고유 문자의 갯수를 저장할 변수로, 중복을 제거하기 위해 HashSet으로 초기화한다.       result는 삭제할 문자의 수를 저장할 변수로, 0으로 초기화한다.           0부터 count의 길이 미만까지 i를 증가시키며 아래를 반복한다.            freq는 count의 i번째 값을 꺼내 저장한다.       freq가 0보다 클 때까지 아래를 반복한다.                    set에서 freq가 존재하지 않는 고유한 수인 경우, set에 freq를 넣고 반복을 중단한다.           위의 경우가 아니라면 freq를 감소시키고 삭제한 수인 result를 증가시킨다.                           반복이 완료되면 제거한 문자의 수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-deletions-to-make-character-frequencies-unique/",
        "teaser": null
      },{
        "title": "Leetcode Java Cousins in Binary Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public boolean isCousins(TreeNode root, int x, int y) {     Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();     queue.offer(root);     while (!queue.isEmpty()) {       int size = queue.size();       boolean foundX = false;       boolean foundY = false;       for (int i = 0; i &lt; size; i++) {         TreeNode curr = queue.poll();         if (curr.val == x) {           foundX = true;         }         if (curr.val == y) {           foundY = true;         }         if (curr.left != null &amp;&amp; curr.right != null) {           if ((curr.left.val == x &amp;&amp; curr.right.val == y) || (curr.left.val == y &amp;&amp; curr.right.val == x)) {             return false;           }         }         if (curr.left != null) {           queue.offer(curr.left);         }         if (curr.right != null) {           queue.offer(curr.right);         }       }       if (foundX &amp;&amp; foundY) {         return true;       }     }     return false;   }  }   결과  Link   설명     root에서 x와 y가 사촌 노드의 값인지 검증하는 문제이다.            사촌 노드는 서로 동일한 깊이의 다른 부모 노드를 가진 노드들을 의미한다.                queue는 동일한 깊이의 노드들을 탐색하기 위한 변수로, LinkedList로 초기화하고 root를 초기값으로 넣어준다.       queue가 비어있지 않을 때 까지 아래를 반복한다.            size에 queue의 크기를 넣어준다.       foundX와 foundY는 x와 y를 찾을 변수로, 둘 다 false로 초기화한다.       0부터 size 미만까지 i를 증가시키면서 아래를 반복한다.                    curr에 queue에서 꺼낸 TreeNode를 넣어준다.           curr의 값이 x와 같으면 foundX를 true로, y와 같으면 foundY를 true로 바꾸어준다.           curr의 자식 노드가 모두 존재하는 경우, 자식 노드들의 값이 x와 y인 경우 사촌 노드가 아니므로 false를 주어진 문제의 결과로 반환한다.           curr의 자식 노드들이 존재하면 queue에 좌측부터 순차적으로 넣어준다.                       foundX와 foundY가 true인 사촌 노드이면, true를 주어진 문제의 결과로 반환한다.           반복이 완료되면 사촌 노드가 아니므로, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/cousins-in-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Path With Minimum Effort",
        "excerpt":"문제  Link   코드  class Solution {    public int minimumEffortPath(int[][] heights) {     int row = heights.length;     int col = heights[0].length;     Queue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;((a, b) -&gt; a[2] - b[2]);     int[][] dist = new int[row][col];     int[][] directions = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };     for (int[] r : dist) {       Arrays.fill(r, Integer.MAX_VALUE);     }     dist[0][0] = 0;     queue.add(new int[] { 0, 0, 0 });     while (!queue.isEmpty()) {       int[] curr = queue.poll();       int x = curr[0];       int y = curr[1];       int diff = curr[2];       if (x == row - 1 &amp;&amp; y == col - 1) {         return diff;       }       for (int[] direction : directions) {         int nx = x + direction[0];         int ny = y + direction[1];         if (nx &gt;= 0 &amp;&amp; nx &lt; row &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; col) {           int next = Math.max(diff, Math.abs(heights[nx][ny] - heights[x][y]));           if (next &lt; dist[nx][ny]) {             dist[nx][ny] = next;             queue.add(new int[] { nx, ny, next });           }         }       }     }     return 0;   }  }   결과  Link   설명     heights의 좌측 상단부터 우측 하단까지 이동하기 위한 최소한의 노력을 구하는 문제이다.            최소한의 노력은 이동하는 셀의 절대적 값의 차이이다.           문제 풀이에 필요한 변수를 정의한다.            row와 col은 height의 행과 열의 길이를 저장한 변수이다.       queue는 높이 차이를 오름차순으로 저장하여 관리할 변수로, PriorityQueue로 각 값의 세 번째 값의 차이의 오름차순으로 정렬되도록 초기화하고 첫 값을 [0, 0, 0]으로 넣어준다.       dist는 이동에 대한 절대적 값의 차이를 저장할 변수로, $row \\times col$ 크기의 배열로 초기화하고 모든 값을 Integer의 최댓 값으로 넣어준다.       directions는 이동 방향을 저장할 변수로, 좌우상하 순의 [x, y] 좌표를 넣어준다.           queue가 비어있지 않을 때까지 아래를 반복한다.            curr에 queue의 앞에 있는 값을 꺼내 넣어준 후 x, y, diff에 순차적으로 값을 넣어준다.       현재 위치가 우측 하단의 마지막 위치인 경우, diff을 주어진 문제의 결과로 반환한다.       directions를 direction에 순차적으로 넣고 아래를 반복한다.                    nx에 x와 direction[0]을 더해서, ny에 y와 direction[1]을 더해서 넣어준다.           nx가 [0, row] 범위에 존재하면서 ny가 [0, col] 범위에 존재하는 경우, 아래를 계속 수행하고 아니면 다음 반복을 수행한다.           next에 diff와 heights[nx][ny]의 값과 heights[x][y]의 차잇값 중 큰 값을 넣어준다.           next가 dist[nx][ny]의 값보다 작은 경우, dist[nx][ny]에 next를 넣어주고 queue에 [nx, ny, next]를 넣어준다.                           반복이 완료되면 최소한의 노력으로 이동할 수 없으므로, 0을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/path-with-minimum-effort/",
        "teaser": null
      },{
        "title": "Leetcode Java Rotting Oranges",
        "excerpt":"문제  Link   코드  class Solution {    public int orangesRotting(int[][] grid) {     for (int i = 0; i &lt; grid.length; i++) {       for (int j = 0; j &lt; grid[0].length; j++) {         if (grid[i][j] == 2) {           this.dfs(grid, i, j, 2);         }       }     }     int minutes = 2;     for (int[] row : grid) {       for (int col : row) {         if (col == 1) {           return -1;         }         minutes = Math.max(minutes, col);       }     }     return minutes - 2;   }    private void dfs(int[][] grid, int i, int j, int minutes) {     if (i &gt;= 0 &amp;&amp; i &lt; grid.length &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; grid[0].length &amp;&amp; grid[i][j] != 0 &amp;&amp; (grid[i][j] == 1 || grid[i][j] &gt;= minutes)) {       grid[i][j] = minutes;       this.dfs(grid, i - 1, j, minutes + 1);       this.dfs(grid, i + 1, j, minutes + 1);       this.dfs(grid, i, j - 1, minutes + 1);       this.dfs(grid, i, j + 1, minutes + 1);     }   }  }   결과  Link   설명     아래의 규칙을 만족하는 grid를 이용하여 신선한 오렌지가 없어질 때 까지 걸리는 시간(분)을 반환하는 문제이다.            grid 내 값은 아래를 의미한다.                    0은 빈 셀을 의미한다.           1은 신선한 오렌지를 의미한다.           2는 썩은 오렌지를 의미한다.                       매 시간(분) 마다 썩은 오렌지의 4 방향에 존재하는 신선한 오렌지는 썩게된다.       신선한 오렌지를 모두 썩게할 수 없다면 -1을 반환한다.                0부터 grid.length 미만까지 i를, 0부터 grid[0].length 미만까지 j를 증가시키며 grid[i][j]의 값이 2인 썩은 오렌지이면 3번에서 정의한 dfs(int[][] grid, int i, int j, int minutes) 메서드를 수행한다.       DFS 방식으로 신선한 오렌지가 썩을 때 까지 걸리는 시간을 구하기 위한 dfs(int[][] grid, int i, int j, int minutes) 메서드를 정의한다.            아래의 조건에 모두 해당하는 경우, 현재 위치에서 4 방향으로 minutes를 1 증가시켜 재귀 호출을 수행한다.                    i와 j가 그리드 내 범위에 있는 경우.           gird[i][j]의 값이 0이 아닌 경우.           grid[i][j]의 값이 1인 신선한 오렌지이거나, minutes 이상인 소요 시간(분)이 현재 시간(분) 보다 큰 경우.                                minutes는 소요 시간(분)을 저장할 변수로, 2로 초기화한다.       grid의 모든 값을 순차적으로 아래를 검증한다.            하나라도 신선한 오렌지가 존재하면, -1을 주어진 문제의 결과로 반환한다.       minutes에 minutes와 col 중 큰 값을 저장한다.           반복이 완료되면 minutes에서 초기값인 2를 뺀 값을 주어진 문제의 결과로 반환한다.   해설     minutes를 2로 초기화 하여 계산하는 이유는 썩은 오렌지의 위치에서 시간 계산을 수행할 때, 현재 값 이상으로 적용해야 별도의 배열을 생성하지 않고 grid를 이용하여 내 신선한 오렌지와 빈 칸의 값을 유지하며 시간을 누적 계산 할 수 있다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/rotting-oranges/",
        "teaser": null
      },{
        "title": "Leetcode Java The K Weakest Rows in a Matrix",
        "excerpt":"문제  Link   코드  class Solution {    public int[] kWeakestRows(int[][] mat, int k) {     Queue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;((a, b) -&gt; a[0] != b[0] ? b[0] - a[0] : b[1] - a[1]);     int[] result = new int[k];     for (int i = 0; i &lt; mat.length; i++) {       queue.offer(new int[] { this.find(mat[i]), i });       if (queue.size() &gt; k) {         queue.poll();       }     }     while (k &gt; 0) {       result[--k] = queue.poll()[1];     }     return result;   }    private int find(int[] row) {     int low = 0;     int high = row.length;     while (low &lt; high) {       int mid = low + (high - low) / 2;       if (row[mid] == 1) {         low = mid + 1;       } else {         high = mid;       }     }     return low;   }  }   결과  Link   설명     아래의 규칙을 만족하는 이진 정수 배열인 mat 내 약한 순서대로 k개의 행 위치 값을 반환하는 문제이다.            mat내 값은 0(민간인), 1(군인)으로 구성되며 군인은 민간인 앞에 위치한다.       아래 중 하나를 만족하는 경우, i가 j보다 약하다.                    i열의 군인의 수가 j열의 군인의 수보다 작다.           i열과 j열의 군인의 수가 같으면서, i &lt; j 를 만족한다.                           문제 풀이에 필요한 변수를 정의한다.            queue는 크기 순으로 행과 군인의 수를 저장할 변수로, 군인의 수가 같지 않으면 행의 위치 차이로 아니면 군인 수의 차이로 내림차순 정렬하여 저장할 수 있도록 초기화한다.       result는 결과를 저장할 변수로, k 크기의 정수 배열로 초기화한다.           0부터 mat의 길이 미만까지 i를 증가시키며 아래를 반복한다.            queue에 4번에서 정의한 find(int[] row) 메서드를 mat[i]로 수행한 결과와 i를 배열로 넣어준다.       queue의 크기가 k보다 큰 경우, 가장 큰 값인 앞의 값을 꺼내서 queue에서 제거한다.           군인의 수를 탐색하기 위한 find(int[] row) 메서드를 정의한다.            low와 high는 마지막 군인의 위치를 탐색할 변수로, 0과 row의 길이로 초기화한다.       low가 high보다 작을 때 까지 아래를 반복한다.                    mid에 $low + \\frac{high - low}{2}$인 중앙값을 넣어준다.           row[mid]가 1(군인)인 경우, low에 $mid + 1$을 넣고 아니면 high에 mid를 넣어준다.                       반복이 완료되면 마지막 군인의 위치인 low를 반환한다.           k가 0 이상일 때 까지 k를 감소시키며 result의 역순으로 queue의 값을 꺼내 넣어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/the-k-weakest-rows-in-a-matrix/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Operations to Reduce X to Zero",
        "excerpt":"문제  Link   코드  class Solution {    public int minOperations(int[] nums, int x) {     int sum = 0;     for (int num : nums) {       sum += num;     }     int max = -1;     int curr = 0;     for (int left = 0, right = 0; right &lt; nums.length; right++) {       curr += nums[right];       while (left &lt;= right &amp;&amp; curr &gt; sum - x) {         curr -= nums[left++];       }       if (curr == sum - x) {         max = Math.max(max, right - left + 1);       }     }     return max == -1 ? -1 : nums.length - max;   }  }   결과  Link   설명     nums의 좌측과 우측의 값을 하나씩 더해서 x가 되는 최소 횟수를 구하는 문제이다.            단, 값이 없는 경우 -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            sum은 nums의 모든 값의 합을 저장할 변수로, nums의 모든 값을 더한 값을 넣어준다.       max는 남은 값의 최대 갯수를 저장할 변수로, -1로 초기화한다.       curr은 현재까지 합을 저장할 변수로, 0으로 초기화한다.           left와 right는 제거한 숫자의 좌측과 우측의 위치를 저장할 변수로, 둘 다 0으로 초기화하고 right가 nums의 길이 미만까지 증가시키며 아래를 반복한다.            curr에 nums[right]의 값을 더해준다.       left가 right보다 같거나 작고, curr이 $sum - x$보다 클 때 까지 curr에 nums[left]의 값을 빼고 left를 증가시킨다.       curr이 $sum - x$와 동일한 경우, max에 max와 $right - left + 1$인 잔여 값의 갯수 중 큰 값을 저장한다.           반복이 완료되면 max가 -1인지 검증하여 -1이면 -1을, 아니면 nums의 길이에서 max를 뺀 최소 횟수를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-operations-to-reduce-x-to-zero/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Number of K Consecutive Bit Flips",
        "excerpt":"문제  Link   코드  class Solution {    public int minKBitFlips(int[] nums, int k) {     int length = nums.length;     int curr = 0;     int result = 0;     for (int i = 0; i &lt; length; i++) {       if (i &gt;= k &amp;&amp; nums[i - k] &gt; 1) {         curr--;         nums[i - k] -= 2;       }       if (curr % 2 == nums[i]) {         if (i + k &gt; length) {           return -1;         }         nums[i] += 2;         curr++;         result++;       }     }     return result;   }  }   결과  Link   설명     0과 1로 이루어진 num의 값을 연속된 k개의 값을 뒤집을 때, 0이 없어지기 위한 최소 횟수를 구하는 문제이다.            0을 모두 없앨 수 없으면, -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       curr은 현재 위치를 저장할 변수로, 0으로 초기화한다.       result는 최소 횟수를 저장할 변수로, 0으로 초기화한다.           0부터 length 미만까지 i를 증가시키며 아래를 반복한다.            i가 k 이상이면서 num의 $i - k$번째 값이 1보다 큰 경우, 뒤집은 이력이 있으므로 curr을 감소시키고 nums의 $i - k$번째 값을 2 감소시킨다.       curr을 2로 나눈 나머지가 nums[i]와 같은 경우, 아래를 수행한다.                    $i + k$가 length보다 큰 경우, 0을 모두 없앨 수 없으므로 -1을 주어진 문제의 결과로 반환한다.                       nums[i]에 2를 증가시키고, curr과 result를 증가시켜 다음 위치로 이동하면서 뒤집은 횟수를 증가시킨다.           반복이 완료되면 뒤집은 횟수인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-number-of-k-consecutive-bit-flips/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest String Chain",
        "excerpt":"문제  Link   코드  class Solution {    public int longestStrChain(String[] words) {     Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();     Arrays.sort(words, (a, b) -&gt; a.length() - b.length());     int result = 0;     for (String word : words) {       int max = 0;       for (int i = 0; i &lt; word.length(); i++) {         max = Math.max(max, map.getOrDefault(word.substring(0, i) + word.substring(i + 1), 0) + 1);       }       map.put(word, max);       result = Math.max(result, max);     }     return result;   }  }   결과  Link   설명          words 내 한 단어씩 붙여서 다음 단어를 만들 수 있는 문자열의 가장 많은 연결 문자열 갯수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            map은 문자열 별 연결 횟수를 저장하기 위한 변수로, HashMap으로 초기화한다.       result는 가장 많은 연결 문자열의 갯수를 저장할 변수로, 0으로 초기화한다.                words를 짧은 문자열순으로 정렬한다.       words의 모든 문자열을 word에 넣고 아래를 반복한다.            max는 word를 이용하여 가장 많은 연결 문자열의 갯수를 저장할 변수로, 0으로 초기화한다.       0부터 word의 길이 미만까지 i를 증가시키며 아래를 수행한다.                    max에 max와 map에서 word의 처음부터 i번째 자리까지 문자열과 $i + 1$번째부터 끝까지 문자열을 이어준 key의 값을 꺼내 1을 더한 값 중 큰 값을 넣어준다.                       map에 word와 max를 넣어 word까지 최대 연결 횟수를 저장한다.       result에 result와 max 중 가장 큰 값을 넣어준다.           반복이 완료되면 가장 많은 연결 문자열의 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-string-chain/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Squareful Arrays",
        "excerpt":"문제  Link   코드  class Solution {    public int numSquarefulPerms(int[] nums) {     return this.dfs(nums, 0);   }    private int dfs(int[] nums, int index) {     if (index &gt;= nums.length) {       return 1;     }     int sum = 0;     for (int i = index; i &lt; nums.length; i++) {       if (!this.isSwapable(nums, index, i)) {         continue;       }       this.swap(nums, index, i);       if (index == 0 || this.isSquareful(nums, index)) {         sum += this.dfs(nums, index + 1);       }       this.swap(nums, index, i);     }     return sum;   }    private boolean isSwapable(int[] nums, int i, int j) {     while (i &lt; j) {       if (nums[i++] == nums[j]) {         return false;       }     }     return true;   }    private void swap(int[] nums, int i, int j) {     int temp = nums[i];     nums[i] = nums[j];     nums[j] = temp;   }    private boolean isSquareful(int[] nums, int idx) {     int sqrt = (int) Math.sqrt(nums[idx] + nums[idx - 1]);     return (sqrt * sqrt) == (nums[idx] + nums[idx - 1]);   }  }   결과  Link   설명     nums의 좌우 값의 합이 완전 제곱이 되도록 정렬 가능한 경우의 수를 반환하는 문제이다.            완전 제곱은 한 정수에 대한 제곱 값에 해당하는 경우를 의미한다.                3번에서 정의한 dfs(int[] nums, int index) 메서드의 index에 0을 넣어 수행한 결과를 주어진 문제의 결과로 반환한다.       DFS 방식으로 검증할 dfs(int[] nums, int index) 메서드를 정의한다.            index가 nums의 길이 이상인 경우, 다음 검증이 불가능하므로 1을 반환한다.       sum은 경우의 수를 더할 변수로, 0으로 초기화한다.       index부터 nums의 길이 미만까지 i를 증가시켜 아래를 반복한다.                    동일한 수가 이어져 스왑이 필요 없는 경우, 다음 반복을 수행한다.           nums의 index번째 값과 i번째 값을 스왑해준다.           index가 0이거나 완전 제곱을 만족하는 경우, sum에 $index + 1$로 재귀 호출을 수행한 결과를 더해준다.           위의 수행이 완료되면 nums의 index번째 값과 i번째 값을 스왑하여 원복해준다.                       반복이 완료되면 sum을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-squareful-arrays/",
        "teaser": null
      },{
        "title": "Leetcode Java Sort Array By Parity",
        "excerpt":"문제  Link   코드  class Solution {    public int[] sortArrayByParity(int[] nums) {     for (int i = 0, j = 0; j &lt; nums.length; j++) {       if (nums[j] % 2 == 0) {         int temp = nums[i];         nums[i++] = nums[j];         nums[j] = temp;       }     }     return nums;   }  }   결과  Link   설명          nums의 짝수 값을 배열 앞으로, 홀수 값을 배열 뒤로 이동시키는 문제이다.       i와 j는 홀수와 짝수 값의 위치를 저장할 변수로, 둘 다 0으로 초기화 시키고 j가 nums의 길이 미만까지 증가시키며 아래를 반복한다.            nums[j]의 값이 짝수인 경우, i와 j의 값의 위치를 바꿔준다.           반복이 완료되면 정렬된 nums를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-squareful-arrays-copy/",
        "teaser": null
      },{
        "title": "Leetcode Java Find the Town Judge",
        "excerpt":"문제  Link   코드  class Solution {    public int findJudge(int n, int[][] trust) {     int[] count = new int[n + 1];     for (int[] t : trust) {       count[t[0]]--;       count[t[1]]++;     }     for (int i = 1; i &lt;= n; i++) {       if (count[i] == n - 1) {         return i;       }     }     return -1;   }  }   결과  Link   설명     n개의 [a, b]의 값이 있는 trust 배열 내 값으로 아래를 검증한 결과를 반환한다.            a는 b를 가르키며, b의 값이 아무도 가르키지 않으면 해당 값을 반환한다.       위의 경우가 존재하지 않으면 -1을 반환한다.                count는 서로 연결되어 있는지 검증하기 위한 배열로, $n + 1$ 크기의 배열로 초기화한다.            trust의 모든 값을 반복하여 count의 첫 값에 해당하는 값은 감소, 두 번째 값에 해당하는 값은 증가시켜준다.            1부터 n 이하까지 i를 증가시키며 count 값이 $n - 1$에 해당하면 해당 숫자를 모두 가르키므로 해당 값을 주어진 문제의 결과로 반환한다.       반복이 완료되면 -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-the-town-judge/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Binary Tree II",
        "excerpt":"문제  Link   코드  class Solution {    public TreeNode insertIntoMaxTree(TreeNode root, int val) {     if (root == null || val &gt; root.val) {       TreeNode treeNode = new TreeNode(val);       treeNode.left = root;       return treeNode;     } else {       root.right = this.insertIntoMaxTree(root.right, val);       return root;     }   }  }   결과  Link   설명     이진 트리 노드인 root에 val에 해당하는 노드를 이어주는 문제이다.            단, b는 a에 존재하지 않는 값이다.           root가 null이거나 val이 root의 val 값보다 큰 경우, 아래를 수행한다.            treeNode에 val을 이용하여 새 TreeNode를 생성하여 treeNode의 left 자식 노드에 root를 넣은 후 treeNode를 반환한다.           위의 경우가 아니라면 root의 right 자식 노드 자리에 root의 right TreeNode를 이용하여 재귀 호출한 결과를 넣어주고 root를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-binary-tree-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove Colored Pieces if Both Neighbors are the Same Color",
        "excerpt":"문제  Link   코드  class Solution {    public boolean winnerOfGame(String colors) {     char[] charArray = colors.toCharArray();     int sum = 0;     for (int i = 1; i &lt; charArray.length - 1; i++) {       if (charArray[i] == charArray[i - 1] &amp;&amp; charArray[i] == charArray[i + 1]) {         if (charArray[i] == 'A') {           sum++;         } else {           sum--;         }       }     }     return sum &gt; 0;   }  }   결과  Link   설명          ‘A’와 ‘B’ 문자로 이루어진 colors를 이용하여 좌우 문자가 동일한 문자의 갯수가 ‘B’보다 ‘A’가 더 많은지 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            charArray는 colors를 문자열로 변환하여 저장한 변수이다.       sum은 좌우 문자가 동일한 ‘A’ 문자의 갯수를 저장하기 위한 변수로, 0으로 초기화시켜준다.           1부터 charArray의 길이보다 1 작은 값 미만까지 i를 증가시키며 아래를 반복한다.            charArray[i]의 좌우 문자가 같은 경우, 해당 문자가 ‘A’면 sum을 증가 ‘B’면 sum을 감소시킨다.           sum이 0보다 큰지 검증한 결과를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-colored-pieces-if-both-neighbors-are-the-same-color/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Good Pairs",
        "excerpt":"문제  Link   코드  class Solution {    public int numIdenticalPairs(int[] nums) {     int result = 0;     int[] count = new int[101];     for (int num : nums) {       result += count[num]++;     }     return result;   }  }   결과  Link   설명          nums 배열 내 동일한 값의 위치를 짝을 지을 경우, 가능한 경우의 수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 경우의 수를 저장하기 위한 변수로, 0으로 초기화한다.       count는 동일한 값 별로 갯수를 저장할 배열로, 값의 최댓값인 100보다 1 큰 101 크기의 정수 배열로 초기화한다.           nums의 모든 값을 반복하여 count의 해당 값을 증가시키고 result에 해당 값을 더해준다.            n이란 값의 동일한 갯수가 증가할 경우, n!의 짝을 만들 수 있다.           반복이 완료되면 겅우의 수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-good-pairs/",
        "teaser": null
      },{
        "title": "Leetcode Java Available Captures for Rook",
        "excerpt":"문제  Link   코드  class Solution {    private int[][] directions = new int[][] {     { 0, 1 },     { 1, 0 },     { 0, -1 },     { -1, 0 }   };    public int numRookCaptures(char[][] board) {     for (int i = 0; i &lt; 8; i++) {       for (int j = 0; j &lt; 8; j++) {         if (board[i][j] == 'R') {           return this.numRookCaptures(board, i, j, directions[0])              + this.numRookCaptures(board, i, j, directions[1])              + this.numRookCaptures(board, i, j, directions[2])              + this.numRookCaptures(board, i, j, directions[3]);         }       }     }     return 0;   }    private int numRookCaptures(char[][] board, int x, int y, int[] direction) {     while (x &gt;= 0 &amp;&amp; x &lt; 8 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; 8 &amp;&amp; board[x][y] != 'B') {       if (board[x][y] == 'p') {         return 1;       } else {         x += direction[0];         y += direction[1];       }     }     return 0;   }  }   결과  Link   설명     $8 \\times 8$ 크기의 체스판에서 아래의 체스말들로 흰 룩이 잡을 수 있는 검정색 폰의 갯수를 구하는 문제이다.            체스판의 각 공간의 값은 아래와 같다.                    ‘R’은 흰색 룩을 의미한다.           ‘B’는 흰색 비숍을 의미한다.           ‘p’는 검정색 폰을 의미한다.           ’.’은 빈 공간을 의미한다.                       룩은 네 방향(북, 동, 남, 서) 중 하나의 방향으로 원하는 횟수만큼 이동이 가능하며, 아래의 경우 멈춘다.                    체스판의 끝인 경우.           검정색 폰을 잡은 경우.           흰색 비숍이 앞에 있는 경우.                                전역 변수인 directions는 룩의 이동 방향을 저장할 변수로, 북동남서 순으로 [x, y] 좌표를 넣어 초기화한다.       0부터 8미만까지 i를, 0부터 8미만까지 y를 증가시키며 아래를 반복한다.            board[i][j]가 ‘R’인 흰색 룩인 경우, 4번에서 정의한 numRookCaptures(char[][] board, int x, int y, int[] direction) 메서드를 수행한 결과를 directions의 순서대로 수행한 결과의 합을 주어진 문제의 결과로 반환한다.           주어진 좌표인 [x, y]에서 이동 방향인 direction을 이동하며 잡을 수 있는 검정색 폰을 탐색하기 위한 numRookCaptures(char[][] board, int x, int y, int[] direction) 메서드를 정의한다.            x와 y가 0 ~ 7 범위 내까지 board[x][y]가 ‘B’인 흰색 비숍이 아닌 경우일 때까지 아래를 반복한다.                    board[x][y]가 ‘p’인 검정색 폰인 경우, 잡은 횟수인 1을 반환한다.           위의 경우가 아니라면 direction 방향으로 x와 y를 더한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/available-captures-for-rook/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Cost to Merge Stones",
        "excerpt":"문제  Link   코드  class Solution {    public int mergeStones(int[] stones, int k) {     int length = stones.length;     if ((length - 1) % (k - 1) &gt; 0) {       return -1;     }     int[] sum = new int[length + 1];     for (int i = 0; i &lt; length; i++) {       sum[i + 1] = sum[i] + stones[i];     }     int[][] dp = new int[length][length];     for (int end = k; end &lt;= length; end++) {       for (int start = 0; start + end &lt;= length; start++) {         int max = start + end - 1;         dp[start][max] = Integer.MAX_VALUE;         for (int mid = start; mid &lt; max; mid += k - 1) {           dp[start][max] = Math.min(dp[start][max], dp[start][mid] + dp[mid + 1][max]);         }         if ((max - start) % (k - 1) == 0) {           dp[start][max] += sum[max + 1] - sum[start];         }       }     }     return dp[0][length - 1];   }  }   결과  Link   설명          stones 내 연속된 k개의 값을 더해 최후의 하나의 값을 만들기 위한 각 부분 합을 더한 값이 최소가 되는 값을 구하는 문제이다.            length는 stones의 길이를 저장한 변수이다.            $\\frac{length - 1}{k - 1}$의 결과가 정수로 떨어지지 않은 경우, k개씩 값을 더해서 최후의 하나의 값이 되지 않으므로 -1을 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            sum은 각 위치 별 합계를 저장할 변수로, $length + 1$ 크기로 초기화하고 두 번째 위치부터 이전까지 값들의 합을 더해 넣어준다.       dp는 부분 합을 더한 값이 최소가 되는 값을 찾기 위한 배열로, $length \\times length$ 크기의 2차원 배열로 초기화한다.           k부터 length 이하까지 end를 증가시키고, 0부터 $start + end$가 length 이하일 때 까지 start를 증가시키며 아래를 반복한다.            max는 start번째 반복의 최대 위치인 $start + end - 1$을 넣어준다.       dp[start][max]의 값에 정수의 최댓값을 넣어준다.       start부터 max 미만까지 mid를 $k - 1$씩 증가시키며 아래를 수행한다.                    dp[start][max]의 값에 dp[start][max]의 값과 dp[start][mid]의 값에 dp[$mid + 1$][max]의 값을 더한 값 중 작은 값을 넣어준다.                       $\\frac{max - start}{k - 1}$의 결과가 정수로 떨어지는 경우, dp[start][max]에 sum[max + 1]의 값에 sum[start]의 값을 뺀 start번째 값에서 max까지의 값의 합을 더해준다.           반복이 완료되면 문제의 조건에 대한 값이 최소가 되는 dp[0][$length - 1$]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-cost-to-merge-stones/",
        "teaser": null
      },{
        "title": "Leetcode Java Max Dot Product of Two Subsequences",
        "excerpt":"문제  Link   코드  class Solution {    public int maxDotProduct(int[] nums1, int[] nums2) {     int nums1Length = nums1.length;     int nums2Length = nums2.length;     int[][] dp = new int[nums1Length + 1][nums2Length + 1];     for (int[] r : dp) {       Arrays.fill(r, Integer.MIN_VALUE);     }     for (int i = 0; i &lt; nums1Length; i++) {       for (int j = 0; j &lt; nums2Length; j++) {         dp[i + 1][j + 1] = Math.max(Math.max(dp[i][j + 1], dp[i + 1][j]),             (nums1[i] * nums2[j]) + Math.max(0, dp[i][j]));       }     }     return dp[nums1Length][nums2Length];   }  }   결과  Link   설명          nums1의 임의 위치에서 nums2와의 스칼라곱이 최댓값을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            nums1Length와 nums2Length은 nums1과 nums2의 길이를 저장한 변수이다.       dp는 최댓값을 구하기 위한 배열로, $(nums1Length + 1) \\times (nums2Length + 1)$ 크기의 2차원 정수 배열로 초기화하고 모든 값에 정수의 가장 작은 값을 넣어준다.           0부터 nums1Length 미만까지 i를 증가시키고, 0부터 nums2Length 미만까지 j를 증가시키며 아래를 반복한다.            dp[$i + 1$][$j + 1$] 위치에 아래의 값들 중 큰 값을 넣어준다.                    dp[i][$j + 1$]의 값과 dp[$i + 1$][j]의 값 중 큰 값.           $nums1[i] \\times nums2[j]$의 값에 이전 값이 존재하면 dp[i][j]를 아니면 0을 더한 값.                           반복이 완료되면 최댓값이 저장된 dp[nums1Length][nums2Length]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/max-dot-product-of-two-subsequences/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Number of Operations to Make Array Continuous",
        "excerpt":"문제  Link   코드  class Solution {    public int minOperations(int[] nums) {     Arrays.sort(nums);     int result = Integer.MAX_VALUE;     int count = 0;     int[] dp = new int[nums.length];     for (int i = 0, j = 1; i &lt; nums.length; i++) {       while (j &lt; nums.length &amp;&amp; nums[j] &lt;= nums[i] + nums.length - 1) {         if (nums[j - 1] == nums[j]) {           count++;         }         dp[j++] = count;       }       result = Math.min(result, i + (nums.length - j) + count - dp[i]);     }     return result;   }  }   결과  Link   설명          nums 내 숫자들이 연속되도록 구성하고자할 때, 바꿀 최소 숫자의 갯수를 구하는 문제이다.            nums의 숫자들을 오름차순으로 정렬한다.       문제 풀이에 필요한 변수를 정의한다.            result는 최소 숫자의 갯수를 저장할 변수로, 정수의 최댓값으로 초기화한다.       count는 바꿀 숫자의 갯수를 계산할 변수로, 0으로 초기화한다.       dp는 최소 숫자의 갯수를 계산하기 위한 배열로, nums의 길이 크기의 정수 배열로 초기화한다.           0부터 nums의 길이 미만까지 i를 증가시키고 j는 1로 초기화 시켜 아래를 반복한다.            j가 nums의 길이 미만이면서 nums[j]의 값이 $nums[i] + nums.length - 1$보다 같거나 작을 때 까지 아래를 반복한다.                    nums의 $j - 1$번째 숫자와 j번째 숫자가 동일한 경우, 값을 바꿔야 하므로 count를 증가시킨다.           dp의 j번째 위치에 count를 넣어주고 j를 증가시킨다.                       result에 이전에 계산한 최소 갯수인 result와 $i + (nums.length - j) + count - dp[i]$인 [i, j] 사이 값을 정렬하고 다른 값을 변경할 경우 중 작은 값을 넣어준다.           반복이 완료되면 최소 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-number-of-operations-to-make-array-continuous/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Flowers in Full Bloom",
        "excerpt":"문제  Link   코드  class Solution {    public int[] fullBloomFlowers(int[][] flowers, int[] people) {     int length = flowers.length;     int[] start = new int[length];     int[] end = new int[length];     for (int i = 0; i &lt; length; i++) {       start[i] = flowers[i][0];       end[i] = flowers[i][1];     }     Arrays.sort(start);     Arrays.sort(end);     length = people.length;     int[] result = new int[length];     for (int i = 0; i &lt; length; i++) {       result[i] = this.getIndex(start, people[i] + 1) - this.getIndex(end, people[i]);     }     return result;   }    private int getIndex(int[] flowers, int target) {     int left = 0;     int right = flowers.length - 1;     while (left &lt; right) {       int mid = left + (right - left) / 2;       if (flowers[mid] &lt; target) {         left = mid + 1;       } else {         right = mid;       }     }     return flowers[left] &gt;= target ? left : left + 1;   }  }   결과  Link   설명     people의 위치에 도달할 때 flowers의 개화된 꽃의 갯수를 반환하는 문제이다.            flowers[i] = [starti, endi]로, 개화와 낙화의 지점이 저장되어 있다.           문제 풀이에 필요한 변수를 정의한다.            length는 flowers의 길이를 저장한 변수이다.       start와 end는 flowers의 꽃의 개화 시기와 낙화 시기를 넣을 배열로, 각각 length 크기의 정수 배열로 초기화하여 flowers를 이용하여 꽃의 개화와 낙화 지점를 넣고 오름차순 정렬해준다.                    start와 end를 오름차순으로 정렬하더라도 각 위치에서 개화된 꽃의 수는 변함이 없다.                       length에 people의 길이를 저장해준다.       result는 결과를 저장할 변수로, length 길이의 정수 배열로 초기화한다.           0부터 length 미만까지 i를 증가시키며 아래를 반복한다.            result[i] 위치에 4번에서 정의한 getIndex(int[] flowers, int target) 메서드를 start, $people[i] + 1$로 수행한 결과와 end, people[i]로 수행한 결과의 차잇값인 개화된 꽃의 수를 넣어준다.           flowers의 target 위치에서 개화된 꽃의 시작과 종료 위치를 탐색하기 위한 getIndex(int[] flowers, int target) 메서드를 정의한다.            left와 right는 위치 탐색에 필요한 변수로, 0과 $flowers.length - 1$로 초기화한다.       left가 right 미만일 때 까지 아래를 반복한다.                    mid에 $left + \\frac{right - left}{2}$인 중앙값을 넣어준다.           flowers[mid]가 target 미만인 경우, left에 $mid + 1$을 넣어 하한 범위를 높혀준다.           위의 경우가 아니라면, right에 mid를 넣어 상한 범위를 낮혀준다.                       flowers[left]의 값이 target 이상이면 left를 아니면 $left + 1$를 반환한다.           반복이 완료되면 위치 별 개화된 꽃의 수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-flowers-in-full-bloom/",
        "teaser": null
      },{
        "title": "Leetcode Java Find in Mountain Array",
        "excerpt":"문제  Link   코드  /**  * // This is MountainArray's API interface.  * // You should not implement it, or speculate about its implementation  * interface MountainArray {  *     public int get(int index) {}  *     public int length() {}  * }  */   class Solution {    public int findInMountainArray(int target, MountainArray mountainArr) {     int length = mountainArr.length();     int peak = 0;     for (int left = 0, right = length - 1; left &lt; right;) {       int mid = (left + right) / 2;       if (mountainArr.get(mid) &lt; mountainArr.get(mid + 1)) {         left = peak = mid + 1;       } else {         right = mid;       }     }     for (int left = 0, right = peak; left &lt;= right;) {       int mid = (left + right) / 2;       int high = mountainArr.get(mid);       if (high == target) {         return mid;       } else if (high &gt; target) {         right = mid - 1;       } else {         left = mid + 1;       }     }     for (int left = peak, right = length - 1; left &lt;= right;) {       int mid = (left + right) / 2;       int high = mountainArr.get(mid);       if (high == target) {         return mid;       } else if (high &lt; target) {         right = mid - 1;       } else {         left = mid + 1;       }     }     return -1;   }  }   결과  Link   설명     MountainArray를 이용하여 target에 해당하는 최소 위치를 반환하는 문제이다.            단, target에 해당하는 높이가 MountainArray에 존재하지 않으면 -1을 주어진 문제의 결과로 반환한다.       MountainArray는 최소 3개 이상의 정수로 이루어져 있으며, 산꼭대기를 기준으로 좌측과 우측의 높이는 계속 감소한다.       MountainArray의 length() 메서드는 산의 길이를 반환한다.       MountainArray의 get(int index) 메서드는 index번째 위치에서 산의 높이를 반환하며, 100번 이상 호출하는 경우 오답으로 취급한다.           문제 풀이에 필요한 변수를 정의한다.            length는 mountainArr의 length() 메서드를 호출하여 길이를 저장한 변수이다.       peak는 산꼭대기를 저장할 변수로, 0으로 초기화한다.           left는 0, right는 $length - 1$로 초기화하고 left가 right 미만까지 아래를 반복하여 산꼭대기 위치를 peak에 넣어준다.            mid는 중앙값을 저장할 변수로, $\\frac{left + right}{2}$로 초기화한다.       mountainArr의 mid번째 높이가 $mid + 1$보다 작은 경우, left와 peak에 $mid + 1$을 넣어 하한 위치를 증가시킨다.       위의 경우가 아니라면, right에 mid를 넣어 상한 위치를 감소시킨다.           left는 0, right는 peak로 초기화하고 left가 right 이하일 때 까지 아래를 반복하여 산의 좌측 능선에서 target에 해당하는 위치를 탐색한다.            mid는 중앙값을 저장할 변수로, $\\frac{left + right}{2}$로 초기화한다.       high는 mountainArr의 mid번째 높이를 가져와 넣어준다.       high가 target과 동일한 경우, 가장 작은 좌측 능선에 대한 위치이므로 mid를 주어진 문제의 결과로 반환한다.       high가 target보다 큰 경우, $mid - 1$을 넣어 상한 위치를 감소시킨다.       위의 모든 경우가 아닌 경우, left에 $mid + 1$을 넣어 하한 위치를 증가시킨다.           위에서 존재하지 않는다면 left는 peak, right는 $length - 1$로 초기화하고 left가 right 이하일 때 까지 아래를 반복하여 산의 우측 능선에서 target에 해당하는 위치를 탐색한다.            mid는 중앙값을 저장할 변수로, $\\frac{left + right}{2}$로 초기화한다.       high는 mountainArr의 mid번째 높이를 가져와 넣어준다.       high가 target과 동일한 경우, 가장 작은 좌측 능선에 대한 위치이므로 mid를 주어진 문제의 결과로 반환한다.       high가 target보다 큰 경우, $mid - 1$을 넣어 상한 위치를 감소시킨다.       위의 모든 경우가 아닌 경우, left에 $mid + 1$을 넣어 하한 위치를 증가시킨다.           모든 반복이 완료되면 mountainArr의 각 위치 별 높이에서 target에 해당하는 높이가 존재하지 않으므로, -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-in-mountain-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Common Characters",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; commonChars(String[] words) {     int length = words.length;     int[][] count = new int[length][26];     for (int i = 0; i &lt; length; i++) {       for (int j = 0; j &lt; words[i].length(); j++) {         count[i][words[i].charAt(j) - 'a']++;       }     }     List&lt;String&gt; result = new ArrayList&lt;&gt;();     for (int j = 0; j &lt; 26; j++) {       int min = 101;       for (int i = 0; i &lt; length; i++) {         min = Math.min(min, count[i][j]);       }       while (min-- &gt; 0) {         result.add(String.valueOf((char) (j + 'a')));       }     }     return result;   }  }   결과  Link   설명     words 문자열 내 공통된 문자들을 추려내는 문제이다.            단, 반복된 문자열이 동일한 갯수로 존재하면 동일한 갯수로 넣어준다.           문제 풀이에 필요한 변수를 정의한다.            length는 words의 길이를 저장한 변수이다.       count는 각 문자 별 문자의 수를 저장할 변수로, $length \\times 26$ 크기의 정수 배열로 초기화하고 각 문자를 활용하여 문자열 별 문자의 갯수를 계산해서 넣어준다.       result는 결과를 넣을 변수로, ArrayList로 초기화한다.           영문자의 갯수인 0부터 26미만까지 j를 증가시키며 아래를 반복한다.            min은 최대 갯수인 100보다 큰 101로 초기화하고, 0부터 length 미만까지 i를 증가시키며 min에 min과 count[i][j]의 값 중 작은 값을 넣어준다.       min이 0보다 클 때 까지 result에 영소문자 j번째 문자를 result에 넣어준다.           반복이 완료되면 공통된 문자들이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-common-characters/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Ways to Stay in the Same Place After Some Steps",
        "excerpt":"문제  Link   코드  class Solution {    public int numWays(int steps, int arrLen) {     int length = Math.min(steps, arrLen);     long[][] dp = new long[steps + 1][length + 1];     dp[0][0] = 1;     for (int i = 0; i &lt; steps; i++) {       for (int j = 0; j &lt; length; j++) {         dp[i + 1][j] = (dp[i][j] + dp[i][j + 1] + (j &gt; 0 ? dp[i][j - 1] : 0)) % 1000000007;       }     }     return (int) dp[steps][0];   }  }   결과  Link   설명     arrLen 크기의 배열의 첫 위치에서 steps번 이동 혹은 이동하지 않는 선택을 통해 첫 위치로 끝날 수 있는 경우의 수를 구하는 문제이다.            단, 방법의 수가 매우 클 수 있으므로 모듈러 $10^9 + 7$를 사용하여 값을 계산한다.           문제 풀이에 필요한 변수를 저의한다.            length는 최대 이동 가능 거리를 저장할 변수로, steps와 arrLen 중 작은 값을 넣어준다.       dp는 경우의 수를 계산하기 위한 배열로, $(steps + 1) \\times (length + 1)$ 크기의 2차원 정수 배열로 초기화하고 첫 값에 1을 넣어준다.           0부터 steps 미만까지 i를 증가시키고, 0부터 length 미만까지 j를 증가시키며 아래를 수행한다.            dp[$i + 1$][j] 위치에 아래의 값들을 더한 후 $10^9 + 7$로 나눈 값을 넣어준다.                    이전 위치까지 이동 횟수인 dp[i][j]의 값           이전 위치에서 이동 범위를 늘린 dp[i][$j + 1$]의 값           j가 0보다 큰 이동 범위가 존재하는 경우, 이전 위치까지의 경우의 수인 dp[i][$j - 1$]의 값 혹은 첫 수행인 경우 0.                           반복이 완료되면 경우의 수가 저장된 dp[steps][0]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-ways-to-stay-in-the-same-place-after-some-steps/",
        "teaser": null
      },{
        "title": "Leetcode Java Check If Word Is Valid After Substitutions",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isValid(String s) {     String abc = \"abc\";     while (s.contains(abc)) {       s = s.replace(abc, \"\");     }     return s.isEmpty();   }  }   결과  Link   설명          “abc” 문자열을 이용하여 문자열 s를 만들 수 있는지 검증하는 문제이다.            s 문자열에서 “abc” 문자열이 존재하면 하나 씩 제거한 후, 빈 문자열인지 검증한 결과를 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/check-if-word-is-valid-after-substitutions/",
        "teaser": null
      },{
        "title": "Leetcode Java Check Max Consecutive Ones III",
        "excerpt":"문제  Link   코드  class Solution {    public int longestOnes(int[] nums, int k) {     int i = 0;     int j = 0;     while (j &lt; nums.length) {       if (nums[j++] == 0) {         k--;       }       if (k &lt; 0 &amp;&amp; nums[i++] == 0) {         k++;       }     }     return j - i;   }  }   결과  Link   설명          nums 내 k개의 0을 1로 전환할 때, 가장 긴 연속된 1의 갯수를 구하는 문제이다.            i와 j는 1의 시작과 종료의 위치를 저장할 변수로, 둘 다 0으로 초기화한다.       j가 nums의 길이 미만일 때 까지 아래를 반복한다.            nums[j]의 값이 0인 경우, k를 감소시킨 후 모든 경우 j를 증가시켜 위치를 이동시켜준다.       k가 0보다 작으면서 nums[i]의 값이 0인 경우, k를 증가시켜 이전 감소시킨 전환 갯수를 반환한 후 모든 경우 i를 증가시켜 시작 위치를 이동시켜준다.           반복이 완료되면 $j - i$인 가장 긴 연속된 1의 갯수를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/max-consecutive-ones-iii/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Score of a Good Subarray",
        "excerpt":"문제  Link   코드  class Solution {    public int maximumScore(int[] nums, int k) {     int length = nums.length;     int i = k - 1;     int j = k + 1;     int min = nums[k];     while (0 &lt;= i &amp;&amp; min &lt;= nums[i]) {       i--;     }     while (j &lt; length &amp;&amp; min &lt;= nums[j]) {       j++;     }     int result = min * (j - i - 1);     while (0 &lt;= i || j &lt; length) {       if (i &lt; 0 || (j &lt; length &amp;&amp; nums[i] &lt;= nums[j])) {         min = nums[j];         while (j &lt; length &amp;&amp; min &lt;= nums[j]) {           j++;         }       } else {         min = nums[i];         while (0 &lt;= i &amp;&amp; min &lt;= nums[i]) {           i--;         }       }       result = Math.max(result, min * (j - i - 1));     }     return result;   }  }   결과  Link   설명     nums의 좋은 부분 배열의 최대 점수를 구하는 문제이다.            좋은 부분 배열은 i &lt;= k &lt;= j 를 만족하는 i ~ j 번째 값들의 배열이다.       점수는 i ~ j 번째 값들 내 최솟값과 $j - i + 1$을 곱한 값으로 계산한다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       min은 nums 내 최솟값을 저장할 변수로, nums의 k번째 값으로 초기화한다.       i는 좋은 부분 배열의 시작 위치를 저장할 변수로, $k - 1$를 넣고 i가 0 이상이면서 nums[i]의 값이 min 이상일 때 까지 i를 감소시키며 시작 위치를 초기화한다.       j는 좋은 부분 배열의 종료 위치를 저장할 변수로, $k + 1$를 넣고 j가 length 미만이면서 nums[j]의 값이 min 이상일 때 까지 j를 증가시키며 종료 위치를 초기화한다.       result는 최대 점수를 저장할 변수로, 현재 위치인 [i, j] 구간의 부분 배열의 점수인 $min \\times (j - i - 1)$로 초기화한다.           i와 j가 배열 범위 내에 있을 때 까지 아래를 수행한다.            i가 0 미만이거나 j가 length 미만이면서 nums[i]의 값이 nums[j]의 값 이하인 경우, min에 nums[j]의 값을 넣고 j가 length 미만이면서 min이 nums[j]의 값 이하일 때까지 j를 증가시킨다.       위의 경우가 아니라면, min에 nums[i]의 값을 넣고 i가 0 이상이면서 min이 nums[i]의 값 이하일 때 까지 i를 감소시킨다.       위의 수행이 완료되면 result에 result와 $min \\times (j - i - 1)$ 중 큰 값을 넣어준다.           반복이 완료되면 최대 점수인 result를 주어진 문제의 결과로 반환한다.   해설     첫 값부터 마지막 값까지 반복하여 각 수행에 따라 i와 j의 값을 증감시키므로 점수 계산 배율인 $j - i + 1$을 $(j - 1) - (i - 1) + 1 = j - i - 1$로 계산한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-score-of-a-good-subarray/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximize Sum Of Array After K Negations",
        "excerpt":"문제  Link   코드  class Solution {    public int largestSumAfterKNegations(int[] nums, int k) {     Arrays.sort(nums);     for (int i = 0; k &gt; 0 &amp;&amp; i &lt; nums.length &amp;&amp; nums[i] &lt; 0; i++, k--) {       nums[i] = -nums[i];     }     int result = 0;     int min = Integer.MAX_VALUE;     for (int num : nums) {       result += num;       min = Math.min(min, num);     }     return result - ((k % 2) * min * 2);   }  }   결과  Link   설명          nums 내 k개의 값을 음수/양수로 전환하였을 때 nums 내 값들의 합이 최대를 구하는 문제이다.            nums의 값들을 오름차순으로 정렬한다.            0부터 nums의 길이 미만까지 i를 증가시키고, k가 0보다 클 때 까지 k를 감소시키며 nums의 i번째 값을 음수/양수 전환한다.       문제 풀이에 필요한 변수를 정의한다.            result는 최대인 값을 저장할 변수로, 0으로 초기화한다.       min은 값의 최솟값을 저장할 변수로, 정수의 최댓값으로 초기화한다.           nums의 모든 값을 순차적으로 num에 넣어 아래를 반복한다.            result에 num을 넣고, min에 min과 num 중 작은 값을 넣어준다.           result에 $\\frac{k}{2} \\times min \\times 2$의 값을 빼준 값을 주어진 문제의 결과로 반환한다.            이미 nums의 모든 값을 result에 넣었으므로 min에 2를 곱해준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximize-sum-of-array-after-k-negations/",
        "teaser": null
      },{
        "title": "Leetcode Java Clumsy Factorial",
        "excerpt":"문제  Link   코드  class Solution {    public int clumsy(int n) {     switch (n) {       case 1: case 2: return n;       case 3: return 6;       case 4: return 7;     }     switch (n % 4) {       case 1: case 2: return n + 2;       case 3: return n - 1;       default: return n + 1;     }   }  }   결과  Link   설명     아래를 만족하는 공식을 대입하여 값을 구하는 문제이다.            Factorial의 함수는 $factorial(n) = n \\times (n - 1) \\times … 2 \\times 1$의 공식을 수행한다.       이를 변조한 clumsy 함수는 $clumsy(n)= n \\times (n - 1) / (n - 2) + (n - 3) - … \\times 4 / 3 + 2 - 1$ 형태로 곱하기, 나누기, 더하기, 빼기 순으로 n부터 1까지 수행한 결과를 반환한다.           n이 아래의 경우를 만족하면, 각 경우에 대한 값을 주어진 문제의 결과로 반환한다.            n이 1과 2인 경우, n을 반환한다.       n이 3인 경우, 6을 반환한다.       n이 4인 경우, 7을 반환한다.       n을 4로 나눈 나머지가 1과 2인 경우, $n + 2$를 반환한다.       n을 4로 나눈 나머지가 3인 경우, $n - 1$을 반환한다.       그 외의 경우, $n + 1$을 반환한다.           해설     고정된 경우인, 1 ~ 4까지는 각 계산의 결과를 반환한다.   그 외의 경우, 네 산술 연산자를 수행하는 4가지 경우에 대해서 수행한 결과는 각 수행에 따라 아래와 같은 공식이 성립된다.            n을 4로 나눈 나머지가 1인 경우, $clumsy(5) = \\frac{5 \\times 4}{3} + 2 - 1 = 2$과 같이 $n + 2$이 결과로 산출된다.       n을 4로 나눈 나머지가 2인 경우, $clumsy(6) = \\frac{6 \\times 5}{4} + 3 - (2 \\times 1) = 9$아 같이 $n + 1$이 나머지가 1과 동일한 결과로 산출된다.       n을 4로 나눈 나머지가 3인 경우, $clumsy(7) = \\frac{7 \\tiems 6}{5} + 4 - \\frac{3 \\times 2}{1} = 6$인 $n - 1$이 결과로 산출된다.       n을 4로 나눈 나머지가 0인 경우, $clumsy(8) = \\frac{8 \\times 7}{6} + 5 - \\frac{4 \\times 3}{2} + 1 = 9$인 $n + 1$이 결과로 산출된다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/clumsy-factorial/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Domino Rotations For Equal Row",
        "excerpt":"문제  Link   코드  class Solution {    public int minDominoRotations(int[] tops, int[] bottoms) {     int result = -1;     for (int i = 1; i &lt;= 6; i++) {       int curr = this.calculate(tops, bottoms, i);       if (curr != -1 &amp;&amp; (result == -1 || result &gt; curr)) {         result = curr;       }     }     return result;   }    private int calculate(int[] tops, int[] bottoms, int index) {     int top = 0;     int bottom = 0;     for (int i = 0; i &lt; tops.length; i++) {       if (tops[i] != index &amp;&amp; bottoms[i] != index) {         return -1;       } else if (tops[i] != index) {         top++;       } else if (bottoms[i] != index) {         bottom++;       }     }     return Math.min(top, bottom);   }  }   결과  Link   설명     tops와 bottoms의 두 배열 내 한 배열 내 값들이 동일하게 만들기 위한 최소 횟수를 구하는 문제이다.            단, 한 배열이라도 동일하게 만들 수 없으면 -1을 주어진 문제의 결과로 반환한다.                result는 최소 횟수를 저장하기 위한 변수로, -1로 초기화한다.       배열 내 값의 범위인 1부터 6까지 i를 증가시키며 아래를 반복한다.            curr에 4번에서 정의한 calculate(int[] tops, int[] bottoms, int index) 메서드를 수행한 결과를 넣어준다.       curr이 -1이면서 result가 -1이거나 curr보다 큰 경우, result에 curr을 넣어준다.           현재 위치까지 top과 bottom의 바꾼 최소 갯수를 계산할 calculate(int[] tops, int[] bottoms, int index) 메서드를 정의한다.            변경 횟수를 저장할 top과 bottom을 0으로 초기화한다.       0부터 top의 길이 미만까지 i를 증가시키며 아래를 반복한다.                    tops[i]의 값과 bottom[i]의 값이 index가 아닌 경우, 동일한 값이 아니므로 -1을 반환한다.           tops[i]의 값만 index가 아닌 경우, top을 증가시켜 bottom의 값과 위치를 바꾼 횟수를 증가시킨다.           bottoms[i]의 값만 index가 아닌 경우, bottom을 증가시켜 top의 값과 위치를 바꾼 횟수를 증가시킨다.                       반복이 완료되면 최소 변경 횟수인 top과 bottom 중 작은 값을 반환한다.           3번의 반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-domino-rotations-for-equal-row/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Trees With Factors",
        "excerpt":"문제  Link   코드  class Solution {    public int numFactoredBinaryTrees(int[] arr) {     int length = arr.length;     long[] count = new long[length];     Arrays.fill(count, 1);     Arrays.sort(arr);     long result = 0;     for (int i = 1; i &lt; length; i++) {       for (int left = 0, right = i - 1; left &lt;= right;) {         long product = 1L * arr[left] * arr[right];         if (product == arr[i]) {           count[i] += count[left] * count[right];           if (arr[left] != arr[right]) {             count[i] += count[left] * count[right];           }           left++;           right--;         } else if (product &lt; arr[i]) {           left++;         } else {           right--;         }       }     }     for (long num : count) {       result += num;     }     return (int) (result % 1000000007);   }  }   결과  Link   설명     arr의 값들을 이용하여 아래의 조건을 만족하게 만들 수 있는 이진 트리의 수를 구하는 문제이다.            자식 노드가 존재하는 경우, 자식 노드의 값들을 곱한 값이 부모 노드의 값이 되어야 한다.       값이 매우 클 수 있으므로, 모듈러 $10^9 + 7$을 적용한 값으로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            length는 arr의 길이를 저장한 변수이다.       count는 각 길이 별 만들 수 있는 이진 노드의 갯수를 저장할 배열로, length 크기에 각 갯수가 클 수 있으므로 long형의 정수 배열로 정의하고 모든 위치에 1을 넣어 초기화한다.       result는 이진 트리의 총 갯수를 저장할 변수로, 각 값의 합이 매우 클 수 있으므로 long형의 0으로 초기화한다.           arr의 값들을 오름차순으로 정렬하고 최소 크기인 1부터 length 미만까지 i를 증가시키며 아래를 반복한다.            left에 0, right에 $i - 1$을 넣고 left가 right 이하일 때 까지 아래를 다시 반복한다.                    product에 arr[left]의 값과 arr[right]의 값을 long형으로 변환 후 곱하여 넣어준다.           product가 arr[i]의 값과 동일한 자식 노드가 가능한 값인 경우, count[i]에 count[left]의 값과 count[right]의 값을 곱한 값을 더한 후 arr[left]의 값과 arr[right]의 값이 다르면 위치를 변경 가능하므로 다시 한 번 더해준다. 그 이후 left를 증가시키고 right를 감소시켜 범위를 좁혀준다.           product가 arr[i]의 값보다 작은 경우, left를 증가시켜 하한 범위를 높혀준다.           그 외인 product가 arr[i]의 값보다 큰 경우, right를 감소시켜 상한 범위를 낮춰준다.                           반복이 완료되면 count의 모든 값을 result에 넣은 후 모듈러 $10^9 + 7$을 적용한 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-trees-with-factors/",
        "teaser": null
      },{
        "title": "Leetcode Java Sort Integers by The Number of 1 Bits",
        "excerpt":"문제  Link   코드  class Solution {    public int[] sortByBits(int[] arr) {     int length = arr.length;     for (int i = 0; i &lt; length; i++) {       arr[i] += Integer.bitCount(arr[i]) * 10001;     }     Arrays.sort(arr);     for (int i = 0; i &lt; length; i++) {       arr[i] %= 10001;     }     return arr;   }  }   결과  Link   설명     arr의 값들을 bit로 변환한 값의 1의 갯수가 작은 값순서로 값들을 오름차순 정렬하는 문제이다.            [0, 1, 2, 3, 4, 5, 6, 7, 8]의 값을 예를 들어보자.                    1의 갯수가 1개인 [1, 2, 4, 8]           1의 갯수가 2개인 [3, 5, 6]           1의 갯수가 3개인 [7]           위를 이어주면 [1, 2, 4, 8, 3, 5, 6, 7]이 된다.                                length는 arr의 길이를 저장한 값이다.       0부터 length 미만까지 i를 증가시키며 arr[i]의 값에 arr[i]의 비트 수를 10001로 곱한 값을 더해준다.            값의 범위는 [0, $10^4$]이므로, 범위의 상한을 넘는 모듈러 형식으로 사용하기 위한 값으로 $10^4 + 1$을 사용한다.           arr의 값을 오름차순으로 정렬한 후, 0부터 length 미만까지 i를 증가시키며 arr[i]의 값을 10001로 나눈 나머지를 넣어 원래 값으로 복원한 후 arr을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sort-integers-by-the-number-of-1-bits/",
        "teaser": null
      },{
        "title": "Leetcode Java Find The Original Array of Prefix Xor",
        "excerpt":"문제  Link   코드  class Solution {    public int[] findArray(int[] pref) {     for (int i = pref.length - 1; i &gt; 0; i--) {       pref[i] ^= pref[i - 1];     }     return pref;   }  }   결과  Link   설명     pref 내 값들을 pref[i] = pref[0] ^ pref[1] ^ … ^ pref[i]를 만족하는 배열로 만들어 반환하는 문제이다.            ’^’ 연산자는 XOR 비트 연산자이다.                $pref.length - 1$부터 0초과일 때 까지 i를 감소하며, pref[i]에 자신의 값과 pref[$i - 1$]의 값으로 XOR 비트 연산을 수행한 값을 넣어준다.       각 위치 별 XOR 연산을 수행하여 완성된 pref 배열을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-the-original-array-of-prefix-xor/",
        "teaser": null
      },{
        "title": "Leetcode Java Build an Array With Stack Operations",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; buildArray(int[] target, int n) {     List&lt;String&gt; list = new ArrayList&lt;&gt;();     int i = 0;     int j = 0;     while (i++ &lt;= n &amp;&amp; j &lt; target.length) {       list.add(\"Push\");       if (target[j] == i) {         j++;       } else {         list.add(\"Pop\");       }     }     return list;   }  }   결과  Link   설명     [1, n] 범위 내 값들을 이용하여 아래의 규칙대로 순차적으로 증가하는 값이 저장된 정수 배열인 target과 동일한 배열인 stack을 만들 수 있는 연산 순서를 반환하는 문제이다.            target을 만들기 위한 기본 연산은 아래와 같다.                    “Push”는 stack의 뒤에 값을 넣어준다.           “Pop”은 stack의 뒤에 있는 값을 빼준다.                       [1, n] 범위 내 값들을 순서대로 사용하여 위의 연산만 수행 가능하다.       범위 내 값들만 순차적으로 사용하여 연산을 수행한다.           문제 풀이에 필요한 변수를 정의한다.            list는 연산을 순차적으로 넣을 변수로, ArrayList로 초기화한다.       i는 [1, n] 범위 내 위치 j는 target 내 위치를 저장할 변수로, 둘 다 0으로 초기화한다.           i가 n 이하이면서 j가 target의 길이 미만까지 아래를 반복하면서 i를 증가시켜준다.            list에 “Push”를 넣고 값을 추가해준다.       target[j]의 값과 i와 동일한 경우, j를 증가시키고 아니면 list에 “Pop”을 추가하여 값을 제거한 것을 표시해준다.           반복이 완료되면 연산 순서가 저장된 list를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/build-an-array-with-stack-operations/",
        "teaser": null
      },{
        "title": "Leetcode Java Last Moment Before All Ants Fall Out of a Plank",
        "excerpt":"문제  Link   코드  class Solution {    public int getLastMoment(int n, int[] left, int[] right) {     int result = 0;     for (int point : left) {       result = Math.max(result, point);     }     for (int point : right) {       result = Math.max(result, n - point);     }     return result;   }  }   결과  Link   설명          널판지 위에 총 n마리의 개미 중 왼쪽으로 향하는 개미의 위치가 저장된 left와 오른쪽으로 향하는 개미의 위치가 저장된 right가 1초에 한 칸씩 이동할 때 모두 떨어지는데 걸리는 시간을 구하는 문제이다.            result는 개미가 널판지 위에서 모두 떨어지는 시간을 저장할 변수로, 0으로 초기화한다.            left의 값들 중 result에 가장 큰 값인 마지막으로 출발하는 개미의 위치를 넣어준다.            right의 값들 중 result에 가장 작은 값인 개미의 위치를 n에 뺀 값을 넣어준다.            반복이 완료되면 가장 멀리 떨어진 개미가 널판지 아래로 떨어지는 시간이 저장된 result를 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/last-moment-before-all-ants-fall-out-of-a-plank/",
        "teaser": null
      },{
        "title": "Spring Cache",
        "excerpt":"Spring Cache1     Spring Cache Abstraction를 사용하여 비용이 많이 드는 메서드 수행을 반복하지 않고 데이터를 반환함으로써, 시스템 성능을 향상시킬 수 있다.   단, 여러 노드로 구성된 어플리케이션과 같은 Multi-Process 환경에서는 Cache Provider를 환경에 따라 구성해야 한다.   Dependency  &lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;   &lt;version&gt;5.3.30&lt;/version&gt; &lt;/dependency&gt;  implementation 'org.springframework:spring-context-support:5.3.30'     일반적으로 “spring-context-support” 의존성을 maven dependency로 추가 혹은 gradle implementation하여 사용할 수 있다.   &lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt;  implementation 'org.springframework.boot:spring-boot-starter-cache'     Spring Boot를 사용하는 경우, “spring-boot-starter-cache” 의존성을 maven dependency로 추가 혹은 gradle implementation하면 내장되어 사용할 수 있다.   @EnableCaching &amp; CacheManager  @EnableCaching @Configuration public class CacheConfiguration {    @Bean   public CacheManager cacheManager() {     SimpleCacheManager cacheManager = new SimpleCacheManager();     cacheManager.setCaches(Arrays.asList(new ConcurrentMapCache(\"users\")));     return cacheManager;   }  }     @EnableCaching 어노테이션을 이용하여 캐싱 기능을 활성하 하는 @Confuguration 클래스를 정의한다.   Spring 내 캐싱 기능을 관리하는 CacheManager Bean을 설정해야 하는데, ConcurrentMapCache를 관리할 Cache 이름으로 초기화 하여 넣어준다.   Cache Annotation  @CacheCofig  @Repository @CacheConfig(cacheNames = \"users\") public class UsersRepository { }     클래스 전역으로 캐시에 대한 설정을 공통으로 적용하는 어노테이션이다.   @Cacheable  @Cacheable(key = \"#id\", unless = \"#result == null\") public User select(Long id) {   return MAP.get(id); }     캐시를 저장하기 위한 어노테이션으로, 메서드 단위로 설정하여 key와 동일한 요청이 발생하면 캐싱된 데이터를 반환한다.   @CachePut &amp; @CacheEvict  @CachePut(key = \"#user.id\") @CacheEvict(key = \"'all'\") public User update(User user) {   MAP.put(user.getId(), user);   return user; }     @CachePut을 사용하여 key에 해당하는 캐싱된 데이터를 요청된 값으로 변경시켜줄 수 있다.   @CacheEvict을 사용하여 key에 해당하는 값에 대한 캐싱된 데이터를 삭제할 수 있으며, ‘all’을 이용하여 전체 조회에 대한 값을 삭제하거나 allEntiries=true 설정을 이용하여 모든 데이터를 삭제할 수 있다.   @Caching  @Caching(evict = {   @CacheEvict(key = \"#id\"),   @CacheEvict(key = \"'all'\") }) public boolean delete(Long id) {   User user = MAP.remove(id);   System.out.println(user);   return true; }     메서드에는 동일한 메서드를 붙일 수 없으므로 여러 캐시를 관리하기 위한 어노테이션으로, 동일한 기능 별 메서드를 그룹화하여 사용할 수 있다.   Conclusion     Cache는 시스템 개발에 반드시 고려해야 하는 사항으로, 서비스 운영에 지장을 주지 않을 정도의 최적화된 범위 내 적합한 읽기 / 쓰기 전략등을 활용하여 적용해야 하는 기능이다.   단순 Spring Cache 뿐 아니라 Redis, EhCache, 등을 통해 서비스 규모와 범위에 따라 다양한 방식으로 서비스에 Cache를 적용할 수 있다.   Reference   ※ Sample Code는 여기에서 확인 가능합니다.                 Caching Data with Spring &#8617;           ","categories": ["Spring"],
        "tags": ["Programming","Spring","Cache"],
        "url": "/spring/spring-cache/",
        "teaser": null
      },{
        "title": "Leetcode Java Find the Winner of an Array Game",
        "excerpt":"문제  Link   코드  class Solution {    public int getWinner(int[] arr, int k) {     int result = arr[0];     int count = 0;     for (int i = 1; i &lt; arr.length; i++) {       if (result &lt; arr[i]) {         result = arr[i];         count = 0;       }       if (++count == k) {         break;       }     }     return result;   }  }   결과  Link   설명     모두 다른 값으로 구성된 정수 배열인 arr 내 값들 중 아래의 규칙대로 k번 승리한 값을 반환하는 문제이다.            최초 승리자는 arr의 맨 앞의 값으로, 1번 승리한 값으로 시작한다.       arr의 맨 앞의 값이 다음번째 값보다 큰 경우 승리한다.       패배한 값은 배열의 맨 마지막으로 이동한다.           문제 풀이에 필요한 변수를 정의한다.            result는 현재 승리한 값을 저장할 변수로, 첫 승리자인 arr[0]의 값을 넣어준다.       count는 현재까지 승리한 횟수를 저장할 변수로, 0으로 초기화한다.           1부터 arr 길이 미만까지 i를 증가시키며 아래를 반복한다.            result가 arr[i]의 값보다 작은 경우, 패배하였으므로 result에 arr[i]의 값을 넣고 count를 0으로 초기화한다.       이긴 횟수인 count를 증가시킨 후 count가 k와 동일한 경우, 반복을 종료한다.           위의 반복에서 찾은 k번 이긴 숫자인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-the-winner-of-an-array-game/",
        "teaser": null
      },{
        "title": "PostgreSQL Barman",
        "excerpt":"Barman1     PostgreSQL의 Replication 구성 이후 Recovery Point를 지나서 복구 불가능한 Standby 서버는 데이터를 삭제하고 다시 구성해야 한다.   이런 문제점을 해결하기 위한 방식 중 Backup 수단을 고려해야 하는데, 그 중 REPMGR과 연동이 수월하면서 PostgreSQL기반의 EnterpriseDB(“EDB”)에서 오픈소스로 개발 및 유지보수하는 Barman을 소개한다.   Introduction     예기치 못한 상황에서 비즈니스의 연속성을 유지하기 위해서 필요한 도구를 제공한다.   대표적으로 비즈니스 연속성에는 아래의 두 항목이 0이 되는 이상적인 환경이 제공되기를 원한다.            Recovery Point Objective(RPO) : 중대한 사고로 인해 서비스에서 데이터가 손실될 수 있는 최대 목표 기간을 의미한다.       Recovery Time Objective(RTO) : 비즈니스 연속성 중단을 방지하기 위해서 서비스를 복구할 수 있는 목표 기간 및 서비스 수준을 의미한다.           Barman은 위의 상황을 이상적으로 제공하기 위해서 사용하기 위한 백업 도구이다.   Repmgr using Barman     Rermgr 구성에 Barman 설정을 할 경우, 아래의 순서대로 진행하여야 한다.            Barman 서버 구성.       Primary 서버를 Barman 서버에 백업 후 concurrent_backup 수행.       Standby 서버의 Repmgr 설정 내 Barman 설정 후 “repmgr standby clone” 명령어 수행을 통해 Barman 연동.       Replication Cluster 구성 이후 “repmgr cluster show” 명령어를 사용하여 확인.           Primary의 기본 데이터와 백업 주기에 설정된 데이터들을 기반으로 Replication Cluster 구성 및 Disaster Recovery가 가능한 구조로 설정이 된다.   Requirement     Linux/Unix   Python &gt;= 3.6   Python modules:            argcomplete       psycopg2 &gt;= 2.4.2       python-dateutil       setuptools           PostgreSQL &gt;= 10 (next version will require PostgreSQL &gt;= 11)   rsync &gt;= 3.0.4 (optional)   Install     Barman 설치는 2ndquadrant Repository를 설정하여 yum으로 가능하며, 세부 사항은 Document#Installation 섹션을 참고한다.   compression 설정을 사용할 경우, 사용하려는 타입에 맞는 utility를 설치해야 한다.     yum install barman yum install gzip           SSH Setting     Barman과 연동하여 Backup과 Recovery를 수행하기 위해서 SSH 설정을 구성하려는 모든 서버에서 수행해야 한다.            우선 PostgreSQL 관리 계정인 postgres 계정으로 들어가 “/.ssh” 폴더를 만든다.       Password 인증을 사용하지 않기 위해 SSH RSA Public &amp; Private Key 파일을 생성한다.       SSH 연결 시, 인증에 사용할 “authorized_keys” 파일에 자기 자신의 “id_rsa.pub” 파일 내용을 넣어주고, 해당 파일 권한을 600(rw——-)으로 변경한다.         su barman mkdir -p ~/.ssh cd ~/.ssh ssh-keygen -t rsa cat id_rsa.pub &gt;&gt; authorized_keys chmod 600 authorized_keys                           모든 서버에 SSH key를 생성하였으면, 각 서버의 barman 계정으로 SSH 접근하기 위한 다른 서버들의 SSH key를 가져와서 넣어주어야 한다.            각 서버의 SSH 연결에 대한 SSH key를 “ssh-copy-id” 명령어를 이용하여 인증 후 가져온다.       가져온 후 서버 도메인 정보가 맞게 적용되어 있는지 확인 후 수정한다.       마지막으로 “restorecon” 명령어를 이용하여 설정을 서버에 적용한다.         ssh-copy-id -p 22 barman@{IP} restorecon -Rv ~/.ssh                           Barman Configuration     barman을 설치하면 barman 설정인 “/etc/barman/” 폴더 내 “barman.conf” 파일과 백업 데이터베이스 설정을 수행할 “conf.d” 폴더가 생성된다.   위에서 우선 “barman.conf” 설정을 수정한다.     [barman] barman_user = barman configuration_files_directory = /etc/barman/conf.d barman_home = /var/lib/barman log_file = /etc/barman/logs/barman.log log_level = ERROR compression = gzip immediate_checkpoint = true basebackup_retry_times = 3 retention_policy = RECOVERY WINDOW OF 1 WEEKS                retention_policy는 백업 보관 기간을 설정하는 옵션으로, Repmgr 구성에서 오류가 발생하여 복구하기 위한 Recovery Point를 확장하기 위한 기간을 고려하여 설정하면 된다.       백업을 위한 Primary 서버의 설정 파일 “/etc/barman/conf.d/repmgr-primary-server.conf”을 만들어준다.   [primary] description =  \"Repmgr Primary Server\"   ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; SSH options (mandatory) ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ssh_command = ssh postgres@10.0.2.1   ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; PostgreSQL connection string (mandatory) ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; conninfo = host=10.0.2.1 port=5432 user=postgres dbname=repmgr   ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; Backup settings (via rsync over SSH) ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; backup_method = rsync reuse_backup = link backup_options = concurrent_backup parallel_jobs = 1   ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; Continuous WAL archiving (via 'archive_command') ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; archiver = on path_prefix = \"/usr/pgsql-10/bin\"   ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; PostgreSQL streaming connection string ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; streaming_conninfo = host=10.0.2.1 port=5432 user=postgres dbname=repmgr   ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; WAL streaming settings (via pg_receivewal) ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; streaming_archiver = on slot_name = primary create_slot = auto      PostgreSQL 내 계정을 별도 생성하여 사용하지 않고 postgres 계정으로 명령 수행하도록 할 수 있다.   백업 방식은 공식 홈페이지의 Document#Backup-and-Architecture 섹션을 참고하여 설정을 변경한다.   Install in PostgreSQL Server  Barman-cli &amp; rsync     Barman 서버와 연동할 PostgreSQL 서버들에는 클라이언트 유틸리티인 barman-cli를 설치한다.     yum install barman-cli           rsync 방식으로 Backup을 수행하는 경우, PostgreSQL 서버에도 rsnyc가 설치되어 있어야 한다.     yum install rsync           PostgreSQL Configuration     PostgreSQL 서버 내 PostgreSQL 설정에서 “postgresql.conf” 파일에 아래의 내용을 추가한다.     max_wal_senders = 3         # max number of walsender processes                           # (change requires restart) max_replication_slots = 3   # max number of replication slots wal_level = replica         # minimal, replica, or logical                           # (change requires restart) archive_mode = on           # enables archiving; off, on, or always                           # (change requires restart) archive_command = 'rsync -a %p postgres@10.0.2.20:/var/lib/barman/primary/incoming/%f'           PostgreSQL 서버 내 PostgreSQL 설정에서 “pg_hba.conf” 파일에 아래의 내용을 추가한다.     host    all     barman                  10.0.2.0/24        trust host    all     streaming_barman        10.0.2.0/24        trust           Repmgr Configuration     Repmgr 설정 내 “/etc/repmgr/{POSTGRESQL_VERSION}/repmgr.conf” 파일에 Barman 서버 설정을 수행한다. ```shell restore_command=’/usr/bin/barman-wal-restore -U postgres 10.0.2.20 primary %f %p’   barman_host=barmanserver barman_server=10.0.2.1 restore_command=/usr/bin/barman-wal-restore barmanserver 10.0.2.1 %f %p   # Clone - Repmgr 구성 내 Primary 서버의 연동을 설정한다. ```shell barman switch-wal --force --archive primary barman cron barman check primary      “barman check {SERVER_NAME}” 명령어를 수행하여 OK가 되지 않는 항목은 각 설정을 수정하여 모두 정상화 시켜야된다.   Backup     Barman을 통해 임의 시점에서 설정된 “backup_method”의 방식으로 시스템 운영 중 백업 수행이 가능하다.            rsync/SSH의 경우 “ssh_command”의 설정을 활용된다.         barman backup primary                           Caution     Barman을 구성할 때 주의 사항으로, 기본으로 생성하는 barman 계정을 그대로 사용해야한다.   Rermgr 등 다른 시스템과 연동 설정을하다 보면 원인 파악이 어려운 다양한 오류가 발생할 수 있다.            이 때 Linux 로그(“/var/logs/*”) 내 연동 요청에 대해서 “Permission denied” 혹은 “Failed”등의 오류를 참고한다.           Conclusion     이 외에도 pgBackRest, WAL-E, pg_basebackup, 등을 이용한 백업 방안이 존재하므로 서비스 환경과 시스템 구성에 맞는 도구를 선택하는 것 또한 중요하다.   백업은 위에서 이야기한 RPO, RTO가 0이 되는 이상적인 비즈니스 연속성을 제공된 환경을 구성하기 위해 가장 중요한 수단이다.   서비스가 안정적으로 구성된다면 다양한 기능 개발, 시스템 안정성 확보, UX 설계 등을 기반으로 사용자의 만족도 증진에 집중할 수 있으므로 반드시 고려해보기를 바란다.   Reference                 Barman Home &#8617;           ","categories": ["PostgreSQL"],
        "tags": ["Programming","Database","PostgreSQL","Barman"],
        "url": "/postgresql/postgresql-barman/",
        "teaser": null
      },{
        "title": "PostgreSQL Pgpool-II",
        "excerpt":"Pgpool-II[^Pgpool-II]     PostgreSQL 서버 풀을 관리하는 도구로, 단일 PostgreSQL 구성에서 사용할 수 없는 다양한 기능을 제공한다.   Features  High Availability     여러 PostgreSQL 서버를 사용하여 HA 구성을 제공하며, 손상된 서버를 서버 풀에서 자동으로 제거하여 데이터베이스 작업을 계속 수행한다.   Pgpool-II는 Watchdog이라는 Pgpool-II 자체에 대한 HA 기능도 제공하여 Quorum Algorithm을 사용하여 Split-Brain 현상이 발생하지 않도록 지원한다.     Load balancing       더 높은 성능을 얻기 위해서 여러 PostgreSQL 서버에 Read 쿼리를 분산시켜준다.   Write 쿼리는 아래의 각 경우에 따라 해당 서버로 전달된다.            Streaming Replication 모드인 경우, Primary 서버에만 제공된다.       그 외의 Native Replication 모드이거나 Snapshot Isolation 모드인 경우, 모든 서버로 분산시켜준다.         Connection Pooling                   PostgreSQL 서버에 대해 설정된 연결을 유지하고 동일한 속성(user, database, protocol version, and other connection parameters)을 가진 새 연결이 들어올 때마다 이를 재 사용한다.     Online Recovery       하나의 명령을 실행하여 데이터베이스 노드의 온라인 복구를 수행할 수 있다.   자동 장애 조치와 함께 온라인 복구를 사용하는 경우 장애 조치에 의해 분리된 노드를 자동으로 대기 노드로 연결하는 것이 가능하다.   새로운 PostgreSQL 서버를 동기화하고 연결하는 것도 가능하다.     Limiting Exceeding Connections       PostgreSQL의 최대 동시 연결 수에는 제한이 있으며, 최대 연결 수를 늘리면 리소스 소비가 증가하고 전체 시스템 성능에 부정적인 영향을 미칠 수 있으므로 제한에 도달하면 새 연결이 거부된다.     Watchdog       여러 Pgpool-II를 연결하여 강력한 Cluster 시스템을 구성하며, 단일 실패 지점 또는 Split-Brain을 방지할 수 있습니다.   Split-Brain을 방지하기 위해서는 최소 3개 이상의 Pgpool-II를 연결해야한다.     In Memory Query Cache       한 쌍의 SELECT 문과 그 결과를 저장하여 동일한 SELECT가 들어오면 Pgpool-II는 캐시에서 값을 반환한다.   SQL 구문 분석이나 PostgreSQL에 대한 액세스가 포함되지 않으므로 매우 빠르다.   Install  libevent &amp; libevent     위에서 이야기한 In Memory Query Cache 기능을 활용하므로 libevent와 libmemcached를 설치해야 pgpool을 설치 가능하다.     yum install libevent yum install libevent           Pgpool-II     Pgpool 사이트 내 Downloads 페이지를 참고하여 Yum repository 설정이거나 RPM을 다운로드 받아 설치하면 된다.   Pgpool-II Configuration     Pgpool-II를 설치하면 “/etc/pgpool-II” 폴더 내 다양한 설정 파일이 존재한다.   pgpool.conf  # ---------------------------- # pgPool-II configuration file # ---------------------------- backend_clustering_mode = 'streaming_replication'   #------------------------------------------------------------------------------ # CONNECTIONS #------------------------------------------------------------------------------ # - pgpool Connection Settings - listen_addresses = '*' port = 9999 socket_dir = '/tmp' pcp_listen_addresses = '*' pcp_port = 9898 pcp_socket_dir = '/tmp'  # - Backend Connection Settings - backend_hostname0 = '10.0.2.1' backend_port0 = 5432 backend_weight0 = 1 backend_data_directory0 = '/var/lib/pgsql/12/data' backend_flag0 = 'ALWAYS_PRIMARY' backend_application_name0 = 'master'   backend_hostname1 = '10.0.2.10' backend_port1 = 5432 backend_weight1 = 1 backend_data_directory1 = '/var/lib/pgsql/12/data' backend_flag1 = 'ALLOW_TO_FAILOVER' backend_application_name1 = 'standby1'   backend_hostname2 = '10.0.2.20' backend_port2 = 5432 backend_weight2 = 1 backend_data_directory2 = '/var/lib/pgsql/12/data' backend_flag2 = 'ALLOW_TO_FAILOVER' backend_application_name2 = 'standby2'  #------------------------------------------------------------------------------ # POOLS #------------------------------------------------------------------------------ num_init_children = 100  #------------------------------------------------------------------------------ # FILE LOCATIONS #------------------------------------------------------------------------------ pid_file_name = '/var/run/pgpool/pgpool.pid' logdir = '/etc/pgpool-II/log'  #------------------------------------------------------------------------------ # LOAD BALANCING MODE #------------------------------------------------------------------------------ load_balance_mode = on ignore_leading_white_space = on write_function_list = '' database_redirect_preference_list = '' app_name_redirect_preference_list = '' allow_sql_comments = off disable_load_balance_on_write = 'transaction'  #------------------------------------------------------------------------------ # STREAMING REPLICATION MODE #------------------------------------------------------------------------------ # - Streaming - sr_check_period = 10 sr_check_user = 'repmgr' sr_check_password = 'repmgr' sr_check_database = 'repmgr' delay_threshold = 1000000   pcp.conf     pg_md5를 이용하여 패스워드를 암호화 하여 “username:[md5 encrypted password]” 형태로 넣어준다.     root:1060b7b46a3bd36b3a0d66e0127d0517           Firewall     위에서 사용하는 9999 포트에 대해서 방화벽 설정을 추가 후 적용한다.     firewall-cmd --permanent --zone=public --add-port=9999/tcp firewall-cmd --reload           Service     Pgpool-II 서비스를 등록 및 상태를 확인한다.     systemctl enable pgpool systemctl start pgpool systemctl status pgpool           Node check     psql 명령어로 Pgpool-II 서비스에 연결하여 pool에 연결된 node들의 상태를 확인한다.     psql -h localhost -p 9999 -U repmgr -d repmgr -c 'show pool_nodes;'           Conclusion     단일 PostgreSQL을 사용하다 보면 부하 분산에 대한 다양한 구성을 고려하게된다.   Repmgr에서 이야기하였듯이 Scale-up은 서비스 중단에 대한 리스크가 분명히 존재하므로 유연한 구성을 하기 위한 Scale-out 등 다양한 방법을 고려하여야 한다.   이러한 모든 작업은 개발과 동일하게 확장에 열려있도록 아키텍쳐를 구성하고 원활한 서비스를 제공하기 위한 기반 작업이다.   위에서 설명하였듯이 다양한 기능들이 Pgpool-II에 존재하지만, 이 글에서 작성한 단순 구성 설정 외 다양한 설정들을 이용하여 자신만의 서비스에 접목시키면 더 효율적인 서비스 운영이 될 것으로 판단된다.   Reference  ","categories": ["PostgreSQL"],
        "tags": ["Programming","Database","PostgreSQL","Pgpool-II"],
        "url": "/postgresql/postgresql-pgpool-ii/",
        "teaser": null
      },{
        "title": "PostgreSQL REPMGR",
        "excerpt":"Repmgr1     PostgreSQL의 Replication 구성 방법 중 내부 설정만 사용하여 설정하는 방안도 있지만, PostgreSQL기반의 EnterpriseDB(“EDB”)에서 오픈소스로 개발 및 유지보수하는 Repmgr의 신뢰도와 다수 기능을 제공하는 Repmgr을 소개한다.   Terms  Replication Cluster     Streaming Replication 연결된 PostgreSQL 서버의 네트워크이다.     Node       Replication Cluster내 단일 PostgreSQL 서버이다.     Upstream Node       통상적으로 Primary 서버로, Standby 서버들과 연결하여 Streaming Replication을 전송하는 역할을 수행하는 노드이다.     Failover       Primary 서버가 장애가 발생하게 되면 적당한 Standby 서버가 Primary로 승격하는 작업이다.   Repmgr Daemon인 Repmgrd는 Downtime의 최소화를 위해 Automatic Failover를 지원한다.     Switchover       Primary 서버가 오프라인이 필요할 경우, 적당한 Standby 서버가 Primary 서버의 역할을 수행하도록 역할을 전환하는 작업이다.   Repmgr 커맨드를 통해 해당 기능을 제공한다.     Fencing       장애 조치 상황에서 Standby 서버가 Primary로 승격하고 나서 기존 Pirmary 서버가 다시 온라인 상태가 되어 Split-Brain 현상이 발생하지 않도록 하는 실패한 Primary 서버를 격리하는 작업이다.     Witness Server       노드가 두 대 이상으로 구성하는 경우, 두 대 이상의 Standby 서버가 존재하여 Primary 승격을 판단시켜줄 서버이다.   Replication Cluster의 일부는 아니지만 Repmgr 메타데이터 스키마의 복사본을 포함하고 있다.   이 또한 Fencing에서 이야기한 Split-Bran 현상을 방지하기 위한 역할을 수행한다.   Install  SSH Configuration     Replication 구성 관리를 위한 SSH 설정을 구성하려는 모든 서버에서 수행해야 한다.            우선 PostgreSQL 관리 계정인 postgres 계정으로 들어가 “/.ssh” 폴더를 만든다.       Password 인증을 사용하지 않기 위해 SSH RSA Public &amp; Private Key 파일을 생성한다.       SSH 연결 시, 인증에 사용할 “authorized_keys” 파일에 자기 자신의 “id_rsa.pub” 파일 내용을 넣어주고, 해당 파일 권한을 600(rw——-)으로 변경한다.         su postgres mkdir -p ~/.ssh cd ~/.ssh ssh-keygen -t rsa cat id_rsa.pub &gt;&gt; authorized_keys chmod 600 authorized_keys                           모든 서버에 SSH key를 생성하였으면, 각 서버의 postgres 계정으로 SSH 접근하기 위한 다른 서버들의 SSH key를 가져와서 넣어주어야 한다.            각 서버의 SSH 연결에 대한 SSH key를 “ssh-copy-id” 명령어를 이용하여 인증 후 가져온다.       가져온 후 서버 도메인 정보가 맞게 적용되어 있는지 확인 후 수정한다.       마지막으로 “restorecon” 명령어를 이용하여 설정을 서버에 적용한다.         ssh-copy-id -p 22 postgres@{IP} restorecon -Rv ~/.ssh                           Edit /etc/sudoers     Repmgr에서 postgres 계정으로 관리자 명령어를 수행하기 위한 기본 권한 허용하기 위해서 “/etc/sudoers” 파일을 수정한다.     postgres ALL=NOPASSWD: /usr/bin/systemctl stop postgresql-12, \\ /usr/bin/systemctl start postgresql-12, \\ /usr/bin/systemctl restart postgresql-12, \\ /usr/bin/systemctl reload postgresql-12, \\ /usr/bin/systemctl stop repmgr12 \\ /usr/bin/systemctl start repmgr12 \\ /usr/bin/systemctl restart repmgr12 \\ /usr/bin/systemctl reload repmgr12           Add repmgr user in PostgreSQL     PostgreSQL Database 내 Replication 관리 계정과 Replication할 데이터베이스를 추가해야한다.     su postgres createuser --superuser repmgr createdb --owner=repmgr repmgr           기존 사용하는 계정과 DB가 존재하는 경우, 아래와 같이 해당 계정에 replication 권한만 부여하고 사용해도 된다.     ALTER USER gracefulsoul replication;           PostgreSQL Configuration     PostgreSQL 설정 파일인 “postgresql.conf”에 아래 항목을 설정한다.   “max_wal_senders”는 연결하려는 $Replication DB Count + 1$로 설정하면 된다.     listen_addresses = '*' wal_level = replica max_wal_senders = 3 wal_keep_segments = 8 archive_mode = on archive_command = 'true' shared_preload_libraries = 'repmgr'           PostgreSQL 연결과 관련한 설정 파일인 “pg_hba.conf” 파일에 아래 항목을 추가한다.   기존 사용하던 계정과 DB가 존재하는 경우, 해당 계정과 DB로 설정해야한다.     local   replication     repmgr                                  trust host    replication     repmgr          127.0.0.1/32            trust host    replication     repmgr          10.0.2.0/24             trust local   repmgr          repmgr                                  trust host    repmgr          repmgr          127.0.0.1/32            trust host    repmgr          repmgr          10.0.2.0/24             trust           Repmgr Install     Repmgr의 기본적인 설치 방법은 공식 문서인 Installing repmgr from packages를 참조하는 것이 좋다.   RPM을 받아 설치하고자 한다면, EDB의 Public Repository에서 버전에 맞춰 다운로드후 rpm 설치를 수행한다.     rpm -Uvh repmgr12-5.3.0-1.el7.x86_64.rpm           Repmgr Configuration     RPM을 설치하였다면 “/etc/repmgr/{PostgreSQLVersion}” 경로에 “repmgr.conf” 설정 파일을 수정해야한다.   node_id=1 node_name='primary' conninfo='host=10.0.2.1 port=5432 dbname=repmgr user=repmgr' data_directory='/var/lib/pgsql/12/data'   #------------------------------------------------------------------------------ # Server settings #------------------------------------------------------------------------------ config_directory='/var/lib/pgsql/12/data'  #------------------------------------------------------------------------------ # Replication settings #------------------------------------------------------------------------------ replication_user='repmgr' replication_type='physical' use_replication_slots=yes  #------------------------------------------------------------------------------ # Logging settings #------------------------------------------------------------------------------ log_level='ERROR' log_file='/etc/repmgr/12/repmgr.log'  #------------------------------------------------------------------------------ # Event notification settings #------------------------------------------------------------------------------ event_notification_command='/etc/repmgr/12/failover_promote.sh %n %e %d' event_notifications='repmgrd_failover_promote'  #------------------------------------------------------------------------------ # Environment/command settings #------------------------------------------------------------------------------ pg_bindir='/usr/pgsql-12/bin' repmgr_bindir='/usr/pgsql-12/bin'  #------------------------------------------------------------------------------ # Failover and monitoring settings (repmgrd) #------------------------------------------------------------------------------ failover='automatic' reconnect_attempts=4 reconnect_interval=2 promote_command='/usr/pgsql-12/bin/repmgr standby promote -f /etc/repmgr/12/repmgr.conf --siblings-follow --log-to-file' follow_command='/usr/pgsql-12/bin/repmgr standby follow -f /etc/repmgr/12/repmgr.conf --log-to-file --upstream-node-id=%n' monitoring_history=yes monitor_interval_secs=5  #------------------------------------------------------------------------------ # service control commands #------------------------------------------------------------------------------ service_start_command='sudo systemctl start postgresql-12' service_stop_command='sudo systemctl stop postgresql-12' service_restart_command='sudo systemctl restart postgresql-12' service_reload_command='sudo systemctl reload postgresql-12' repmgrd_service_start_command='sudo systemctl start repmgr12' repmgrd_service_stop_command='sudo systemctl stop repmgr12'      기존 사용하던 계정과 DB가 존재하는 경우, 각 설정마다 적용한 dbname과 user정보를 수정해주어야 한다.   data_directory를 변경하였을 경우, 반드시 설정을 통해서 변경한 디렉토리로 설정하여야 한다.   promote_command와 follow_command의 경우, 반드시 repmgr 파일의 절대 경로로 적용하여야 정상적인 커맨드 수행이 가능하다.   “failover_promote.sh” 파일은 “failover” 설정이 “automatic”인 경우 사용할 파일로, 각자 구성에 맞추어 설정해야한다.            “%n” : 신규 Primary로 승격한 노드 번호       “%e” : Clustering 구조 내 발생한 이벤트 유형       “%d” : Clustering 구조 내 발생한 이벤트 상세 내용       “%e”가 “repmgrd_failover_promote”인 경우, 승격한 노드 번호와 죽은 노드 번호를 확인 가능하므로 “PostgreSQL Stop -&gt; REPMGR Node Rejoin -&gt;  PostgreSQL Start”를 스크립트로 만들면 클러스터링 구조의 Recovery Point를 내에서 빠른 복구가 가능하다.           저 외에도 다양한 설정들이 있으나, 글이 너무 길어질 수 있으므로 미사용 설정과 주석은 모두 삭제하였다.   Repmgr service enable     최종 설정된 REPMGR service를 등록하여 서버 재시작에도 자동 실행되도록 설정한다.     systemctl enable repgmr12           Repmgr Clustering  primary DB Register     기존 사용하던 Database를 Primary로 등록한다.     /usr/pgsql-12/bin/repmgr primary register /usr/pgsql-12/bin/repmgr cluster show           stnadby DB Register     등록된 Primary DB를 clone하여 Standby DB를 구성한다.     # Remove all PostgreSQL's data systemctl stop postgresql-12 rm -rf /var/lib/pgsql/12/data/* # Clone /usr/pgsql-12/bin/repmgr -h 10.0.2.1 -p 5432 -U repmgr -d repmgr standby clone           복제가 완료되면 Standby DB를 등록하고 시작한다.   systemctl start postgresql-12 systemctl start repmgr12 /usr/pgsql-12/bin/repmgr standby register /usr/pgsql-12/bin/repmgr cluster show   Failover  Manual     Standby DB 서버에서 “switchover” 명령어를 수행할 때, “–dry-run”을 통한 테스트 실행을 수행하여 정상적인 클러스터링 구조 설정이 되었는지 확인 후 수행한다.     /usr/pgsql-12/bin/repmgr standby switchover --siblings-follow --dry-run           Automatic     Primary DB를 강제종료할 때 설정된 “reconnect_interval”초마다 “reconnect_attempts”번 확인 후 “promote_command” 수행을 통해 Standby DB가 Primary로 승격하게 될 것이다.   단, 수행 이전에 Node Rejoin 커맨드를 만들어 놓고 수행하는 것이 좋다.            Replication의 Recovery Point를 벗어난 Node는 회복이 불가능하므로 재구성해야한다.       위를 방지하기 위해 PostgreSQL 서버 설정 내 “max_wal_size”를 높히는 방법, 혹은 Backup 도구를 사용하는 방법 등이 존재한다.         systemctl stop postgresql-12                           Conclusion     CPU나 Memory를 확장하여 Scale-up하는 방식의 확장이 불가능한 환경에서는 Replication 구성을 통해 Scale-out을 이용하여 구성하는 방법을 검토해야 한다.   구성이 다양해지고 Replication을 통해 역할이 분담이 될 때, 가장 고민하고 시간을 할애해야 하는 것은 해당 구성에 대한 테스트를 통한 안정성 확보이다.   데이터베이스는 서비스의 가장 중요한 부분으로, 장애가 발생하여 복구가 불가능한 최악의 상황에도 대처 가능하도록 백업 도구를 적극적으로 활용하는 것을 추천한다.   Reference                 repmgr Home &#8617;           ","categories": ["PostgreSQL"],
        "tags": ["Programming","Database","PostgreSQL","Repmgr"],
        "url": "/postgresql/postgresql-repmgr/",
        "teaser": null
      },{
        "title": "PostgreSQL",
        "excerpt":"PostgreSQL1     PostgreSQL은 대중적으로 MySQL과 동시에 많이 사용하는 확장 가능 및 표준 준수를 강조하는 Open Source ORDMBS로, 다양한 기능들을 제공하며 여러 나라의 개발자들의 자발적인 노력으로 꾸준히 발전하고 있다.   캘리포니아 대학교 버클리 캠퍼스의 POSTGRES 프로젝트로 시작한 PostgreSQL은 1986년부터 35년이 넘는 시간동안 꾸준히 발전해왔으며, 현재도 3개월 단위의 릴리즈가 2024년 8월까지 확정되어있다.   잡설로, PostgreSQL의 로고인 ‘Slonik’이라는 이름의 코끼리는 아가사 크리스티의 소설 ‘코끼리는 기억한다’에서 착안해 제안했다는 이야기도 있다.         Why use it?     오픈 소스이기 때문에 개발 및 운영에 대한 비용 절감을 추구할 수 있으며, 다양한 시스템들간 유연한 연동이 가능하다.   활성화된 커뮤니티는 다양한 소속의 개발자들과의 소통을 통해 기능 확장을 통한 시스템 확장성을 확보하며 문제점 해결과 기능 보완을 통한 견고한 안정성을 확보 할 수 있다.   Popularity          DB-Engines에서 제공하는 시스템 인지도와 관련된 순위는 아래와 같다.             위에서 동일하게 제공하는 시계열 추이 그래프로, 상위 5개의 DBMS를 살펴보았다.             위에서 보듯이 PostgreSQL은 꾸준한 관심과 인지도가 상승하는 것을 확인할 수 있으며, 이를 통한 시스템의 발전을 기대할 수 있는 것이다.       Inexhaustive list     Data Types            Primitives: Integer, Numeric, String, Boolean       Structured: Date/Time, Array, Range / Multirange, UUID       Document: JSON/JSONB, XML, Key-value (Hstore)       Geometry: Point, Line, Circle, Polygon       Customizations: Composite, Custom Types           Data Integrity            UNIQUE, NOT NULL       Primary Keys       Foreign Keys       Exclusion Constraints       Explicit Locks, Advisory Locks           Concurrency, Performance            Indexing: B-tree, Multicolumn, Expressions, Partial       Advanced Indexing: GiST, SP-Gist, KNN Gist, GIN, BRIN, Covering indexes, Bloom filters       Sophisticated query planner / optimizer, index-only scans, multicolumn statistics       Transactions, Nested Transactions (via savepoints)       Multi-Version concurrency Control (MVCC)                           Parallelization of read queries and building B-tree indexes                       Table partitioning       All transaction isolation levels defined in the SQL standard, including Serializable       Just-in-time (JIT) compilation of expressions           Reliability, Disaster Recovery            Write-ahead Logging (WAL)       Replication: Asynchronous, Synchronous, Logical       Point-in-time-recovery (PITR), active standbys       Tablespaces           Security            Authentication: GSSAPI, SSPI, LDAP, SCRAM-SHA-256, Certificate, and more       Robust access-control system       Column and row-level security       Multi-factor authentication with certificates and an additional method           Extensibility            Stored functions and procedures       Procedural Languages: PL/pgSQL, Perl, Python, and Tcl. There are other languages available through extensions, e.g. Java, JavaScript (V8), R, Lua, and Rust       SQL/JSON constructors and path expressions       Foreign data wrappers: connect to other databases or streams with a standard SQL interface       Customizable storage interface for tables       Many extensions that provide additional functionality, including PostGIS           Internationalisation, Text Search            Support for international character sets, e.g. through ICU collations       Case-insensitive and accent-insensitive collations       Full-text search           Additional            Major Release에 다양한 기능들이 지속적으로 추가 및 개선되고 있으며, 버전에 따른 자세한 기능 목록은 Feature Matrix를 참고하기 바란다.           Conclusion     Oracle이 Sun Microsystems를 인수하면서 많은 개발자들이 MySQL에서 다른 DBMS로 전환을 고려하면서 자연스럽게 오픈 소스인 PostgreSQL에도 많은 관심을 가지게 된 것 같다.   또한 엔터프라이즈 목적으로 PostgreSQL를 사용하는 EnterpriseDB에서는 Oracle과 MySQL 대체 가능할 정도로 발전시키기 위한 노력을 꾸준히 하고 있다.   서비스의 종류와 사용 방안에 따라 다양한 데이터베이스를 사용할 수 있으나, 커뮤니티의 활성화를 통해 점층적으로 발전하는 PostgreSQL은 고려해야 할 DBMS임은 분명하다.   Reference                 PostgreSQL HOME &#8617;           ","categories": ["PostgreSQL"],
        "tags": ["Programming","Database","PostgreSQL"],
        "url": "/postgresql/postgresql/",
        "teaser": null
      },{
        "title": "Leetcode Java Seat Reservation Manager",
        "excerpt":"문제  Link   코드  class SeatManager {    private boolean[] seats;   private int reserved;   private int unreserved;    public SeatManager(int n) {     this.seats = new boolean[n + 1];     this.reserved = 1;     this.unreserved = 0;   }    public int reserve() {     if (unreserved == 0) {       this.seats[reserved] = true;       return this.reserved++;     } else {       for (int i = 1; i &lt; this.seats.length; i++) {         if (!this.seats[i]) {           this.seats[i] = true;           this.unreserved--;           return i;         }       }     }     return -1;   }    public void unreserve(int seatNumber) {     this.unreserved++;     this.seats[seatNumber] = false;   }  }  /**  * Your SeatManager object will be instantiated and called as such:  * SeatManager obj = new SeatManager(n);  * int param_1 = obj.reserve();  * obj.unreserve(seatNumber);  */   결과  Link   설명     [1, n] 범위의 자석의 예약 관리하는 SeatManager 클래스를 완성하는 문제이다.            생성자인 SeatManager(int n)는 [1, n] 범위의 자리를 초기화한다.       메서드인 reserve()는 가장 작은 숫자의 예약하지 않은 좌석을 가져와 예약하고 번호를 반환한다.       메서드인 unreserve(int seatNumber)는 seatNumber의 좌석을 예약 해지한다.           좌석 예약을 위한 전역 변수를 정의한다.            seats는 좌석을 관리하기 위한 변수이다.       reserved는 예약된 좌석을 계산하기 위한 변수이다.       unreserved는 예약을 해지한 좌석을 계산하기 위한 변수이다.           생성자인 SeatManager(int n)를 완성한다.            seats를 $n + 1$ 크기의 부울 배열로 초기화한다.       reserved는 첫 예약의 시작 위치인 1로 초기화한다.       unreserved는 해지한 예약이 없으므로 0으로 초기화한다.           메서드인 reserve()를 완성한다.            unreserved가 0인 경우, seats[reserved]의 값을 true로 바꾸어주고 reserved를 증가시켜준다.       위의 경우가 아니라면 seats의 빈 좌석을 찾아 true로 바꾸고, unreserved를 증가시킨 후 해당 위치를 반환한다.           메서드인 unreserve(int seatNumber)를 완성한다.            unreserved를 증가시키고 seats[seatNumber]의 값을 false인 빈 자리로 바꾸어준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/seat-reservation-manager/",
        "teaser": null
      },{
        "title": "Leetcode Java Eliminate Maximum Number of Monsters",
        "excerpt":"문제  Link   코드  class Solution {    public int eliminateMaximum(int[] dist, int[] speed) {     int length = dist.length;     for (int i = 0; i &lt; length; i++) {       dist[i] = (dist[i] - 1) / speed[i];     }     Arrays.sort(dist);     for (int i = 0; i &lt; length; i++) {       if (dist[i] &lt; i) {         return i;       }     }     return length;   }  }   결과  Link   설명          dist 거리에 있는 괴물들이 speed의 속도로 달려올 때, 1분에 한 번씩 쏠 수 있는 총으로 잡을 수 있는 괴물의 최대 수를 구하는 문제이다.            length는 dist의 길이인 괴물의 수를 저장할 변수이다.            0부터 length 미만까지 i를 증가시키면서 dist[i]에 $\\frac{dist[i] - 1}{spped[i]}$인 몬스터가 도달하는 시간을 저장해준다.            dist를 오름차순 정렬해준 후 dist[i]가 i보다 작은 경우, 몬스터가 해당 시간 이전에 도달했으므로 i를 주어진 문제의 결과로 반환한다.            반복이 완료되면 모든 괴물을 잡았으므로 length를 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/eliminate-maximum-number-of-monsters/",
        "teaser": null
      },{
        "title": "Leetcode Java Determine if a Cell Is Reachable at a Given Time",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isReachableAtTime(int sx, int sy, int fx, int fy, int t) {     int x = Math.abs(sx - fx);     int y = Math.abs(sy - fy);     int min = Math.min(x, y) + Math.abs(y - x);     if (min == 0) {       return t != 1;     } else {       return t &gt;= min;     }   }  }   결과  Link   설명          [sx, sy] 위치에서 [fx, fy] 위치까지 인접한 셀로 이동하는 시간일 1초일 때, t초 내 도달 가능한지 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            x와 y는 x축과 y축의 차이를 넣을 변수로, $sx - fx$의 절댓값과 $sy - fy$의 절댓값으로 초기화한다.       min은 최소 시간을 저장할 변수로, x와 y 중 작은 값에 $y - x$의 절댓값을 더해서 넣어준다.           min이 0인 경우, 시작과 종료가 동일한 위치인 경우이므로 t가 1이 아닌 경우만 주어진 문제의 결과로 true를 아니면 false로 반환한다.            t가 1인 경우, 어느 방향으로 이동하던지 자기 위치로 돌아올 수 없다.       t가 2인 경우, 어느 방향으로 이동했다 되돌아올 수 있다.       t가 3인 경우, 대각선을 활용하여 시작 위치에서 인접한 두 위치를 이동한 후 대각선으로 되돌아올 수 있다.       위의 각 경우에서, 1인 경우는 복귀가 불가능하며 2 이상의 짝수는 왕래를 통해 가능하고, 3 이상의 홀수는 같은 프로세스로 가능하다.           min이 0이 아닌 경우에는, t가 min 이상인 최소 이동 거리에 속한다면 주어진 문제의 결과로 true로 아니면 false를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/determine-if-a-cell-is-reachable-at-a-given-time/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Number of Homogenous Substrings",
        "excerpt":"문제  Link   코드  class Solution {    public int countHomogenous(String s) {     int count = 0;     int result = 0;     char[] charArray = s.toCharArray();     for (int left = 0, right = 0; right &lt; charArray.length; right++) {       if (charArray[left] == charArray[right]) {         count++;       } else {         left = right;         count = 1;       }       result = (result + count) % 1000000007;     }     return result;   }  }   결과  Link   설명     s의 연속된 문자열 중 동일한 문자로 이루어진 부분 문자열의 수를 구하는 문제이다.            “abbaa”의 경우, 아래와 같다.                    “a”가 3번, “aa”가 1번           “b”가 2번, “bb”가 1번           총 7개이다.                       배열의 크기가 매우 클 수 있으므로 모듈러 $10^9 + 7$을 적용한다.           문제 풀이에 필요한 변수를 정의한다.            count는 동일한 문자로 이루어진 문자열의 갯수를 저장할 변수로, 0으로 초기화한다.       result는 부분 문자열의 수를 저장할 변수로, 0으로 초기화한다.       charArray는 s를 문자 배열로 저장한 변수이다.           left와 right가 0부터 right가 charArray 길이 미만일 때 까지 right를 증가시키며 아래를 반복한다.            charArray의 left번째 문자와 right번째 문자가 동일한 경우, count를 증가시킨다.       동일하지 않은 경우, left에 right를 넣어주고 count를 1로 초기화한다.       result에 result와 count를 더한 후 모듈러 $10^9 + 7$을 적용한 값을 넣어준다.           반복이 완료되면 동일한 문자로 이루어진 부분 문자열의 수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-number-of-homogenous-substrings/",
        "teaser": null
      },{
        "title": "Leetcode Java Restore the Array From Adjacent Pairs",
        "excerpt":"문제  Link   코드  class Solution {    public int[] restoreArray(int[][] adjacentPairs) {     int length = adjacentPairs.length;     Map&lt;Integer, int[]&gt; map = new HashMap&lt;&gt;();     for (int i = 0; i &lt; length; i++) {       int[] adjacentPair = adjacentPairs[i];       if (map.containsKey(adjacentPair[0])) {         map.get(adjacentPair[0])[1] = adjacentPair[1];       } else {         map.put(adjacentPair[0], new int[] { adjacentPair[1], -1000000 });       }       if (map.containsKey(adjacentPair[1])) {         map.get(adjacentPair[1])[1] = adjacentPair[0];       } else {         map.put(adjacentPair[1], new int[] { adjacentPair[0], -1000000 });       }     }     int[] result = new int[length + 1];     int start = -1000000;     for (Map.Entry&lt;Integer, int[]&gt; entry : map.entrySet()) {       if (entry.getValue()[1] == -1000000) {         start = entry.getKey();         break;       }     }     result[0] = start;     for (int i = 1, value = -1000000; i &lt; result.length; i++) {       int[] pair = map.get(start);       int temp = pair[0] == value ? pair[1] : pair[0];       result[i] = temp;       value = start;       start = temp;     }     return result;   }  }   결과  Link   설명     아래의 조건을 만족하는 adjacentPairs를 이용하여 인접한 값끼리 묶어서 하나의 배열로 반환하는 문제이다.            adjacentPairs[i] = [ui, vi]는 ui와 vi가 인접하다는 의미이다.       순서에 상관 없이, 조건을 만족하는 배열을 만들어 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            length는 adjacentPairs의 길이를 저장한 변수이다.       map은 adjacentPairs의 임의 값에 대한 연관된 값들을 모아 저장할 변수로, HashMap으로 초기화한다.           0부터 length 미만까지 i를 증가시키면서 아래를 수행한다.            adjacentPair에 adjacentPairs의 i번째 배열을 넣어준다.       map에 adjacentPair[0]의 값이 map 내 키로 존재하는지에 따라 아래를 수행한다.                    존재하는 경우, 해당 키의 값인 배열에 adjacentPair[1]의 값을 넣어준다.           존재하지 않는 경우, 해당 키에 연관된 adjacentPair[1]의 값과 값 범위의 하한값인 -100000을 배열로 넣어준다.                       map에 adjacentPair[1]의 값이 map 내 키로 존재하는지에 따라 아래를 수행한다.                    존재하는 경우, 해당 키의 값인 배열에 adjacentPair[0]의 값을 넣어준다.           존재하지 않는 경우, 해당 키에 연관된 adjacentPair[0]의 값과 값 범위의 하한값인 -100000을 배열로 넣어준다.                                start는 시작 값을 찾기 위한 변수로 값의 하한 값인 -100000으로, result는 결과를 넣을 배열로 $length + 1$ 크기의 정수 배열로 초기화한다.       map을 순환하면서 값인 배열의 두 번째 값이 -100000인 연관된 값이 하나만 존재하는 경우, start에 해당 key 값을 넣고 반복을 종료한다.            순서는 상관 없으므로, 시작 값이든 종료 값이든 상관이 없다.                시작 값인 result[0] 값에 start를 넣어준다.       value는 값의 하한 값인 -10000으로 정의하고, 1부터 result의 길이 미만까지 i를 증가시키면서 아래를 반복한다.            pair에 map의 start번째 값을 꺼내 넣어준다.       temp에 pair의 첫 값이 value와 같으면 두 번째 값을, 아니면 첫 번째 값을 넣어준다.       result[i]에 temp를, value에 start를, start에 temp를 순차적으로 넣어준다.           반복이 완료되면 연관된 값들을 모아 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/restore-the-array-from-adjacent-pairs/",
        "teaser": null
      },{
        "title": "Leetcode Java Design Graph With Shortest Path Calculator",
        "excerpt":"문제  Link   코드  class Graph {    private int n;   private int[][] costs;    public Graph(int n, int[][] edges) {     this.costs = new int[n][n];     this.n = n;     for (int[] a : this.costs) {       Arrays.fill(a, (int) 1e9);     }     for (int[] e : edges) {       this.costs[e[0]][e[1]] = e[2];     }     for (int i = 0; i &lt; n; i++) {       this.costs[i][i] = 0;     }     for (int k = 0; k &lt; n; k++) {       for (int i = 0; i &lt; n; i++) {         for (int j = 0; j &lt; n; j++) {           this.costs[i][j] = Math.min(this.costs[i][j], this.costs[i][k] + this.costs[k][j]);         }       }     }   }    public void addEdge(int[] e) {     for (int i = 0; i &lt; this.n; i++) {       for (int j = 0; j &lt; this.n; j++) {         this.costs[i][j] = Math.min(this.costs[i][j], this.costs[i][e[0]] + this.costs[e[1]][j] + e[2]);       }     }   }    public int shortestPath(int node1, int node2) {     if (this.costs[node1][node2] &gt;= (int) 1e9) {       return -1;     } else {       return this.costs[node1][node2];     }   }  }  /**  * Your Graph object will be instantiated and called as such:  * Graph obj = new Graph(n, edges);  * obj.addEdge(edge);  * int param_2 = obj.shortestPath(node1,node2);  */   결과  Link   설명     [0, $n - 1$]까지 노드간 최단 길이를 찾을 수 있는 Graph 객체를 완성하는 문제이다.            edge[i] = [fromi, toi, edgeCosti]로, fromi에서 toi로 가는데 걸리는 비용이 edgeCosti임을 나타낸다.       생성자인 Graph(int n, int[][] edges)는, n과 edges를 이용하여 Graph 객체를 초기화하는 역할을 수행한다.       메서드인 addEdge(int[] edge)는, 이전까지 존재하지 않는 edge를 Graph 객체에 추가하는 역할을 수행한다.       메서드인 shortestPath(int node1, int node2)는, node1부터 node2까지 가장 짧은 비용을 반환하는 역할을 수행한다. 단, 경로가 존재하지 않으면 -1을 반환한다.           Graph의 객체에 필요한 전역 변수를 정의한다.            n은 노드의 갯수를 저장할 변수이다.       costs는 노드 간 비용을 저장할 변수이다.           생성자인 Graph(int n, int[][] edges)를 초기화한다.            n을 전역 변수 n에 넣어준다.       전역 변수 cost에 한 노드에서 다른 노드로 이동하기 위한 비용을 저장하기 위해서, 2차원 배열로 초기화하고 모든 값에 노드 간 길이의 상한값인 $10^9$를 넣어준다.       costs의 내 모든 노드가 자기 자신의 노드로 이동하는 costs[i, i]에 0을 넣어준다.       k, i, j 순으로 0부터 n 미만까지 k, i, j를 각각 증가시키며 아래를 반복한다.       costs[i][j]에 자기 자신의 값과 $cost[i][k] + cost[k][j]$인 k를 경유하고 이동한 값 중 가장 작은 값을 넣어준다.           메서드인 addEdge(int[] edge)를 초기화한다.            i, j 순으로 0부터 n 미만까지 i, j를 각각 증가시키며 아래를 반복한다.                    costs[i][j]에 자기 자신의 값과 $costs[i][e[0]] + csts[e[1]][j] + e[2]$인 엣지 라인을 경유하고 가는 경우의 비용 중 작은 값을 넣어주낟.                           메서드인 shortestPath(int node1, int node2)를 초기화한다.            costs[node1][node2]가 $10^9$보다 큰 경우, 루트가 존재하지 않으므로 -1을 반환한다.       위의 경우가 아니라면 costs[node1][node2]의 비용을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/design-graph-with-shortest-path-calculator/",
        "teaser": null
      },{
        "title": "Leetcode Java Construct Binary Search Tree from Preorder Traversal",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public TreeNode bstFromPreorder(int[] preorder) {     return this.bst(preorder, Integer.MAX_VALUE, new int[] { 0 });   }    private TreeNode bst(int[] preorder, int bound, int[] i) {     if (i[0] == preorder.length || bound &lt; preorder[i[0]]) {       return null;     }     TreeNode root = new TreeNode(preorder[i[0]++]);     root.left = this.bst(preorder, root.val, i);     root.right = this.bst(preorder, bound, i);     return root;   }  }   결과  Link   설명          preorder를 이용하여 Pre-Order의 TreeNode를 완성하는 문제이다.            BST로 TreeNode를 완성할 bstFromPreorder(int[] preorder, int bound, int[] i) 메서드를 수행하여 만들어진 TreeNode를 주어진 문제의 결과로 반환한다.             i[0]이 preorder의 길이와 동일하거나 bound가 preorder[i[0]] 값보다 작은 경우, 노드를 만들 수 없으므로 null을 반환한다.       root에 preorder[i[0]] 값을 가진 TreeNode를 만들어주고 i[0] 값을 증가시킨다.       root의 left TreeNode 위치에 root의 val 값을 이용한 재귀 호출을 수행한 결과를 넣어준다.       root의 right TreeNode 위치에 bound 값을 이용한 재귀 호출을 수행한 결과를 넣어준다.       수행이 완료되면 root를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/construct-binary-search-tree-from-preorder-traversal/",
        "teaser": null
      },{
        "title": "Leetcode Java Sort Vowels in a String",
        "excerpt":"문제  Link   코드  class Solution {    public String sortVowels(String s) {     String vowels = \"aeiouAEIOU\";     char[] charArray = s.toCharArray();     int length = charArray.length;     char[] vowelArray = new char[length];     int i = 0;     for (char c : charArray) {       if (vowels.indexOf(c) != -1) {         vowelArray[i++] = c;       }     }     Arrays.sort(vowelArray, 0, i);     StringBuilder sb = new StringBuilder();     for (int j = i = 0; i &lt; charArray.length; i++) {       if (vowels.indexOf(charArray[i]) != -1) {         sb.append(vowelArray[j++]);       } else {         sb.append(charArray[i]);       }     }     return sb.toString();   }  }   결과  Link   설명          문자열 s 내 자음은 그 자리 그대로 유지하고, 모음만 ASCII 코드의 오름차순으로 정렬하여 위치를 바꾸는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            vowels는 모음을 저장한 변수로, 모음 문자열을 대소문자 모두 포함하여 “aeiouAEIOU”로 초기화한다.       charArray는 s를 문자 배열로 변환하여 저장한 변수이다.       vowelArray는 모음 문자만 모아서 저장할 변수로, 최대 가능한 문자 갯수인 length 길이의 문자 배열로 초기화한다.       i는 vowelArray의 처음부터 모음 문자를 넣기 위한 위치 변수로, 0으로 초기화하고 charArray의 모든 문자들을 순차적으로 탐색하여 vowelArray에 넣어준 후 넣은 값들을 오름차순 정렬시켜준다.       sb는 결과 문자열을 동적으로 생성할 변수로, StringBuilder로 초기화한다.           i를 0으로 초기화하고, j를 0으로 정의한 후 charArray의 길이 미만까지 i를 증가시키며 아래를 반복한다.            charArray[i]의 문자가 모음인 경우, sb에 vowelArray[j]의 문자를 넣어주고 j를 증가시킨다.       위의 경우가 아니라면, sb에 charArray[i]의 문자를 넣어준다.           반복이 완료되면 sb를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sort-vowels-in-a-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Unique Length-3 Palindromic Subsequences",
        "excerpt":"문제  Link   코드  class Solution {    public int countPalindromicSubsequence(String s) {     int result = 0;     char[] charArray = s.toCharArray();     int length = charArray.length;     for (char c = 'a'; c &lt;= 'z'; c++) {       int start = -1;       int end = -1;       for (int i = 0; i &lt; length; i++) {         if (charArray[i] == c) {           if (start == -1) {             start = i;           }           end = i;         }       }       if (start != -1 &amp;&amp; end != -1 &amp;&amp; end - start &gt;= 2) {         boolean[] seen = new boolean[26];         for (int i = start + 1; i &lt; end; i++) {           int num = charArray[i] - 'a';           if (!seen[num]) {             seen[num] = true;             result++;           }         }       }     }     return result;   }  }   결과  Link   설명          s의 임의 세 문자를 이용하여 만들 수 있는 앞과 뒤가 동일한 문자열인 회문의 중복되지 않은 갯수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 회문의 갯수를 저장할 변수로, 0으로 초기화한다.       charArray는 s를 문자 배열로 변환하여 저장한 변수이다.       length는 charArray의 길이를 저장한 변수이다.           ‘a’부터 ‘z’까지 c를 증가시키며 아래를 반복한다.            start와 end를 회문의 시작과 종료 위치를 저장할 변수로, charArray의 문자들을 반복하여 start의 회문의 시작 위치를 넣고 end에 c의 마지막 위치를 넣어준다.       start와 end가 -1이 아니면서 end와 start의 차이가 2 이상인 최소 3자리 이상인 경우, 아래를 수행한다.                    seen은 회문의 가운데 문자 중 확인한 문자를 체크하기 위한 변수로, 영문자의 갯수인 26 크기의 부울 배열로 초기화한다.           $start + 1$부터 end 미만까지 i를 증가시키며, charArray[i]의 문자가 이전에 존재하지 않은 경우 seen[num]을 true로 변경하고 중복되지 않은 회문의 갯수인 result를 증가시켜 증가시킨다.                           반복이 완료되면 중복되지 않은 회문의 갯수인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/unique-length-3-palindromic-subsequences/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Element After Decreasing and Rearranging",
        "excerpt":"문제  Link   코드  class Solution {    public int maximumElementAfterDecrementingAndRearranging(int[] arr) {     int length = arr.length;     int[] count = new int[length];     for (int i = 0; i &lt; length; i++) {       count[Math.min(arr[i] - 1, length - 1)]++;     }     int result = 1;     for (int i = 1; i &lt; length; i++) {       result = Math.min(i + 1, result + count[i]);     }     return result;   }  }   결과  Link   설명     양의 정수 배열 arr을 이용하여 아래의 조건과 연산을 수행하여 최댓값을 반환하는 문제이다.            arr의 첫 값은 1로 시작해야한다.       인접한 값들의 차이는 1 이하여야 한다.       위의 조건에 맞도록 여러 번 연산할 수 있는 작업은 아래와 같다.                    arr의 값이라도 최대한 작은 정수로 만든다.           arr의 값들을 임의 순서로 재배치한다.                           문제 풀이에 필요한 변수를 정의한다.            length는 arr의 길이를 저장한 변수이다.       count는 숫자 계산에 필요한 배열로, 1부터 시작하므로 가장 큰 값인 length 크기의 정수 배열로 초기화하고 0부터 legnth까지 i를 증가시키며 count의 $arr[i] - 1$과 $length - 1$ 중 작은 위치의 값을 증가시킨다.       result는 최댓값을 저장할 변수로, 시작 값인 1로 초기화한다.                1부터 length 미만까지 i를 증가시키며 result에 $i + 1$과 $result + count[i]$ 중 작은 값을 넣어준다.       반복이 완료되면 최댓값이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-element-after-decreasing-and-rearranging/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Unique Binary String",
        "excerpt":"문제  Link   코드  class Solution {    public String findDifferentBinaryString(String[] nums) {     StringBuilder sb = new StringBuilder();     for (int i = 0; i &lt; nums.length; i++) {       sb.append(nums[i].charAt(i) == '0' ? '1' : '0');     }     return sb.toString();   }  }   결과  Link   설명     nums와 중복되지 않은 임의의 이진 값을 찾는 문제이다.            nums[i]의 길이와 nums의 길이와 같으며, 여러 값이 존재하면 임의 하나의 값을 반환한다.                sb는 결과를 저장할 변수로, 동적인 문자열 생성을 위해 StringBuilder로 초기화한다.            0부터 length까지 i를 증가시키면서 nums[i]의 i번째 문자가 0이면 1로, 1이면 0으로 반전시킨다.       중복되지 않은 임의 이진 값이 저장된 sb를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-unique-binary-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimize Maximum Pair Sum in Array",
        "excerpt":"문제  Link   코드  class Solution {    public int minPairSum(int[] nums) {     Arrays.sort(nums);     int result = 0;     int length = nums.length;     for (int i = 0; i &lt; length / 2; i++) {       result = Math.max(result, nums[i] + nums[length - i - 1]);     }     return result;   }  }   결과  Link   설명     정수 배열인 nums를 이용하여 아래의 조건을 만족하는 쌍들 중 합이 가장 큰 값을 구하는 문제이다.            각 정수는 하나의 쌍에만 속한다.       가장 큰 쌍의 합은 가장 작은 경우가 되어야 한다.                nums를 오름차순으로 정렬한다.       문제 풀이에 필요한 변수를 정의한다.            result는 쌍의 합이 가장 큰 값을 저장할 변수로, 0으로 초기화한다.       length는 nums의 길이를 저장한 변수이다.                0부터 $\\frac{length}{2}$미만까지 i를 증가시키면서 result에 result와 현 위치에서 작은 값과 큰 값의 쌍을 묶은 합인 $nums[i] + nums[length - i - 1]$의 값 중 큰 값을 넣어준다.       반복이 완료되면 쌍의 합이 가장 큰 값인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimize-maximum-pair-sum-in-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Frequency of the Most Frequent Element",
        "excerpt":"문제  Link   코드  class Solution {    public int maxFrequency(int[] nums, int k) {     int result = 1;     int i = 0;     int j = 0;     Arrays.sort(nums);     for (long sum = 0; j &lt; nums.length; j++) {       sum += nums[j];       while (sum + k &lt; (long) nums[j] * (j - i + 1)) {         sum -= nums[i];         i += 1;       }       result = Math.max(result, j - i + 1);     }     return result;   }  }   결과  Link   설명          최대 k번 수행을 통해 nums 내 특정 값을 1씩 증가시킬 수 있는데, 연속으로 동일한 값이 되는 최대 길이를 구하는 문제이다.            nums를 오름차순으로 정렬 수행한다.       문제 풀이에 필요한 변수를 정의한다.            result는 연속으로 동일한 값이 되는 최대 길이를 저장할 변수로, 0으로 초기화한다.       sum은 이전 값을 저장해줄 변수로, overflow를 방지하기 위해서 Long 타입으로 정의 후 0으로 초기화한다.           i와 j를 0으로 초기화하고 j가 nums의 길이 미만일 때 까지 j를 증가시키며 아래를 반복한다.            sum에 nums[j]의 값을 더해준다.       $nums[j] \\times (j - i + 1)$의 값이 $k + sum$보다 크면 더 증가시켜도 동일한 값이 되지 못하므로, sum에 nums[i]의 값을 빼고 i를 증가시켜준다.       result에 result와 $j - i + 1$중 큰 값을 넣어 최대 길이를 저장한다.           반복이 완료되면 최대 길이가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/frequency-of-the-most-frequent-element/",
        "teaser": null
      },{
        "title": "Leetcode Java Reduction Operations to Make the Array Elements Equal",
        "excerpt":"문제  Link   코드  class Solution {    public int reductionOperations(int[] nums) {     Arrays.sort(nums);     int result = 0;     int length = nums.length;     for (int i = length - 1; i &gt; 0; i--) {       if (nums[i - 1] != nums[i]) {         result += length - i;       }     }     return result;   }  }   결과  Link   설명          nums의 값을 내부 값으로 낮춰가면서 모든 값이 동일할 때 까지 걸리는 횟수를 구하는 문제이다.            nums의 값들을 오름차순으로 정렬한다.       문제 풀이에 필요한 변수를 정의한다.            result는 횟수를 계산하기 위한 변수로, 0으로 초기화한다.       length는 nums의 길이를 저장한 변수이다.           $length - 1$부터 0 초과일 때 까지 i를 감소시키면서 아래를 반복한다.            nums[$i - 1$]의 값과 nums[i]의 값이 다른 경우, result에 바꾸기 위한 횟수인 $length - i$을 더해준다.           반복이 완료되면 감소 횟수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reduction-operations-to-make-the-array-elements-equal/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Amount of Time to Collect Garbage",
        "excerpt":"문제  Link   코드  class Solution {    public int garbageCollection(String[] garbage, int[] travel) {     int[] charArray = new int[128];     char[] garbages = new char[] { 'M', 'P', 'G' };     int result = 0;     for (int i = 0; i &lt; garbage.length; i++) {       result += garbage[i].length();       for (int j = 0; j &lt; garbage[i].length(); j++) {         charArray[garbage[i].charAt(j)] = i;       }     }     for (int i = 1; i &lt; travel.length; i++) {       travel[i] += travel[i - 1];     }     for (int g : garbages) {       if (charArray[g] &gt; 0) {         result += travel[charArray[g] - 1];       }     }     return result;   }  }   결과  Link   설명          철, 종이, 유리 쓰레기를 순차적으로 ‘M’, ‘P’, ‘G’ 문자로 정의하고 각각 걸리는 시간을 travel로 정의할 때, garbage의 모든 쓰레기를 수거하기 위한 시간을 계산하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            charArray는 쓰레기를 저장하기 위한 변수로, 영대문자의 최대 ASCII 코드 값인 128 크기의 정수 배열로 초기화한다.       garbages는 쓰레기인 ‘M’, ‘P’, ‘G’ 문자를 저장한 배열이다.       result는 수거하는데 걸리는 시가을 저장하기 위한 변수로, 0으로 초기화한다.           0부터 garbage의 크기 미만까지 i를 증가시키며 아래를 반복한다.            result에 garbage의 크기를 더해준다.       0부터 garbage[i]의 길이 미만까지 j를 증가시키며, charArray 내 garbage[i]의 j번째 문자 위치에 마지막 발생한 위치인 i를 넣어준다.                1부터 travel 길이 미만까지 travel[i]에 travel[$i - 1$]을 더해 시간을 더해준다.       garbages를 순차적으로 g에 넣어 charArray[g]의 값이 0보다 큰 경우, result에 travel의 $charArray[g] - 1$인 소요 시간을 더해준 후 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-amount-of-time-to-collect-garbage/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Nice Pairs in an Array",
        "excerpt":"문제  Link   코드  class Solution {    public int countNicePairs(int[] nums) {     int result = 0;     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();     for (int num : nums) {       int reverse = 0;       for (int i = num; i &gt; 0; i /= 10) {         reverse = (reverse * 10) + (i % 10);       }       int value = map.getOrDefault(num - reverse, 0);       map.put(num - reverse, value + 1);       result = (result + value) % 1000000007;     }     return result;   }  }   결과  Link   설명     nums 내 두 값 중 한 값만 반전시켜 번갈아 더한 값이 동일한 쌍의 수를 구하는 문제이다.            단, 쌍의 수가 매우 클 수 있으므로 모듈러 $10^9 + 7$을 적용한다.           문제 풀이에 필요한 변수를 정의한다.            result는 쌍의 수를 저장할 변수로, 0으로 초기화한다.       map은 쌍의 수를 계산하기위한 변수로, HashMap으로 초기화한다.           nums의 모든 값을 num에 순차적으로 넣어 아래를 반복한다.            reverse에 num의 값을 반전시켜 넣어준다.       value에 map 내 $num - reverse$의 결과가 키인 값인 동일한 쌍의 수가 있으면 해당 값을 꺼내고, 아니면 0으로 초기화한다.       map에 $num - reverse$가 키인 값에 $value + 1$을 넣어준다.       result에 $result + value$를 모듈러 $10^9 + 7$을 적용한 값을 넣어준다.           반복이 완료되면 모듈러를 적용한 쌍의 수가 저장된 result를 주어진 문제의 결과로 반환한다.   해설     두 값 중 한 값만 반전시켜 번갈아 더한 값이 동일한 경우, 자기 자신의 값에 반전시킨 값을 뺀 결과가 동일한다.   예를 들어, 42와 97의 경우 $42 + 79 = 24 + 97 = 121$를 만족하며 $42 - 24 = 97 - 79 = 18$을 만족한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-nice-pairs-in-an-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Diagonal Traverse II",
        "excerpt":"문제  Link   코드  class Solution {    public int[] findDiagonalOrder(List&lt;List&lt;Integer&gt;&gt; nums) {     int max = 0;     int length = 0;     List&lt;Integer&gt;[] map = new ArrayList[100001];     for (int i = 0; i &lt; nums.size(); i++) {       List&lt;Integer&gt; list = nums.get(i);       int size = list.size();       length += size;       for (int j = 0; j &lt; size; j++) {         int sum = i + j;         if (map[sum] == null) {           map[sum] = new ArrayList&lt;&gt;();         }         map[sum].add(list.get(j));         max = Math.max(max, sum);       }     }     int[] result = new int[length];     int index = 0;     for (int i = 0; i &lt;= max; i++) {       List&lt;Integer&gt; curr = map[i];       for (int j = curr.size() - 1; j &gt;= 0; j--) {         result[index++] = curr.get(j);       }     }     return result;   }   }   결과  Link   설명          nums 내 값들을 2차원 배열 형태로 구성했을 때, 좌측 상단의 첫 값부터 좌측 아래에서 우측 위로 대각선 방향으로 이동했을 때 만나는 숫자 순서대로 정렬해서 하나의 배열로 만드는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            max는 nums를 이용하여 만들 수 있는 대각선의 갯수로, 0으로 초기화한다.       length는 nums 내 값들의 수를 저장할 변수로, 0으로 초기화한다.       map은 대각선대로 값을 이어줄 변수로, 값의 가장 큰 갯수보다 1 큰 100001 크기의 ArrayList 배열로 초기화한다.                    위의 값들을 nums를 반복하여 max에 nums의 대각선의 갯수를, length에 nums 내 값들의 수를, map에 $i + j$인 각 대각선 순서대로 첫 행부터 마지막 행까지 값들을 넣어준다.                       result는 숫자들을 순서대로 넣어 줄 배열로, length 길이의 정수 배열로 초기화한다.       index는 result의 각 위치를 순서대로 넣기 위한 변수로, 첫 위치인 0으로 초기화한다.           map을 첫 배열의 List부터 순차적으로 반복하여 역순으로, result에 값을 넣어 주어진 문제의 결과로 반환한다.   해설     숫자의 대각선 순서대로 저장할 map을 List의 배열로 초기화한 이유는 각 위치는 i번째 행과 j번째 행을 더한 위치가 아래와 같이 순차적으로 계산이 가능하므로 이를 활용한다.            첫 번째 대각선 : $0 + 0 = 0$       두 번째 대각선 : $0 + 1 = 1 + 0 = 1$       세 번쨰 대각선 : $0 + 2 = 1 + 1 = 2 + 0 = 2$           nums 내 각 List의 값들은 동일하지 않은 길이의 정수 값으로 이루어졌으므로, map에 값이 들어간 List의 수는 map개가 존재하고 result의 길이는 length로 초기화하기 위해 두 값을 계산한다.   map의 각 List는 첫 행부터 마지막 행 순으로 각 배열에 값을 넣었으므로, 대각선대로 역순으로 result에 값을 넣는다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/diagonal-traverse-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Arithmetic Subarrays",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Boolean&gt; checkArithmeticSubarrays(int[] nums, int[] l, int[] r) {     List&lt;Boolean&gt; result = new ArrayList&lt;&gt;();     for (int i = 0; i &lt; l.length; i++) {       result.add(this.checkArithmeticSubarrays(nums, l[i], r[i]));     }     return result;   }    private boolean checkArithmeticSubarrays(int[] nums, int left, int right) {     if (right - left &lt; 2) {       return true;     }     int min = Integer.MAX_VALUE;     int max = Integer.MIN_VALUE;     for (int i = left; i &lt;= right; i++) {       min = Math.min(min, nums[i]);       max = Math.max(max, nums[i]);     }     int diff = max - min;     int length = right - left;     if (diff % length != 0) {       return false;     }     if (diff % length != 0) {       return false;     }     diff /= length;     if (diff == 0) {       return true;     }     boolean[] visited = new boolean[length + 1];     for (int i = left; i &lt;= right; i++) {       int value = nums[i] - min;       if (value % diff != 0) {         return false;       } else {         int index = value / diff;         if (visited[index]) {           return false;         } else {           visited[index] = true;         }       }     }     return true;   }  }   결과  Link   설명          nums 내 [l[i], r[i]] 범위의 부분 배열로 산술(등차) 수열을 만들 수 있는지 검증하는 문제이다.            결과를 넣을 result를 정의하고, l과 r의 처음부터 끝까지 값들을 이용하여 3번에서 정의한 checkArithmeticSubarrays(int[] nums, int left, int right)를 수행한 결과를 result에 넣어 주어진 문제의 결과로 반환한다.            [left, right] 범위 내 산술 수열을 검증하기 위한 checkArithmeticSubarrays(int[] nums, int left, int right) 메서드를 정의한다.             $right - left$가 2 미만인 경우, 무조건 산술 수열이므로 true를 반환한다.       min과 max에 위의 범위 내 최솟값과 최댓값을 넣어준다.       diff는 $max - min$인 차잇값을, length는 $right - left$의 숫자 갯수를 넣어준다.       diff에 length를 나눈 나머지 값이 0이 아닌 경우, 등차 수열을 이룰 수 없으므로 false를 반환한다.       diff에 legnth를 나눈 값을 넣어주고 해당 값이 0인 경우, 등차 수열을 이룰 수 있으므로 true를 반환한다.       visited는 동일한 값이 발생했는지 확인하기 위한 배열로, $length + 1$ 크기의 부울 배열로 초기화한다.       left부터 right 이하까지 i를 증가시키며 아래를 반복한다.                    value에 $nums[i] - min$인 등차 수열의 증가치를 넣어준다.           value를 diff로 나눈 나머지가 0이 아닌 경우 false를 반환한다.           위의 경우가 아니라면 value를 diff로 나눈 값이 visited에 존재하면 false를 반환하고, 없으면 visited의 해당 위치 값을 true로 바꾸어준다.                       반복이 완료되면 nums의 [left, right] 구간의 값들로 등차 수열을 이룰 수 있는지 검증이 완료되었으므로, true를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/arithmetic-subarrays/",
        "teaser": null
      },{
        "title": "Leetcode Java Sum of Absolute Differences in a Sorted Array",
        "excerpt":"문제  Link   코드  class Solution {    public int[] getSumAbsoluteDifferences(int[] nums) {     int length = nums.length;     int[] result = new int[length];     int[] sum = new int[length + 1];     for (int i = 0; i &lt; length; i++) {       sum[i + 1] = sum[i] + nums[i];     }     for (int i = 0; i &lt; length; i++) {       result[i] = (i * nums[i]) - sum[i] + (sum[length] - sum[i] - ((length - i) * nums[i]));     }     return result;   }  }   결과  Link   설명          nums의 각 자리 별 모든 값의 차잇값에 대한 절댓값을 더해서 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       result는 각 자리 별 모든 값의 차잇값에 대한 절댓값을 더한 값을 저장하기 위한 변수로, length 길이의 정수 배열로 초기화한다.       sum은 누계하기 위한 변수로, $length + 1$ 크기의 정수 배열로 초기화하고 $i + 1$ 위치에 i번째 값까지의 누계를 넣어준다.           0부터 length 미만까지 i를 증가시키며 아래를 반복한다.            result[i]에 아래의 값들을 더해준다.                    i번째 값 이전까지의 결과는 $(nums[i] - num[0]) + (nums[i] - nums[1]) + … + (nums[i] - nums[i - 1]) = (i \\times nums[i]) - sum[i]$이다.           i번째 값에는 같은 값끼리 빼기 때문에 0이 된다.           i번쨰 값 이후부터의 결과는 처음과 같이 하면 음수가 되기 때문에, 반대로 이후 값부터 빼므로 $(nums[i + 1] - nums[i]) + (nums[i + 2] - nums[i]) + … + (nums[length - 1] - nums[i]) = sum[length] - sum[i] - ((length - i) * nums[i])$이 된다.                           계산된 결과가 담긴 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sum-of-absolute-differences-in-a-sorted-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Complement of Base 10 Integer",
        "excerpt":"문제  Link   코드  class Solution {    public int bitwiseComplement(int n) {     if (n == 0) {       return 1;     } else {       int power = 1;       while (power &lt;= n) {         power *= 2;       }       return (power - 1) - n;     }   }  }   결과  Link   설명          n의 1의 보수를 구하는 문제이다.            n이 0인 경우, 1을 반환한다.            그 외의 경우 power가 n보다 큰 2의 배수로 만들어 1의 보수를 구하는 공식인 $(power - 1) - n$의 결과를 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/complement-of-base-10-integer/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Ways to Divide a Long Corridor",
        "excerpt":"문제  Link   코드  class Solution {    public int numberOfWays(String corridor) {     char[] charArray = corridor.toCharArray();     int length = charArray.length;     int seat = 0;     long result = 1;     for (int i = 0; i &lt; length; i++) {       if (charArray[i] == 'S') {         seat++;         while (++i &lt; length &amp;&amp; charArray[i] != 'S') {         }         if (i &lt; length &amp;&amp; charArray[i] == 'S') {           seat++;         }         int divider = 1;         while (++i &lt; length &amp;&amp; charArray[i] != 'S') {           divider++;         }         if (divider &gt; 1 &amp;&amp; i &lt; length) {           result = (result * divider) % 1000000007;         }         i--;       }     }     return seat != 0 &amp;&amp; seat % 2 == 0 ? (int) result : 0;   }  }   결과  Link   설명     corridor를 이용하여 아래의 규칙을 만족하는 복도를 만들 수 있는 경우의 수를 구하는 문제이다.            corridor 내 ‘S’는 자리를, ‘P’는 식물을 의미한다.       corridor 시작 전과 끝에는 룸 디바이더로 구성되어 있으며, 복도를 나누기 위해서는 양 쪽 모두 정확히 2개의 좌석이 포함되어야하고 식물의 갯수는 상관 없다.       답이 매울 클 수 있으므로 모듈러 $10^9 + 7$을 적용한 값을 반환한다.       답이 존재하지 않는 경우, 0을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            charArray는 corridor를 문자 배열로 변환한 변수이다.       length는 charArray의 길이를 저장한 변수이다.       seat는 좌석의 갯수를 저장할 변수로, 0으로 초기화한다.       result는 경우의 수를 저장할 변수로, 값이 매우 클 수 있으므로 long 타입의 1로 초기화한다.           0부터 length 미만까지 i를 증가시키며 아래를 수행한다.            charArray[i]의 문자가 ‘S’인 좌석의 경우만 아래를 수행하며, ‘P’인 식물의 경우 갯수 제한이 없으므로 다음 반복을 수행한다.       seat를 증가시켜 좌석의 수를 증가시켜주고, i가 legnth 미만이면서 ‘S’가 아닌 문자일 때 까지 i를 증가시켜준다.       i를 증가시킨 값이 length 미만이면서 charArray[i]의 문자가 ‘S’인 경우, seat를 증가시켜 2개로 만들어준다.       divider는 복도를 만들 수 있는 경우의 수로, 1로 초기화 후 i를 증가시킨 값이 length 미만이면서 charArray[i]의 문자가 ‘S’가 아닐 때 까지 divider를 증가시켜 경우의 수를 증가시켜준다.       divider가 1보다 크면서 i가 length 미만인 경우, result에 기존 경우의 수인 result와 현재 위치에서 복도를 만들 수 있는 경우의 수인 divider의 곱에 모듈러 $10^9 + 7$을 적용한 값을 넣어준다.       마지막으로 복도 시작 전 위치에서 다시 반복을 수행하기 위하여 i를 감소시켜준다.           반복이 완료되면 아래의 경우를 모두 만족하지 않으면 result를 int로 변환하여, 아니면 0을 주어진 문제의 결과로 반환한다.            seat가 0인 복도 생성이 불가능한 경우.       seat의 갯수가 홀수라서 정확히 2개 단위로 복도 생성을 모두 수행하지 못하는 경우.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-ways-to-divide-a-long-corridor/",
        "teaser": null
      },{
        "title": "Leetcode Java Pairs of Songs With Total Durations Divisible by 60",
        "excerpt":"문제  Link   코드  class Solution {    public int numPairsDivisibleBy60(int[] time) {     long[] count = new long[60];     for (int t : time) {       count[t % 60]++;     }     long result = 0;     if (count[0] &gt; 1) {       result += count[0] * (count[0] - 1) / 2;     }     if (count[30] &gt; 1) {       result += count[30] * (count[30] - 1) / 2;     }     for (int i = 1; i &lt; 30; i++) {       result += count[i] * count[60 - i];     }     return (int) result;   }  }   결과  Link   설명          time 내 값들을 이용하여 두 값의 합이 60초 단위가 되는 경우의 수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            count는 60초로 나눈 나머지 여분의 시간으로 끝나는 값들의 갯수를 저장할 변수로, overflow를 방지하기 위하여 long 형태의 배열로 초기화하고 time의 각 값들을 60으로 나눈 나머지의 위치에 갯수를 저장해준다.       result 경우의 수를 저장할 변수로, overflow를 방지하기 위하여 long 형태의 0으로 초기화한다.                count[0]의 갯수가 2개 이상인 경우, 해당 값들의 순서를 변경했을 때 나올 수 있는 경우의 수인 $\\frac{count[0] \\times (count[0] - 1)}{2}$를 result에 더해준다.                   count[30]의 갯수가 2개 이상인 경우, 0초와 동일하게 해당 값들의 순서를 변경했을 때 나올 수 있는 경우의 수인 $\\frac{count[30] \\times (count[30] - 1)}{2}$를 result에 더해준다.           0초와 30초를 제외한 1 ~ 29초 구간을 i를 증가시키며 60초 단위로 떨어지는 조합의 경우의 수를 result에 더해준 후, int로 형변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/pairs-of-songs-with-total-durations-divisible-by-60/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum One Bit Operations to Make Integers Zero",
        "excerpt":"문제  Link   코드  class Solution {    public int minimumOneBitOperations(int n) {     int result = 0;     int sign = 1;     while (n &gt; 0) {       result += (n ^ (n - 1)) * sign;       sign = -sign;       n &amp;= n - 1;     }     return Math.abs(result);   }  }   결과  Link   설명     정수 n을 아래의 규칙을 이용하여 0으로 변환하는데 필요한 최소 작업 수를 구하는 문제이다.            n의 이진 표현에서 가장 우측 비트를 변경한다.       n의 이진 표현에서 $i - 1$번째 비트가 1일 때, $i - 2$번째 부터 가장 우측에 있는 비트가 0으로 설정된 경우 i번째 비트를 변경한다.           문제 풀이에 필요한 변수를 정의한다.            result는 최소 작업의 수를 저장할 변수로, 0으로 초기화한다.       sign은 최소 작업의 수를 계산하기 위한 변수로, 1로 초기화한다.           n이 0 초과일 때까지 아래를 수행한다.            result에 n과 $n - 1$의 XOR(^) 비트 연산 수행 결과와 sign의 곱을 더해준다.       sign의 부호를 반전시켜준다.       n에 n과 $n - 1$과 AND(&amp;) 비트 연산을 수행한 결과를 넣어, n의 이진 표현에서 가장 좌측에 존재하는 1의 위치를 다음 1의 위치로 이동한다.           반복이 완료되면 최소 작업의 수가 계산된 result의 절댓값을 주어진 문제의 결과로 반환한다.   해설     i번째 위치만 1인 값을 0으로 변환하기 위한 과정은 아래와 같다.            1 -&gt; 0 = 1       2 -&gt; 0 = 3       4 -&gt; 0 = 7           위의 결과를 통해 $2^i$를 0으로 변환하기 위한 과정은 $2^(i + 1) - 1 =$ n ^ ($n - 1$)의 공식을 얻을 수 있다.   이를 이용하여 각 위치를 계산하기 위해서는 위치 별 값에 대해서 n ^ ($n - 1$)의 값을 빼주어야 한다.            예를 들어 n이 6인 경우, $110 = 2^3 - 1 - (2^2 - 1) = $3 ^ 2 - 2 ^ 1$ = 7 - 3 = 4$ 가 된다.           결과인 result는 각 경우를 지속 차감하여 음수로 전환될 수 있지만, 부호를 제외한 단순 횟수로는 동일하므로 절댓값을 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-one-bit-operations-to-make-integers-zero/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Words That Can Be Formed by Characters",
        "excerpt":"문제  Link   코드  class Solution {    public int countCharacters(String[] words, String chars) {     int[] count = new int[26];     for (char c : chars.toCharArray()) {       count[c - 'a']++;     }     int result = 0;     for (String word : words) {       if (this.canBeFormed(count, word)) {         result += word.length();       }     }     return result;   }    private boolean canBeFormed(int[] count, String word) {     int[] temp = new int[26];     for (char c : word.toCharArray()) {       int num = c - 'a';       temp[num]++;       if (temp[num] &gt; count[num]) {         return false;       }     }     return true;   }  }   결과  Link   설명          words 내 단어들 중 chars의 문자들로 구성할 수 있는 단어의 총 길이을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            count는 chars의 단어의 갯수를 너헝줄 변수로, 26 크기의 정수 배열로 초기화 후 chars의 각 문자를 이용하여 count에 문자의 갯수를 넣어준다.       result는 총 길이를 구하기 위한 변수로, 0으로 초기화한다.           words를 순차적으로 word에 넣어 아래를 반복한다.            4번에서 정의한 canBeFormed(int[] count, String word) 메서드를 수행한 결과가 true이 ㄴ경우, result에 word의 길이를 넣어준다.           단어를 구성할 수 있는지 검증하기위한 canBeFormed(int[] count, String word) 메서드를 정의한다.            temp는 word의 영문자 갯수를 구하기 위한 변수로, 동일하게 26 크기의 정수 배열로 초기화한다.       word의 각 단어를 순차적으로 c에 넣어 아래를 반복한다.                    num에 c를 ‘a’로 뺀 영문자 위치를 저장하고, temp[num]의 값을 증가시킨다.           temp[num]의 값이 count[num]보다 커지게 되면, 만들 수 없으므로 false를 반환한다.                       반복이 완료되면 true를 반환한다.           반복이 완료되면 총 단어의 길이가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-words-that-can-be-formed-by-characters/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Time Visiting All Points",
        "excerpt":"문제  Link   코드  class Solution {    public int minTimeToVisitAllPoints(int[][] points) {     int result = 0;     for (int i = 1; i &lt; points.length; i++) {       int[] curr = points[i];       int[] prev = points[i - 1];       result += Math.max(Math.abs(curr[0] - prev[0]), Math.abs(curr[1] - prev[1]));     }     return result;   }  }   결과  Link   설명     points의 각 지점을 이동하기 위한 최소 시간을 구하는 문제이다.            모든 이동(가로, 세로, 대각)의 걸리는 시간은 1로 취급한다.                시간을 계산할 result를 0으로 초기화한다.       1부터 points의 길이 미만까지 반복하여 현재 위치의 x와 y값을 이전 위치의 x와 y값을 각각 뺸 값 중 큰 값을 result에 더해준다.            가로, 세로, 대각 이동의 시간이 동일하므로 x축과 y축에 대한 길이만 판단한다.           반복이 완료되면 계산된 최소 시간인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-time-visiting-all-points/",
        "teaser": null
      },{
        "title": "Leetcode Java Largest 3-Same-Digit Number in String",
        "excerpt":"문제  Link   코드  class Solution {    public String largestGoodInteger(String num) {     int result = -1;     for (int i = 2; i &lt; num.length(); i++) {       if (num.charAt(i - 2) == num.charAt(i) &amp;&amp; num.charAt(i - 1) == num.charAt(i)) {         result = Math.max(result, num.charAt(i) - '0');       }     }     StringBuilder sb = new StringBuilder();     for (int i = 0; i &lt; 3; i++) {       sb.append((char) (48 + result));     }     return result == -1 ? \"\" : sb.toString();   }  }   결과  Link   설명     num내 3개의 연속된 숫자가 동일한 값들 중 가장 큰 값을 찾는 문제이다.            조건에 맞는 값이 없는 경우, ““를 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            result는 num내 3개의 연속된 숫자가 동일한 값들 중 큰 값을 넣을 변수로, nums를 반복하여 세 값이 동일한 문자열의 가장 큰 숫자의 위치를 넣어준다.       sb는 동적으로 문자를 만들 변수로, StringBuilder로 초기화한다.                0부터 3 미만까지 i를 증가시키며 sb에 해당 숫자를 문자로 변환하여 이어준다.       result가 -1인 경우 ““을, 값이 존재하는 경우 sb를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/largest-3-same-digit-number-in-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Count of Matches in Tournament",
        "excerpt":"문제  Link   코드  class Solution {    public int numberOfMatches(int n) {     return n - 1;   }  }   결과  Link   설명          n개의 팀을 이용해서 토너먼트 수행하는 경우, 경기 숫자를 구하는 문제이다.            토너먼트는 모든 경우에 아래와 같이 계산되므로, $n - 1$을 주어진 문제의 결과로 반환한다.             토너먼트의 기본 룰은 아래와 같다.                    n이 짝수인 경우, $\\frac{n}{2}$회 경기가 진행되고 동일한 값만큼의 팀이 다음 경기를 수행하게된다.           n이 홀수인 경우, 짝수와 동일한 횟수의 경기와 팀이 다음 라운드로 진출하지만 부전승으로 한 팀이 다음 경기에 합류하게 된다.                       위를 통해 모든 경기는 진 팀만 토너먼트에서 탈락되므로, 우승한 한 팀만 남게되면 $n - 1$번의 경기를 수행해야한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-of-matches-in-tournament/",
        "teaser": null
      },{
        "title": "Leetcode Java Calculate Money in Leetcode Bank",
        "excerpt":"문제  Link   코드  class Solution {    public int totalMoney(int n) {     int quotient = n / 7;     int remainder = n % 7;     return ((28 + remainder) * quotient)         + (((quotient * (quotient - 1)) / 2) * 7)         + ((remainder * (remainder + 1)) / 2);   }  }   결과  Link   설명     아래의 규칙대로 저금하는 경우, n일차에 얼마가 모이는지 계산하는 문제이다.            월요일부터 일요일까지 1달러부터 매일 1달러씩 증가하며 저금한다.                    월(1), 화(2), 수(3), 목(4), 금(5), 토(6), 일(7)                       한 주가 넘어가면 그 전주의 월요일보다 1달러 증가시켜 한 주를 다시 저금한다.                    2 주차 : 월(2), 화(3), 수(4), 목(5), 금(6), 토(7), 일(8)           3 주차 : 월(3), …, 일(9)                                주 단위를 나타내는 quotient에 $\\frac{n}{7}$의 몫을, 한 주가 꽉 차지 않은 나머지 일자를 나타내는 remainder에 나머지를 저장한다.       아래의 계산식을 더한 값을 주어진 문제의 결과로 반환한다.            한 주 가중치를 제외한 합과 한 주를 채우지 못한 나머지 요일의 값을 더한 값에 완료된 주차를 곱한 $(28 + remainder) \\times quotient$의 결과 값.       완료 주에 대한 가중치를 나타내는 $\\frac{quotient \\tiems (quotient - 1)}{2} \\tiems 7$의 결과 값.       완료되지 않은 주에 대한 가중치를 나타내는 $\\frac{remainder \\times (remainder + 1)}{2}$의 결과 값.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/calculate-money-in-leetcode-bank/",
        "teaser": null
      },{
        "title": "Leetcode Java Largest Odd Number in String",
        "excerpt":"문제  Link   코드  class Solution {    public String largestOddNumber(String num) {     int i = num.length();     while (--i &gt;= 0) {       if (num.charAt(i) % 2 == 1) {         return num.substring(0, i + 1);       }     }     return \"\";   }  }   결과  Link   설명          num의 연속된 숫자들을 이용하여 가장 큰 홀수 숫자를 탐색하는 문제이다.       num의 역순부터 탐색하여 마지막 숫자가 홀수인 경우, num의 처음 위치부터 i번째 위치까지 주어진 문제의 결과로 반환한다.            재배열이 없이 num의 연속된 숫자가 가장 큰 홀수가 되는 경우는 마지막 위치가 홀수가 되는 위치라는 의미이다.           반복이 완료되면 홀수가 존재하지 않으므로, ““을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/largest-odd-number-in-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Capacity To Ship Packages Within D Days",
        "excerpt":"문제  Link   코드  class Solution {    public int shipWithinDays(int[] weights, int days) {     int max = 0;     int sum = 0;     for (int weight : weights) {       max = Math.max(max, weight);       sum += weight;     }     while (max &lt; sum) {       int mid = max + ((sum - max) / 2);       int need = 1;       int curr = 0;       for (int weight : weights) {         if (curr + weight &gt; mid) {           need += 1;           curr = 0;         }         curr += weight;       }       if (need &gt; days) {         max = mid + 1;       } else {         sum = mid;       }     }     return max;   }  }   결과  Link   설명          days번 이동할 물건들의 무게인 weights를 최대한 균등한 무게로 나누어 옮기기 위한 선박의 최소 중량을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            max는 물건들 중 가장 큰 무게를 저장할 변수로, weights 내 가장 무거운 무게를 넣어준다.       sum은 물건들의 총 중량을 저장할 변수로, weights의 모든 값을 더해 넣어준다.           max가 sum보다 작을 때 까지 아래를 반복한다.            mid는 한 번에 이동할 물건의 최대 무게를 저장할 변수로, 중앙값인 $max + \\frac{sum - max}{2}$로 초기화한다.       count는 이동 횟수를 저장할 변수로, 1로 초기화한다.       curr은 현재 이동할 물건의 무게를 저장할 변수로, 0으로 초기화한다.       weights를 이용하여 mid만큼의 중량이 되지 않도록 이동하기 위한 count를 계산한다.       count가 days보다 높은 경우 선박의 중량을 더 높게 측정하기 위해 max에 $mid + 1$을 넣어주고, 반대의 경우 선박의 중량을 더 낮게 측정하기 위해 sum에 mid를 넣어 범위를 축소시킨다.           반복이 완료되면 계산된 선박의 최소 중량인 max를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/capacity-to-ship-packages-within-d-days/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Product of Two Elements in an Array",
        "excerpt":"문제  Link   코드  class Solution {    public int maxProduct(int[] nums) {     int[] max = new int[] { Integer.MIN_VALUE, Integer.MIN_VALUE };     for (int num : nums) {       if (num &gt; max[0]) {         max[1] = max[0];         max[0] = num;       } else if (num &gt; max[1]) {         max[1] = num;       }     }     return (max[0] - 1) * (max[1] - 1);   }  }   결과  Link   설명          nums 내 가장 큰 두 값을 이용하여 각 값에서 1을 빼고 곱한 결과를 구하는 문제이다.            max는 가장 큰 두 값을 저장하기 위한 변수로, 두 값을 저장해야하므로 2 크기의 정수 배열에 정수의 가장 작은 값을 넣어 초기화한다.            nums의 모든 값을 반복하여 max에 가장 큰 두 값을 찾아 넣어준다.            가장 큰 두 값을 이용하여 $(max[0] - 1) \\times (max[1] - 1)$를 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-product-of-two-elements-in-an-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Special Positions in a Binary Matrix",
        "excerpt":"문제  Link   코드  class Solution {    public int numSpecial(int[][] mat) {     int row = mat.length;     int col = mat[0].length;     int[] rowSum = new int[row];     int[] colSum = new int[col];     int result = 0;     for (int i = 0; i &lt; row; i++) {       for (int j = 0; j &lt; col; j++) {         if (mat[i][j] == 1) {           rowSum[i]++;           colSum[j]++;         }       }     }     for (int i = 0; i &lt; row; i++) {       for (int j = 0; j &lt; col; j++) {         if (mat[i][j] == 1 &amp;&amp; rowSum[i] == 1 &amp;&amp; colSum[j] == 1) {           result++;         }       }     }     return result;   }  }   결과  Link   설명          mat 배열 내 상하좌우의 모든 값의 합이 1인 셀의 갯수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            row와 col은 mat의 행과 열의 수를 저장한 변수이다.       rowSum과 colSum은 행과 열 별 합을 구하기 위한 변수로, row와 col 크기의 정수 배열로 초기화한다.       result는 셀의 갯수를 저장할 변수로, 0으로 초기화한다.                mat의 모든 값을 반복하여 rowSum에는 행의 위치 별 합을, colSum에는 열의 위치 별 합을 넣어준다.       mat[i][j], rowSum, colSum 모두 1인 조건을 만족하는 셀들을 모두 result에 더한 후 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/special-positions-in-a-binary-matrix/",
        "teaser": null
      },{
        "title": "Leetcode Java Partition Array Into Three Parts With Equal Sum",
        "excerpt":"문제  Link   코드  class Solution {    public boolean canThreePartsEqualSum(int[] arr) {     int sum = 0;     for (int num : arr) {       sum += num;     }     if (sum % 3 != 0) {       return false;     }     int average = sum / 3;     sum = 0;     int count = 0;     for (int num : arr) {       sum += num;       if (sum == average) {         sum = 0;         count++;         if (count == 3) {           return true;         }       }     }     return false;   }  }   결과  Link   설명          arr의 연속된 값들을 3등분하여 각 부분 배열의 합이 동일한 값으로 나눌 수 있는지 검증하는 문제이다.            sum에 arr의 모든 값을 더해서 넣어준 후 해당 값을 3으로 정확히 나눌 수 있는지 검증하여 불가능한 경우, false를 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            average는 3등분 기준 값을 넣을 변수로, sum을 3으로 나눈 값을 넣어준다.       sum을 부분 합을 저장하기 위해서 0으로 초기화한다.       count는 부분 배열의 수를 저장할 변수로, 0으로 초기화한다.           arr의 모든 값을 차례대로 num에 넣어 아래를 반복한다.            sum에 num을 더해준다.       sum이 average와 동일한 경우, 아래를 수행한다.                    다음 부분 합을 계산하기 위해서 sum을 0으로 초기화 후, count를 증가시킨다.           count가 3이면 arr의 값들을 동일한 값으로 3등분 가능하므로, true를 주어진 문제의 결과로 반환한다.                           반복이 완료되면 arr의 값들을 동일한 값으로 3등분할 수 없으므로, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/partition-array-into-three-parts-with-equal-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Best Sightseeing Pair",
        "excerpt":"문제  Link   코드  class Solution {    public int maxScoreSightseeingPair(int[] values) {     int result = 0;     int max = 0;     for (int i = 0; i &lt; values.length; i++) {       result = Math.max(result, max + values[i] - i);       max = Math.max(max, values[i] + i);     }     return result;   }  }   결과  Link   설명          values의 i &lt; j를 만족하는 두 위치의 값을 이용하여 $values[i] + values[j] + i - j$가 최대가 되는 값을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 최대가 되는 값을 저장할 변수로, 0으로 초기화한다.       max는 위치 값과 해당 값의 합이 최대인 값을 저장하기 위한 변수로, 0으로 초기화한다.           0부터 values의 길이 미만까지 i를 증가시키며 아래를 수행한다.            result에 result와 이전까지 가장 큰 값과 위치 값을 가진 max에 $values[i] - i$의 값 중 큰 값을 넣어준다.       max에 max와 $values[i] + i$ 중 큰 값을 다시 넣어준다.           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/best-sightseeing-pair/",
        "teaser": null
      },{
        "title": "Leetcode Java Buy Two Chocolates",
        "excerpt":"문제  Link   코드  class Solution {    public int buyChoco(int[] prices, int money) {     int[] mins = new int[] { Integer.MAX_VALUE, Integer.MAX_VALUE };     for (int price : prices) {       if (price &lt; mins[0]) {         mins[1] = mins[0];         mins[0] = price;       } else {         mins[1] = Math.min(mins[1], price);       }     }     int leftover = money - (mins[0] + mins[1]);     return leftover &gt;= 0 ? leftover : money;   }  }   결과  Link   설명     prices의 가격을 가진 초콜릿들 중 가장 낮은 가격의 초콜릿 두 개를 money 내 구입한 후 남은 가격을 반환하는 문제이다.            만일 money로 가장 낮은 가격의 초콜릿 두 개를 사지 못한다면 money를 주어진 문제의 결과로 반환한다.                mins는 가장 작은 가격의 초콜릿 가격을 담기 위한 변수로, 2 크기의 정수 배열로 정의하여 각 값을 정수의 최댓값으로 초기화하여 prices의 모든 값을 순차적으로 반복하여 mins에 가장 낮은 가격의 초콜릿 두 개의 가격을 넣어준다.       leftover는 money에서 두 초콜릿의 가격을 뺀 잔돈으로, 주어진 문제의 결과로 0 이상이면 leftover를 아니면 money를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/buy-two-chocolates/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Score After Splitting a String",
        "excerpt":"문제  Link   코드  class Solution {    public int maxScore(String s) {     int zeros = 0;     int ones = 0;     int max = Integer.MIN_VALUE;     for (int i = 0; i &lt; s.length(); i++) {       if (s.charAt(i) == '0') {         zeros++;       } else {         ones++;       }       if (i != s.length() - 1) {         max = Math.max(zeros - ones, max);       }     }     return max + ones;   }  }   결과  Link   설명          s를 두 문자열로 나누어 좌측 문자열의 0의 갯수와 우측 문자열의 1의 갯수가 가장 큰 값을 구하는 문제이다.       문제 풀이에 필요한 변수를 저으이한다.            zeros와 ones는 0과 1의 수를 저장할 변수로, 둘 다 0으로 초기화한다.       max는 좌측 문자열의 0의 갯수에서 1의 갯수를 뺀 값이 가장 큰 값을 저장할 변수로, 정수의 가장 작은 값으로 초기화한다.           0부터 s의 길이 미만까지 아래를 반복한다.            s의 i번째 문자가 0인 경우 zeros를 증가시키고 아니면 ones를 증가시킨다.       i가 마지막 위치가 아닌 경우, max에 $zeros - ones$와 max 중 큰 값을 넣어준다.           반복이 완료되면 $max + ones$를 주어진 문제의 결과로 반환한다.   해설     좌측의 0의 갯수와 우측의 1의 갯수가 가장 큰 값에 대한 공식은 아래와 같다.   $MAX(left_zeros + right_ones) = MAX(left_zeros - left_ones + left_ones + right_ones) = MAX(left_zeros - left_ones) + total_ones$   위의 공식을 이용하여 MAX(left_zeros - left_ones)를 구한 값에 1의 총 갯수를 더하면 원하는 값이 나오게 된다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-score-after-splitting-a-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Changes To Make Alternating Binary String",
        "excerpt":"문제  Link   코드  class Solution {    public int minOperations(String s) {     int result = 0;     int length = s.length();     for (int i = 0; i &lt; length; i++) {       if ((i % 2) != s.charAt(i) - '0') {         result++;       }     }     return Math.min(result, length - result);   }  }   결과  Link   설명          0과 1로만 이루어진 s를 동일한 숫자가 연속되어 나타나지 않도록 재배열할 때, 바꿔야하는 최소한의 문자 갯수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 바꿀 문자의 갯수를 저장할 변수로, 0으로 초기화하한ㄷ.       length는 s의 길이를 지정한 변수이다.                0부터 length까지 홀수 위치에 ‘1’이, 짝수 위치에 ‘0’이 존재하는지 검증하여 해당 갯수를 result에 넣어준다.       반복이 완료되면 result의 반대 경우인 홀수 위치에 ‘0’이, 짝수 위치에 ‘1’이 존재하는 경우에 대한 갯수인 $length - result$와 result 중 작은 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-changes-to-make-alternating-binary-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Smallest Integer Divisible by K",
        "excerpt":"문제  Link   코드  class Solution {    public int smallestRepunitDivByK(int k) {     if (k % 2 == 0 || k % 5 == 0) {       return -1;     }     int result = 0;     for (int i = 1; i &lt;= k; i++) {       result = ((result * 10) + 1) % k;       if (result == 0) {         return i;       }     }     return -1;   }  }   결과  Link   설명     1로만 이루어진 임의 정수 중 k로 나눌 수 가장 작은 양의 정수를 구하는 문제이다.            단, 해당 정수가 존재하지 않으면, -1을 주어진 문제의 결과로 반환한다.                k가 2와 5의 약수인 경우 뒷 자리가 1로 끝날 수 없으므로, -1을 주어진 문제의 결과로 반환한다.            값을 저장할 result를 0으로 초기화한다.       1부터 k 이하까지 i를 증가시키며 아래를 수행한다.            result에 $(result \\times 10) + 1$을 수행한 결과를 overflow를 방지하기 위해 k로 나눈 나머지를 넣어준다.       result가 0이면 나눌 수 있는 값이 존재한다는 의미이므로, 글자 자릿수인 i를 주어진 문제의 결과로 반환한다.           반복이 완료되면 조건에 만족하는 양의 정수가 없으므로, -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/smallest-integer-divisible-by-k/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Dice Rolls With Target Sum",
        "excerpt":"문제  Link   코드  class Solution {    public int numRollsToTarget(int n, int k, int target) {     return this.numRollsToTarget(new int[n + 1][target + 1], n, k, target);   }    private int numRollsToTarget(int[][] dp, int n, int k, int target) {     if (n == 0 &amp;&amp; target == 0) {       return 1;     }     if (target &lt; n || n * k &lt; target) {       return 0;     }     if (dp[n][target] != 0) {       return dp[n][target];     }     int result = 0;     for (int i = 1; i &lt;= k; i++) {       if (target &lt; i) {         break;       }       result = (result + this.numRollsToTarget(dp, n - 1, k, target - i) % 1000000007) % 1000000007;     }     dp[n][target] = result;     return result;   }  }   결과  Link   설명     [1, k] 범위의 k면의 주사위를 n번 돌려서 target이 되는 경우의 수를 구하는 문제이다.            단, 값이 매우 클 수 있으므로 모듈러 $10^9 + 7$를 적용한다.                경우의 수를 구하기 위한 3번의 numRollsToTarget(int[][] dp, int n, int k, int target) 메서드를 $(n + 1) \\times (target + 1)$ 크기의 2차원 배열을 dp에 넣어 수행한 결과를 주어진 문제의 결과로 반환한다.       재귀 호출을 통해 값을 구하기 위한 numRollsToTarget(int[][] dp, int n, int k, int target) 메서드를 정의한다.            n과 target이 0인 경우, 1을 반환한다.       target이 n 미만이거나 $n \\times k$가 target 미만인 경우, 경우의 수가 없으므로 0을 반환한다.       dp[n][target]의 값이 0이 아닌 경우, 이미 수행된 dp[n][target]의 값을 반환한다.       계산을 수행할 result를 0으로 초기화하고, 아래를 1부터 k까지 i를 증가시키며 반복한다.                    target이 i보다 작은 경우, 반복을 중지한다.           result에 result와 n에 $n - 1$을, target에 $target - i$를 넣어 재귀 호출을 수행한 결과에 모둘러 $10^9 + 7$를 적용한 결과를 더한 값에 overflow를 방지하기 위해서 다시 모듈러 $10^9 + 7$를 적용한 값을 넣어준다.                       dp[n][target]에 저장된 result를 넣고 result를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-dice-rolls-with-target-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary String With Substrings Representing 1 To N",
        "excerpt":"문제  Link   코드  class Solution {    public boolean queryString(String s, int n) {     for (int i = n; i &gt; n / 2; i--) {       if (!s.contains(Integer.toBinaryString(i))) {         return false;       }     }     return true;   }  }   결과  Link   설명          [1, n] 범위의 숫자들의 이진 문자열이 모두 s에 부분 문자열인지 검증하는 문제이다.       n부터 $\\frac{n}{2}$ 이상일 때까지 i를 감소시키며 i의 이진 문자열이 s에 포함되지 않는 경우, 주어진 문제의 결과로 false로 반환한다.            i &lt; $\\frac{n}{2}$를 만족할 때, $i \\times 2$의 이진 문자열은 i의 이진 문자열을 모두 포함하기 때문에 [$\\frac{n}{2} + 1$, n] 범위의 숫자들만 검증을 수행한다.           반복이 모두 완료되면 모두 포함되므로, 주어진 문제의 결과로 true를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-string-with-substrings-representing-1-to-n/",
        "teaser": null
      },{
        "title": "Leetcode Java Redistribute Characters to Make All Strings Equal",
        "excerpt":"문제  Link   코드  class Solution {    public boolean makeEqual(String[] words) {     int length = words.length;     if (length == 1) {       return true;     }     int wordsLength = 0;     for (String word : words) {       wordsLength += word.length();     }     if (wordsLength % length != 0) {       return false;     }     int[] counts = new int[26];     for (String word : words) {       for (char c : word.toCharArray()) {         counts[c - 'a']++;       }     }     for (int count : counts) {       if (count % length != 0) {         return false;       }     }     return true;   }  }   결과  Link   설명          words의 모든 문자열의 특정 단어를 다른 문장으로 이동하여 모든 문자열이 동일하게 구성할 수 있는지 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 words의 길이를 저장한 변수이다.                    length가 1로, 문자열이 1개만 존재하면 true를 주어진 문제의 결과로 반환한다.                       wordsLength는 words의 모든 문자열의 길이를 저장한 변수로, words를 반복하여 모든 문자열의 길이를 저장한다.                    wordsLength를 length로 나눌 수 없으면, 동일한 문자열 구성이 불가능하므로 false를 주어진 문제의 결과로 반환한다.                       counts는 문자들의 갯수를 저장할 변수로, 영문자 갯수인 26 크기의 정수 배열로 초기화한 후 words를 반복하여 모든 문자의 갯수를 계산해준다.                counts를 반복하여 각 문자의 갯수가 length 배수가 아니라면 주어진 문제의 결과로 false를 주어진 문제의 결과로 반환한다.       반복이 완료되면 동일한 문자열로 동일하게 구성할 수 있으므로, true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/redistribute-characters-to-make-all-strings-equal/",
        "teaser": null
      },{
        "title": "Leetcode Java Largest Substring Between Two Equal Characters",
        "excerpt":"문제  Link   코드  class Solution {    public int maxLengthBetweenEqualCharacters(String s) {     int[] dp = new int[26];     int max = -1;     for (int i = 0; i &lt; s.length(); i++) {       int index = s.charAt(i) - 97;       if (dp[index] == 0) {         dp[index] = i + 1;       } else {         max = Integer.max(max, i - dp[index]);       }     }     return max;   }  }   결과  Link   설명     문자열 s의 동일한 두 문자의 길이가 가장 긴 구간을 찾는 문제이다.            단, 동일한 문자가 없으면 -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            dp는 문자의 시작 위치를 저장할 변수로, 영문자의 갯수인 26 크기의 정수 배열로 초기화한다.       max는 가장 긴 길이를 저장할 변수로 -1로 초기화한다.           0부터 s의 길이 미만까지 i를 증가시키며 아래를 반복한다.            index에 s의 i번째 문자 위치의 값을 저장한다.       dp[index]의 값이 존재하지 않는 경우, $i + 1$을 넣어준다.       dp[index]의 값이 존재하는 경우, max에 max와 $i - dp[index]$의 값을 넣어 가장 긴 길이를 저장한다.           반복이 완료되면 가장 긴 길이가 저장된 max를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/largest-substring-between-two-equal-characters/",
        "teaser": null
      },{
        "title": "Leetcode Java Convert to Base -2",
        "excerpt":"문제  Link   코드  class Solution {    public String baseNeg2(int n) {     if (n == 0) {       return \"0\";     }     StringBuilder sb = new StringBuilder();     while (n != 0) {       int num = n % -2;       n /= -2;       if (num &lt; 0) {         num += 2;         n++;       }       sb.append(num);     }     return sb.reverse().toString();   }  }   결과  Link   설명          n을 -2진법으로 반환하는 문제이다.            n이 0인경우, 0을 주어진 문제의 결과로 반환한다.            sb는 동적 문자열 생성에 필요한 변수로, StringBuilder로 초기화한다.            n이 0이 아닐 때 까지 -2진수를 표현하기 위해 n을 나누면서 sb에 값을 이어준다.            반복이 완료되면 sb를 역순으로 전환하여 주어진 문제의 결과로 반환한다.       참고  Wikipedia - Negative base   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/convert-to-base-2/",
        "teaser": null
      },{
        "title": "Leetcode Java Convert an Array Into a 2D Array With Conditions",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; findMatrix(int[] nums) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     int[] counts = new int[nums.length + 1];     for (int num : nums) {       if (result.size() &lt;= counts[num]) {         result.add(new ArrayList&lt;&gt;());       }       result.get(counts[num]++).add(num);     }     return result;   }  }   결과  Link   설명     nums의 요소들을 아래의 규칙대로 모아 반환하는 문제이다.            nums 안의 값들만 사용하여 중복되지 않은 정수를 모은다.       정수 집합의 크기는 최소화하여야 한다.           문제 풀이에 필요한 변수를 정의한다.            result는 정수 집합을 저장할 변수로, ArrayList로 초기화한다.       counts는 정수를 따로 저장하기 위해 사용할 변수로, nums의 길이보다 1 큰 정수 배열로 초기화한다.           nums의 모든 값을 num에 넣어 아래를 반복한다.            result의 길이보다 counts[num]의 값이 같거나 작은 경우, result에 새로운 정수 집합을 넣기 위해 ArrayList를 넣어준다.       result에 counts[num]번째 List를 꺼내 num을 넣은 후, 반복된 값이 들어가지 않기 위해서 counts[num]을 증가시킨다.           반복이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/convert-an-array-into-a-2d-array-with-conditions/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Laser Beams in a Bank",
        "excerpt":"문제  Link   코드  class Solution {    public int numberOfBeams(String[] bank) {     int result = 0;     int prev = 0;     int curr = 0;     for (String s : bank) {       curr = 0;       for (char c : s.toCharArray()) {         if (c == '1') {           curr++;         }       }       if (curr &gt; 0) {         result += prev * curr;         prev = curr;       }     }     return result;   }  }   결과  Link   설명     bank 내 레이저의 갯수를 반환하는 문제이다.            bank[i]는 ‘0’과 ‘1’로 구성된 i번째 행으로, ‘0’은 빈 셀을 ‘1’은 보안 장치를 의미한다.       아래의 조건을 모두 만족하는 경우, 두 보안 장치 사이에 레이저가 하나 존재한다.                    r1, r2 두 장치는 r1 &lt; r2의 다른 두 행에 위치한다.           r1 &lt; i &lt; r2인 각 행에 대해 i번째 행에는 보안 장치가 없다.                           문제 풀이에 필요한 변수를 정의한다.            result는 레이저의 갯수를 저장할 변수로, 0으로 초기화한다.       prev와 curr은 이전과 현재 행의 보안 장치 갯수를 저장할 변수로, 둘 다 0으로 초기화한다.           bank의 문자열을 s에 순차적으로 넣고 아래를 반복한다.            curr을 0으로 초기화하고 s내 1의 갯수를 넣어준다.       curr이 0보다 큰 경우, result에 prev의 행과 curr의 행 사이에 존재할 수 있는 레이저 갯수인 $prev \\times curr$를 더해주고 prev에 curr을 넣어준다.           반복이 완료되면 레이저의 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-laser-beams-in-a-bank/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Number of Operations to Make Array Empty",
        "excerpt":"문제  Link   코드  class Solution {    public int minOperations(int[] nums) {     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();     for (int num : nums) {       map.put(num, map.getOrDefault(num, 0) + 1);     }     int result = 0;     for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {       int value = entry.getValue();       if (value == 1) {         return -1;       }       result += value / 3;       if (value % 3 != 0) {         result++;       }     }     return result;   }  }   결과  Link   설명     nums내 동일한 값을 둘, 셋 단위로 제거할 때 모두 제거하기까지 걸리는 최소한의 작업 수를 반환하는 문제이다.            단, 삭제가 불가능한 경우 -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            map은 숫자별 갯수를 계산하기 위한 변수로, HashMap으로 정의하고 nums 내 숫자 별 갯수를 모두 넣어준다.       result는 횟수를 계산하기 위한 변수로, 0으로 초기화한다.           map의 각 값을 entry에 넣고 아래를 반복한다.            value에 entry의 값을 넣어주고, 1인 경우 잔여 값이 되므로 -1을 주어진 문제의 결과로 반환한다.       result에 value가 3배수이면 3으로 나눈 값을, 아니면 3으로 나눈 값에 1을 증가한 값을 더해준다.           반복이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-number-of-operations-to-make-array-empty/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Prefix Divisible By 5",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Boolean&gt; prefixesDivBy5(int[] nums) {     List&lt;Boolean&gt; result = new ArrayList&lt;&gt;();     int remainder = 0;     for (int num : nums) {       remainder = ((remainder &lt;&lt; 1) + num) % 5;       result.add(remainder == 0);     }     return result;   }  }   결과  Link   설명          nums의 각 자리 순서까지 이진 표현법으로 변환할 경우, 5로 나눌 수 있는지 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 결과를 저장할 변수로, ArrayList로 초기화한다.       remainder는 nums의 현재 위치까지 이진 표현법의 값이 5로 나눌 수 있는지 검증하기 위해 나머지를 저장한 변수로, 0으로 초기화한다.           nums의 각 값을 num에 넣고 아래를 반복한다.            remainder에 remainder의 비트를 좌측으로 한 자리 이동시킨 값에 num을 더한 후 5로 나눈 나머지를 넣어주고, 해당 값이 0인지 검증한 결과를 result에 넣어준다.           결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-prefix-divisible-by-5/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Profit in Job Scheduling",
        "excerpt":"문제  Link   코드  class Solution {    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {     int length = startTime.length;     Job[] jobs = new Job[length];     for (int i = 0; i &lt; length; i++) {       jobs[i] = new Job(startTime[i], endTime[i], profit[i]);     }     Arrays.sort(jobs, Comparator.comparingInt(a -&gt; a.end));     return this.jobScheduling(jobs, new int[length]);   }    private int jobScheduling(Job[] jobs, int[] dp) {     int length = jobs.length;     dp[0] = jobs[0].profit;     for (int i = 1; i &lt; length; i++) {       int profit = jobs[i].profit;       int index = this.search(jobs, i);       if (index != -1) {         profit += dp[index];       }       dp[i] = Math.max(profit, dp[i - 1]);     }     return dp[length - 1];   }    private int search(Job[] jobs, int index) {     int start = 0, end = index - 1;     while (start &lt;= end) {       int mid = start + ((end - start) / 2);       if (jobs[index].start &gt;= jobs[mid + 1].end) {         start = mid + 1;       } else if (jobs[index].start &gt;= jobs[mid].end) {         return mid;       } else {         end = mid - 1;       }     }     return -1;   } }  class Job {    int start;   int end;   int profit;    public Job(int start, int end, int profit) {     this.start = start;     this.end = end;     this.profit = profit;   }  }   결과  Link   설명     아래의 규칙을 만족하는 job을 이용하여 겹치지 않도록 작업을 수행할 때, 얻을 수 있는 최대 이익을 반환하는 문제이다.            i번째 작업인 job[i]는 [startTime[i], endTime[i]]동안 수행한 작업의 이윤이 profit[i]이라는 의미이다.       endTime과 startTime이 동일한 다른 작업의 경우, 바로 다음 작업을 수행할 수 있다.                작업에 대한 start, end, proift 정보를 같이 관리하기 위한 Job 클래스를 정의한다.       문제 풀이에 필요한 변수를 정의한다.            length는 startTime의 길이를 저장한 변수이다.       jobs는 각 작업 정보를 저장하기 위한 Job 배열로, 0부터 length까지 반복하여 각 작업 정보를 jobs에 순차적으로 같이 넣어준 후 종료 시간 기준으로 정렬해준다.       4번에서 정의한 jobScheduling(Job[] jobs, int[] dp) 메서드를 dp 자리에 length 크기의 정수 배열을 초기화해 넣어 수행한 결과를 주어진 문제의 결과로 반환한다.           작업의 최대 이익을 계산하기 위한 jobScheduling(Job[] jobs, int[] dp) 메서드를 정의한다.            length에 jobs의 길이를 저장한다.       dp의 첫 자리에 가장 짧게 종료되는 jobs[0]의 profit 값을 넣어준다.       1부터 length 미만까지 i를 증가시키며 아래를 반복한다.                    profit에 jobs[i]의 profit 값을 넣어준다.           index에 5번에서 정의한 search(Job[] jobs, int index) 메서드를 index자리에 i를 넣어 수행한 결과를 넣어준다.           index가 -1이면 현재 작업을 이어 수행할 수 있으므로, profit에 이전까지 이익의 합계인 dp[index]의 값을 더해준다.           dp[i]의 자리에 profit과 dp[$i - 1$]의 값 중 최대 이익이 되는 값을 넣어준다.                       반복이 완료되면 최대 이익이 계산된 dp[$length - 1$]을 주어진 문제의 결과로 반환한다.           작업 시간이 겹치는지 검사할 search(Job[] jobs, int index) 메서드를 정의한다.            start에 0을, end에 $index - 1$인 이전까지 위치를 넣어준다.       start가 end 이하일 때까지 아래를 반복한다.                    mid에 $start + \\frac{end - start}{2}$의 중앙값을 넣어준다.           jobs[index].start의 값이 jobs[$mid + 1$].end의 값보다 크거나 같으면, start에 $mid + 1$을 넣어 시작 위치를 증가시켜준다.           위를 만족하지 않고 jobs[index].start의 값이 jobs[mid].end의 값보다 크거나 같으면, mid를 반환한다.           위의 모든 값을 만족하지 않으면 end에 $mid - 1$을 넣어 종료 위치를 감소시켜준다.                       반복이 완료되면 겹치는 시간이 존재하지 않으므로 -1을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-profit-in-job-scheduling/",
        "teaser": null
      },{
        "title": "Leetcode Java Next Greater Node In Linked List",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public int[] nextLargerNodes(ListNode head) {     List&lt;Integer&gt; list = new ArrayList&lt;&gt;();     for (ListNode node = head; node != null; node = node.next) {       list.add(node.val);     }     int[] result = new int[list.size()];     Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();     for (int i = 0; i &lt; list.size(); i++) {       while (!stack.isEmpty() &amp;&amp; list.get(stack.peek()) &lt; list.get(i)) {         result[stack.pop()] = list.get(i);       }       stack.push(i);     }     return result;   }  }   결과  Link   설명          head의 각 노드에서 우측에 있는 값들 중 현재 값보다 가장 큰 값을 찾아 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            list는 각 노드의 값들을 넣어줄 변수로, ArrayList로 정의하고 node의 val 값을 순차적으로 넣어준다.       result는 결과를 넣을 변수로, list의 크기의 정수 배열로 초기화한다.       stack은 노드 별 각 값을 비교하고 넣을 변수로, Stack으로 초기화한다.           0부터 list의 길이 미만까지 i를 증가시키면서 아래를 수행한다.            stack이 비어있지 않으면서 list에서 stack의 가장 나중에 넣은 값에 해당하는 위치의 값이 list의 i번째 값보다 작은 경우, result의 stack 내 앞의 값을 꺼내 해당하는 위치에 list의 i번째 값을 넣어준다.       값의 비교를 위해 stack에 i를 넣어준다.           반복이 완료되면 각 노드 별 비교 값이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/next-greater-node-in-linked-list/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Enclaves",
        "excerpt":"문제  Link   코드  class Solution {    public int numEnclaves(int[][] grid) {     int row = grid.length;     int col = grid[0].length;     int result = 0;     for (int i = 0; i &lt; row; i++) {       this.dfs(grid, i, 0);       this.dfs(grid, i, col - 1);     }     for (int j = 0; j &lt; col; j++) {       this.dfs(grid, 0, j);       this.dfs(grid, row - 1, j);     }     for (int i = 0; i &lt; row; i++) {       for (int j = 0; j &lt; col; j++) {         if (grid[i][j] == 1) {           result++;         }       }     }     return result;   }    private void dfs(int grid[][], int i, int j) {     if (0 &lt;= i &amp;&amp; i &lt;= grid.length - 1 &amp;&amp; 0 &lt;= j &amp;&amp; j &lt;= grid[i].length - 1 &amp;&amp; grid[i][j] == 1) {       grid[i][j] = 0;       this.dfs(grid, i + 1, j);       this.dfs(grid, i - 1, j);       this.dfs(grid, i, j + 1);       this.dfs(grid, i, j - 1);     }   }  }   결과  Link   설명     grid 내 육지와 인접하지 않은 섬의 크기를 반환하는 문제이다.            grid의 가장자리는 육지와 인접해있다.       ‘0’은 바다를, ‘1’은 육지를 의미한다.           재귀 호출을 이용하여 육지와 인접한 셀을 바다로 바꾸어줄 dfs(int grid[][], int i, int j) 메서드를 정의한다.            i와 j가 grid 내 범위에 있으면서 grid[i][j]가 1인 육지인 경우 아래를 수행한다.                    grid[i][j]의 위치에 0을 넣어 바다로 바꾸어준다.           상하좌우를 반복하여 인접한 육지를 모두 바다로 바꾸어준다.                           문제 풀이에 필요한 변수를 정의한다.            row와 col은 행과 열의 길이를 저장한 변수이다.       result는 육지와 인접하지 않은 섬의 크기를 저장할 변수로, 0으로 초기화한다.                0부터 row 미만까지 i를 증가시키며 행의 시작과 종료 위치에 인접한 육지를 2번에서 정의한 dfs(int grid[][], int i, int j) 메서드를 수행하여 제거해준다.            0부터 col 미만까지 j를 증가시키며 열의 시작과 종료 위치에 인접한 육지를 2번에서 정의한 dfs(int grid[][], int i, int j) 메서드를 수행하여 제거해준다.       grid 내 셀의 값이 1인 육지인 경우 result를 증가시켜 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-enclaves/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove Outermost Parentheses",
        "excerpt":"문제  Link   코드  class Solution {    public String removeOuterParentheses(String s) {     StringBuilder sb = new StringBuilder();     int count = 0;     for (char c : s.toCharArray()) {       if ((c == '(' &amp;&amp; count++ &gt; 0) || (c == ')' &amp;&amp; count-- &gt; 1)) {         sb.append(c);       }     }     return sb.toString();   }  }   결과  Link   설명          문자열 s의 각 괄호마다 외부에 존재하는 괄호를 제거하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            sb는 동적 문자열을 생성하기 위한 변수로, StringBuilder로 초기화한다.       count는 괄호의 갯수를 계산하기 위한 변수로, 0으로 초기화한다.                문자열 s의 각 문자를 c에 순차적으로 넣어 괄호의 시작 전과 후의 문자를 제외하고 sb에 문자를 이어준다.       반복이 완료되면 완성된 문자열이 저장된 sb를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-outermost-parentheses/",
        "teaser": null
      },{
        "title": "Leetcode Java Amount of Time for Binary Tree to Be Infected",
        "excerpt":"문제  Link   코드  class Solution {    private int amount;    public int amountOfTime(TreeNode root, int start) {     this.dfs(root, start);     return this.amount;   }    private int dfs(TreeNode root, int start) {     if (root == null) {       return 0;     }     int left = this.dfs(root.left, start);     int right = this.dfs(root.right, start);     if (root.val == start) {       this.amount = Math.max(left, right);       return -1;     } else if (left &gt;= 0 &amp;&amp; right &gt;= 0) {       return Math.max(left, right) + 1;     } else {       this.amount = Math.max(this.amount, Math.abs(left - right));       return Math.min(left, right) - 1;     }   }  }   결과  Link   설명          root의 감염 시작점인 start부터 모든 노드가 감염되기까지의 시간을 계산하는 문제이다.            amount는 감염에 걸리기까지 시간을 저장할 전역 변수이다.            4번에서 정의한 dfs(TreeNode root, int start) 메서드를 수행한 후 amount를 주어진 문제의 결과로 반환한다.            DFS 방식으로 감염 시간을 계산하기 위한 dfs(TreeNode root, int start) 메서드를 정의한다.             root가 null이면 감염 대상이 없으므로, 0을 반환한다.       left와 right에 각 노드 별 재귀 호출을 수행한 결과를 넣어준다.       root의 val 값이 start인 감염 시작점인 경우 amount에 left와 right 중 가장 큰 값을 넣어준 후 -1을 반환한다.       left와 right가 0보다 큰 감염 노드를 포함하지 않은 경우, left와 right의 가장 오래걸리는 시간에 현재 노드까지 포함하여 1을 추가한 시간을 반환한다.       위의 경우가 아닌 감염 노드를 포함한 경우, amount에 amount와 $left - right$의 절댓값 중 큰 값을 넣은 후 left와 right 중 작은 값에 1을 뺀 값을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/amount-of-time-for-binary-tree-to-be-infected/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Difference Between Node and Ancestor",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public int maxAncestorDiff(TreeNode root) {     return dfs(root, root.val, root.val);   }    private int dfs(TreeNode root, int max, int min) {     if (root == null) {       return max - min;     } else {       max = Math.max(max, root.val);       min = Math.min(min, root.val);       return Math.max(this.dfs(root.left, max, min), this.dfs(root.right, max, min));     }   }  }   결과  Link   설명          root의 상위 노드와 하위 노드의 차이가 가장 큰 값을 찾는 문제이다.            3번에서 정의한 dfs(TreeNode root, int max, int min) 메서드의 각 정수 값에 root.val 값을 넣어 수행한 결과를 주어진 문제의 결과로 반환한다.            DFS방식으로 최대 차잇값을 구하기 위한 dfs(TreeNode root, int max, int min) 메서드를 정의한다.             root가 null인 leaf노드인 경우, 현재까지의 최댓값과 최솟값의 차이인 $max - min$을 반환한다.       root가 null이 아니면 아래를 수행한다.                    max와 min에 root의 val값과 비교한 값을 다시 넣어준다.           root의 left와 right TreeNode로 재귀 호출한 결과 중 큰 값을 반환한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-difference-between-node-and-ancestor/",
        "teaser": null
      },{
        "title": "Leetcode Java Determine if String Halves Are Alike",
        "excerpt":"문제  Link   코드  class Solution {    public boolean halvesAreAlike(String s) {     String vowels = \"aeiouAEIOU\";     int a = 0;     int b = 0;     for (int i = 0, j = s.length() - 1; i &lt; j; i++, j--) {       a += vowels.indexOf(s.charAt(i)) &gt; -1 ? 1 : 0;       b += vowels.indexOf(s.charAt(j)) &gt; -1 ? 1 : 0;     }     return a == b;   }  }   결과  Link   설명     문자열 s를 절반으로 나누었을 때, 전반부와 후반부 내 모음의 갯수가 동일한지 검증하는 문제이다.            모음은 ‘a’, ‘e’, ‘i’, ‘o’, ‘u’, ‘A’, ‘E’, ‘I’, ‘O’, ‘U’로 구성된다.           문제 풀이에 필요한 변수를 정의한다.            vowels는 모음을 저장한 변수로, 모음을 모두 모아 ‘aeiouAEIOU’로 초기화한다.       a와 b는 전반부와 후반부의 모음 갯수로, 둘 다 0으로 초기화한다.                i가 0, j가 s의 길이보다 1 작은 값부터 i가 j보다 작을 때 까지 i를 증가, j를 감소시키며 s의 전반부와 후반부 문자의 갯수를 계산하여 a와 b에 넣어준다.       a와 b가 동일한지 여부를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/determine-if-string-halves-are-alike/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Number of Steps to Make Two Strings Anagram",
        "excerpt":"문제  Link   코드  class Solution {    public int minSteps(String s, String t) {     int[] count = new int[26];     for (int i = 0; i &lt; s.length(); i++) {       count[s.charAt(i) - 'a']++;       count[t.charAt(i) - 'a']--;     }     int result = 0;     for (int num : count) {       if (num &gt; 0) {         result += num;       }     }     return result;   }  }   결과  Link   설명          문자열 t의 일부 문자들을 변경하여 s를 구성할 수 있는 Anagram 문자열로 변환하기위한 최소 횟수를 계산하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            count는 s와 t의 문자 갯수를 가감할 변수로, 영문자의 갯수인 26 크기의 정수 배열로 초기화하여 s와 t를 반복하여 문자 갯수를 계산하여 넣어준다.       result는 결과를 저장할 변수로, 0으로 초기화하고 count를 반복하여 0 초과인 값을 넣어준다.           결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-number-of-steps-to-make-two-strings-anagram/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Players With Zero or One Losses",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; findWinners(int[][] matches) {     int[] count = new int[100001];     for (int i = 0; i &lt; matches.length; i++) {       int win = matches[i][0];       int lose = matches[i][1];       if (count[win] == 0) {         count[win] = -1;       }       if (count[lose] == -1) {         count[lose] = 1;       } else {         count[lose]++;       }     }     List&lt;List&lt;Integer&gt;&gt; result = Arrays.asList(new ArrayList&lt;&gt;(), new ArrayList&lt;&gt;());     for (int i = 0; i &lt; count.length; i++) {       if (count[i] == -1) {         result.get(0).add(i);       } else if (count[i] == 1) {         result.get(1).add(i);       }     }     return result;   }  }   결과  Link   설명     아래와 같은 값이 있는 matches를 이용하여 한 번도 패배하지 않은 사람과 한 번만 패배한 사람을 모아 반환하는 문제이다.            matches[i] = [winneri, loseri]를 나타낸다.           문제 풀이에 필요한 변수를 정의한다.            count는 패배 횟수를 저장할 변수로, 0부터 matches의 길이 미만까지 i를 증가시키며 아래의 규칙대로 값을 넣어준다.                    win에는 matches[i][0]인 승리한 사람의 번호를, lose에는 matches[i][1] 패배한 사람의 번호를 넣어준다.           count[win]이 0인 패배한적이 없는 사람인 경우, -1을 넣어 패배하지 않았다는 것을 표시해준다.           count[lose]의 값이 -1이면 1로, 그 외는 값을 증가시켜준다.                       result는 결과 값을 넣기 위한 변수로, ArrayList에 패배하지 않은 사람이 들어갈 ArrayList와 한 번만 패배한 사람이 들어갈 ArrayList를 넣어 초기화한다.           0부터 count의 길이 미만까지 i를 증가시키며 아래를 수행한다.            count[i]가 -1이면 패배한 적이 없으므로, result의 첫번째 ArrayList에 해당 사람의 번호인 i를 넣어준다.       count[i]가 1이면 한 번만 패배하였으므로, result의 두번째 ArrayList에 해당 사람의 번호인 i를 넣어준다.           반복이 완료되면 각 그룹이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-players-with-zero-or-one-losses/",
        "teaser": null
      },{
        "title": "Leetcode Java Sum of Root To Leaf Binary Numbers",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public int sumRootToLeaf(TreeNode root) {     return this.dfs(root, 0);   }    private int dfs(TreeNode root, int val) {     if (root == null) {       return 0;     } else {       val = (val * 2) + root.val;       return root.left == root.right ? val : this.dfs(root.left, val) + this.dfs(root.right, val);     }   }  }   결과  Link   설명          0과 1의 값들만 가진 root를 이용하여 root에서 leaf로 갈 때 순서대로의 이진 표현법이 최대가 되는 값을 구하는 문제이다.            3번에서 정의한 dfs(TreeNode root, int val) 메서드의 val에 0을 넣고 수행한 결과를 주어진 문제의 결과로 반환한다.            root가 null인 노드가 없을 경우, 0을 반환한다.            root가 null이 아닌 경우, 아래를 수행한다.             val에 $(val \\times 2) + root.val$ 값을 넣어 이진 수를 계산한다.       root의 left TreeNode와 right TreeNode가 동일 한 값인 null이면 더 이상 진행이 안되므로 val을, 아니면 left TreeNode와 right TreeNode를 각각 val을 이용하여 재귀 호출한 결과를 더해서 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sum-of-root-to-leaf-binary-numbers/",
        "teaser": null
      },{
        "title": "Leetcode Java Unique Number of Occurrences",
        "excerpt":"문제  Link   코드  class Solution {    public boolean uniqueOccurrences(int[] arr) {     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();     for (int num : arr) {       map.put(num, map.getOrDefault(num, 0) + 1);     }     Set&lt;Integer&gt; set = new HashSet&lt;&gt;();     for (int value : map.values()) {       if (!set.add(value)) {         return false;       }     }     return true;   }  }   결과  Link   설명          arr의 각 숫자들이 고유한 갯수로 나타나는지 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            map은 arr의 각 숫자 별 갯수를 계산하기 위한 변수로, HashMap으로 초기화하고 arr을 반복하여 갯수를 계산해준다.       set은 갯수가 고유한지 검증하기 위한 변수로, HashSet으로 초기화한다.                map의 value들을 반복하여 set에 value를 넣어주다가 존재하는 값이 존재하면, false를 주어진 문제의 결과로 반환한다.       반복이 완료되면 각 숫자가 고유한 갯수로 존재하므로, true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/unique-number-of-occurrences/",
        "teaser": null
      },{
        "title": "Leetcode Java Camelcase Matching",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Boolean&gt; camelMatch(String[] queries, String pattern) {     List&lt;Boolean&gt; result = new ArrayList&lt;&gt;();     for (String query : queries) {       result.add(this.isMatch(query, pattern));     }     return result;   }    private boolean isMatch(String query, String pattern) {     int i = 0;     for (char c : query.toCharArray()) {       if (i &lt; pattern.length() &amp;&amp; c == pattern.charAt(i)) {         i++;       } else if (c &lt; 'a') {         return false;       }     }     return i == pattern.length();   }  }   결과  Link   설명          문자열 배열인 queries 내 pattern에 해당하는 대문자 순서대로의 문자열인지 검증하는 문제이다.            result는 결과를 저장할 변수이다.            queries의 각 문자열을 query에 순차적으로 넣어 4번에서 정의한 isMatch(String query, String pattern) 메서드를 수행한 결과를 result에 넣어준다.       query가 pattern에 해당하는 형태의 문자열인지 검증하기 위한 isMatch(String query, String pattern) 메서드를 정의한다.            i는 pattern 문자열의 위치 값을 저장할 변수로, 0으로 초기화한다.       query의 각 값을 c에 넣어 아래를 반복한다.                    i가 pattern 길이 미만이면서 c가 pattern의 i번째 문자와 동일한 경우, i를 증가시켜준다.           위의 경우가 아니면서 c가 ‘a’문자열보다 작은 영대문자에 속하는 경우, false를 반환한다.                       반복이 완료되면 i가 pattern의 마지막 위치인지 검증한 결과를 반환한다.           결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/camelcase-matching/",
        "teaser": null
      },{
        "title": "Leetcode Java Video Stitching",
        "excerpt":"문제  Link   코드  class Solution {    public int videoStitching(int[][] clips, int time) {     int min = 0;     int max = 0;     int result = 0;     while (max &lt; time) {       for (int i = 0; i &lt; clips.length; i++) {         int[] clip = clips[i];         if (clip[0] &lt;= min &amp;&amp; clip[1] &gt; max) {           max = clip[1];         }       }       if (min == max) {         return -1;       }       min = max;       result++;     }     return result;   }  }   결과  Link   설명     비디오 클립이 담긴 clips를 이용하여 time까지 클립을 잇기 위한 최소 클립의 갯수를 구하는 문제이다.            clips[i] = [starti, endi]를 만족한다.           문제 풀이에 필요한 변수를 정의한다.            min과 max는 time까지 클립을 잇기 위한 클립을 구하기 위한 변수로, 둘 다 0으로 초기화한다.       result는 최소 클립의 갯수를 저장할 변수로, 0으로 초기화한다.           max가 time 미만일 때 까지 아래를 반복한다.            0부터 clips의 길이 미만까지 i를 증가시키며 시작 값이 min 이하이거나 같고, 종료 값이 max 이상일 때, max에 종료 값을 넣어준다.       min과 max가 동일하면 time까지 이어줄 수 없으므로 -1을 주어진 문제의 결과로 반환한다.       위의 경우가 아니라면 이어줄 클립이 존재하므로, min에 max를 넣어준 후 result를 증가시켜 클립의 수를 계산해준다.           반복이 완료되면 최소 클립의 수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/video-stitching/",
        "teaser": null
      },{
        "title": "Leetcode Java Divisor Game",
        "excerpt":"문제  Link   코드  class Solution {  \tpublic boolean divisorGame(int n) { \t\treturn n % 2 == 0; \t}  }   결과  Link   설명     엘리스와 밥이 아래의 규칙대로 게임을 수행할 때, 엘리스가 이기는지 검증하는 문제이다.            0 &lt; x &lt; n를 만족할 때, n % x == 0인 임의의 x를 선택하여 n을 $n - x$로 바꾸어준다.       플레이어가 더 이상 수행이 불가능한 n이 0이 되는 경우, 게임에서 지게 된다.           n이 짝수인지를 검증하여 해당 결과를 주어진 문제의 결과로 반한환다.   해설     n의 각 경우에 대해서 확인해보자.            n이 1인 경우, 1을 선택하면서 바로 지게된다.       n이 2인 경우, 1을 선택하면 이기게 된다.       n이 3인 경우, 1을 선택하면 밥은 1을 다시 선택하므로 반드시 지게된다.       n이 4인 경우, 1을 선택하면 n이 3이 되므로, 밥은 1을 선택하여 이기게된다.           위의 각 경우에 대한 시나리오를 기반으로 n이 홀수인 경우에는 지고, 짝수인 경우에는 이기므로 짝수인지 검증한 결과가 주어진 문제의 결과로 된다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/divisor-game/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Length of a Concatenated String with Unique Characters",
        "excerpt":"문제  Link   코드  class Solution {    private int result;    public int maxLength(List&lt;String&gt; arr) {     this.result = 0;     this.dfs(arr, \"\", 0);     return this.result;   }    private void dfs(List&lt;String&gt; arr, String s, int index) {     boolean isUnique = this.validate(s);     if (isUnique) {       this.result = Math.max(this.result, s.length());     }     if (index == arr.size() || !isUnique) {       return;     }     for (int i = index; i &lt; arr.size(); i++) {       this.dfs(arr, s + arr.get(i), i + 1);     }   }    private boolean validate(String s) {     Set&lt;Character&gt; set = new HashSet&lt;&gt;();     for (char c : s.toCharArray()) {       if (set.contains(c)) {         return false;       }       set.add(c);     }     return true;   }  }   결과  Link   설명          arr의 각 요소들을 순차적으로 이어서 고유 문자들로만 이루어진 문자열을 만들 때, 가능한 최대 길이를 구하는 문제이다.            result는 가능한 최대 길이를 저장할 전역 변수이다.            result를 0으로 초기화하고 4번에서 정의한 dfs(List arr, String s, int index) 메서드에 \"\"과 0을 같이 넣어 수행한다.       DFS 방식으로 탐색할 dfs(List arr, String s, int index) 메서드를 정의한다.            isUnique는 s의 문자열이 고유한 문자들로 이루어졌는지 검증한 변수로, validate(String s) 메서드를 수행하여 검증한 결과를 넣어준다.       isUnique가 true인 고유 문자들로 구성되어 있다면, result에 result와 s의 길이 중 큰 값인 길이를 넣어준다.       index가 arr의 길이와 동일하거나 isUnique가 false인 고유 문자열이 아닌 경우, 수행을 중단한다.       index부터 arr의 길이까지 i를 증가시키며 s에 s와 arr의 i번째 문자를 이어주고, index에 $i + 1$을 넣어 재귀 호출을 순차적으로 수행한다.           4번의 수행이 완료되면 최대 길이가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-length-of-a-concatenated-string-with-unique-character/",
        "teaser": null
      },{
        "title": "Leetcode Java Recover a Tree From Preorder Traversal",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    private int index = 0;    public TreeNode recoverFromPreorder(String traversal) {     return this.dfs(traversal, 0);   }    private TreeNode dfs(String traversal, int depth) {     int num = 0;     while (this.index + num &lt; traversal.length() &amp;&amp; traversal.charAt(this.index + num) == '-') {       num++;     }     if (num != depth) {       return null;     }     int next = this.index + num;     while (next &lt; traversal.length() &amp;&amp; traversal.charAt(next) != '-') {       next++;     }     int val = Integer.parseInt(traversal.substring(this.index + num, next));     this.index = next;     TreeNode root = new TreeNode(val);     root.left = this.dfs(traversal, depth + 1);     root.right = this.dfs(traversal, depth + 1);     return root;   }  }   결과  Link   설명          preorder로 깊이를 대시(‘-‘) 문자의 갯수로 구분된 문자열 traversal을 이용하여 TreeNode를 구성하는 문제이다.            index는 traversal 문자열의 위치를 저장할 전역 변수로, 0으로 초기화한다.            4번에서 정의한 dfs(String traversal, int depth)를 depth에 0을 넣어 수행한 결과를 주어진 문제의 결과로 반환한다.            DFS 방식으로 TreeNode를 구성하기 위한 dfs(String traversal, int depth) 메서드를 정의한다.             num은 대시(‘-‘) 문자의 갯수를 저장할 변수로, $index + num$이 traversal의 길이 미만이면서 traversal의 해당 위치의 문자가 ‘-‘일때 까지 num을 증가시키며 대시(‘-‘) 문자의 갯수를 저장한다.       num이 depth가 아닌 경우, 연결된 TreeNode가 아니므로 null을 반환한다.       next는 다음 숫자의 위치를 저장할 변수로, $index + num$을 넣어 초기화한다.       다시 next가 traversal의 길이 미만이면서 대시(‘-‘) 문자가 아닐 때 까지 next를 이동시켜준다.       val에 traversal의 [$index + num$, next] 까지 숫자를 정수로 변환하여 넣어준다.       root에 val 값을 이용하여 TreeNode를 만들어 넣어준다.       preorder 순으로 TreeNode를 구성하기 위하여 아래를 순차적으로 수행한다.                    root의 left TreeNode에 $depth + 1$을 이용하여 재귀 호출한 결과를 넣어준다.           root의 right TreeNode에 $depth + 1$을 이용하여 재귀 호출한 결과를 넣어준다.                       위를 이용하여 만들어진 TreeNode인 root를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/recover-a-tree-from-preorder-traversal/",
        "teaser": null
      },{
        "title": "Leetcode Java Pseudo-Palindromic Paths in a Binary Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public int pseudoPalindromicPaths(TreeNode root) {     return this.dfs(root, 0);   }    private int dfs(TreeNode root, int count) {     if (root == null) {       return 0;     }     count ^= 1 &lt;&lt; (root.val - 1);     int result = this.dfs(root.left, count) + this.dfs(root.right, count);     if (root.left == root.right &amp;&amp; (count &amp; (count - 1)) == 0) {       result++;     }     return result;   }  }   결과  Link   설명          root의 루트 노드부터 리프 노드까지 값들을 이어준 값 중 최소 한 개 이상의 값을 재 배열하였을 때, 앞과 뒤가 동일한 문자열(이하 회문)이 되는 경우의 수를 구하는 문제이다.            3번에서 정의한 dfs(TreeNode root, int count) 메서드를 count에 0을 넣고 수행한 결과를 주어진 문제의 결과로 반환한다.            DFS 방식으로 회문이 되는 문자열을 검증하기 위한 dfs(TreeNode root, int count) 메서드를 정의한다.             root가 null인 경우, 이어줄 값이 없으므로 0을 반환한다.       count에 count와 1의 비트를 $root.val - 1$번 좌측으로 이동한 값의 XOR(^) 비트 연산을 수행한 결과를 넣어준다.       result는 경우의 수를 계산하기 위한 변수로, root의 left와 right TreeNode를 순차적으로 count를 활용하여 재귀 호출한 결과를 더해서 넣어준다.       root의 left와 right TreeNode가 null이면서 count와 $count - 1$을 AND(&amp;) 비트 연산을 수행한 결과가 0인 경우, 회문을 만들 수 있으므로 result를 증가시킨다.       계산된 회문이 가능한 경우인 result를 반환한다.           해설     TreeNode의 값은 [1, 9] 범위 내 값으로 이루어져 있으며, 회문이 되는 경우 XOR(^) 비트 연산을 수행하면 단 하나의 값만 남게 된다.   위의 조건을 기반으로 1을 좌측으로 8번 이동시켜도 $2^8 = 256$이 되므로, count에 자신의 값과 1을 $root.val - 1$번 좌측으로 이동시킨 값을 XOR(^) 연산을 root 노드부터 leaf 노드까지 모두 수행하였을 때 회문이 되는 경우는 단 하나의 1 비트만 존재하는 경우이다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/pseudo-palindromic-paths-in-a-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Common Subsequence",
        "excerpt":"문제  Link   코드  class Solution {  \tpublic int longestCommonSubsequence(String text1, String text2) { \t\tchar[] text1CharArray = text1.toCharArray(); \t\tchar[] text2CharArray = text2.toCharArray(); \t\tint text1Length = text1CharArray.length; \t\tint text2Length = text2CharArray.length; \t\tint[][] dp = new int[text1Length + 1][text2Length + 1]; \t\tfor (int i = 1; i &lt;= text1Length; i++) { \t\t\tfor (int j = 1; j &lt;= text2Length; j++) { \t\t\t\tif (text1CharArray[i - 1] == text2CharArray[j - 1]) { \t\t\t\t\tdp[i][j] = 1 + dp[i - 1][j - 1]; \t\t\t\t} else { \t\t\t\t\tdp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); \t\t\t\t} \t\t\t} \t\t} \t\treturn dp[text1Length][text2Length]; \t}  }   결과  Link   설명          text1과 text2의 중간 문자들만 제거하여 동일하게 만들 수 있는 가장 긴 길이를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            text1CharArray와 text2CharArray는 text1과 text2를 문자 배열로 변환하여 저장한 변수이다.       text1Length와 text2Length는 text1과 text2의 문자 길이를 저장한 변수이다.       dp는 가장 긴 문자열의 길이를 찾기 위한 배열로, $(text1Length + 1) \\times (text2Length + 1)$ 크기의 2차원 배열로 초기화한다.           1부터 text1Length 이하까지 i를 증가시키고, 1부터 text2Length 이하까지 j를 증가시키며 아래를 반복한다.            text1CharArray[$i - 1$] 문자와 text2CharArray[$j - 1$] 문자가 동일한 경우, dp[i][j]에 현재까지 위치를 추가하여 $1 + dp[i - 1][j - 1]$의 값을 넣어준다.       위의 경우가 아닌 경우, 이전 위치까지 각 경우인 dp[i][j]에 dp[$i - 1$][j]와 dp[i][$j - 1$] 중 큰 값을 넣어준다.           반복이 완료되면 가장 긴 길이가 저장된 dp[text1Length][text2Length]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-common-subsequence/",
        "teaser": null
      },{
        "title": "Leetcode Java Two City Scheduling",
        "excerpt":"문제  Link   코드  class Solution {    public int twoCitySchedCost(int[][] costs) {     int length = costs.length / 2;     int[] dp = new int[length * 2];     int result = 0;     int index = 0;     for (int[] cost : costs) {       dp[index++] = cost[1] - cost[0];       result += cost[0];     }     Arrays.sort(dp);     for (int i = 0; i &lt; length; i++) {       result += dp[i];     }     return result;   }  }   결과  Link   설명     아래를 만족하는 costs에 해당하는 2n명의 직원들을 각 도시에 n명씩 도착하기 위한 최소 비용을 구하는 문제이다.            costs[i] = [aCosti, bCosti] 를 만족할 때, 각 값은 아래를 의미한다.                    aCosti는 i번째 직원이 a 도시로 이동하기 위한 비용을 나타낸다.           bCosti는 i번째 직원이 b 도시로 이동하기 위한 비용을 나타낸다.                           문제 풀이에 필요한 변수를 정의한다.            length는 각 도시에 도착하기 위한 인원들을 저장할 변수로, costs의 길이를 2로 나눈 값을 저장한다.       dp는 최소 비용을 계산하기 위한 배열로, $length \\times 2$ 크기의 정수 배열로 초기화한다.       result는 최소 비용을 저장할 변수로, 0으로 초기화한다.       index는 dp의 위치 값을 저장할 변수로, 0으로 초기화한다.           costs의 모든 값을 순차적으로 cost에 넣고 아래를 수행한다.            dp[index]의 위치에 $cost[1] - cost[0]$인 b 도시로 이동하는 비용과 a 도시로 이동하는 비용의 차이를 저장하고 index를 증가시켜준다.       result에 a 도시로 이동하는 비용인 cost[0]을 더해준다.                dp를 오름차순으로 저장하여 b 도시로 이동하는 비용이 비교적 낮은 오름차순으로 정렬해준다.       정렬된 dp의 앞의 절반 값을 result에 더해주면서 b도시로 이동하기 위한 기회비용을 계산하여 주어진 문제의 결과로 반환한다.   해설     a 도시로 가는 비용을 모두 더한 후, dp에는 a 도시로 가는 비용에서 b 도시로 가는 비용을 뺀 b 도시로 가기 위한 기회(환불)비용이 큰 순서대로 넣어준다.   a 도시로 가는 비용을 저장한 result에서 위의 dp 내 기회(환불)비용이 가장 큰 절반 값을 더하면 최소 비용을 구할 수 있다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/two-city-scheduling/",
        "teaser": null
      },{
        "title": "Leetcode Java Matrix Cells in Distance Order",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) {     int[][] result = new int[rows * cols][];     result[0] = new int[] { rCenter, cCenter };     int index = 1;     int max = Math.max(rCenter, rows - rCenter - 1) + Math.max(cCenter, cols - cCenter - 1);     for (int i = 1; i &lt;= max; i++) {       int row = rCenter - i;       int col = cCenter;       for (int j = i; j &gt; 0; j--) {         if (row &gt;= 0 &amp;&amp; col &gt;= 0) {           result[index++] = new int[] { row, col };         }         row++;         col--;       }       for (int j = i; j &gt; 0; j--) {         if (row &lt; rows &amp;&amp; col &gt;= 0) {           result[index++] = new int[] { row, col };         }         row++;         col++;       }       for (int j = i; j &gt; 0; j--) {         if (row &lt; rows &amp;&amp; col &lt; cols) {           result[index++] = new int[] { row, col };         }         row--;         col++;       }       for (int j = i; j &gt; 0; j--) {         if (row &gt;= 0 &amp;&amp; col &lt; cols) {           result[index++] = new int[] { row, col };         }         row--;         col--;       }     }     return result;   }  }   결과  Link   설명          $rows \\times cols$ 크기의 2차원 배열 내 [rCenter, cCenter] 위치에서 가장 가까운 거리부터 먼 거리까지 순서대로 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 가까운 거리 순서대로 저장할 배열로, 가능한 셀의 갯수인 $rows \\times cols$ 크기의 2차원 정수 배열로 초기화하고 첫 값을 시작 위치인 [rCenter, cCenter]를 넣어준다.       index는 result에 저장할 위치 값을 저장할 변수로, 첫 값이 포함되었으므로 1로 초기화한다.       max는 현재 위치인 [rCenter, cCenter]에서 모서리까지 가장 먼 거리를 저장할 변수로, rCenter와 $rows - rCenter - 1$인 행의 최대 이동거리 중 큰 값과 cCenter와 $cols - cCenter - 1$ 중 큰 값을 더해서 넣어준다.           1부터 max 이하까지 i를 증가시키며 아래를 반복한다.            row에 $rCenter - i$를, col에 cCenter를 넣어준다.       위-좌측의 대각선 방향으로 탐색하기 위해서 i부터 0 초과까지 j를 감소시키며 아래를 수행한다.                    [row, col] 위치가 배열 내에 존재하는 0 이상인 경우, result[index]에 [row, col] 위치를 넣고 index를 증가시킨다.           위치 이동을 위해서 row를 증가시키고, col을 감소시킨다.                       좌측-아래의 대각선 방향으로 탐색하기 위해서 i부터 0 초과까지 j를 감소시키며 아래를 수행한다.                    [row, col] 위치가 배열 내에 존재하는 row가 rows 미만이면서 col이 0 이상인 경우, result[index]에 [row, col] 위치를 넣고 index를 증가시킨다.           위치 이동을 위해서 row와 col을 증가시킨다.                       아래-우측의 대각선 방향으로 탐색하기 위해서 i부터 0 초과까지 j를 감소시키며 아래를 수행한다.                    [row, col] 위치가 배열 내에 존재하는 row가 rows 미만이면서 col이 colse 미만인 경우, result[index]에 [row, col] 위치를 넣고 index를 증가시킨다.           위치 이동을 위해서 row를 감소시키고, col을 증가시킨다.                       우측-위의 대각선 방향으로 탐색하기 위해서 i부터 0 초과까지 j를 감소시키며 아래를 수행한다.                    [row, col] 위치가 배열 내에 존재하는 row가 0 이상이면서 col이 colse 미만인 경우, result[index]에 [row, col] 위치를 넣고 index를 증가시킨다.           위치 이동을 위해서 row와 col을 감소시킨다.                           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/matrix-cells-in-distance-order/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Submatrices That Sum to Target",
        "excerpt":"문제  Link   코드  class Solution {    public int numSubmatrixSumTarget(int[][] matrix, int target) {     int row = matrix.length;     int col = matrix[0].length;     int result = 0;     for (int i = 0; i &lt; row; i++) {       int[] dp = new int[col];       for (int j = i; j &lt; row; j++) {         for (int k = 0; k &lt; col; k++) {           dp[k] += matrix[j][k];         }         for (int l = 0; l &lt; col; l++) {           int sum = 0;           for (int m = l; m &lt; col; m++) {             sum += dp[m];             if (sum == target) {               result++;             }           }         }       }     }     return result;   }  }   결과  Link   설명          matrix 내 부분 배열 내 값들의 합이 target이 되는 부분 배열의 갯수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            row와 col은 행과 열의 갯수를 저장할 변수이다.       result는 부분 배열의 갯수를 저장할 변수로, 0으로 초기화한다.           0부터 row 미만까지 i를 증가시키며 아래를 수행한다.            dp는 합계 계산을 돕기 위한 배열로, col 크기의 정수로 초기화한다.       i부터 row 미만까지 j를 증가시키며 아래를 수행한다.                    0부터 col 미만까지 k를 증가시키며, dp[k]의 값에 matrix[j][k]의 값을 누계한다.           0부터 col 미만까지 l을 증가시키며, sum을 초기화 한 후 l부터 col 미만까지 m을 증가시키며 sum에 dp[m]의 값을 더해서 sum과 target이 동일한 경우 조건을 충족하므로 result를 증가시켜준다.                           반복이 완료되면 조건을 만족하는 부분 배열의 수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-submatrices-that-sum-to-target/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Sum of Two Non-Overlapping Subarrays",
        "excerpt":"문제  Link   코드  class Solution {    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {     return Math.max(this.maxSum(nums, firstLen, secondLen), this.maxSum(nums, secondLen, firstLen));   }    private int maxSum(int[] nums, int firstLen, int secondLen) {     int sumFirstLen = 0;     int sumSecondLen = 0;     for (int i = 0; i &lt; firstLen + secondLen; i++) {       if (i &lt; firstLen) {         sumFirstLen += nums[i];       } else {         sumSecondLen += nums[i];       }     }     int result = sumFirstLen  + sumSecondLen;     for (int i = firstLen + secondLen, max = sumFirstLen; i &lt; nums.length; i++) {       sumFirstLen += nums[i - secondLen] - nums[i - firstLen - secondLen];       sumSecondLen += nums[i] - nums[i - secondLen];       max = Math.max(max, sumFirstLen);       result = Math.max(result, max + sumSecondLen);     }     return result;   }  }   결과  Link   설명          nums의 firstLen 크기와 secondLen 크기의 겹치지 않은 연속된 부분 배열들의 합이 최대인 값을 구하는 문제이다.            3번에서 정의한 maxSum(int[] nums, int firstLen, int secondLen)에 firstLen과 secondLen을 순서를 바꾸어 각각 수행한 결과 중 큰 값을 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            sumFirstLen과 sumSecondLen은 firstLen과 secondLen 크기의 연속된 부분 배열의 값의 합을 저장할 변수로, nums의 firstLen개의 값과 그 다음 secondLen개의 값을 각각 더해준다.       result는 부분 배열들의 합을 저장할 변수로, sumSecondLen과 sumFirstLen의 값을 더해서 넣어준다.       $firstLen + secondLen$부터 nums의 길이 미만까지 i를 증가시키고, max에 sumFirstLen을 넣어 아래를 반복한다.                    sumFirstLen에 다음 위치 값인 nums[$i - secondLen$] 값을 더한 후, 제거 할 좌측 값인 nums[$i - firstLen - secondLen$] 값을 빼준다.           sumSecondLen에 다음 위치 값인 nums[i] 값을 더한 후, 제거 할 좌측 값인 nums[$i - secondLen$] 값을 빼준다.           max에 이전까지 첫 부분 배열의 최댓값인 max와 현재 첫 부분 배열의 합인 sumFirstLen 중 큰 값을 넣어준다.           result에 이전까지 최댓값인 result와 현재 값들의 합인 $max + sumSecondLen$ 중 큰 값을 넣어준다.                           반복이 완료되면 각 구간의 합이 최대가 되는 결과가 저장된 result를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-sum-of-two-non-overlapping-subarrays/",
        "teaser": null
      },{
        "title": "Leetcode Java Stream of Characters",
        "excerpt":"문제  Link   코드  class StreamChecker {    private TrieNode root;   private StringBuilder sb;    public StreamChecker(String[] words) {     this.root = new TrieNode();     this.sb = new StringBuilder();     for (String word : words) {       TrieNode node = this.root;       char[] charArray = word.toCharArray();       int length = charArray.length;       for (int i = length - 1; i &gt;= 0; i--) {         int index = charArray[i] - 'a';         if (node.children[index] == null) {           node.children[index] = new TrieNode();         }         node = node.children[index];       }       node.isWord = true;     }   }    public boolean query(char letter) {     this.sb.append(letter);     TrieNode node = this.root;     for (int i = this.sb.length() - 1; i &gt;= 0 &amp;&amp; node != null; i--) {       node = node.children[this.sb.charAt(i) - 'a'];       if (node != null &amp;&amp; node.isWord) {         return true;       }     }     return false;   }  }  public class TrieNode {    public boolean isWord;   public TrieNode[] children;    public TrieNode() {     this.children = new TrieNode[26];   }  }  /**  * Your StreamChecker object will be instantiated and called as such:  * StreamChecker obj = new StreamChecker(words);  * boolean param_1 = obj.query(letter);  */   결과  Link   설명     words로 초기화된 문자 스트림에서 순차적으로 문자를 이어줄 때, 접미사가 words 내 존재하는지 검증하는 문제이다.            생성자인 StreamChecker(String[] words)는 words를 이용하여 객체를 초기화하는 역할을 수행한다.       메서드인 query(char letter)는 letter를 문자열로 계속 이어주고, 접미사가 words 내 존재하는지 여부를 반환한다.           문제 풀이에 필요한 전역 변수를 정의한다.            root는 문자를 Trie를 활용하여 저장할 변수이다.       sb는 query 메서드를 통해 입력된 문자를 순차적으로 이어줄 변수이다.           생성자인 StreamChecker(String[] words)를 정의한다.            root에 아래의 값을 가진 TrieNode를 초기화하여 넣어준다.                    isWord는 현재 위치까지 문자로 존재하는지 여부를 나타내기 위한 값을 저장하는 변수이다.           children은 현재 문자 이후에 나타날 문자를 새 TrieNode로 이어줄 변수로, 영문자의 갯수인 26 크기로 초기화 하여 넣어준다.                       sb는 동적 문자열의 생성을 위해 StringBuilder로 초기화한다.       words를 반복하여 root의 children에 각 문자열의 역순으로 TrieNode를 이어서 넣어주면서, 시작되는 문자 위치에 isWord를 true로 해당 문자열이 존재하는 것을 체크해준다.           메서드인 query(char letter)를 정의한다.            sb에 letter를 이어준 후, node에 root를 넣어준다.       sb의 마지막 위치부터 처음이면서, node가 null이 아닐 때 까지 i를 감소시키며 아래를 반복한다.                    node에 node의 children 중 sb의 i번째 문자 순서의 TrieNode를 넣어준다.           node가 null이 아니면서 isWord인 초기에 주입된 words에 포함된 단어인 경우, true를 반환한다.                       반복이 완료되면 sb의 접미사가 words 내 존재하지 않으므로, false를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/stream-of-characters/",
        "teaser": null
      },{
        "title": "Leetcode Java Moving Stones Until Consecutive",
        "excerpt":"문제  Link   코드  class Solution {    public int[] numMovesStones(int a, int b, int c) {     int[] stones = { a, b, c };     Arrays.sort(stones);     if (stones[2] - stones[0] == 2) {       return new int[] { 0, 0 };     } else if (Math.min(stones[1] - stones[0], stones[2] - stones[1]) &lt;= 2) {       return new int[] { 1, stones[2] - stones[0] - 2 };     } else {       return new int[] { 2, stones[2] - stones[0] - 2 };     }   }  }   결과  Link   설명     a, b, c의 돌 세 개를 아래의 규칙으로 게임을 진행할 때, [최소 이동 수, 최대 이동 수]를 배열로 반환하는 문제이다.            x &lt; y &lt; z인 세 돌이 존재할 때, x 혹은 z의 돌을 이용하여 x &lt; k &lt; z를 만족하는 y가 아닌 k 위치로 돌을 이동할 수 있다.                stones는 a, b, c 세 돌의 위치를 저장할 변수로, 정수 배열에 넣어 오름차순 정렬해준다.       아래의 규칙을 만족하는 경우, 각 경우에 따른 값을 주어진 문제의 결과로 반환한다.            $stones[2] - stones[0]$이 2인 a, b, c 세 돌이 붙어있는 경우, 모든 이동이 불가능하므로 [0, 0] 배열을 주어진 문제의 결과로 반환한다.       $stones[1] - stones[0]$ 혹은 $stones[2] - stones[1]$의 결과가 2 이하인 경우, [1, $stones[2] - stones[0] - 2$] 배열을 주어진 문제의 결과로 반한한다.                    두 경우 중 하나만 2 이하인 경우, a와 c 돌 중 하나만 b와 인접하므로 최소 이동 횟수는 한 돌만 이동하는 1이 된다.           최대 이동 횟수는 가장 우측에 있는 돌의 위치와 좌측에 있는 돌의 위치의 이동 경우인 $stones[2] - stones[0] - 1$과 b 돌의 위치인 1을 추가로 뺀 경우가 된다.                       위의 경우가 아니라면, [2, $stones[2] - stones[0] - 2$] 배열을 주어진 문제의 결과로 반한한다.                    위 두 경우를 모두 만족하지 않으면 a, b, c 세 돌의 사이의 간격이 존재하므로, a와 c를 이동하는 최소 2번의 이동 횟수가 존재한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/moving-stones-until-consecutive/",
        "teaser": null
      },{
        "title": "Leetcode Java Sequential Digits",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; sequentialDigits(int low, int high) {     int[] nums = {       12, 23, 34, 45, 56, 67, 78, 89,       123, 234, 345, 456, 567, 678, 789,       1234, 2345, 3456, 4567, 5678, 6789,       12345, 23456, 34567, 45678, 56789,       123456, 234567, 345678, 456789,       1234567, 2345678, 3456789,       12345678, 23456789,       123456789     };     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     int length = nums.length;     for (int i = 0; i &lt; length; i++) {       if (nums[i] &lt; low) {         continue;       } else if (nums[i] &gt; high) {         break;       } else {         result.add(nums[i]);       }     }     return result;   }  }   결과  Link   설명          [low, high] 범위 내 0을 제외한 이전 자리의 값보다 다음 자리의 값이 큰 순차적인 정수들을 오름차순으로 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            nums는 모든 가능한 숫자의 범위를 저장한 변수로, 최소 가능한 12부터 최대 가능한 123456789까지 경우의 수를 모두 넣어준다.       result는 결과를 저장할 변수로, ArrayList로 초기화한다.       length는 nums의 길이를 저장한 변수이다.           0부터 length 미만까지 i를 증가시키며 아래를 반복한다.            nums[i] 값이 low보다 작은 경우 대상에서 제외되므로, 다음 반복을 수행한다.       nums[i] 값이 high보다 큰 경우 범위를 초과하였으므로, 반복을 중단한다.       위의 경우들이 모두 아닌 범위 내 값이면, result에 nums[i] 값을 넣어준다.           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sequential-digits/",
        "teaser": null
      },{
        "title": "Leetcode Java Partition Array for Maximum Sum",
        "excerpt":"문제  Link   코드  class Solution {    public int maxSumAfterPartitioning(int[] arr, int k) {     int length = arr.length;     int[] dp = new int[length + 1];     for (int i = 1; i &lt;= length; i++) {       int max = 0;       int sum = 0;       for (int j = 1; j &lt;= k &amp;&amp; i - j &gt;= 0; j++) {         max = Math.max(max, arr[i - j]);         sum = Math.max(sum, (max * j) + dp[i - j]);       }       dp[i] = sum;     }     return dp[length];   }  }   결과  Link   설명          arr을 이용하여 인접한 값들을 최대 k개까지 해당 숫자들 중 가장 큰 값으로 연속되도록 변환할 때, 배열 내 값들의 합이 가장 큰 값을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 arr의 길이를 저장한 변수이다.       dp는 배열의 값들을 합한 결과가 가장 큰 값을 계산하기 위한 배열로, $length + 1$ 크기의 정수 배열로 초기화한다.           1부터 length 이하까지 i를 증가시키며 아래를 반복한다.            max와 sum은 가장 큰 값과 합계를 저장할 변수로, 둘 다 0으로 초기화시킨다.       1부터 k 이하이면서 $i - j$가 0보다 클 때까지 j를 증가시키며 아래를 반복한다.                    max에 이전까지 최댓값인 max와 현재 값인 arr[$i - j$] 중 큰 값을 저장한다.           sum에 이전까지 합계인 sum과 현재까지 가장 큰 값을 j번 반복하고 현재 값을 더한 $(max \\times j) + dp[i - j]$ 값 중 큰 값을 저장한다.                       dp[i]에 sum을 저장한다.           반복이 완료되면 변환된 배열 내 값들의 합이 최대가 되는 값이 저장된 dp[length]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/partition-array-for-maximum-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Coloring A Border",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] colorBorder(int[][] grid, int row, int col, int color) {     int rows = grid.length;     int cols = grid[0].length;     if (grid[row][col] != color) {       this.dfs(grid, row, col, color, grid[row][col], new boolean[rows][cols], rows, cols);     }     return grid;   }    private void dfs(int[][] grid, int row, int col, int color, int value, boolean[][] visited, int rows, int cols) {     if (row &lt; 0 || rows &lt;= row || col &lt; 0 || cols &lt;= col || grid[row][col] != value || visited[row][col]) {       return;     }     visited[row][col] = true;     boolean border = false;     if (row == 0 || col == 0 || col == cols - 1 || row == rows - 1 || grid[row + 1][col] != value         || grid[row - 1][col] != value || grid[row][col - 1] != value || grid[row][col + 1] != value) {       border = true;     }     this.dfs(grid, row + 1, col, color, value, visited, rows, cols);     this.dfs(grid, row - 1, col, color, value, visited, rows, cols);     this.dfs(grid, row, col + 1, color, value, visited, rows, cols);     this.dfs(grid, row, col - 1, color, value, visited, rows, cols);     if (border) {       grid[row][col] = color;     }   }  }   결과  Link   설명     grid[row][col] 위치에서 시작하여 아래의 조건을 만족하는 셀들에 color의 값을 넣어 반환하는 문제이다.            grid[row][col] 값과 인접한 네 방향의 셀의 값이 다른 경우 grid의 경계라 칭한다.       grid의 경계에 해당하는 값들을 모두 color를 넣어준다.                rows와 cols에 grid의 행과 열의 길이를 저장해서 넣어준다.            grid[row][col]이 color를 만족하지 않는 경우, 4번에서 정의한 dfs(int[][] grid, int row, int col, int color, int value, boolean[][] visited, int rows, int cols) 메서드를 value에 grid[row][col] 값과 visited에 $rows \\times cols$ 크기의 2차원 부울 배열을 넣어 수행한다.       DFS 방식으로 grid에 color를 색칠할 dfs(int[][] grid, int row, int col, int color, int value, boolean[][] visited, int rows, int cols) 메서드를 정의한다.            아래의 조건을 만족하면 색을 칠할 수 없으므로, 수행을 종료한다.                    row와 col이 grid의 범위를 벗어나는 경우.           grid[row][col] 값이 value가 아닌 경우.           visited[row][col] 값이 true인 이미 방문한 셀인 경우.                       visited[row][col]의 값을 true로 바꾼 후, border인지 검증하기 위한 값을 false로 초기화한다.       row과 col가 범위를 벗어나거나 상하좌우의 값이 value가 아닌 경우, border를 만족하므로 true로 바꾸어준다.       grid[row][col] 위치에서 네 방향을 순차적으로 재귀 호출을 수행해준다.       border가 true이면 색을 칠할 수 있으므로, gird[row][col]의 위치에 color를 넣어준다.           결과가 저장된 grid를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/coloring-a-border/",
        "teaser": null
      },{
        "title": "Leetcode Java Valid Boomerang",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isBoomerang(int[][] points) {     return (points[0][0] - points[1][0]) * (points[0][1] - points[2][1]) !=         (points[0][0] - points[2][0]) * (points[0][1] - points[1][1]);   }  }   결과  Link   설명          세 점의 위치가 있는 points가 부메랑 같이 휘어있는지 구하는 문제이다.            세 점의 위치가 휘어 있다는 것은 한 점에서 나머지 두 점까지의 기울기가 다르다는 의미이므로, 기울기를 구하는 공식을 대입하여 계산한다.             $\\frac{points[0][0] - points[1][0]}{points[0][1] - points[1][1]} != \\frac{points[0][0] - points[2][0]}{points[0][1] - points[2][1]}$ 를 성립한다.       위의 경우, 분모가 0이 되는 경우는 성립이 되지 않으므로 분모에 해당하는 공식을 양 변에 각각 곱해준다.       $(points[0][0] - points[1][0]) \\times (points[0][1] - points[2][1]) != (points[0][0] - points[2][0]) \\times (points[0][1] - points[1][1])$ 이 성립한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/valid-boomerang/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Search Tree to Greater Sum Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public TreeNode bstToGst(TreeNode root) {     this.bstToGst(root, new TreeNode(0));     return root;   }    private void bstToGst(TreeNode node, TreeNode sum) {     if (node == null) {       return;     }     this.bstToGst(node.right, sum);     sum.val += node.val;     node.val = sum.val;     this.bstToGst(node.left, sum);   }  }   결과  Link   설명          이진 검색 트리인 root를 이용하여 노드의 값을 현재까지의 모든 값들의 합을 넣은 노드로 변환하는 문제이다.            3번에서 정의한 bstToGst(TreeNode node, TreeNode sum) 메서드를 sum 자리에 새 TreeNode를 넣어 수행한다.       주어진 조건에 맞는 노드의 값을 설정하기 위한 bstToGst(TreeNode node, TreeNode sum) 메서드를 정의한다.            node가 null인 경우 수행이 불가능하므로, 수행을 중단한다.       node의 right TreeNode를 이용하여 재귀 호출을 수행한다.       sum의 val에 node의 val을 더해준 후, node의 val에 sum의 val 값을 넣어준다.       node의 left TreeNode를 이용하여 재귀 호출을 수행한다.           반복이 완료되면 완성된 root를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-search-tree-to-greater-sum-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Length of String After Deleting Similar Ends",
        "excerpt":"문제  Link   코드  class Solution {    public int minimumLength(String s) {     char[] charArray = s.toCharArray();     int left = 0;     int right = s.length() - 1;     while (left &lt; right &amp;&amp; charArray[left] == charArray[right]) {       char c = s.charAt(left);       while (left &lt;= right &amp;&amp; charArray[left] == c) {         left++;       }       while (left &lt;= right &amp;&amp; charArray[right] == c) {         right--;       }     }     return right - left + 1;   }  }   결과  Link   설명     ‘a’, ‘b’, ‘c’로 이루어진 문자열 s를 이용하여 아래의 규칙을 만족하는 최소 문자열의 길이을 구하는 문제이다.            문자열 s의 앞과 뒤에 동일한 문자가 존재하면, 앞과 뒤에 연속된 동일 문자들을 모두 제거해준다.       문자열 s의 앞과 뒤에 동일한 문자가 존재하지 않으면 반복을 그만한다.           문제 풀이에 필요한 변수를 정의한다.            charArray는 s를 문자 배열로 변환한 변수이다.       left와 right는 charArray 내 좌측과 우측의 위치 변수로, 시작 위치인 0과 종료 위치인 $s.length - 1$로 초기화한다.           left가 right보다 작으면서 charArray의 left번째 문자와 right번째 문자가 동일할 때까지 아래를 반복한다.            c에 charArray의 left번째 문자를 넣어준다.       left가 right보다 작거나 같으면서 charArray의 left번째 문자가 c와 동일할 때까지 left를 증가시켜 동일한 문자를 제거한다.       left가 right보다 작거나 같으면서 위와 반대로 charArray의 right번째 문자가 c와 동일할 때까지 right를 감소시켜 동일한 문자를 제거한다.           반복이 완료되면 남은 문자열의 길이인 $right - left + 1$를 주어진 문제의 길이로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-length-of-string-after-deleting-similar-ends/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Score Triangulation of Polygon",
        "excerpt":"문제  Link   코드  class Solution {    public int minScoreTriangulation(int[] values) {     int length = values.length;     int[][] dp = new int[length][length];     for (int[] row : dp) {       Arrays.fill(row, -1);     }     return this.dfs(values, dp, 1, length - 1);   }    private int dfs(int[] values, int[][] dp, int i, int j) {     if (i &gt;= j) {       return 0;     } else if (dp[i][j] != -1) {       return dp[i][j];     } else {       int min = Integer.MAX_VALUE;       for (int k = i; k &lt; j; k++) {         min = Math.min(min, this.dfs(values, dp, i, k) + this.dfs(values, dp, k + 1, j) + values[i - 1] * values[k] * values[j]);       }       return dp[i][j] = min;     }   }  }   결과  Link   설명          주어진 values의 길이보다 2 작은 갯수의 삼각형을 만들 때, 각 꼭짓점의 값들을 values의 값을 대입하여 각 삼각형 내 모든 꼭짓점의 값들을 곱한 값을 더한 값이 최소가 되는 값을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 values의 길이를 저장한 변수이다.       dp는 각 삼각형 내 모든 꼭짓점의 값들을 곱한 값을 더한 값이 최소가 되는 값을 구하기 위한 변수로, $length \\times length$ 크기의 2차원 정수 배열로 초기화 후 모든 값에 -1을 넣어준다.                4번에서 정의한 dfs(int[] values, int[][] dp, int i, int j) 메서드의 i에 1을, j에 $length - 1$을 넣어 수행하여 탐색한 최솟값을 주어진 문제의 결과로 반환한다.       DFS 방식으로 최소 값을 탐색할 dfs(int[] values, int[][] dp, int i, int j) 메서드를 정의한다.            i가 j보다 큰 탐색 범위를 벗어나는 경우, 0을 반환한다.       위의 경우가 아니면서 dp[i][j]의 값이 -1이 아닌 탐색한 위치인 경우, 해당 값을 반환한다.       위의 모든 경우가 아니라면 아래를 수행한다.                    min에 정수의 최댓값을 넣어준다.           k가 i부터 j 미만일 때까지 k를 증가시키면서, min에 i와 j의 위치에 i와 k, $k + 1$과 j를 넣어 재귀 호출을 수행한 값에 각 꼭짓점의 값을 곱한 값과 min 중 작은 값을 넣어준다.           dp[i][j]의 위치에 min을 넣어준 후, 해당 값을 반환한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-score-triangulation-of-polygon/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Elements With Maximum Frequency",
        "excerpt":"문제  Link   코드  class Solution {    public int maxFrequencyElements(int[] nums) {     int[] count = new int[101];     int max = 0;     for (int num : nums) {       count[num]++;       if (count[num] &gt; max) {         max = count[num];       }     }     int result = 0;     for (int num : nums) {       if (max == count[num]) {         result += count[num]--;       }     }     return result;   }  }   결과  Link   설명          nums 내 가장 많이 존재하는 값들의 갯수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            count는 nums 내 숫자들의 갯수를 계산할 변수로, 발생 가능한 최댓값의 크기보다 1 큰 정수 배열로 초기화한다.       max는 nums 내 가장 많이 존재하는 숫자의 갯수를 저장할 변수로, 0으로 초기화한다.                nums를 반복하여 count에 숫자들의 갯수를, max에 가장 많이 존재하는 숫자의 갯수를 저장해준다.       result에 최대 발생한 갯수를 누계하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-elements-with-maximum-frequency/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Common Value",
        "excerpt":"문제  Link   코드  class Solution {    public int getCommon(int[] nums1, int[] nums2) {     for (int i = 0, j = 0; i &lt; nums1.length &amp;&amp; j &lt; nums2.length;) {       if (nums1[i] == nums2[j]) {         return nums1[i];       } else if (nums1[i] &lt; nums2[j]) {         i++;       } else {         j++;       }     }     return -1;   }  }   결과  Link   설명     오름차순으로 정렬된 nums1과 nums2 배열에 공통적으로 존재하는 값들 중 가장 작은 값을 반환하는 문제이다.            단, 공통적으로 존재하는 값이 없는 경우 -1을 주어진 문제의 결과로 반환한다.           i와 j를 0으로 초기화하여 nums1과 nums2의 길이 미만일 때까지 아래를 반복한다.            nums1[i]의 값이 nums2[j]의 값과 동일한 경우, 해당 값을 주어진 문제의 결과로 반환한다.       nums1[i]의 값이 nums2[j]의 값보다 작은 경우, i를 증가시키고 그 반대의 경우 j를 증가시킨다.           반복이 완료되면 공통적으로 존재하는 값이 없다는 의미이므로, -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-common-value/",
        "teaser": null
      },{
        "title": "Leetcode Java Moving Stones Until Consecutive II",
        "excerpt":"문제  Link   코드  class Solution {    public int[] numMovesStonesII(int[] stones) {     Arrays.sort(stones);     int length = stones.length;     int low = length;     int high = Math.max(stones[length - 1] - stones[1], stones[length - 2] - stones[0]) - length + 2;     for (int i = 0, j = 0; j &lt; length; j++) {       while (stones[j] - stones[i] &gt;= length) {         i++;       }       if (j - i + 1 == length - 1 &amp;&amp; stones[j] - stones[i] == length - 2) {         low = Math.min(low, 2);       } else {         low = Math.min(low, length - (j - i + 1));       }     }     return new int[] { low, high };   }  }   결과  Link   설명     돌의 위치가 저장된 stones의 값들을 이용하여 아래의 규칙대로 게임을 수행할 때, 최소 이동 횟수와 최대 이동 횟수를 구하여 정수 배열로 반환하는 문제이다.            위치가 가장 작거나 큰 돌을 엔드포인트 돌이라고 하고, 비어 있는 값으로 바꾸면 더 이상 엔드포인트 돌이 아니게된다.                    엔드포인트 돌을 변경할 때, 가장 작거나 큰 값으로 변경해야하면 이동할 수 없다.                       더 이상 돌의 위치를 변경할 수 없을 때 게임은 종료된다.                stones의 값들을 오름차순 정렬해준다.       문제 풀이에 필요한 변수를 정의한다.            length는 stones의 길이를 저장한 변수이다.       low는 최소 이동 횟수를 저장할 변수로, 최대 변경 가능한 length로 초기화한다.       high는 최대 이동 횟수를 저장할 변수로, $stones[length - 1] - stones[1]$의 값과 $stones[length - 2] - stones[0]$의 값 중 큰 값에 $length - 2$를 뺀 값을 넣어준다.                    가장 작은 값의 돌을 유지한 채 이동할 수 있는 최대 이동 횟수는, $(stones[length - 1] - stones[length - 2] - 1) + (stones[length - 2] - stones[length - 3] - 1) + … + (stones[2] - stones[1] - 1) = stones[n - 1] - stones[1] - (length - 2)$이다.           가장 큰 값의 돌을 유지한 채 이동할 수 있는 최대 이동 횟수는, 위와 동일하게 계산하여 $stones[length - 2] - stones[0] - (length - 2)$를 만족한다.           위의 경우를 대입하여 $stones[n - 1] - stones[1]$의 값과 $stones[length - 2] - stones[0]$의 값 중 큰 값에 $length - 2$를 빼준 값이 최대 이동 횟수가 된다.                           i와 j가 0부터 j가 length 미만일 때 까지 j를 증가시키며 아래를 수행한다.            $stones[j] - stones[i]$의 값이 length보다 큰 경우, i를 증가시켜 위치를 증가시켜준다.       $j - i + 1$의 값이 $length - 1$과 동일하고 $stones[j] - stones[i]$의 값이 $length - 2$와 동일한지 검증하여 아래를 수행한다.                    동일한 경우, low에 low와 2 중 작은 값을 넣어준다.           동일하지 않은 경우, low에 low와 $length - (j - i + 1)$ 중 작은 값을 넣어준다.                           반복이 완료되면 low와 high를 정수 배열에 순차적으로 넣어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/moving-stones-until-consecutive-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Robot Bounded In Circle",
        "excerpt":"문제  Link   코드  class Solution {    private static final int[][] DIRECTIONS = {     { 0, 1 },     { -1, 0 },     { 0, -1 },     { 1, 0 }   };    public boolean isRobotBounded(String instructions) {     int i = 0;     int[] point = new int[2];     for (char c : instructions.toCharArray()) {       switch (c) {         case 'L': i = (i + 1) % 4; break;         case 'R': i = (i + 3) % 4; break;         default:           point[0] += DIRECTIONS[i][0];           point[1] += DIRECTIONS[i][1];       }     }     return point[0] == 0 &amp;&amp; point[1] == 0 || i != 0;   }  }   결과  Link   설명     로봇이 [0, 0] 위치에서 위로 움직여 instructions의 처음부터 끝까지 문자들을 아래의 규칙대로 계속 수행할 때 시작 위치를 기준으로 계속 재귀하는지 검증하는 문제이다.            ‘G’는 1칸 직진한다.       ‘L’은 좌측(시계 반대 방향)으로 이동한다.       ‘R’은 우측(시계 방향)으로 이동한다.           문제 풀이에 필요한 변수를 정의한다.            DIRECTIONS는 방향을 저장할 전역 변수로, 위 - 왼쪽 - 아래 - 오른쪽 방향으로 이동하기 위한 가감치를 넣어 정의한다.       i는 이동 방향을 DIRECTIONS에 존재하는 값의 위치 값을 저장할 변수로, 초기 방향인 0으로 초기화한다.       point는 현재 위치의 좌표를 저장할 변수로, 2차원 정수 배열로 초기화한다.           instructions의 각 문자를 c에 넣어 순차적으로 아래를 수행한다.            c가 ‘L’인 경우, $i + 1$의 값을 4로 나눈 나머지 값을 넣어준다.       c가 ‘R’인 경우, $i + 3$의 값을 4로 나눈 나머지 값을 넣어준다.       그 외의 c가 ‘G’인 경우, point의 각 자리에 DIRECTIONS[i]의 값을 더해준다.           반복이 완료되면 아래의 조건 중 하나라도 만족하면 true를 아니면 false를 주어진 문제의 결과로 반환한다.            point가 [0, 0]의 위치로 돌아오는 경우.       i가 0이 아닌 초기 방향과 달라서, 앞의 순서대로 다시 반복하면 원래 자리로 돌아오는 경우.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/robot-bounded-in-circle/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove Zero Sum Consecutive Nodes from Linked List",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode removeZeroSumSublists(ListNode head) {     if (head == null) {       return head;     }     ListNode curr = head;     int sum = 0;     while (curr != null) {       sum += curr.val;       if (sum == 0) {         return this.removeZeroSumSublists(curr.next);       } else {         curr = curr.next;       }     }     head.next = this.removeZeroSumSublists(head.next);     return head;   }  }   결과  Link   설명          head 내 연속된 값의 합이 0이 되는 노드를 제거하는 문제이다.            head가 null인 경우, head를 그대로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            curr은 현재 ListNode를 저장할 변수로, head로 넣어준다.       sum은 노드의 합을 저장할 변수로, 0으로 초기화한다.           curr이 null이 아닐 때까지 아래를 반복한다.            sum에 curr의 val 값을 더해준다.       sum이 0인 경우, 현재까지의 노드들을 무시하기 위해서 curr의 다음 ListNode로 재귀 호출한 결과를 반환한다.       sum이 0이 아닌 경우, curr에 curr의 다음 ListNode를 넣어 반복을 계속 수행한다.           반복이 완료되면 head의 다음 ListNode에 해당 ListNode로 재귀 호출한 결과를 넣어준 후 완성된 head를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-zero-sum-consecutive-nodes-from-linked-list/",
        "teaser": null
      },{
        "title": "Leetcode Java Find the Pivot Integer",
        "excerpt":"문제  Link   코드  class Solution {    public int pivotInteger(int n) {     for (int i = 0, j = n, sum = 0; i &lt; j;) {       if (sum &gt; 0) {         sum -= j--;       } else {         sum += i++;       }       if (sum == 0 &amp;&amp; i == j) {         return i;       }     }     return -1;   }  }   결과  Link   설명     1부터 x까지, x부터 n까지 합이 동일한 x를 찾는 문제이다.            x가 존재하지 않으면, -1을 주어진 문제의 결과로 반환한다.           i와 sum은 0, j는 n으로초기화하여 i가 j 미만일 때 까지 아래를 반복한다.            sum이 0보다 큰 경우, sum에 j를 빼주고 j를 감소시킨다.       sum이 0보다 작거나 같은 경우, sum에 i를 더해주고 i를 증가시킨다.       sum이 0이면서 i와 j가 동일한 경우, i를 주어진 문제의 결과로 반환한다.           반복이 완료되면 x가 존재하지 않으므로, -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-the-pivot-integer/",
        "teaser": null
      },{
        "title": "Leetcode Java Flower Planting With No Adjacent",
        "excerpt":"문제  Link   코드  class Solution {    public int[] gardenNoAdj(int n, int[][] paths) {     List&lt;Integer&gt;[] graph = new ArrayList[n];     for (int i = 0; i &lt; n; i++) {       graph[i] = new ArrayList&lt;&gt;();     }     for (int[] path : paths) {       int x = path[0] - 1;       int y = path[1] - 1;       graph[x].add(y);       graph[y].add(x);     }     int[] result = new int[n];     for (int i = 0; i &lt; n; i++) {       int[] colors = new int[5];       for (int neighbor : graph[i]) {         colors[result[neighbor]] = 1;       }       for (int j = 4; j &gt; 0; j--) {         if (colors[j] == 0) {           result[i] = j;         }       }     }     return result;   }  }   결과  Link   설명     1 ~ n까지의 정원을 아래의 규칙대로 1 ~ 4의 색을 가진 꽃들을 심을 경우, 정원 별 심은 꽃을 정수 배열로 순차적으로 넣어 반환하는 문제이다.            paths[i] = [xi, yi]는 xi번째 정원에서 yi번째 정원으로 이동하는 경로가 저장되어 있다.       정원은 최대 3개의 길로 왕래가 가능하며, 연결된 정원은 서로 다른 꽃이 심어져야 한다.           문제 풀이에 필요한 변수를 정의한다.            graph는 1 ~ n까지의 정원의 연결된 경로를 저장할 변수로, 각 위치에 ArrayList로 초기화 후 paths를 반복하여 graph의 $path[0] - 1$번째 ArrayList에 $path[1] - 1$을, $path[1] - 1$번째 ArrayList에 $path[0] - 1$를 넣어준다.       result는 결과를 저장할 변수로, n 크기의 정수 배열로 초기화한다.           0부터 n까지 i를 증가시키며 아래를 반복한다.            colors는 i번째 정원과 연결된 꽃의 색상을 저장할 배열로, 값을 체크하기 쉽도록 5 크기의 정수 배열로 초기화 후 graph의 i번째 ArrayList를 반복하여 연결된 정원 내 꽃의 색상에 대한 번호에 1을 넣어준다.       4부터 0 초과일 때 까지 j를 감소시키며 아래를 수행한다.                    colors[j]가 0인 연결된 정원들 내 존재하지 않는 꽃의 색인 경우, result[i]의 위치에 j를 넣어준다.                           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/flower-planting-with-no-adjacent/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Customers Who Bought All Products",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT customer_id FROM Customer GROUP BY customer_id HAVING COUNT(distinct product_key) = (SELECT COUNT(product_key) FROM Product)   결과  Link   설명          Product 테이블에 등록된 모든 품목을 구매한 customer_id를 Customer 테이블에서 찾는 문제이다.            Customer 테이블의 customer_id 기준으로 GROUP BY 수행할 때 아래를 조건으로 수행한다.             GROUP BY 되는 customer_id의 갯수가 Product 테이블의 품목 갯수와 동일한지 여부를 HAVING 조건으로 수행한다.          ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/customers-who-bought-all-products/",
        "teaser": null
      },{
        "title": "Leetcode Java Last Stone Weight",
        "excerpt":"문제  Link   코드  class Solution {    public int lastStoneWeight(int[] stones) {     Arrays.sort(stones);     for (int i = stones.length - 1, j = i - 1; j &gt;= 0;) {       if (stones[j] == stones[i]) {         stones[i] = 0;         stones[j] = 0;       } else if (stones[j] &gt; stones[i]) {         stones[j] = stones[j] - stones[i];         stones[i] = 0;       } else {         stones[j] = stones[i] - stones[j];         stones[i] = 0;       }       Arrays.sort(stones, 0, i);       i--;       j--;     }     return stones[0];   }  }   결과  Link   설명     돌의 무게를 가진 stones를 이용하여 아래의 규칙을 만족하는 결과를 반환하는 문제이다.            가장 무거운 두 돌의 돌맹이의 무게가 같으면 두 돌 모두 파괴된다.       가장 무거운 두 돌의 돌맹이의 무게가 다르면 두 돌의 차이를 남긴다.       마지막 남은 돌이 없으면 0을 반환한다.                stones의 값들을 오름차순으로 정렬한다.       i는 $stones.length - 1$로, j는 $i - 1$로 초기화하여 j가 0보다 클 때 까지 아래를 반복한다.            stones의 i번째 돌과 j번째 돌의 무게가 동일하면 0으로 둘 모두 0으로 바꾼다.       위의 경우가 아니라 어느 한 쪽 돌의 무게가 크다면, 큰 돌의 자리에 두 돌의 차잇값을 넣어준다.       stones의 처음부터 j까지 돌들의 무게를 오름차순 정렬하고 i와 j를 감소한다.           수행이 완료되면 stones의 첫 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/last-stone-weight/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove All Adjacent Duplicates In String",
        "excerpt":"문제  Link   코드  class Solution {    public String removeDuplicates(String s) {     StringBuilder sb = new StringBuilder();     for (char c : s.toCharArray()) {       if (sb.length() &gt; 0 &amp;&amp; sb.charAt(sb.length() - 1) == c) {         sb.deleteCharAt(sb.length() - 1);       } else {         sb.append(c);       }     }     return sb.toString();   }  }   결과  Link   설명          문자열 s에서 인접한 동일 문자들을 반복 제거한 문자열을 반환하는 문제이다.            sb는 동적으로 문자열을 이어주기 위한 변수로, StringBuilder로 초기화한다.       s의 문자들을 순차적으로 c 에 넣어 아래를 반복한다.            sb의 길이가 0보다 크면서 sb의 이전 문자가 c와 동일한 경우, sb의 이전 문자를 제거한다.       위의 경우가 아니라면 sb에 c를 이어준다.           반복이 완료되면 sb를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-all-adjacent-duplicates-in-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Last Stone Weight II",
        "excerpt":"문제  Link   코드  class Solution {    public int lastStoneWeightII(int[] stones) {     int sum = 0;     for (int stone : stones) {       sum += stone;     }     int[] dp = new int[(sum / 2) + 1];     for (int i = 0; i &lt; stones.length; i++) {       for (int j = sum / 2; j &gt;= stones[i]; j--) {         dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);       }     }     return sum - (2 * dp[sum / 2]);   }  }   결과  Link   설명     돌의 무게가 저장된 stones를 이용하여 아래의 규칙대로 돌을 부술 때, 남은 돌의 무게가 최소가 되는 값을 구하는 문제이다.            x와 y 두 돌의 무게가 x &lt;= y를 만족할 때, 두 돌을 부순 결과는 아래와 같다.                    x와 y의 무게가 동일하다면, 두 돌은 파괴된다.           x와 y의 무게가 돌일하지 않다면, x는 파괴되고 두 돌의 무게 차이 값의 돌이 남는다.                       마지막엔 하나의 돌만 남게 되고, 돌이 남아있지 않는다면 주어진 문제의 결과로 0을 반환한다.           문제 풀이에 필요한 변수를 정의한다.            sum은 돌의 합계를 저장할 변수로, stones의 모든 돌의 무게를 더해준다.       dp는 부서진 돌의 무게를 계산하기 위해 사용할 배열로, $\\frac{sum}{2} + 1$ 크기의 정수 배열로 초기화한다.           0부터 stones의 길이 미만까지 i를 증가시키고, $\\frac{sum}{2}$부터 stones[i] 이상일 때 까지 j를 감소시키며 아래를 반복한다.            dp[j]에 dp[j]와 dp[$j - stones[i]$]에 stones[i]를 뺀 값 중 큰 값을 넣어준다.           주어진 문제의 결과로 $sum - (2 \\times dp[\\frac{sum}{2}])$의 값을 주어진 문제의 결과로 반환한다.   해설     돌은 두 집단을 나누어 부수게 되므로, 계산을 최소화 하기 위해 값의 범위를 $\\frac{sum}{2}$로 정하고 dp를 해당 값보다 1 큰 크기로 초기화한다.   stones의 i는 순차적으로 증가시키고, j는 역순으로 탐색하는 이유는 dp[$j - stones[i]$]의 값에 대해서 $i + 1$번째 돌을 고려하지 않고 계산되었으므로 다시 반복하지 않기 위해서이다.   이렇게 남은 돌의 무게가 최소가 되는 값은, stones 내 돌 무게의 합인 sum에서 dp의 마지막 위치에 저장된 절반 범위 내 부서질 돌의 최대 무게인 dp[$\\frac{sum}{2}$] 값에 2를 곱한 값을 빼준 값이 된다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/last-stone-weight-ii/",
        "teaser": null
      },{
        "title": "Leetcode MySQL Actors and Directors Who Cooperated At Least Three Times",
        "excerpt":"문제  Link   코드  # Write your MySQL query statement below SELECT actor_id, director_id FROM ActorDirector GROUP BY actor_id, director_id HAVING COUNT(*) &gt;= 3   결과  Link   설명     ActorDirector 테이블에서 actor_id, director_id가 동일한 데이터가 3개 이상인 조합을 찾는 간단한 문제이다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","MySQL"],
        "url": "/leetcode/actors-and-directors-who-cooperated-at-least-three-times/",
        "teaser": null
      },{
        "title": "Leetcode Java Merge In Between Linked Lists",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {     ListNode head = list1;     for (int i = 1; i &lt; a; i++) {       head = head.next;     }     ListNode tail = head;     for (int i = a; i &lt;= b; i++) {       tail = tail.next;     }     head.next = list2;     while (list2.next != null) {       list2 = list2.next;     }     list2.next = tail.next;     return list1;   }  }   결과  Link   설명          list1 리스트노드에서 a번째 노드에서 b번째 노드까지 제거하고 그 사이에 list2 리스트노드를 이어주는 문제이다.            head에 list1을 넣고 1부터 a 미만일 때 까지 i를 증가시키며, haed에 head의 next 노드를 넣어 무시해야 할 위치에 해당하는 노드를 정해준다.            tail에 head를 넣고 a부터 b 이하일 때 까지 i를 증가시키며, tail에 tail의 next 노드를 넣어 무시해야 할 위치가 끝나는 노드의 위치에 해당하는 노드를 저장한다.            head의 next에 list2를 넣어 이어주고, list2의 마지막 위치의 next 노드에 tail의 next 노드를 넣고 list1을 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/merge-in-between-linked-lists/",
        "teaser": null
      },{
        "title": "Leetcode Java Height Checker",
        "excerpt":"문제  Link   코드  class Solution {    public int heightChecker(int[] heights) {     int[] counts = new int[101];     for (int height : heights) {       counts[height]++;     }     int result = 0;     int i = 0;     for (int height : heights) {       while (counts[i] == 0) {         i++;       }       if (i != height) {         result++;       }       counts[i]--;     }     return result;   }  }   결과  Link   설명          heights의 값들이 오름차순으로 정렬되지 않은 값의 갯수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            counts는 heights 내 값들의 갯수를 저장할 변수로, 값의 상한인 100까지 들어갈 수 있도록 101 크기의 정수 배열로 초기화 후 heights의 값들의 갯수를 넣어준다.       result는 정렬되지 않은 값의 갯수를 저장할 변수로, 0으로 초기화한다.       i는 현재 높이 값을 저장할 변수로, 0으로 초기화한다.           heights의 모든 값들을 순차적으로 height에 넣고 아래를 반복한다.            counts[i]의 값이 0인 heights에 존재하지 않는 값인 경우, 존재하는 위치까지 i를 계속 증가시킨다.       i와 height가 다른 경우 현재 위치에 맞지 않는 높이이므로, result를 증가시킨다.       값을 차감한 count[i]의 값을 감소시킨다.           반복이 완료되면 정렬되지 않은 값의 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/height-checker/",
        "teaser": null
      },{
        "title": "Leetcode Java Grumpy Bookstore Owner",
        "excerpt":"문제  Link   코드  class Solution {    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {     int max = 0;     int sum = 0;     int[] total = new int[2];     for (int i = 0; i &lt; customers.length; i++) {       total[0] += customers[i];       total[1] += customers[i] * grumpy[i];       sum += customers[i] * grumpy[i];       if (i &gt; minutes - 1) {         sum -= customers[i - minutes] * grumpy[i - minutes];       }       max = Math.max(sum, max);     }     return total[0] - total[1] + max;   }  }   결과  Link   설명     customers와 grumpy를 이용하여 아래의 규칙에 따라 하루 종일 만족할 수 있는 최대 고객 수를 반환하는 문제이다.            i분에 customers[i]명의 고객이 방문하고, grumpy[i]의 값은 만족도를 나타낸다.       grumpy[i]의 값이 1이면 심술을, 만족하면 0을 뜻한다.       주인은 minutes분 동안 1회 심술을 방지할 수 있다.           문제 풀이에 필요한 변수를 정의한다.            max는 minutes분 동안 심술을 방지하고 만족한 최대 고객 수를 저장하기 위한 변수로, 0으로 초기화한다.       sum은 minutes분 동안 심술을 방지하고 만족한 최대 고객 수를 계산하기 위한 변수로, 0으로 초기화한다.       total은 방문한 고객의 수와 만족한 고객의 합계를 저장할 변수로, 2차원 정수 배열로 초기화한다.           0부터 customers의 길이 미만까지 i를 증가시키며 아래를 반복한다.            total[0]에 customers[i]인 고객의 수를 더해준다.       total[1]에 $customers[i] \\times grumpy[i]$인 만족한 고객의 수를 더해준다.       sum에 $customers[i] * grumpy[i]$를 더해 만족한 고객의 수를 누계한다.       i가 $minutes - 1$보다 큰 경우, sum에서 $i - minuets$번째 만족한 고객의 수를 빼준다.       sum에 max와 sum 중 큰 값을 넣어준다.           반복이 완료되면 $total[0] - total[1]$인 만족하지 않은 고객의 수에 minutes 동안 심술을 방지한 최대 고객의 수인 max를 더해 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/grumpy-bookstore-owner/",
        "teaser": null
      },{
        "title": "Leetcode Java Previous Permutation With One Swap",
        "excerpt":"문제  Link   코드  class Solution {    public int[] prevPermOpt1(int[] arr) {     int i = arr.length - 2;     int j = arr.length - 1;     while (i &gt;= 0 &amp;&amp; arr[i] &lt;= arr[i + 1]) {       i--;     }     if (i &lt; 0) {       return arr;     }     while (arr[j] &gt;= arr[i] || (j &gt; 0 &amp;&amp; arr[j] == arr[j - 1])) {       j--;     }     int temp = arr[j];     arr[j] = arr[i];     arr[i] = temp;     return arr;   }  }   결과  Link   설명     arr 내 한 번의 값 변경을 통해서 arr보다 사전적으로 작지만 사전적으로 가장 큰 배열을 반환하는 문제이다.            단, 불가능한 경우 arr 그대로 반환한다.                i와 j는 값의 변경을 위한 위치 변수로, 마지막의 두 위치를 순차적으로 넣어준다.            i가 0보다 크면서 다음 값보다 클 때 까지 i를 감소시킨다.            i가 0보다 작으면 구성이 불가능하므로, arr을 반환한다.            arr의 j번째 값이 i번째 값보다 크거나, j가 0보다 크고 이전 위치와 동일할 때 까지 j를 감소시킨다.       i와 j의 위치가 결정되면 두 값의 위치를 바꾼 arr을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/previous-permutation-with-one-swap/",
        "teaser": null
      },{
        "title": "Leetcode Java Distant Barcodes",
        "excerpt":"문제  Link   코드  class Solution {    public int[] rearrangeBarcodes(int[] barcodes) {     int length = barcodes.length;     for (int i = 1; i &lt; length; i++) {       if (barcodes[i] == barcodes[i - 1]) {         int j = i + 1;         while (j &lt; length &amp;&amp; barcodes[i] == barcodes[j]) {           j++;         }         if (j &lt; length) {           barcodes[i] = barcodes[j];           barcodes[j] = barcodes[i - 1];         }       }     }     for (int i = length - 2; i &gt;= 0; i--) {       if (barcodes[i] == barcodes[i + 1]) {         int j = i - 1;         while (j &gt;= 0 &amp;&amp; barcodes[j] == barcodes[i]) {           j--;         }         if (j &gt;= 0) {           barcodes[i] = barcodes[j];           barcodes[j] = barcodes[i + 1];         }       }     }     return barcodes;   }  }   결과  Link   설명          barcodes의 각 숫자들의 인접한 숫자들끼리 동일하지 않은 값으로 재배치하는 문제이다.            length는 barcodes의 길이를 저장한 변수이다.       1부터 length까지 i를 증가시키며 barcodes의 앞에서 뒤 순서로 아래를 반복하여 순서를 다시 섞어준다.            barcodes의 i번째 값과 $i - 1$번째 값이 동일한 경우, 아래를 수행한다.                    j는 바꿀 값의 위치를 저장할 변수로, $i + 1$로 초기화하여 j가 length 미만이면서 barcodes의 i번째 자리의 값과 j번째 자리의 값이 동일할 때 까지 j를 증가시켜준다.           j가 length 미만인 값을 찾은 경우, barcodes의 i번째 위치에 j번째 값을 j번째 위치에 $i + 1$번째 값을 넣어 값을 섞어준다.                           $length - 2$부터 0 이상일 때 까지 i를 감소시키며 barcodes의 뒤에서 앞 순서를 아래를 반복하여 순서를 다시 섞어준다.            barcodes의 i번째 값과 $i + 1$번째 값이 동일한 경우, 아래를 수행한다.                    j는 바꿀 값의 위치를 저장할 변수로, $i - 1$로 초기화하여 j가 0 이상이면서 barcodes의 j번째 자리의 값과 i번째 자리의 값이 동일할 때 까지 j를 감소시켜준다.           j가 0 이상인 경우 값을 찾은 경우, barcodes의 i번째 위치에 j번째 값을 j번째 위치에 $i + 1$번째 값을 넣어 값을 섞어준다.                           위의 두 반복이 완료되어 동일한 값이 인접하지 않도록 섞은 barcodes를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/distant-barcodes/",
        "teaser": null
      },{
        "title": "Leetcode Java Lexicographically Smallest Equivalent String",
        "excerpt":"문제  Link   코드  class Solution {    public String smallestEquivalentString(String s1, String s2, String baseStr) {     int[] graph = new int[26];     for (int i = 0; i &lt; 26; i++) {       graph[i] = i;     }     char[] s1CharArray = s1.toCharArray();     char[] s2CharArray = s2.toCharArray();     for (int i = 0; i &lt; s1.length(); i++) {       int j = this.find(graph, s1CharArray[i] - 'a');       int k = this.find(graph, s2CharArray[i] - 'a');       if (k &lt; j) {         graph[j] = k;       } else {         graph[k] = j;       }     }     StringBuilder sb = new StringBuilder();     for (char c : baseStr.toCharArray()) {       sb.append((char) ('a' + this.find(graph, c - 'a')));     }     return sb.toString();   }    private int find(int[] graph, int index) {     while (graph[index] != index) {       index = graph[index];     }     return index;   }  }   결과  Link   설명     등치 문자열인 s1과 s2의 등가 정보를 이용하여, 사전적으로 가장 작은 등가 문자열인 baseStr을 반환하는 문제이다.            등치 문자열은 $s1 = abc$, $s2 = cde$일 때,  “a” == “c”, “b” == “d”, “c” == “e”를 만족한다.       위를 이용하여 baseStr이 “eed” 문자열일 때, “acd”와 “aab”는 등가 문자열이며 이 중 “aab”는 사전적으로 가장 작은 등가 문자열이다.           문제 풀이에 필요한 변수를 정의한다.            graph는 등치 문자열의 영문자 위치 값을 저장할 변수로, 26 크기의 정수 배열로 초기화하여 각 위치에 0부터 25까지 넣어준다.       s1CharArray와 s2CharArray는 s1과 s2를 문자 배열로 저장한 변수이다.           graph의 index번째 문자의 등치 문자열 탐색에 필요한 find(int[] graph, int index) 메서드를 정의한다.            graph의 index번째 값이 index가 아닐 때 까지 index에 graph[index] 값을 넣어준 후, index를 반환한다.           0부터 s1의 길이 미만까지 i를 증가시키며 아래를 수행한다.            j와 k에 s1CharArray와 s2CharArray의 i번째 문자의 영문자 순서를 이용하여 find 메서드를 수행한 결과를 각각 넣어준다.       k가 j보다 작은 경우 사전적인 순서대로 저장해야 하므로, graph[j]에 k를 아니면 grpah[k]에 j를 넣어준다.           반복이 완료되면 최종 문자열을 만들기 위한 sb를 StringBuilder로 초기화한 후 baseStr의 각 문자를 순차적으로 c에 넣어 아래를 수행한다.            sb에 ‘a’에 c의 영문자 순서를 이용하여 find 메서드를 수행한 결과를 더하여 이어준다.           반복이 완료되면 저장된 sb를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/lexicographically-smallest-equivalent-string/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Product Sales Analysis I",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT Product.product_name, Sales.year, Sales.price FROM Sales JOIN Product ON Product.product_id = Sales.product_id   결과  Link   설명     Sales 테이블의 product_id를 이용하여 Product의 이름을 가져와 product_name, year, price 순으로 필드를 보여주는 문제이다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/product-sales-analysis-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Length of Longest Subarray With at Most K Frequency",
        "excerpt":"문제  Link   코드  class Solution {    public int maxSubarrayLength(int[] nums, int k) {     Map&lt;Integer, Integer&gt; count = new HashMap&lt;&gt;();     int result = 0;     for (int i = 0, j = 0; j &lt; nums.length; j++) {       count.put(nums[j], count.getOrDefault(nums[j], 0) + 1);       while (count.get(nums[j]) &gt; k) {         count.put(nums[i], count.get(nums[i++]) - 1);       }       result = Math.max(result, j - i + 1);     }     return result;   }  }   결과  Link   설명          nums 내 숫자의 갯수가 k개 이하인 부분 배열 중 가장 긴 부분 배열의 길이를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            count는 nums 내 숫자의 갯수를 계산할 변수로, HashMap으로 초기화한다.       result는 가장 긴 부분 배열의 길이를 저장할 변수로, 0으로 초기화한다.           i는 0으로, j는 0부터 nums의 길이 미만까지 j를 증가시키며 아래를 반복한다.            count에 nums[j]에 해당하는 갯수를 증가시켜준다.       count의 nums[j]에 해당하는 갯수가 k 초과일 때 까지 count의 nums[i]에 해당하는 갯수를 감소시키고 i를 증가시킨다.       result에 result와 $j - i + 1$인 현재까지의 부분 배열의 길이 중 큰 값을 넣어준다.           반복이 완료되면 가장 긴 부분 배열의 길이가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/length-of-longest-subarray-with-at-most-k-frequency/",
        "teaser": null
      },{
        "title": "Leetcode Java Length of Longest Subarray With at Most K Frequency",
        "excerpt":"문제  Link   코드  class Solution {    public long countSubarrays(int[] nums, int k) {     int max = 0;     for (int num : nums) {       max = Math.max(max, num);     }     long result = 0;     for (int i = 0, j = 0; j &lt; nums.length; j++) {       k -= nums[j] == max ? 1 : 0;       while (k == 0) {         k += nums[i++] == max ? 1 : 0;       }       result += i;     }     return result;   }  }   결과  Link   설명          nums내 동일한 값이 정확히 k번 나타나는 부분 배열의 수를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            max는 nums 내 가장 큰 값을 저장할 변수로, nums를 반복하여 가장 큰 값을 찾아 넣어준다.       result는 부분 배열의 수를 저장할 변수로, 0으로 초기화한다.           i는 0으로, j는 0부터 nums의 길이 미만까지 증가시키며 아래를 수행한다.            k에 nums[j]의 값이 max와 동일하면 1을 빼준다.       k가 0이 될 때까지 k에 nums[i]의 값이 max와 동일하면 조건에 부합하므로 1을 더해주고 i를 증가시킨다.       result에 부분 배열의 수인 i를 더해준다.           반복이 완료되면 부분 배열의 수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-subarrays-where-max-element-appears-at-least-k-times/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Subarrays With Fixed Bounds",
        "excerpt":"문제  Link   코드  class Solution {    public long countSubarrays(int[] nums, int minK, int maxK) {     long result = 0;     int bad = -1;     int min = -1;     int max = -1;     for (int i = 0; i &lt; nums.length; i++) {       if (nums[i] &lt; minK || nums[i] &gt; maxK) {         bad = i;       }       if (nums[i] == minK) {         min = i;       }       if (nums[i] == maxK) {         max = i;       }       result += Math.max(0L, Math.min(min, max) - bad);     }     return result;   }  }   결과  Link   설명          nums 내 [minK, maxK] 범위 내인 값들만 존재하는 부분 배열의 수를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 부분 배열의 수를 저장할 변수로, 0으로 초기화한다.       bad는 범위를 벗어나는 값의 마지막 위치를 저장할 변수로, -1로 초기화한다.       min과 max는 최소 최대가 되는 위치를 저장할 변수로, -1로 초기화한다.           0부터 nums의 길이 미만일 때 까지 i를 증가시키며 아래를 반복한다.            nums[i]의 값이 [minK, maxK] 범위를 벗어나면, bad에 현재 위치인 i를 넣어준다.       nums[i]의 값이 minK의 값과 동일하면 min에 i를, maxK의 값과 동일하면 max에 i를 넣어준다.       result에 min과 max중 작은 값에 bad를 뺀 조건에 맞는 부분 배열의 수를 음수인 경우를 제외하고 더해준다.           반복이 완료되면 부분 배열의 수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-subarrays-with-fixed-bounds/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Product Sales Analysis III",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT product_id, year AS first_year, quantity, price FROM Sales WHERE (product_id, year) IN (     SELECT product_id, MIN(year)     FROM Sales     GROUP BY product_id )   결과  Link   설명          Sales 테이블은 판매한 이력을 가진 테이블로, 각 물품별로 첫 해에 팔린 모든 행의 product id, year, quantity, price 필드만 반환하는 문제이다.            문제의 목표는 product_id 별 가장 작은 년도에 팔린 데이터를 가져와야 하므로, Sales의 데이터를 product_id와 year의 최솟값을 간추려 Sales 테이블의 앞의 값의 데이터들만 가져온다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/product-sales-analysis-iii/",
        "teaser": null
      },{
        "title": "Leetcode Java Greatest Common Divisor of Strings",
        "excerpt":"문제  Link   코드  class Solution {    public String gcdOfStrings(String str1, String str2) {     if (!(str1 + str2).equals(str2 + str1)) {       return \"\";     } else {       return str2.substring(0, this.getGcd(str1.length(), str2.length()));     }   }    private int getGcd(int a, int b) {     return b == 0 ? a : this.getGcd(b, a % b);   }  }   결과  Link   설명     두 문자열 str1과 str2을 이용하여 str2 문자열로 str1 문자열을 나눌 때, 최대 길이의 문자열을 구하는 문제이다.            문자열 s는 “t”로 구성된 문자열 “ttt…tt” 문자열로, 해댕 문자열은 문자열 “t”로 문자열 s를 나눌 수 있다고 표현한다.           str1과 str2를 번갈아 앞뒤로 더한 문자열이 동일한지 여부에 따라 결과를 반환한다.            두 문자열이 동일하지 않으면 str2 문자열로 str1 문자열을 나눌 수 없으므로, 빈 문자열(““)을 주어진 문제의 결과로 반환한다.       위의 경우가 아니라면, str2의 처음부터 두 문자열의 길이의 최대 공약수 위치 이전까지 문자열을 잘라 주어진 문제의 결과로 반환한다.           해설     문자열을 나누는데 기준은 str1이 str2로 구성되어야 한다.   그렇기 때문에 두 문자열 str1과 str2을 앞뒤로 합친 결과가 동일해야 나눌 수 있다.   위의 경우가 아니라면, 두 문자열 str1과 str2의 길이에 대한 최대 공약수를 구하면 최소 중복을 제거한 최대 길이의 문자열을 구할 수 있다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/greatest-common-divisor-of-strings/",
        "teaser": null
      },{
        "title": "Leetcode Java Flip Columns For Maximum Number of Equal Rows",
        "excerpt":"문제  Link   코드  class Solution {    public int maxEqualRowsAfterFlips(int[][] matrix) {     int result = 0;     int row = matrix.length;     int col = matrix[0].length;     int[] temp = new int[col];     for (int i = 0; i &lt; row; i++) {       int count = 0;       for (int j = 0; j &lt; col; j++) {         temp[j] = 1 - matrix[i][j];       }       for (int k = i; k &lt; row; k++) {         if (Arrays.equals(matrix[k], matrix[i]) || Arrays.equals(matrix[k], temp)) {           count++;         }       }       result = Math.max(result, count);     }     return result;   }  }   결과  Link   설명          matrix의 임의 열들 내 값들을 0에서 1로 혹은 1에서 0으로 뒤집을 때, 모든 값이 동일한 행의 최대 갯수를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 플립 이후에 모든 값이 동일한 행의 최대 갯수를 저장할 변수로, 0으로 초기화한다.       row와 col은 matrix의 행과 열의 길이를 저장한 변수이다.       temp는 플립하기 위한 임시 배열로, col 크기의 정수 배열로 초기화한다.           0부터 row 미만까지 i를 증가시키며 아래를 수행한다.            count는 i번째 수행에 대해서 결과 값을 저장할 변수로, 0으로 초기화한다.       0부터 col 미만까지 j를 증가시키며, temp의 각 위치에 값을 뒤집어 넣어준다.       i부터 row 미만까지 k를 증가시키며, matrix[k]와 matrix[i] 혹은 matrix[k]와 temp가 동일한 값으로 구성된 경우 count를 증가시켜준다.       result에 result와 count 중 큰 값을 넣어준다.           반복이 완료되면 최대 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/flip-columns-for-maximum-number-of-equal-rows/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Nesting Depth of the Parentheses",
        "excerpt":"문제  Link   코드  class Solution {    public int maxDepth(String s) {     int count = 0;     int result = 0;     for (char c : s.toCharArray()) {       switch (c) {         case '(': result = Math.max(result, ++count); break;         case ')': count--; break;         default:       }     }     return result;   }  }   결과  Link   설명     아래의 규칙을 만족하는 유효한 괄호 문자열의 최대 깊이를 반환하는 문제이다.            유효한 괄호 문자열(이하 VPS)는 아래의 규칙을 따른다.                    빈 문자열은 “”, 단일 문자는 “(“, “)”를 제외한 문자이다.           VPS를 만족하는 A와 B는 AB로 표기한다.           VPS를 만족하는 A는 (A)로 표기한다.                       VPS의 최대 깊이는 아래의 규칙을 따른다.                    \"”의 깊이는 0이다.           ”(“, “)”를 제외한 단일 문자의 깊이는 0이다.           $A + B$의 깊이는 A와 B의 깊이 중 가장 큰 깊이를 나타낸다.           “(A)”의 깊이는 $1 + A 문자열의 깊이$이다.                           문제 풀이에 필요한 변수를 정의한다.            count는 괄호의 수를 저장할 변수로, 0으로 초기화한다.       result는 최대 깊이를 저장할 변수로, 0으로 초기화한다.           s의 각 문자들을 c에 순차적으로 넣고 아래를 수행한다.            c가 ‘(‘ 문자인 경우, result에 result와 count를 증가시킨 다음 문자의 VPS 깊이 중 큰 값을 넣어준다.       c가 ‘)’ 문자인 경우, count를 감소시켜 VPS의 깊이를 감소시킨다.           반복이 완료되면 최대 깊이가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-nesting-depth-of-the-parentheses/",
        "teaser": null
      },{
        "title": "Leetcode Java Make The String Great",
        "excerpt":"문제  Link   코드  class Solution {    public String makeGood(String s) {     for (int i = 0; i &lt; s.length() - 1; i++) {       if (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {         return this.makeGood(s.substring(0, i) + s.substring(i + 2));       }     }     return s;   }  }   결과  Link   설명     문자열 s를 아래의 조건을 만족하는 좋은 문자열을 만들어 반환하는 문제이다.            i는 [0, $s.length - 2$] 사이의 값이다.       s의 i번째 문자가 영소문자일 때 $i + 1$번째 문자가 동일한 영대문자이거나 그 반대의 경우를 만족하면 제거한다.       제거 후 위의 절차를 반복 수행하여 제거할 문자가 존재하지 않는 문자열이다.           0부터 $s.length - 1$까지 i를 증가시키며 아래를 반복한다.            s의 i번째 문자와 $i + 1$번째 문자가 동일한 문자의 대/소문자인 경우, 앞의 두 문자를 제거한 문자열로 재귀 호출을 수행한 결과를 반환한다.           위의 결과가 존재하지 않으면 제거할 문자들이 없으므로, s를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/make-the-string-great/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Remove to Make Valid Parentheses",
        "excerpt":"문제  Link   코드  class Solution {    public String minRemoveToMakeValid(String s) {     char[] charArray = s.toCharArray();     int open = 0;     for (int i = 0; i &lt; charArray.length; i++) {       switch (charArray[i]) {         case '(': open++; break;         case ')':           if (open == 0) {             charArray[i] = '.';           } else {             open--;           }           break;         default: break;       }     }     for (int i = charArray.length - 1; i &gt;= 0; i--) {       if (open &gt; 0 &amp;&amp; charArray[i] == '(') {         charArray[i] = '.';         open--;       }     }     StringBuilder sb = new StringBuilder();     for (char c : charArray) {       if (c != '.') {         sb.append(c);       }     }     return sb.toString();   }  }   결과  Link   설명     ’(‘, ‘)’, 영소문자로 이루어진 s를 이용하여 아래의 규칙을 만족하는 유효한 문자열을 반환하는 문제이다.            결과 문자열의 괄호가 유효하도록 ‘(‘, ‘)’를 최소한 제거할 수 있다.       괄호 문자열은 아래의 경우에 유효하다.                    빈 문자열 혹은 영소문자로 이루어진 문자열.           A와 B 문자열이 이어진 AB 문자열.           (A)로 표기된 A가 유효한 문자열.                           문제 풀이에 필요한 변수를 정의한다.            charArray는 문자열 s를 문자 배열로 변환하여 저장한 변수이다.       open은 ‘(‘ 문자의 갯수를 계산할 변수로, 0으로 초기화한다.           0부터 charArray의 길이 미만까지 i를 증가시키며, 문자열 s의 좌측에서 우측으로 아래를 반복하여 괄호를 검증한다.            charArray[i]의 문자에 따라 아래를 수행한다.                    ’(‘ 문자의 경우, open을 증가시킨다.           ’)’ 문자의 경우, open이 0인 경우 charArray[i]에 ‘.’ 문자를 넣어 제거해준다.           그 외의 경우, 반복을 계속 수행한다.                           charArray의 길이보다 1 작은 값부터 0이상일 때 까지 i를 감소시키며, 문자열 s의 우측에서 좌측으로 아래를 반복하여 괄호를 재 검증한다.            open이 0 초과이면서 charArray[i]의 문자가 ‘(‘인 경우, charArray[i]에 ‘.’ 문자를 넣어 제거하고 open을 감소시킨다.           charArray에서 ‘.’ 문자를 제거한 문자들을 StringBuilder를 통해 동적으로 문자열로 만들어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-remove-to-make-valid-parentheses/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Students Unable to Eat Lunch",
        "excerpt":"문제  Link   코드  class Solution {    public int countStudents(int[] students, int[] sandwiches) {     int[] count = { 0, 0 };     int length = students.length;     for (int student : students) {       count[student]++;     }     for (int k = 0; 0 &lt; length &amp;&amp; 0 &lt; count[sandwiches[k]]; k++, length--) {       count[sandwiches[k]]--;     }     return length;   }  }   결과  Link   설명     학생 별 좋아하는 샌드위치 번호를 담은 students를 이용하여 순서대로 sandwiches의 샌드위치를 가져갈 때, 먹을 수 없는 학생의 수를 구하는 문제이다.            학생이 선호하는 샌드위치가 아닌 경우, students의 맨 뒤로 이동하여 다시 대기한다.           문제 풀이에 필요한 변수를 정의한다.            count는 유형 별 샌드위치 갯수를 저장할 변수로, 2차원 배열로 초기화하여 샌드위치의 종류 별 갯수를 넣어준다.       length는 students의 길이인 학생의 수를 저장한 변수이다.                k가 0부터 length가 0 초과이면서 count[sandwiches[k]]의 값이 0보다 클 때까지 k를 증가시키고 length를 감소시키며, count[sandwiches[k]]의 값을 감소시킨다.       반복이 종료되면 샌드위치를 가져가지 못한 학생의 수인 length를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-students-unable-to-eat-lunch/",
        "teaser": null
      },{
        "title": "Leetcode Java Time Needed to Buy Tickets",
        "excerpt":"문제  Link   코드  class Solution {    public int timeRequiredToBuy(int[] tickets, int k) {     int result = 0;     for (int i = 0; i &lt; tickets.length; i++) {       if (i &lt;= k) {         result += Math.min(tickets[i], tickets[k]);       } else {         result += Math.min(tickets[i], tickets[k] - 1);       }     }     return result;   }  }   결과  Link   설명     사람 별 티켓 구매 수량이 저장된 tickets를 이용하여 아래의 규칙을 만족하면서 k번째 사람이 티켓 구매가 완료하는데까지 필요한 시간을 계산하는 문제이다.            tickets의 0번째 대기 순서는 맨 앞, 마지막 대기 순서는 맨 마지막이다.       한 사람이 티켓을 구매하는데 1초가 걸리며, 한 사람에 한 장만 구매가 가능하다.       구매한 사람은 다음 티켓을 구매하기 위해서 맨 뒤로 이동해야 한다.       구매하려던 수량의 티켓을 모두 구매한 사람은 대기열에서 나온다.                result는 k번째 사람이 티켓 구매를 완료하는데까지 필요한 시간을 저장하기 위한 변수로, 0으로 초기화한다.       0부터 tickets의 길이 미만까지 i를 증가시키며 아래를 반복한다.            i가 k 이하인 경우, result에 tickets[i]와 tickets[k] 중 작은 값을 더해 구매 수량에 필요한 시간을 계산해준다.       위의 경우가 아니라면, result에 tickets[i]와 $tickets[k] - 1$ 중 작은 값을 더해 k번째 사람이 구매 후 티켓과 비교하여 시간을 계산해준다.           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/time-needed-to-buy-tickets/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Project Employees I",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT Project.project_id \t, ROUND(AVG(Employee.experience_years), 2) AS average_years FROM Project JOIN Employee ON Employee.employee_id = Project.employee_id GROUP BY Project.project_id   결과  Link   설명     Project 별 Employee의 평균 경력을 소수점 2자리까지 계산하는 문제이다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/project-employees-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Occurrences After Bigram",
        "excerpt":"문제  Link   코드  class Solution {    public String[] findOcurrences(String text, String first, String second) {     String[] words = text.split(\" \");     List&lt;String&gt; result = new ArrayList&lt;&gt;();     for (int i = 2; i &lt; words.length; i++) {       if (first.equals(words[i - 2]) &amp;&amp; second.equals(words[i - 1])) {         result.add(words[i]);       }     }     return result.toArray(new String[] {});   }  }   결과  Link   설명          띄어쓰기로 각 문자열이 구분된 text 문자열에서 first 문자열 다음 second 문자열이 나온 다음 문자열인 third 문자열들을 모아 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            words는 test를 띄어쓰기 단위로 분리하여 저장한 문자열 배열이다.       result는 third 문자열을 모으기 위한 변수로, ArrayList로 초기화한다.           2부터 words의 길이 미만까지 i를 증가시키며 아래를 반복한다.            first와 words[$i - 2$] 문자열이 같으면서 second와 words[$i - 1$] 문자열이 같은 경우, result에 words[i]를 넣어준다.           반복이 완료되면 조건에 만족하는 third 문자열만 모은 result를 문자열 배열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/occurrences-after-bigram/",
        "teaser": null
      },{
        "title": "Leetcode Java Letter Tile Possibilities",
        "excerpt":"문제  Link   코드  class Solution {    public int numTilePossibilities(String tiles) {     int[] count = new int[26];     for (char c : tiles.toCharArray()) {       count[c - 'A']++;     }     return this.dfs(count);   }    private int dfs(int[] count) {     int sum = 0;     for (int i = 0; i &lt; 26; i++) {       if (count[i] &gt; 0) {         sum++;         count[i]--;         sum += this.dfs(count);         count[i]++;       }     }     return sum;   }  }   결과  Link   설명          tiles 내 문자들을 이용하여 중복되지 않은 고유 문자열들을 만들 수 있는 최대 갯수를 계산하는 문제이다.            count는 tiles내 문자들의 갯수를 계산할 변수로, 영문자 갯수인 26 크기의 정수 배열로 초기화하여 tiles 내 문자들에 해당하는 위치에 갯수를 넣어준다.            4번에서 정의한 dfs(int[] count) 메서드를 수행한 결과를 주어진 문제의 결과로 반환한다.            DFS 방식으로 고유 문자열의 갯수를 계산하기 위한 dfs(int[] count) 메서드를 정의한다.             sum은 고유 문자열 갯수의 합을 저장할 변수로, 0으로 초기화한다.       0부터 count의 길이인 26 미만까지 아래를 반복한다.                    count[i]의 값이 0보다 큰 경우 아래를 수행하고 그 외는 다음 반복을 수행한다.           sum을 증가하고 count[i]를 감소시킨다.           감소시킨 count를 이용하여 sum에 재귀호출을 수행한 결과를 더해준다.           count[i]를 다시 증가시켜 원복해준다.                       반복이 완료되어 계산된 고유 문자열의 갯수인 sum을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/letter-tile-possibilities/",
        "teaser": null
      },{
        "title": "Leetcode Java Insufficient Nodes in Root to Leaf Paths",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public TreeNode sufficientSubset(TreeNode root, int limit) {     if (root == null) {       return null;     } else if (root.left == null &amp;&amp; root.right == null) {       return root.val &lt; limit ? null : root;     } else {       root.left = this.sufficientSubset(root.left, limit - root.val);       root.right = this.sufficientSubset(root.right, limit - root.val);       return root.left == root.right ? null : root;     }   }  }   결과  Link   설명          root의 루트 노드부터 리프 노드까지 합계가 limit 이상인 노드가 되기 위해 불필요한 노드들을 삭제하는 문제이다.            root 노드가 null인 경우, 그대로 null을 반환한다.            root 노드의 left, right 노드가 null인 리프 노드인 경우, root의 val 값이 limit보다 작으면 null을 아니면 root를 반환한다.            그 외의 경우, 아래를 수행한다.             root의 left와 right TreeNode에 해당 노드와 $limit - root.val$ 값을 이용하여 순차적으로 재귀 호출을 수행한 결과를 넣어준다.       root의 left와 right가 동일한 null인 경우, null을 아니면 root를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/insufficient-nodes-in-root-to-leaf-paths/",
        "teaser": null
      },{
        "title": "Leetcode Java Smallest Subsequence of Distinct Characters",
        "excerpt":"문제  Link   코드  class Solution {    public String smallestSubsequence(String s) {     int[] count = new int[26];     for (char c : s.toCharArray()) {       count[c - 'a']++;     }     boolean[] visited = new boolean[26];     Stack&lt;Character&gt; stack = new Stack&lt;&gt;();     for (char c : s.toCharArray()) {       count[c - 'a']--;       if (visited[c - 'a']) {         continue;       }       while (!stack.isEmpty() &amp;&amp; c &lt; stack.peek() &amp;&amp; 0 &lt; count[stack.peek() - 'a']) {         visited[stack.pop() - 'a'] = false;       }       stack.push(c);       visited[c - 'a'] = true;     }     StringBuilder sb = new StringBuilder();     for (char c : stack) {       sb.append(c);     }     return sb.toString();   }  }   결과  Link   설명          문자열 s의 문자들을 한 번만 포함된 사전적으로 가장 작은 부분 수열을 찾는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            count는 문자열 s의 문자 갯수를 저장할 배열로, 영문자 갯수인 26 크기의 정수 배열로 초기화하여 s의 문자열 내 각 문자의 위치에 갯수를 더해준다.       visited는 사용한 문자인지 검증하기 위한 배열로, 영문자 갯수인 26 크기의 부울 배열로 초기화한다.       stack은 결과 문자열을 만들기 위한 변수로, Stack으로 초기화한다.           s의 문자들을 순차적으로 c에 넣고 아래를 수행한다.            count의 해당 문자 순서에 해당하는 갯수를 차감시킨다.       visited의 해당 문자 순서에 해당하는 값이 true이면 이미 사용했으므로, 다음 반복을 수행한다.       아래의 경우를 모두 만족하면, visited 내 stack의 가장 앞 문자에 해당하는 순서의 값을 false로 바꿔준다.                    stack 내 문자들이 존재하는 경우.           stack의 가장 앞 문자가 c보다 사전적으로 큰 경우.           count의 stack의 가장 앞 문자에 해당하는 순서의 값이 0보다 큰 경우.                       stack에 c를 넣은 후 visited의 c에 해당하는 순서의 값을 true로 바꾸어준다.           위의 반복이 완료되면 stack에 저장된 값을 순차적으로 꺼내 문자열로 만들어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/smallest-subsequence-of-distinct-characters/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Sales Analysis III",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT Product.product_id, Product.product_name FROM Product WHERE EXISTS ( \tSELECT 1 FROM Sales \tWHERE Sales.sale_date BETWEEN '2019-01-01' AND '2019-03-31' \tAND Sales.product_id = Product.product_id ) AND NOT EXISTS ( \tSELECT 1 FROM Sales \tWHERE Sales.sale_date NOT BETWEEN '2019-01-01' AND '2019-03-31' \tAND Sales.product_id = Product.product_id )   결과  Link   설명     Product 중 2019년 1분기(2019-01-01 ~ 2019-03-31)에만 판매된 품목의 product_id와 product_name을 찾는 문제이다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/sales-analysis-iii/",
        "teaser": null
      },{
        "title": "Leetcode Java Smallest Duplicate Zeros",
        "excerpt":"문제  Link   코드  class Solution {    public void duplicateZeros(int[] arr) {     int i = 0;     int count = 0;     int length = arr.length;     while (i + count &lt; length) {       if (arr[i++] == 0) {         count++;       }     }     for (i = i - 1; count &gt; 0; i--) {       if (i + count &lt; length) {         arr[i + count] = arr[i];       }       if (arr[i] == 0) {         arr[i + --count] = arr[i];       }     }   }  }   결과  Link   설명     정수 배열 arr 내 0이 존재하면 다음 자리부터의 모든 값들을 한 칸 우측으로 밀고 해당 자리에 0을 넣어주는 문제이다.            arr 크기를 벗어난 값은 그대로 제거된다.           문제 풀이에 필요한 변수를 정의한다.            i는 arr 내 탐색을 위한 위치 변수로 사용할 변수로, 0으로 초기화한다.       count는 arr 내 0의 갯수를 계산하기 위한 변수로, arr의 값들을 처음부터 $i + count$인 arr에 포함될 값들의 위치까지 반복하여 0 갯수를 넣어준다.       length는 arr의 길이를 저장한 변수이다.           $i - 1$부터 count가 0 초과일 때 까지 i를 감소시키며 아래를 반복한다.            $i + count$가 length보다 작은 경우, arr[$i + count$] 위치에 arr[i]를 넣어 arr의 마지막부터 값을 옮겨준다.       arr[i]의 값이 0인 경우, count를 감소시킨 후 arr[$i + count$] 위치에 arr[i]를 넣어 0을 이어준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/duplicate-zeros/",
        "teaser": null
      },{
        "title": "Leetcode Java Find if Path Exists in Graph",
        "excerpt":"문제  Link   코드  class Solution {    public boolean validPath(int n, int[][] edges, int source, int destination) {     if (edges.length == 0) {       return true;     } else {       boolean[] visited = new boolean[n];       visited[source] = true;       boolean running = true;       while (running) {         running = false;         for (int[] edge : edges) {           if (visited[edge[0]] != visited[edge[1]]) {             visited[edge[0]] = true;             visited[edge[1]] = true;             running = true;           }           if (visited[destination]) {             return true;           }         }       }       return false;     }   }  }   결과  Link   설명     n개의 점에서 연결선인 edges를 이용하여 source에서 destination까지 연결이 가능한지 여부를 판단하는 문제이다.            각 점은 다른 점과의 연결선이 존재하고, 자기 자신과 연결되는 선은 존재하지 않는다.                edges의 길이가 0인 경우, 연결선이 없으므로 true를 반환한다.       2번의 경우가 아닌 경우, 아래를 수행한다.            visited는 해당 위치의 점을 탐색한 이력을 저장할 배열로, n 크기의 부울 변수로 정의하고 source번째 자리만 true로 초기화한다.       running은 계속 진행할지 여부를 저장할 변수로, true로 초기화한다.           running이 true일 때 까지 아래를 반복한다.            running을 false로 바꾸어주고, edges를 순차적으로 edge에 넣어 아래를 반복한다.                    visited의 edge[0]번째 값이 edge[1]번째 값과 다르면 이미 탐색한 경로가 아니므로, 두 위치에 true를 넣고 running을 true로 바꾸어 탐색을 진행한다.           visited의 destination번째 값이 true인 목표에 도달한 경우, true를 반환한다.                           반복이 모두 완료되어 목표에 도달하는 경로가 없으면, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-if-path-exists-in-graph/",
        "teaser": null
      },{
        "title": "Leetcode Java Largest Values From Labels",
        "excerpt":"문제  Link   코드  class Solution {    public int largestValsFromLabels(int[] values, int[] labels, int numWanted, int useLimit) {     int length = values.length;     int[][] nums = new int[length][2];     for (int i = 0; i &lt; length; i++) {       nums[i][0] = values[i];       nums[i][1] = labels[i];     }     Arrays.sort(nums, (a, b) -&gt; b[0] - a[0]);     int result = 0;     int[] count = new int[20001];     for (int[] num : nums) {       if (count[num[1]] &lt; useLimit) {         count[num[1]]++;         numWanted--;         result += num[0];       }       if (numWanted == 0) {         break;       }     }     return result;   }  }   결과  Link   설명     아래의 조건을 만족하는 부분 집합의 최대 점수를 반환하는 문제이다.            labels의 i번째 요소의 values[i]이다.       부분 집합의 크기가 numWanted보다 작거나 같다.       n개의 요소로 구성된 부분 집합인 s는 useLimit개만큼 동일한 숫자가 포함될 수 있다.           문제 풀이에 필요한 변수를 정의한다.            length는 values의 길이를 저장한 변수이다.       nums는 labels와 values를 엮기 위한 배열로, $length \\times 2$ 크기의 2차원 정수 배열로 초기화하여 nums[i]에 [values[i], labels[i]]를 넣어준 후 값 기준으로 내림차순 정렬한다..       result는 결과를 저장할 변수로 0으로 초기화한다.       count는 값의 갯수를 저장할 변수로, 값의 최대 상한선인 $10^4$보다 1 큰 크기의 정수 배열로 초기화한다.           nums의 값을 순차적으로 num에 넣어 아래를 수행한다.            count[num[1]]의 값이 useLimit보다 작은 경우, 아래를 수행한다.                    count[num[1]]를 증가시켜 사용한 갯수를 증가시키고, numWanted 값을 감소시켜 갯수를 차감한다.           result에 num[0]인 값을 더해준다.                       numWanted가 0인 최대 가능한 부분 집합의 갯수를 채운 경우, 반복을 종료한다.           위의 반복을 통해 최대 점수가 계산된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/largest-values-from-labels/",
        "teaser": null
      },{
        "title": "Leetcode Java Shortest Common Supersequence",
        "excerpt":"문제  Link   코드  class Solution {    public String shortestCommonSupersequence(String str1, String str2) {     int str1Length = str1.length();     int str2Length = str2.length();     char[] str1CharArray = str1.toCharArray();     char[] str2CharArray = str2.toCharArray();     int[][] dp = new int[str1Length + 1][str2Length + 1];     for (int i = str1Length - 1; i &gt;= 0; i--) {       for (int j = str2Length - 1; j &gt;= 0; j--) {         if (str1CharArray[i] == str2CharArray[j]) {           dp[i][j] = 1 + dp[i + 1][j + 1];         } else {           dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]);         }       }     }     StringBuilder sb = new StringBuilder();     for (int i = 0, j = 0; i &lt; str1Length || j &lt; str2Length;) {       if (i &lt; str1Length ^ j &lt; str2Length) {         sb.append(i &lt; str1Length ? str1CharArray[i++] : str2CharArray[j++]);       } else if (str1CharArray[i] == str2CharArray[j]) {         sb.append(str1CharArray[i++]);         ++j;       } else {         sb.append(dp[i + 1][j] &gt; dp[i][j + 1] ? str1CharArray[i++] : str2CharArray[j++]);       }     }     return sb.toString();   }  }   결과  Link   설명          str1과 str2가 모두 포함되는 문자열 중 가장 짧은 문자열을 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            str1Length와 str2Length는 str1과 str2의 길이를 각각 저장한 변수이다.       str1CharArray와 str2CharArray는 str1과 str2를 각각 문자 배열로 변환한 변수이다.       dp는 문자열 조합에 가능한 길이를 저장할 변수로, $(str1Length + 1) \\times (str2Length + 1)$ 길이의 2차원 배열로 초기화한다.           $str1Length - 1$부터 0까지 i를 감소시키고 $str2Length - 1$부터 0까지 j를 감소시키며 아래를 반복한다.            str1CharArray[i]의 값과 str2CharArray[j]의 값이 동일하면 dp[i][j]의 위치에 $1 + dp[i + 1][j + 1]$를 넣어 합쳐지는 문자열의 길이를 증가시킨다.       위의 경우가 아니라면 dp[i][j]의 위치에 $dp[i + 1][j]$의 값과 $dp[i][j + 1]$의 값 중 큰 가장 긴 길이의 문자열의 길이를 넣어준다.                sb는 문자열을 동적으로 만들기 위한 변수로, StringBuilder로 초기화한다.       i와 j가 0부터 i가 str1Length 미만이거나 j가 str2Length미만일 때 까지 아래를 반복한다.            i가 str1Length보다 작은 결과와 j가 str2Length보다 작은 결과의 XOR(^) 연산의 결과가 참인 경우, i가 str1Length보다 작으면 sb에 str1CharArray[i]의 값을 넣고 i를 증가시키고 아니면 sb에 str2CharArray[j]의 값을 넣고 j를 증가시킨다.       위의 경우가 아니면서 str1CharArray[i]의 값과 str2CharArray[j]의 값이 동일한 경우, sb에 str1CharArray[i]를 넣고 i를 증가시킨다.       그 외의 경우 sb에 dp[i + 1][j]의 값이 dp[i][j + 1]의 값보다 크면, str1CharArray[i]의 값을 넣고 i를 증가시키고 아니면 sb에 str2CharArray[j]의 값을 넣고 j를 증가시킨다.           반복이 완료되면 완성된 결과인 sb를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/shortest-common-supersequence/",
        "teaser": null
      },{
        "title": "Leetcode Java N-th Tribonacci Number",
        "excerpt":"문제  Link   코드  class Solution {    public int tribonacci(int n) {     if (n &lt; 2) {       return n;     } else {       int result = 1;       for (int i = 0, j = 1; n &gt; 2; n--) {         int temp = i + j + result;         i = j;         j = result;         result = temp;       }       return result;     }   }  }   결과  Link   설명     n번째 Tribonacci sequence 값을 반환하는 문제이다.            n번째 Tribonacci sequence는 Tn로 나타낸다.       $T0 = 0, T1 = 1, T2 = 1$이다.       $Tn + 3 = Tn + Tn + 1 + Tn + 2$를 만족한다.                n이 2 미만인 경우, n을 그대로 주어진 문제의 결과로 반환한다.       n이 2 이상인 경우, 아래를 수행한다.            result는 결과를 저장할 변수로, 1로 초기화한다.       i와 j는 각각 0과 1로 초기화하여 n의 값이 2보다 클 때까지 아래를 수행하고 n을 감소시킨다.                    temp에 $i + j + result$를 임시로 넣어준다.           i에 j를, j에 result를, result에 temp를 넣어 값을 바꾸어준다.                           반복이 완료되어 계산된 result를 주어진 문제의 결과로 반화한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/n-th-tribonacci-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Ideal Subsequence",
        "excerpt":"문제  Link   코드  class Solution {    public int longestIdealString(String s, int k) {     int[] dp = new int[26];     int result = 1;     for (char c : s.toCharArray()) {       int i = c - 'a';       dp[i]++;       for (int j = Math.max(0, i - k); j &lt;= Math.min(25, i + k); j++) {         if (i != j) {           dp[i] = Math.max(dp[i], dp[j] + 1);         }       }       result = Math.max(result, dp[i]);     }     return result;   }  }   결과  Link   설명     아래 조건을 만족하는 문자열의 최대 길이를 반환하는 문제이다.            결과 문자열 t는 s의 부분 수열이다.       t와 인접한 문자열의 알파벳 순서 차이는 k보다 작거나 같다.       a와 z의 차잇값은 25로, 영문자는 순서 그대로에 대한 차잇값을 계산한다.           문제 풀이에 필요한 변수를 정의한다.            dp는 최대 길이 계산에 필요한 변수로, 26 크기의 정수 배열로 초기화한다.       result는 최대 길이를 계산할 변수로, 최소 길이인 1로 초기화한다.           s의 문자들을 순차적으로 c에 넣어 아래를 수행한다.            i는 c의 영문자 순서를 넣어주고, dp[i]의 값을 증가시킨다.       0과 $i - k$ 중 큰 값부터 25와 $i + k$ 중 작은 값 이하까지 j를 증가시키면서 아래를 반복한다.                    i와 j의 값이 다른 동일 문자가 아닌 경우, dp[i]에 dp[i]와 $dp[j] + 1$ 중 큰 값을 넣어준다.                       위의 반복이 완료되면 result에 이전까지 최대 길이인 result와 현재 최대 길이인 dp[i]의 값 중 큰 값을 넣어준다.           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-ideal-subsequence/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Falling Path Sum II",
        "excerpt":"문제  Link   코드  class Solution {    public int minFallingPathSum(int[][] grid) {     int length = grid.length;     for (int i = 1; i &lt; length; i++) {       int[] min = this.getMinTwoNumbers(grid[i - 1]);       for (int j = 0; j &lt; length; j++) {         if (grid[i - 1][j] == min[0]) {           grid[i][j] += min[1];         } else {           grid[i][j] += min[0];         }       }     }     int result = Integer.MAX_VALUE;     for (int num : grid[length - 1]) {       result = Math.min(result, num);     }     return result;   }    private int[] getMinTwoNumbers(int[] nums) {     int[] min = new int[] { Integer.MAX_VALUE, Integer.MAX_VALUE };     for (int num : nums) {       if (min[0] &gt; num) {         min[1] = min[0];         min[0] = num;       } else if (min[1] &gt; num) {         min[1] = num;       }     }     return min;   }  }   결과  Link   설명          행과 열의 수가 동일한 grid의 첫 행부터 마지막 행까지 동일한 순서의 열로 이동하지 않으면서 값들의 합이 최소 값가 되는 값을 구하는 문제이다.            length는 grid 행의 갯수를 저장한 변수이다.       1부터 length 미만까지 i를 증가시키며 아래를 반복한다.            min에 grid의 $i - 1$ 행 내 가장 작은 두 값을 구해 넣어준다.       0부터 length 미만까지 j를 증가시키며 아래를 반복한다.                    grid[i - 1][j]의 값이 min[0]의 값과 동일한 순서의 열인 경우, grid[i][j]의 값에 min[1]의 값을 더해준다.           위의 경우가 아니라면, grid[i][j]의 값에 최솟값인 min[0]의 값을 더해준다.                           3번의 반복이 완료되면, grid의 마지막 행의 값들 중 가장 작은 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-falling-path-sum-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Statistics from a Large Sample",
        "excerpt":"문제  Link   코드  class Solution {    public double[] sampleStats(int[] count) {     double[] result = new double[] { 256, -1, 0, 0, 0 };     int left = 0;     int right = 255;     int count1 = 0;     int count2 = 0;     int mid1 = 0;     int mid2 = 0;     for (int i = 0; i &lt; count.length; i++) {       if (count[i] &gt; 0) {         if (result[0] == 256) {           result[0] = i;         }         result[1] = i;         result[2] += (double) i * count[i];         if (count[i] &gt; count[(int) result[4]]) {           result[4] = i;         }       }     }     while (left &lt;= right) {       while (count[left] == 0) {         left++;       }       while (count[right] == 0) {         right--;       }       if (count1 &lt; count2) {         count1 += count[left];         mid1 = left++;       } else {         count2 += count[right];         mid2 = right--;       }     }     result[2] /= (count1 + count2);     if (count1 &lt; count2) {       result[3] = mid2;     } else if (count1 &gt; count2) {       result[3] = mid1;     } else {       result[3] = (mid1 + mid2) / 2.0;     }     return result;   }  }   결과  Link   설명          [0, 255] 범위 내 숫자들의 갯수를 저장한 count를 이용하여 순차적으로 [최솟값, 최댓값, 평균값, 중앙값, 최빈값]을 구하여 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 결과를 저장할 변수로, 순차적으로 아래의 의미를 가진 값을 넣어준다.                    첫 번째 값은 최솟값으로, 최대 위치 값보다 1 큰 256을 넣어준다.           두 번째 값은 최댓값으로, 최소 위치 값보다 1 작은 -1을 넣어준다.           나머지는 순서대로 평균값, 중앙값, 최빈값으로 모두 0을 넣어준다.                       left와 right는 숫자 위치를 저장할 변수로, 값에 대한 인덱스의 최솟값과 최댓값의 0과 255로 초기화한다.       count1과 count2는 count의 좌측과 우측의 갯수를 계산할 변수로, 둘 다 0으로 초기화한다.       mid1과 mid2는 중앙값 계산을 count1과 count2에 따라 계산할 변수로, 둘 다 0으로 초기화한다.           0부터 count의 길이 미만까지 i를 증가시키며 아래를 반복한다.            count[i]의 값이 0보다 큰 갯수가 존재하는 경우만 수행을 진행한다.       result[0]의 값인 최솟값이 256인 초기값인 경우, 해당 위치에 i를 넣어준다.       result[1]의 값인 최댓값을 i로 갱신해준다.       result[2]의 값인 평균값을 구하기 위한 값에 i를 실수로 변환하여 count[i]와 곱한 결과를 넣어준다.       count[i]의 값인 최빈값보다 count[result[4]]의 값보다 크다면, 해당 값으로 최빈값을 수정해준다.           left가 right보다 작거나 같을 때 까지 아래를 반복한다.            count[left]가 0이 아닐 때 까지 left를 증가시키고, count[right]가 0이 아닐 때 까지 right를 감소시킨다.       count1이 count2보다 작은 경우, 아래를 수행한다.                    count1에 count[left]의 값을 더해준다.           mid1에 left를 넣고 left를 증가시켜준다.                       count1이 count2보다 작지 않은 경우, 아래를 수행한다.                    count2에 count[right]의 값을 더해준다.           mid2에 right를 넣고 right를 감소시켜준다.                                위의 반복이 완료되면 result[2]인 평균값에 $count1 + count2$ 값을 더해서 해당 값에 나눠주어 평균값을 계산해준다.       count1과 count2의 크기에 따라 중앙값을 넣어준다.            count1이 count2보다 작은 경우 mid2의 값이 중앙값이므로, result[3]에 mid2를 넣어준다.       count1이 count2보다 큰 경우 mid1의 값이 중앙값이므로, result[3]에 mid1을 넣어준다.       두 경우가 아니라면, result[3]에 $frac{mid1 + mid2}{2}$의 값을 실수형태로 계산하여 넣어준다.           반복이 완료되면 모든 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/statistics-from-a-large-sample/",
        "teaser": null
      },{
        "title": "Leetcode Java Car Pooling",
        "excerpt":"문제  Link   코드  class Solution {    public boolean carPooling(int[][] trips, int capacity) {     int[] count = new int[1001];     for (int t[] : trips) {       count[t[1]] += t[0];       count[t[2]] -= t[0];     }     for (int i = 0; capacity &gt;= 0 &amp;&amp; i &lt; count.length; i++) {       capacity -= count[i];     }     return capacity &gt;= 0;   }  }   결과  Link   설명          capacity 좌석이 비어있는 차에서 [승객, 출발지, 도착지]가 저장된 trips를 이용하여 모든 승객들이 도착지에 도달할 수 있는지를 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            count는 승객의 수를 저장할 변수로, 최대 가능한 값의 상한인 1000보다 1 큰 크기의 정수 배열로 초기화하고 trips를 반복하여 출발지와 도착지의 승객들을 가감해준다.                0부터 count의 길이 미만까지 i를 증가시키며, capacity가 0 이상일 때 까지 아래를 반복하여 capacity의 값에 count[i] 값을 차감해준다.       반복이 완료되면 capacity가 0 이상인 좌석이 여유있는지 여부를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/car-pooling/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Number of Operations to Make Array XOR Equal to K",
        "excerpt":"문제  Link   코드  class Solution {    public int minOperations(int[] nums, int k) {     for (int num : nums) {       k ^= num;     }     return Integer.bitCount(k);   }  }   결과  Link   설명          num 내 정수들의 비트를 뒤집어 모든 값들의 XOR 결과가 k가 되기 위한 최소 횟수를 구하는 문제이다.            nums의 모든 값을 num에 순차적으로 넣어 k에 k와 num의 XOR(^) 비트 연산을 수행한 결과를 넣어준 후 k의 비트 중 1의 갯수인 뒤집을 최소 횟수를 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-number-of-operations-to-make-array-xor-equal-to-k/",
        "teaser": null
      },{
        "title": "Leetcode Java Reverse Prefix of Word",
        "excerpt":"문제  Link   코드  class Solution {    public String reversePrefix(String word, char ch) {     int index = word.indexOf(ch);     if (index == -1) {       return word;     } else {       return new StringBuilder(word.substring(0, index + 1)).reverse().toString() + word.substring(index + 1);     }   }  }   결과  Link   설명          word 내 첫 ch 문자 위치까지의 문자열을 거꾸로 뒤집는 문제이다.            index는 word의 ch 위치를 저장할 변수로, -1인 경우 word를 그대로 주어진 문제의 결과로 반환한다.            위의 경우가 아니라면 word의 처음부터 index까지의 문자열을 거꾸로 뒤집고 나머지 문자열을 이어 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reverse-prefix-of-word/",
        "teaser": null
      },{
        "title": "Leetcode Java Largest Positive Integer That Exists With Its Negative",
        "excerpt":"문제  Link   코드  class Solution {    public int findMaxK(int[] nums) {     Arrays.sort(nums);     for (int i = nums.length - 1; i &gt;= 0; i--) {       if (nums[i] &gt; 0 &amp;&amp; Arrays.binarySearch(nums, -nums[i]) &gt;= 0) {         return nums[i];       }     }     return -1;   }  }   결과  Link   설명     nums 내 음수 부호를 제거한 값의 절댓값이 동일한 값을 찾아 양수로 반환하는 문제이다.            단, 값을 찾을 수 없으면 -1을 주어진 문제의 결과로 반환한다.                nums를 오름차순 정렬한다.       nums의 길이보다 1 작은 값부터 0 이상까지 i를 감소시키며 거꾸로 탐색을 수행한다.            nums[i]의 값이 0보다 크면서 nums 내 nums[i]의 음수 값이 존재하는 경우, nums[i]의 값을 주어진 문제의 결과로 반환한다.           반복이 완료되면 조건을 만족하는 값을 찾을 수 없으므로, -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/largest-positive-integer-that-exists-with-its-negative/",
        "teaser": null
      },{
        "title": "Leetcode Java Brace Expansion II",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; braceExpansionII(String expression) {     return this.dfs(expression.toCharArray(), 0, expression.length() - 1);   }    private List&lt;String&gt; dfs(char[] expression, int start, int end) {     Set&lt;String&gt; result = new TreeSet&lt;&gt;();     List&lt;List&lt;String&gt;&gt; groups = new ArrayList&lt;&gt;();     groups.add(new ArrayList&lt;&gt;());     int count = 0;     for (int i = 0, j = start; j &lt;= end; j++) {       if (expression[j] == '{' &amp;&amp; ++count == 1) {         i = j + 1;       } else if (expression[j] == '}' &amp;&amp; --count == 0) {         this.merge(groups, this.dfs(expression, i, j - 1));       } else if (count == 0) {         if (expression[j] == ',') {           groups.add(new ArrayList&lt;&gt;());         } else {           this.merge(groups, new ArrayList&lt;&gt;(Arrays.asList(String.valueOf(expression[j]))));         }       }     }     for (List&lt;String&gt; group : groups) {       for (String word : group) {         result.add(word);       }     }     return new ArrayList&lt;&gt;(result);   }    private void merge(List&lt;List&lt;String&gt;&gt; groups, List&lt;String&gt; group) {     List&lt;String&gt; temp = groups.get(groups.size() - 1);     if (temp.isEmpty()) {       groups.set(groups.size() - 1, group);     } else {       List&lt;String&gt; result = new ArrayList&lt;&gt;();       for (String s1 : temp) {         for (String s2 : group) {           result.add(s1 + s2);         }       }       groups.set(groups.size() - 1, result);     }   }  }   결과  Link   설명     주어진 expression로 아래의 R(expr) 표현식을 이용하여 나타낼 수 있는 문자열을 오름차순으로 정렬하여 반환하는 문제이다.            단일 문자가 들어간 경우는 아래의 결과로 표현된다.                    R(“a”) = {“a”}           R(“w”) = {“w”}                       콤마로 구분된 두 개 이상의 값들로 이루어진 집합인 경우 아래의 결과로 표현된다.                    R(“{a,b,c}”) = {“a”,”b”,”c”}                       두 집합을 다시 묶어진 집합은 각 집합 내 최대 하나의 문자들만 포함된 집합으로 표현된다.                    R(“{{a,b},{b,c}}”) = {“a”,”b”,”c”}                       두 집합을 표현식으로 표현하면 두 문자들의 조합으로 표현된다.                    R(“{a,b}{c,d}”) = {“ac”,”ad”,”bc”,”bd”}                       위 경우들이 포함된 표현식은 아래와 같이 표현된다.                    R(“a{b,c}{d,e}f{g,h}”) = {“abdfg”, “abdfh”, “abefg”, “abefh”, “acdfg”, “acdfh”, “acefg”, “acefh”}                                3번에서 정의한 dfs(char[] expression, int start, int end)에 expression의 문자 배열, 처음 시작인 0, 마지막 위치인 expression의 길이보다 1 작은 값을 각각 넣어 수행한 결과를 주어진 문제의 결과로 반환한다.       DFS 방식으로 결과를 탐색할 dfs(char[] expression, int start, int end) 메서드를 완성한다.            결과를 탐색하기 위한 변수를 정의한다.                    result는 결과를 중복 제거된 사전 순서순으로 저장할 변수로, TreeSet으로 초기화한다.           groups는 가능한 문자열들을 순차적으로 저장할 변수로, ArrayList로 초기화한다.           count는 중괄호(‘{}’)의 갯수를 저장할 변수로, 0으로 초기화한다.                       start부터 end 이하까지 j를 증가시키고 i를 0으로 초기화시켜 아래를 반복한다.                    expression[j]의 값이 중괄호의 시작 문자(‘{‘)이면서 count를 증가시킨 값이 1인 경우, i에 $j + 1$을 넣어준다.           expression[j]의 값이 중괄호의 종료 문자(‘}’)이면서 count를 감소시킨 값이 0인 경우, 4번에서 정의한 merge(List&lt;List&gt; groups, List group) 메서드에 groups와 i부터 $j - 1$까지 재귀 호출한 결과를 넣어 수행한다.           count가 0이면서 expression[j]의 값이 ‘,’인 연결 문자열인 경우, groups에 새 조합을 저장하기위해서 ArrayList를 초기화하여 넣어준다.           count가 0이면서 expression[j]의 값이 일반 문자열인 경우, 4번에서 정의한 merge(List&lt;List&gt; groups, List group) 메서드에 groups와 expression[j]의 값을 새 ArrayList에 넣어 수행한다.                       위의 반복이 완료되면 groups의 값을 순차적으로 group에 넣고, group의 값들을 순차적으로 word에 넣어 result에 넣어 ArrayList로 변환한 값을 반환한다.           groups 내 값들을 R(expr) 표현식과 같이 넣어줄 merge(List&lt;List&gt; groups, List group) 메서드를 정의한다.            temp에 groups의 마지막 ArrayList를 넣어준다.       temp가 비어있는 배열인 경우, 마지막 위치에 group을 넣어준다.       위의 경우가 아니라면 마지막 위치에 temp와 group의 값들을 각각 순차적으로 연결하여 신규 ArrayList에 넣어 groups의 마지막 위치에 넣어준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/brace-expansion-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Distribute Candies to People",
        "excerpt":"문제  Link   코드  class Solution {    public int[] distributeCandies(int candies, int num_people) {     int[] result = new int[num_people];     for (int i = 0; candies &gt; 0; i++) {       result[i % num_people] += Math.min(candies, i + 1);       candies -= i + 1;     }     return result;   }  }   결과  Link   설명     num_people의 사람들에게 순차적으로 1개부터 1개씩 증가시키며 candies의 사탕을 줄 때, 사람들 별 받은 사탕의 갯수를 반환하는 문제이다.            마지막 사람까지 사탕을 받으면 다시 첫 사람부터 사탕의 갯수를 계속 증가시키며 제공한다.                result는 결과를 저장할 배열로, num_people 크기의 정수 배열로 초기화한다.       0부터 candies의 갯수가 0 초과일 때 까지 i를 증가시키며 아래를 반복한다.            result의 $\\frac{i}{num_people}$의 나머지 값에 해당하는 위치에 candies와 $i + 1$ 중 작은 값을 넣어준다.       candies에 제공된 $i + 1$개를 차감해준다.           반복이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/distribute-candies-to-people/",
        "teaser": null
      },{
        "title": "Leetcode Java Delete Node in a Linked List",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode(int x) { val = x; }  * }  */ class Solution {    public void deleteNode(ListNode node) {     node.val = node.next.val;     node.next = node.next.next;   }  }   결과  Link   설명          ListNode로 이루어진 노드들 중 주어진 node만 제거하는 문제이다.            node의 현재 값에 다음 노드의 값을 넣고, 다음 노드를 다다음 노드로 연결시켜 현재 노드를 제거해준다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/delete-node-in-a-linked-list/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove Nodes From Linked List",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode removeNodes(ListNode head) {     if (head != null) {       head.next = this.removeNodes(head.next);       if (head.next != null &amp;&amp; head.val &lt; head.next.val) {         return head.next;       }     }     return head;   }  }   결과  Link   설명          각 노드에서 해당 노드의 값보다 작은 좌측 노드를 제거하는 문제이다.       head가 null이 아닌 경우, 아래를 수행한다.            head의 next 노드에 head의 next ListNode를 넣어 재귀 호출한 결과를 넣어준다.       아래 경우 모두 만족하는 경우, head의 next ListNode를 반환한다.                    head의 next 노드가 null이 아닌 마지막 노드가 아닌 값이 비교가 가능한 경우.           head의 val 값이 head의 next ListNode val 값보다 작아 제거되는 경우.                           위 경우들을 만족하지 않는 경우, head를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-nodes-from-linked-list/",
        "teaser": null
      },{
        "title": "Leetcode Java Double a Number Represented as a Linked List",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode doubleIt(ListNode head) {     if (head.val &gt; 4) {       head = new ListNode(0, head);     }     for (ListNode temp = head; temp != null; temp = temp.next) {       temp.val = (temp.val * 2) % 10;       if (temp.next != null &amp;&amp; temp.next.val &gt; 4) {         temp.val++;       }     }     return head;   }  }   결과  Link   설명          head의 값들은 이은 정수 값을 두 배로 증가시킨 값을 지닌 ListNode로 반환하는 문제이다.            head의 val 값이 4보다 커서 2배를 곱한 값이 자릿수가 증가하는 경우, head에 값은 0 next ListNode는 head를 넣어 초기화한 새 ListNode를 넣어준다.       temp에 head를 넣고 temp가 null이 아닐 때 까지 temp에 temp의 다음 ListNode를 넣어가면서 아래를 반복한다.            temp의 val 값에 해당 값의 2배한 결과의 1의 자리수를 넣어준다.       temp의 다음 ListNode가 null이 아니면서 temp의 다음 ListNode의 값이 4보다 큰 경우, temp의 val값을 증가시켜준다.           위의 반복을 통해 2배의 값으로 이루어진 head를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/double-a-number-represented-as-a-linked-list/",
        "teaser": null
      },{
        "title": "Leetcode Java Path In Zigzag Labelled Binary Tree",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; pathInZigZagTree(int label) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     result.addFirst(label);     while (label &gt; 1) {       int depth = (int) (Math.log(label) / Math.log(2));       label = ((int) Math.pow(2, depth) + ((int) Math.pow(2, depth + 1) - 1 - label)) / 2;       result.addFirst(label);     }     return result;   }  }   결과  Link   설명          1부터 크기의 순서가 좌 -&gt; 우, 우 -&gt; 좌로 진행되는 이진 트리 중 root에서 label 값을 순차적인 지그재그 순서로 label이 되는 순차적인 값을 구하는 문제이다.            result는 결과를 저장할 변수로, ArrayList로 초기화하고 첫 값에 label을 넣어준다.       label이 1 초과일 때 까지 아래를 반복한다.            depth는 이진 트리의 깊이를 저장할 변수로, label의 자연 로그 값에 2의 자연 로그값을 나눈 정수 값을 넣어준다.       label에 $2 ^ depth + \\frac{(2 ^ (depth + 1) - 1 + label)}{2}$인 이진 트리의 부모 노드의 값을 넣어준다.                    $(int) Math.pow(2, depth + 1) - 1 - label$의 값은 이진 트리에서 현재 레벨로 끝나는 이진 트리의 노드 수이다.           위의 값을 기반으로 계산한 $2 ^ depth + \\frac{(2 ^ (depth + 1) - 1 + label)}{2}$의 값은 현재 레벨의 노드 수이다.                           위의 반복을 통해 완성된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/path-in-zigzag-labelled-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximize Happiness of Selected Children",
        "excerpt":"문제  Link   코드  class Solution {    public long maximumHappinessSum(int[] happiness, int k) {     Arrays.sort(happiness);     long result = 0;     int length = happiness.length;     for (int i = length - 1, j = 0; i &gt;= length - k; i--) {       result += Math.max(0, happiness[i] - j++);     }     return result;   }  }   결과  Link   설명     각 아이들의 행복 값이 저장된 happiness에서 k개의 아이를 선택하여 발생할 수 있는 최대의 행복 값을 구하는 문제이다.            행복의 정도는 음수가 될 수 없으며, 한 아이를 고를 경우 다른 아이들의 행복 값이 1 감소한다.                happiness를 오름차순 정렬해준다.       문제풀이에 필요한 변수를 정의한다.            result는 결과 값인 행복 값의 합을 저장할 변수로, 0으로 초기화한다.       length는 happiness의 길이를 저장한 변수이다.           $length - 1$부터 i가 $length - k$보다 클 때 까지 i를 감소시키고 j는 0으로 초기화시켜 아래를 반복한다.            result에 0과 $happiness[i] - j$의 값 중 큰 값을 넣고 j를 증가시켜준다.           반복이 완료되면 k명의 행복의 값이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximize-happiness-of-selected-children/",
        "teaser": null
      },{
        "title": "Leetcode Java Filling Bookcase Shelves",
        "excerpt":"문제  Link   코드  class Solution {    public int minHeightShelves(int[][] books, int shelfWidth) {     int length = books.length;     int[] dp = new int[length + 1];     for (int i = 1; i &lt;= length; i++) {       int width = books[i - 1][0];       int height = books[i - 1][1];       dp[i] = dp[i - 1] + height;       for (int j = i - 1; j &gt; 0 &amp;&amp; width + books[j - 1][0] &lt;= shelfWidth; j--) {         height = Math.max(height, books[j - 1][1]);         width += books[j - 1][0];         dp[i] = Math.min(dp[i], dp[j - 1] + height);       }     }     return dp[length];   }  }   결과  Link   설명     books를 이용하여 shelfWidth 너비의 선반에 책을 순서대로 배치할 때, 책장의 가능한 최소 높이를 반환하는 문제이다.            books[i] = [thicknessi, highi]로, 두께와 높이 정보를 담고 있다.           문제 풀이에 필요한 변수를 정의한다.            length는 books의 길이인 책의 갯수를 저장한 변수이다.       dp는 최소 높이를 계산하기 위해 사용할 배열로, $length + 1$크기의 정수 배열로 초기화한다.           1부터 length 이하까지 i를 증가시키며 아래를 반복한다.            width와 height에 books[$i - 1$]의 두께와 높이 값을 넣어준다.       dp[i]에 이전 값인 dp[$i - 1$]의 값에 height를 더해준다.       $i - 1$부터 0 초과일 때 까지 j를 감소시키고 $width + books[j - 1][0]$의 값이 shelfWidth 이하인 선반 너비를 초과하지 않을 때 까지 아래를 반복한다.                    heigh에 현재 책의 높이인 heigh와 books의 $j - 1$번째 책의 높이 중 큰 값을 넣어준다.           width에 books의 $j - 1$번째 책의 두께를 넣어준다.           dp[i]에 현재까지 최소 높이인 dp[i]와 $dp[j - 1] + height$ 값인 $j - 1$번째 책이 있는 선반에 책을 같이 배치할 경우에 대한 높이 중 작은 값을 넣어준다.                           반복이 완료되면 최소 높이가 저장된 dp[length]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/filling-bookcase-shelves/",
        "teaser": null
      },{
        "title": "Leetcode Java Largest Local Values in a Matrix",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] largestLocal(int[][] grid) {     int[][] result = new int[grid.length - 2][grid.length - 2];     for (int i = 0; i &lt; result.length; i++) {       for (int j = 0; j &lt; result.length; j++) {         int max = 0;         for (int k = i; k &lt; i + 3; k++) {           for (int l = j; l &lt; j + 3; l++) {             max = Math.max(max, grid[k][l]);           }         }         result[i][j] = max;       }     }     return result;   }  }   결과  Link   설명          grid에서 $3 \\times 3$ 범위 내 가장 큰 값으로 이루어진 새 배열을 만들어 반환하는 문제이다.            result는 결과를 저장할 변수로, grid보다 가로와 세로가 2 작은 크기의 2차원 배열로 초기화한다.       0부터 result의 길이 이전까지 i와 j를 증가시키며 아래를 반복한다.            max는 최댓값을 저장할 변수로, 0으로 초기화한다.       k는 i부터 $i + 3$까지, l은 j부터 $j + 3$까지 k와 l을 증가시키며 아래를 반복하여 max에 $3 \\times 3$ 범위 내 가장 큰 값을 넣어준다.       result[i][j]에 max를 넣어준다.           반복이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/largest-local-values-in-a-matrix/",
        "teaser": null
      },{
        "title": "Leetcode Java Parsing A Boolean Expression",
        "excerpt":"문제  Link   코드  class Solution {    public boolean parseBoolExpr(String expression) {     Stack&lt;Character&gt; stack = new Stack&lt;&gt;();     for (char c : expression.toCharArray()) {       if (c == ')') {         Set&lt;Character&gt; seen = new HashSet&lt;&gt;();         while (stack.peek() != '(') {           seen.add(stack.pop());         }         stack.pop();         switch (stack.pop()) {           case '&amp;': stack.push(seen.contains('f') ? 'f' : 't'); break;           case '|': stack.push(seen.contains('t') ? 't' : 'f'); break;           default: stack.push(seen.contains('t') ? 'f' : 't'); break;         }       } else if (c != ',') {         stack.push(c);       }     }     return stack.pop() == 't';   }  }   결과  Link   설명     아래의 조건을 만족하는 부울 표현법인 expression이 유효한지를 검증하는 문제이다.            ‘t’는 true, ‘f’는 false를 의미한다.       ’!(subExpr)’는 부분 표현법인 subExpr의 논리적 NOT 연산을 의미한다.       ‘&amp;(subExpr1, subExpr2, …, subExprn)’은 각 부분 표현법인 subExpr1, subExpr2, …, subExprn의 논리적 AND 연산을 의미한다.                                                       ’               (subExpr1, subExpr2, …, subExprn)’은 각 부분 표현법인 subExpr1, subExpr2, …, subExprn의 논리적 OR 연산을 의미한다.                                                        stack은 각 표현식의 값을 순차적으로 넣었다 빼기 위한 변수로, Stack으로 초기화한다.       expression의 각 문자를 순차적으로 c에 넣어 아래를 수행한다.            c가 ‘)’ 문자인 경우, 아래를 수행한다.                    seen은 탐색한 문자들을 저장할 변수로, 중복을 제거하기 위해 HashSet으로 초기화하고 stack 내 다음 문자가 ‘(‘ 문자가 아닐 때 까지 seen에 stack의 값을 꺼내 넣어준다.           stack의 다음 문자인 ‘(‘ 문자를 꺼내 제거해준다.           stack의 다음 문자가 ‘&amp;’이면 stack에 seen 내 ‘f’ 문자가 존재할 경우 논리적 AND 연산의 결과는 false이므로, ‘f’를 아니면 ‘t’를 넣어준다.                                                                           stack의 다음 문자가 위의 경우가 아니라 ‘                   ‘이면 stack에 seen 내 ‘t’ 문자가 존재할 경우 논리적 OR 연산의 결과는 true이므로, ‘t’를 아니면 ‘f’를 넣어준다.                                                                   stack의 다음 문자가 위의 두 경우가 아니라면 stack에 seen 내 ‘t’ 문자가 존재할 경우 반대의 값으로, ‘f’를 아니면 ‘t’를 넣어준다.                       c가 위의 경우가 아니면서 ‘,’ 문자가 아닌 경우, stack에 c를 넣어준다.           stack 내 값을 꺼낸 문자가 ‘t’인지를 검증한 결과를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/parsing-a-boolean-expression/",
        "teaser": null
      },{
        "title": "Leetcode Java Path with Maximum Gold",
        "excerpt":"문제  Link   코드  class Solution {    public int getMaximumGold(int[][] grid) {     int row = grid.length;     int col = grid[0].length;     int result = 0;     for (int i = 0; i &lt; row; i++) {       for (int j = 0; j &lt; col; j++) {         result = Math.max(result, this.getMaximumGold(grid, row, col, i, j, 0));       }     }     return result;   }    private int getMaximumGold(int[][] grid, int row, int col, int i, int j, int sum) {     if (grid[i][j] == 0) {       return sum;     } else {       int max = 0;       int curr = grid[i][j];       grid[i][j] = 0;       if (i &gt; 0) {         max = Math.max(max, this.getMaximumGold(grid, row, col, i - 1, j, sum));       }       if (i &lt; row - 1) {         max = Math.max(max, this.getMaximumGold(grid, row, col, i + 1, j, sum));       }       if (j &gt; 0) {         max = Math.max(max, this.getMaximumGold(grid, row, col, i, j - 1, sum));       }       if (j &lt; col - 1) {         max = Math.max(max, this.getMaximumGold(grid, row, col, i, j + 1, sum));       }       grid[i][j] = curr;       max += curr;       return max;     }   }  }   결과  Link   설명     grid 내 아래 규칙에 따라 가장 많이 모을 수 있는 금의 갯수를 계산하는 문제이다.            grid 내 셀의 값은 금의 갯수를 나타내며, 0인 경우 감옥을 의미한다.       현재 셀의 위치에서 상하좌우 네 방향 중 금이 존재하는 셀으로이동이 가능하며, 동일한 셀을 두 번 이상 방문할 수 없다.       금이 존재하는 임의 위치에서 금 수집을 중단할 수 있다.           문제 풀이에 필요한 변수를 정의한다.            row와 col은 grid의 행과 열의 수를 저장한 변수이다.       result는 최대 금의 갯수를 저장할 변수로, 0으로 초기화한다.                0부터 row 미만까지 i를 증가시키며, 0부터 col 미만까지 j를 증가시키며 result에 result와 4번에서 정의한 getMaximumGold(int[][] grid, int row, int col, int i, int j, int sum) 메서드를 sum에 0을 넣어 수행한 결과를 넣어준다.       상하좌우 네 방향을 재귀 호출을 통해 탐색하기 위한 getMaximumGold(int[][] grid, int row, int col, int i, int j, int sum) 메서드를 정의한다.            grid[i][j]의 값이 0인 감옥인 경우, 현재까지 합산된 sum을 반환한다.       위의 경우가 아닌 금이 존재하는 셀이라면 아래를 수행한다.                    max에 0을, curr에 grid[i][j]의 값인 현재 위치의 금의 갯수를 넣어준다.           grid[i][j]의 위치에 0을 넣어 현재 위치로 다시 돌아올 수 없도록 한다.           max에 max와 현재 위치에서 이동 가능한 상하좌우 네 방향으로 재귀 호출을 수행한 결과 중 가장 큰 값을 넣어준다.           grid[i][j]의 위치에 다시 curr을 넣어 값을 복원해준다.           max에 curr을 더해준 후 max를 반환해준다.                           3번의 반복이 완료되면 저장된 최대 금의 갯수인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/path-with-maximum-gold/",
        "teaser": null
      },{
        "title": "Leetcode Java Evaluate Boolean Binary Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public boolean evaluateTree(TreeNode root) {     if (root.left == null &amp;&amp; root.right == null) {       return root.val == 1;     } else {       boolean left = this.evaluateTree(root.left);       boolean right = this.evaluateTree(root.right);       return root.val == 2 ? left || right : left &amp;&amp; right;     }   }  }   결과  Link   설명     아래의 규칙에 해당하는 값이 들어가있는 TreeNode인 root를 이용하여 최종 결과를 계산하여 반환하는 문제이다.            자식 노드가 없는 리프 노드는 0인 False와 1인 True의 값을 가진다.       자식 노드가 존재하는 노드는 2인 OR 논리 연산식과 3인 AND 논리 연산식을 가지며, 자식 노드의 연산 결과를 값으로 가진다.                root의 자식 노드가 없는 경우, root가 1인 true인지 검증한 결과를 반환한다.       root의 자식 노드가 있는 경우, 아래를 수행한다.            left와 right에 root의 left와 right TreeNode를 이용하여 각각 재귀 호출한 결과를 넣어준다.                                                       root의 val 값이 2인 OR 연산인 경우, left                               right의 OR 연산 결과를 아니면 left &amp;&amp; right의 AND 연산 결과를 반환한다.                                                   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/evaluate-boolean-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Delete Leaves With a Given Value",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public TreeNode removeLeafNodes(TreeNode root, int target) {     if (root.left != null) {       root.left = this.removeLeafNodes(root.left, target);     }     if (root.right != null) {       root.right = this.removeLeafNodes(root.right, target);     }     return root.left == root.right &amp;&amp; root.val == target ? null : root;   }  }   결과  Link   설명          root 내 target이 val로 가진 리프 노드를 삭제하는 문제이다.            root의 left TreeNode가 존재하는 경우, root의 left TreeNode로 재귀 호출을 수행한 결과를 해당 자리에 넣어준다.            root의 right TreeNode가 존재하는 경우 위와 동일하게, root의 right TreeNode로 재귀 호출을 수행한 결과를 해당 자리에 넣어준다.            root의 left와 right TreeNode가 동일하게 null이면서 root의 val 값이 target인 경우 null을, 아니면 root를 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/delete-leaves-with-a-given-value/",
        "teaser": null
      },{
        "title": "Leetcode Java Defanging an IP Address",
        "excerpt":"문제  Link   코드  class Solution {    public String defangIPaddr(String address) {     StringBuilder sb = new StringBuilder();     for (char c : address.toCharArray()) {       sb.append(c == '.' ? \"[.]\" : c);     }     return sb.toString();   }  }   결과  Link   설명          IPv4 프로토콜을 만족하는 address 내 마침표(“.”)를 “[.]” 문자열로 변환하는 문제이다.            sb는 동적으로 조건에 만족하는 문자열을 만들 변수로, address의 모든 문자들을 순차적으로 반복하여 마침표 문자의 경우만 “[.]” 문자열로 바꿔 문자열로 변환 후 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/defanging-an-ip-address/",
        "teaser": null
      },{
        "title": "Leetcode Java Find the Maximum Sum of Node Values",
        "excerpt":"문제  Link   코드  class Solution {    public long maximumValueSum(int[] nums, int k, int[][] edges) {     long result = 0;     int count = 0;     int min = Integer.MAX_VALUE;     int max = Integer.MIN_VALUE;     for (int num : nums) {       result += num;       int value = (num ^ k) - num;       if (value &gt; 0) {         min = Math.min(min, value);         result += value;         count++;       } else {         max = Math.max(max, value);       }     }     if (count % 2 == 0) {       return result;     } else {       return Math.max(result - min, result + max);     }   }  }   결과  Link   설명          각 점수가 담긴 nums를 이용하여 0번 혹은 모든 edges 내 각 지점에 k를 XOR 비트 연산을 수행한 nums의 합이 최대가 되는 값을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 결과를 저장할 변수로, 0으로 초기화한다.       count는 nums의 각 값에 k를 XOR 비트 연산을 수행한 값이 기존 값보다 큰 갯수를 저장할 변수로, 0으로 초기화한다.       min과 max는 nums의 각 값에 k를 XOR 비트 연산을 수행한 값을 기존값과 뺀 결과의 경우에 따른 최솟값 최댓값을 저장할 변수로, 정수의 최댓값과 최솟값으로 초기화한다.           nums의 각 값을 num에 순차적으로 넣어 아래를 수행한다.            result에 num을 더해준다.       value에 num에 k를 XOR 비트 연산을 수행한 값에 num을 빼준다.       value가 0 초과인 경우, 아래를 수행한다.                    min에 min과 value 중 작은 값을 넣어준다.           result에 value를 더해 결과 값을 증가시켜준 후, 기존 값보다 큰 갯수를 저장한 count를 증가시킨다.                       value가 0 이하인 경우, max에 max와 value 중 큰 값을 저장한다.           반복이 완료되면 count가 짝수인지 홀수인지 검증하여 결과를 반환한다.            count가 짝수인 경우 result가 항상 최대가 되므로, result를 주어진 문제의 결과로 반환한다.       count가 홀수인 경우 최솟값을 빼거나 최댓값을 더한 경우가 최대가 되므로, $result - min$과 $result + max$ 중 큰 값을 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-the-maximum-sum-of-node-values/",
        "teaser": null
      },{
        "title": "Leetcode Java Sum of All Subset XOR Totals",
        "excerpt":"문제  Link   코드  class Solution {    public int subsetXORSum(int[] nums) {     return this.dfs(nums, 0, 0);   }    private int dfs(int[] nums, int index, int curr) {     if (index == nums.length) {       return curr;     } else {       return this.dfs(nums, index + 1, curr ^ nums[index]) + this.dfs(nums, index + 1, curr);     }   }  }   결과  Link   설명          nums내 값들을 이용한 부분 배열들의 값들을 XOR 비트 연산한 값을 더한 결과를 반환하는 문제이다.            3번에서 정의한 dfs(int[] nums, int index, int curr) 메서드의 index와 curr에 0을 넣고 수행한 결과를 주어진 문제의 결과로 반환한다.            DFS 방식으로 합계하기 위한 dfs(int[] nums, int index, int curr) 메서드를 정의한다.             index와 length가 동일한 마지막 위치의 값인 경우, curr을 반환한다.       위의 경우가 아니라면 아래의 두 값의 합을 반환한다.                    index에 $index + 1$과 curr에 curr과 nums[index]의 XOR 비트 연산을 수행한 값을 넣어 재귀 호출을 수행한 결과.           index에 $index + 1$을 넣어 재귀 호출을 수행한 결과.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sum-of-all-subset-xor-totals/",
        "teaser": null
      },{
        "title": "Leetcode Java Corporate Flight Bookings",
        "excerpt":"문제  Link   코드  class Solution {    public int[] corpFlightBookings(int[][] bookings, int n) {     int[] result = new int[n];     for (int[] booking : bookings) {       result[booking[0] - 1] += booking[2];       if (booking[1] &lt; n) {         result[booking[1]] -= booking[2];       }     }     for (int i = 1; i &lt; n; i++) {       result[i] += result[i - 1];     }     return result;   }  }   결과  Link   설명     아래의 규칙을 만족하는 n개의 노선이 저장된 bookings를 이용하여 n개 노선의 각 좌석의 합계를 구하는 문제이다.            bookings[i] = [firsti, lasti, seatsi]로, i번째 항공편은 first 부터 last까지 노선의 좌석이 seats개임을 의미한다.                result는 각 노선 별 좌석의 수를 계산할 변수로, n 크기의 정수 배열로 초기화한다.       bookings의 각 배열 값을 순차적으로 booking에 넣어 아래를 수행한다.            result의 $booking[0] - 1$번째 위치인 시작 노선에 booking[2]인 좌석 수를 더해준다.       booking[1]이 n 미만인 경우, result의 booking[1]번째 값에 booking[2]인 좌석 수를 감소시켜준다.           result의 시작부터 끝까지 다음 위치에 현재 값을 누계하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/corporate-flight-bookings/",
        "teaser": null
      },{
        "title": "Leetcode Java Delete Nodes And Return Forest",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;TreeNode&gt; delNodes(TreeNode root, int[] to_delete) {     Set&lt;Integer&gt; set = new HashSet&lt;&gt;();     for (int value : to_delete) {       set.add(value);     }     List&lt;TreeNode&gt; list = new ArrayList&lt;&gt;();     if (!set.contains(root.val)) {       list.add(root);     }     this.dfs(root, set, list);     return list;   }    private TreeNode dfs(TreeNode node, Set&lt;Integer&gt; set, List&lt;TreeNode&gt; list) {     if (node == null) {       return null;     }     node.left = this.dfs(node.left, set, list);     node.right = this.dfs(node.right, set, list);     if (set.contains(node.val)) {       if (node.left != null) {         list.add(node.left);       }       if (node.right != null) {         list.add(node.right);       }       return null;     }     return node;   }  }   결과  Link   설명     root에서 to_delete에 해당하는 값을 가진 노드를 제거하는 문제이다.            제거된 노드의 자식 노드는 새 노드로 구분하여 반환한다.           문제 풀이에 필요한 변수를 정의한다.            set은 제거할 값을 저장할 변수로, to_delete의 값을 넣어준다.       list는 제거된 노드를 제외한 노드들을 저장할 변수로, ArrayList로 초기화하여 set에 root의 val 값이 존재하지 않으면 list에 root를 먼저 넣어준다.                4번의 dfs(TreeNode node, Set set, List list) 메서드를 수행한다.       DFS 방식으로 노드를 확인하여 제거할 dfs(TreeNode node, Set set, List list) 메서드를 정의한다.            node가 null인 경우, 더 이상 진행이 불가능하므로 null을 반환한다.       node의 left와 right TreeNode를 순차적으로 각각 자신을 이용하여 재귀 호출 수행한 결과를 각 노드의 위치에 넣어준다.       set에 node의 val 값이 존재하여 해당 노드가 제거되는 경우, node의 left와 right TreeNode가 null이 아니면 list에 각각 넣어주고 null을 반환한다.       수행이 완료된 node를 반환한다.           반복이 완료되면 제거할 값의 노드들을 제거한 TreeNode들이 저장된 list를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/delete-nodes-and-return-forest/",
        "teaser": null
      },{
        "title": "Leetcode Java The Number of Beautiful Subsets",
        "excerpt":"문제  Link   코드  class Solution {    public int beautifulSubsets(int[] nums, int k) {     Arrays.sort(nums);     return this.dfs(nums, k, new int[1001], 0, 0);   }    private int dfs(int[] nums, int k, int[] counts, int i, int count) {     for (int j = i; j &lt; nums.length; j++) {       if (nums[j] &lt;= k || counts[nums[j] - k] == 0) {         counts[nums[j]]++;         count = this.dfs(nums, k, counts, j + 1, count + 1);         counts[nums[j]]--;       }     }     return count;   }  }   결과  Link   설명          nums를 이용한 부분 배열 내 값들 중 값의 차이가 k가 되지 않는 부분 배열의 갯수를 구하는 문제이다.            num의 값들을 오름차순으로 정렬한 후 3번에서 정의한 dfs(int[] nums, int k, int[] counts, int i, int count) 메서드를 counts에 값의 최대 크기보다 1 큰 1001을, i와 count에 0을 넣어 수행한 결과를 주어진 문제의 결과로 반환한다.            DFS 방식으로 부분 배열의 갯수를 계산할 dfs(int[] nums, int k, int[] counts, int i, int count) 메서드를 정의한다.             i부터 nums의 길이 미만까지 j를 증가시키며 아래를 반복한다.                    nums[j]의 값이 k보다 작은 비교가 불가능하거나, $counts[nums[j] - k]$인 nums[j]의 값보다 k 작은 값의 갯수가 0이면 다음을 수행한다.           counts[nums[j]]의 값을 증가시켜 부분 배열의 갯수를 증가시켜준다.           count에 i 자리에 $j + 1$을, count 자리에 $count + 1$을 넣어 재귀 호출한 결과를 넣어준다.           counts[nums[j]]의 값을 감소시켜, 위에서 계산한 경우에 대해서 원복해준다.                       반복이 완료되면 계산된 부분 배열의 수인 count를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/the-number-of-beautiful-subsets/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Nesting Depth of Two Valid Parentheses Strings",
        "excerpt":"문제  Link   코드  class Solution {    public int[] maxDepthAfterSplit(String seq) {     int length = seq.length();     int[] result = new int[length];     for (int i = 0, count = 0; i &lt; length; i++) {       if (seq.charAt(i) == '(') {         result[i] = ++count % 2;       } else {         result[i] = count-- % 2;       }     }     return result;   }  }   결과  Link   설명     소괄호로 구성된 seq를 이용하여 아래의 규칙을 따른 결과를 반환하는 문제이다.            유효한 괄호 문자열은 빈 문자열이거나, A와 B가 연결된 AB, (A)로 구성된 문자열이다.       길이인 depth(S)는 아래의 규칙을 따른다.                    depth(“”) = 0           depth(A + B) = max(depth(A), depth(B))           depth(“(“ + A + “)”)  = 1 + depth(A)                       seq를 VPS를 만족하는 A와 B 두 문자열로 구성하여 max(depth(A), depth(B))의 값이 최소가 되도록 한 문자열을 선택한다.                    seq의 길이와 A와 B 문자열의 길이는 동일하다.                       결과의 i번째 값은 seq의 i번째 문자가 A에 포함되어 있으면 0을, 아니면 1을 넣어준다.           문제 풀이에 필요한 변수를 정의한다.            length는 seq의 길이를 저장한 변수이다.       result는 결과 값을 저장할 변수로, length 길이의 정수 배열로 초기화한다.           0부터 length 미만까지 i를 증가시키고, ‘(‘의 갯수를 계산할 count는 0으로 초기화하여 아래를 반복한다.            seq의 i번째 문자가 ‘(‘ 문자인 경우, result[i]에 count를 증가시키고 해당 값을 2로 나눈 나머지 값을 넣어준다.       seq의 i번째 문자가 ‘)’ 문자인 경우, result[i]에 count를 2로 나눈 나머지 값을 넣고 count를 감소시킨다.           반복이 완료되면 result를 주어진 문제의 결과로 반환한다.   해설     max(depth(A), depth(B))의 값이 최소가되기 위해서 depth를 각각 나눠줘야 한다.   depth를 분리하기 위해서 홀수 괄호는 A에, 짝수 괄호는 B에 구성한다.   위로 구성된 결과에 따라서 count가 홀수이면 A에 포함되었다고 판단할 수 있다.            A를 짝수, B를 홀수로 구성하게 되면 count 또한 짝수이면 A에 포함된다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-nesting-depth-of-two-valid-parentheses-strings/",
        "teaser": null
      },{
        "title": "Leetcode Java Print in Order",
        "excerpt":"문제  Link   코드  class Foo {    private Semaphore semaphore;    public Foo() {     this.semaphore = new Semaphore(0);   }    public void first(Runnable printFirst) throws InterruptedException {     // printFirst.run() outputs \"first\". Do not change or remove this line.     printFirst.run();     this.semaphore.release();   }    public void second(Runnable printSecond) throws InterruptedException {     while (!this.semaphore.tryAcquire(1));     // printSecond.run() outputs \"second\". Do not change or remove this line.     printSecond.run();     this.semaphore.release(2);   }    public void third(Runnable printThird) throws InterruptedException {     while (!this.semaphore.tryAcquire(2));     // printThird.run() outputs \"third\". Do not change or remove this line.     printThird.run();   }  }   결과  Link   설명     어떠한 순서의 호출이어도 first, second, third를 순차적으로 출력하는 Foo 클래스를 완성하는 문제이다.            생성자인 Foo()는 객체를 초기화한다.       메서드인 first(Runnable printFirst), second(Runnable printSecond), third(Runnable printThird)는 각 호출에 대해 Runnable로 구현된 파라미터를 수행한다.                전역 변수인 semaphore는 각 호출에 대한 잠금과 해제를 수행하기 위한 변수이다.       생성자인 Foo()를 정의한다.            semaphore에 신규 Semaphore 객체를 공유 자원을 0으로 생성하여 넣어준다.           메서드인 first(Runnable printFirst)를 정의한다.            printFirst을 수행하고 semaphore를 release하여 잠금 해제를 수행한다.           메서드인 second(Runnable printSecond)를 정의한다.            semaphore에 first 메서드가 release 될 때 까지 기다려 다음 수행을 대기한다.       printSecond을 수행하고 semaphore에 permits를 2로 release하여 잠금 해제를 수행한다.           메서드인 third(Runnable printThird)를 정의한다.            semaphore에 second 메서드가 release 될 때 까지 기다려 다음 수행을 대기한다.       printThird를 수행한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/print-in-order/",
        "teaser": null
      },{
        "title": "Leetcode Java Special Array With X Elements Greater Than or Equal X",
        "excerpt":"문제  Link   코드  class Solution {    public int specialArray(int[] nums) {     int length = nums.length;     int[] counts = new int[length + 1];     for (int num : nums) {       if (num &gt;= length) {         counts[length]++;       } else {         counts[num]++;       }     }     int result = 0;     for (int i = length; i &gt; 0; i--) {       result += counts[i];       if (result == i) {         return i;       }     }     return -1;   }  }   결과  Link   설명     nums의 값들보다 크거나 같은 숫자들이 x개 존재하는 숫자 x를 찾는 문제이다.            단, x가 존재하지 않으면 -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       counts는 nums의 숫자 갯수를 저장할 변수로, nums의 num에 순차적으로 값을 넣어 num이 length 보다 크거나 같으면 counts[length]를 아니면 마지막 값인 counts[num]을 증가시켜준다.       result는 x를 찾기위한 변수로 변수로, 0으로 초기화한다.           length부터 0 초과일 때 까지 i를 감소시키며 아래를 반복한다.            result에 counts[i]의 값을 더해주고, result와 i가 동일한 x가 성립되면 해당 값을 반환한다.           반복이 완료되면 x가 존재하지 않으므로, -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/special-array-with-x-elements-greater-than-or-equal-x/",
        "teaser": null
      },{
        "title": "Leetcode Java Get Equal Substrings Within Budget",
        "excerpt":"문제  Link   코드  class Solution {    public int equalSubstring(String s, String t, int maxCost) {     char[] sCharArray = s.toCharArray();     char[] tCharArray = t.toCharArray();     int i = 0;     int j = 0;     while (j &lt; s.length()) {       maxCost -= Math.abs(sCharArray[j] - tCharArray[j++]);       if (maxCost &lt; 0) {         maxCost += Math.abs(sCharArray[i] - tCharArray[i++]);       }     }     return j - i;   }  }   결과  Link   설명          동일한 길이의 문자열 s와 t를 이용하여 maxCost 이하의 비용으로 t의 부분 문자열의 문자를 변경하여 s의 부분 문자열이 동일하게 만들 경우, 가능한 최대 길이의 부분 문자열의 길이를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            sCharArray와 tCharArray는 s와 t를 문자 배열로 변환한 변수이다.       i와 j는 문자열의 시작 위치와 종료 위치를 저장할 변수로, 둘 다 0으로 초기화한다.           j가 s의 길이 미만일 때 까지 아래를 반복한다.            maxCoust에 $sCharArray[j] - tCharArray[j]$의 절댓값을 빼주고 j를 증가시킨다.       maxCoust가 0보다 낮은 경우 시작 위치를 증가시키기 위해서, maxCoust에 $sCharArray[i] - tCharArray[i]$의 절댓값을 더해주고 i를 증가시킨다.           반복이 완료되면 문자열의 길이인 $j - i$를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/get-equal-substrings-within-budget/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Steps to Reduce a Number in Binary Representation to One",
        "excerpt":"문제  Link   코드  class Solution {    public int numSteps(String s) {     int result = 0;     int carry = 0;     for (int i = s.length() - 1; i &gt; 0; i--) {       result++;       if (s.charAt(i) - '0' + carry == 1) {         carry = 1;         result++;       }     }     return result + carry;   }  }   결과  Link   설명     이진법 문자열 s를 이용하여 아래 규칙에 따라 1로 감소시키기 위한 횟수를 구하는 문제이다.            현재 숫자가 짝수이면 2로 나눈다.       현재 숫자가 홀수이면 1을 더한다.           문제 풀이에 필요한 변수를 정의한다.            result는 횟수를 저장할 변수로, 0으로 초기화한다.       carry는 증가하는 값을 저장할 변수로, 0으로 초기화한다.           s의 길이보다 1 작은 값부터 0 초과일 때까지 i를 감소시키며 아래를 반복한다.            값이 짝수/홀수인지 여부를 제외하고 한 번을 수행하므로 result를 증가시킨다.       s의 i번째 문자를 숫자로 변환한 값과 carry를 더한 값이 1인 홀수인 경우 두 번 수행하므로, carry에 1을 넣어주고 result를 증가시킨다.                    홀수인 경우, 1을 증가시키고 짝수를 만들어 2를 나누므로 2번 수행한다.                           반복이 완료되면 마지막 이전까지 계산된 수행 횟수인 result와 carry가 1인 경우 다시 2로 나누어야 하므로 carry를 더한 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Triplets That Can Form Two Arrays of Equal XOR",
        "excerpt":"문제  Link   코드  class Solution {    public int countTriplets(int[] arr) {     int result = 0;     int length = arr.length;     for (int i = 0; i &lt; length; i++) {       int temp = arr[i];       for (int j = i + 1; j &lt; length; j++) {         temp ^= arr[j];         if (temp == 0) {           result += (j - i);         }       }     }     return result;   }  }   결과  Link   설명     정수 배열인 arr을 이용하여 아래의 조건을 만족하는 삼중항(i, j, k)의 수를 반환하는 문제이다.            $0 &lt;= i &lt; j &lt;= k &lt; arr.length$를 만족한다.       a와 b를 아래와 같이 정의한다.                    $a = arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1]$           $b = arr[j] ^ arr[j + 1] ^ … ^ arr[k]$           a == b 를 만족하며, “^” 문자는 XOR 비트 연산을 의미한다.                           문제 풀이에 필요한 변수를 정의한다.            result는 삼중항의 갯수를 저장할 변수로, 0으로 초기화한다.       length는 arr의 길이를 저장한 변수이다.           0부터 length 미만까지 i를 증가시키며 아래를 반복한다.            temp에 arr[i]의 값을 넣고, $i + 1$부터 length 미만까지 j를 증가시키면서 아래를 반복한다.                    temp에 temp와 arr[j]의 값을 XOR 비트 연산을 수행한 값을 넣어준다.           temp가 0인 경우, result에 $j - i$를 더해준다.                           반복이 완료되면 삼중항의 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   해설     1번 설명을 기반으로 a와 b가 동일한 값일 때, 아래를 만족한다.            $a = b$ 의 양 변에 b를 XOR 비트 연산을 수행한다.       $a ^ b = b ^ b$ 이므로, 우변은 0이 되어 $a ^ b = 0$를 만족한다.       마지막으로, $a ^ b = arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1] ^ arr[j] ^ arr[j + 1] ^ … ^ arr[k] = 0$을 만족한다.           위를 기반으로 두 값인 i와 k에 대해서 XOR 비트 연산이 0이 되는 경우, j를 $i + 1$부터 k까지 임의 위치시키는 경우의 수인 $j - 1$개의 경우의 수가 삼중항의 갯수가 된다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-triplets-that-can-form-two-arrays-of-equal-xor/",
        "teaser": null
      },{
        "title": "Leetcode Java Score of a String",
        "excerpt":"문제  Link   코드  class Solution {    public int scoreOfString(String s) {     int result = 0;     for (int i = 0; i &lt; s.length() - 1; i++) {       result += Math.abs(s.charAt(i) - s.charAt(i + 1));     }     return result;   }  }   결과  Link   설명          문자열 s의 각 문자 별 아스키 코드 값의 차이를 계산하는 문제이다.            result는 결과를 저장할 변수로, 0으로 초기화한다.            0부터 s의 길이보다 1 작은 값까지 i를 증가시키며, s의 i번째 문자와 $i + 1$번째 문자의 아스키 코드 값의 차이에 대한 절댓값을 result에 더해준다.            아스키 코드의 차잇값이 저장된 result를 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/score-of-a-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Append Characters to String to Make Subsequence",
        "excerpt":"문제  Link   코드  class Solution {    public int appendCharacters(String s, String t) {     int j = 0;     int sLength = s.length();     int tLength = t.length();     char[] sCharArray = s.toCharArray();     char[] tCharArray = t.toCharArray();     for (int i = 0; i &lt; sLength &amp;&amp; j &lt; tLength; i++) {       if (sCharArray[i] == tCharArray[j]) {         j++;       }     }     return tLength - j;   }  }   결과  Link   설명          문자열 t를 s에 포함된 부분 문자열을 제외하고 남은 문자열의 길이을 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            j는 문자열 t의 위치를 저장할 변수로, 0으로 초기화한다.       sLength와 tLength는 s와 t의 길이를 저장한 변수이다.       sCharArray와 tCharArray는 s와 t를 문자 배열로 변환한 변수이다.           0부터 sLength 미만까지 i를 증가시키고, j가 tLength 미만일 때 까지 아래를 반복한다.            sCharArray[i]의 문자가 tCharArray[j]의 문자와 동일한 경우, j를 증가시켜준다.           반복이 완료되면 s에 순차적으로 포함된 t의 문자들을 제외한 길이인 $tLength - j$를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/append-characters-to-string-to-make-subsequence/",
        "teaser": null
      },{
        "title": "Leetcode Java Print FooBar Alternately",
        "excerpt":"문제  Link   코드  class FooBar {    private int n;   private Semaphore fooSemaphore;   private Semaphore barSemaphore;    public FooBar(int n) {     this.n = n;     this.fooSemaphore = new Semaphore(1);     this.barSemaphore = new Semaphore(0);   }    public void foo(Runnable printFoo) throws InterruptedException {     for (int i = 0; i &lt; this.n; i++) {       this.fooSemaphore.acquire();       // printFoo.run() outputs \"foo\". Do not change or remove this line.       printFoo.run();       this.barSemaphore.release();     }   }    public void bar(Runnable printBar) throws InterruptedException {     for (int i = 0; i &lt; this.n; i++) {       this.barSemaphore.acquire();       // printBar.run() outputs \"bar\". Do not change or remove this line.       printBar.run();       this.fooSemaphore.release();     }   }  }   결과  Link   설명          두 쓰레드 A와 B가 각자 “foo”를 출력하는 foo()와 “bar”를 출력하는 bar()를 수행할 때, “foobar”가 n번 출력되는 FooBar 클래스를 완성하는 문제이다.       출력에 필요한 전역 변수를 정의한다.            n은 출력하는 횟수를 저장할 변수이다.       fooSemaphore와 barSemaphore는 foo와 bar의 순차적인 출력을 위한 변수이다.           생성자인 FooBar(int n)를 정의한다.            전역 변수인 n에 주어진 n을 넣어준다.       전역 변수인 fooSemaphore와 barSemaphore에 “foo” 출력 이후 “bar”를 순차적으로 출력하기 위해서, fooSemaphore의 permits를 1, barSemaphore를 0인 Semaphore 객체로 초기화한다.           메서드인 foo(Runnable printFoo)를 정의한다.            0부터 n까지 i를 증가시키며, 아래를 수행한다.                    fooSemaphore를 잠금하여, 해당 순서 다음 “foo” 출력을 차단한다.           printFoo를 수행 후 barSemaphore를 잠금 해제하여 다음 순서에 “bar”를 출력할 수 있게 한다.                           메서드인 bar(Runnable printBar)를 정의한다.            0부터 n까지 i를 증가시키며, 아래를 수행한다.                    barSemaphore를 잠금하여, 해당 순서 다음 “bar” 출력을 차단한다.           printBar를 수행 후 fooSemaphore를 잠금 해제하여 다음 순서에 “foo”를 출력할 수 있게 한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/print-foobar-alternately/",
        "teaser": null
      },{
        "title": "Leetcode Java Print Zero Even Odd",
        "excerpt":"문제  Link   코드  class ZeroEvenOdd {    private int n;   private Semaphore zeroSemaphore;   private Semaphore evenSemaphore;   private Semaphore oddSemaphore;    public ZeroEvenOdd(int n) {     this.n = n;     this.zeroSemaphore = new Semaphore(1);     this.evenSemaphore = new Semaphore(0);     this.oddSemaphore = new Semaphore(0);   }    // printNumber.accept(x) outputs \"x\", where x is an integer.   public void zero(IntConsumer printNumber) throws InterruptedException {     for (int i = 1; i &lt;= this.n; i++) {       this.zeroSemaphore.acquire();       printNumber.accept(0);       if (i % 2 == 0) {         this.evenSemaphore.release();       } else {         this.oddSemaphore.release();       }     }   }    public void even(IntConsumer printNumber) throws InterruptedException {     for (int i = 2; i &lt;= this.n; i += 2) {       this.evenSemaphore.acquire();       printNumber.accept(i);       this.zeroSemaphore.release();     }   }    public void odd(IntConsumer printNumber) throws InterruptedException {     for (int i = 1; i &lt;= this.n; i += 2) {       this.oddSemaphore.acquire();       printNumber.accept(i);       this.zeroSemaphore.release();     }   }  }   결과  Link   설명          세 개의 쓰레드가 각각 0을 출력하는 zero, 홀수를 출력하는 odd, 짝수를 출력하는 even 메서드를 비동기로 호출할 때, n까지 0 출력 이후 홀수와 짝수를 순차적으로 출력하는 문제이다.       문제 풀이에 필요한 전역 변수를 정의한다.            n은 출력되는 최대값을 저장할 변수이다.       zeroSemaphore, evenSemaphore, oddSemaphore은 순차적으로 0과 짝수, 홀수를 출력하기 위한 순서를 제어하기 위한 변수이다.           생성자인 ZeroEvenOdd(int n)를 정의한다.            n을 전역 변수 n에 넣어준다.       zeroSemaphore는 permits를 1로, evenSemaphore와 oddSemaphore는 0인 Semaphore 객체로 초기화한다.           메서드인 zero(IntConsumer printNumber)를 정의한다.            10부터 n 이하까지 i를 증가시키며 아래를 반복한다.                    zeroSemaphore를 잠궈준다.           printNumber를 0으로 수행하여, 0을 출력해준다.           i가 짝수이면 evenSemaphore를, 홀수이면 oddSemaphore를 release하여 잠금을 해제해준다.                           메서드인 even(IntConsumer printNumber)을 정의한다.            2부터 n 이하까지 i를 2씩 증가시키며 아래를 반복한다.                    evenSemaphore를 잠금 후 printNumber를 i로 수행하여, i를 출력해준다.           zeroSemaphore를 release하여 잠금을 해제하여 다음 수행을 진행하게 해준다.                           메서드인 odd(IntConsumer printNumber)를 정의한다.            1부터 n 이하까지 i를 2씩 증가시키며 아래를 반복한다.                    oddSemaphore를 잠금 후 printNumber를 i로 수행하여, i를 출력해준다.           zeroSemaphore를 release하여 잠금을 해제하여 다음 수행을 진행하게 해준다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/print-zero-even-odd/",
        "teaser": null
      },{
        "title": "Leetcode Java Relative Sort Array",
        "excerpt":"문제  Link   코드  class Solution {    public int[] relativeSortArray(int[] arr1, int[] arr2) {     int[] count = new int[1001];     for (int num : arr1) {       count[num]++;     }     int index = 0;     for (int num : arr2) {       while (count[num]-- &gt; 0) {         arr1[index++] = num;       }     }     for (int i = 0; index &lt; arr1.length &amp;&amp; i &lt; 1001; i++) {       while (count[i]-- &gt; 0) {         arr1[index++] = i;       }     }     return arr1;   }  }   결과  Link   설명          정수 배열 arr2의 값들의 순서대로 arr1을 정렬하고 arr2 내 없는 값들은 정렬 된 이후 순서로 오름차순 정렬하여 넣어주는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            count는 arr1 내 값들의 갯수를 저장할 변수로, arr1의 모든 값을 반복하여 갯수를 계산해준다.       index는 arr1의 값들을 정렬된 순서대로 넣어주기위한 위치 변수로, 첫 위치인 0으로 초기화한다.                arr2의 값들을 순차적으로 반복하여 count 내 값들의 갯수만큼 순서대로 arr1에 넣어준다.            0부터 1001 미만일 때 까지 i를 증가시키고, index가 arr1의 길이 미만일 때 까지 count[i]의 값을 arr1 내 순차적으로 넣어준다.       조건대로 정렬된 arr1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/relative-sort-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Building H2O",
        "excerpt":"문제  Link   코드  class H2O {    private Semaphore hSemaphore;   private Semaphore oSemaphore;    public H2O() {     this.hSemaphore = new Semaphore(2, true);     this.oSemaphore = new Semaphore(0, true);   }    public void hydrogen(Runnable releaseHydrogen) throws InterruptedException {     this.hSemaphore.acquire();     // releaseHydrogen.run() outputs \"H\". Do not change or remove this line.     releaseHydrogen.run();     this.oSemaphore.release();   }    public void oxygen(Runnable releaseOxygen) throws InterruptedException {     this.oSemaphore.acquire(2);     // releaseOxygen.run() outputs \"O\". Do not change or remove this line.     releaseOxygen.run();     this.hSemaphore.release(2);   }  }   결과  Link   설명          어떠한 순서대로 호출하더라도 물의 분자식인 “HHO”(H2O)를 출력하는 H2O 클래스를 완성하는 문제이다.       문제 풀이에 필요한 전역 변수를 정의한다.            hSemaphore와 oSemaphore는 “H”문자와 “O” 문자를 분자식 순서로 출력하기 위해 제어할 변수이다.           생성자인 H2O()를 정의한다.            hSemaphore는 “H” 문자 출력 제어할 변수로, 2번의 잠금과 FIFO방식을 사용하는 Semaphore로 초기화한다.       oSemaphore는 “O” 문자 출력 제어할 변수로, 1번의 잠금과 FIFO방식을 사용하는 Semaphore로 초기화한다.           메서드인 hydrogen(Runnable releaseHydrogen)을 정의한다.            hSemaphore를 첫 번째 잠금하고 releaseHydrogen를 수행한다.       oSemaphore를 첫 번째 잠금 해제한다.           메서드인 oxygen(Runnable releaseOxygen)을 정의한다.            oSemaphore를 두 번째 잠금하고 releaseOxygen을 수행한다.       hSemaphore를 두 번째 잠금 해제한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/building-h2o/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Number of Moves to Seat Everyone",
        "excerpt":"문제  Link   코드  class Solution {    public int minMovesToSeat(int[] seats, int[] students) {     Arrays.sort(seats);     Arrays.sort(students);     int result = 0;     for (int i = 0; i &lt; seats.length; i++) {       result += Math.abs(seats[i] - students[i]);     }     return result;   }  }   결과  Link   설명          students의 각 학생들이 비어있는 자리인 seats의 자리로 각자 이동할 때, 최소 이동 횟수를 구하는 문제이다.            seats와 students를 오름차순으로 정렬하여 좌석과 학생을 인접한 순서로 만들어준다.            result는 최소 이동 횟수를 계산할 변수로, seats와 students의 동일하게 위치한 값들의 차이에 대한 절댓값의 합을 더해서 넣어준 후 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-number-of-moves-to-seat-everyone/",
        "teaser": null
      },{
        "title": "Leetcode Java Lowest Common Ancestor of Deepest Leaves",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    private int depth = 0;   private TreeNode root;    public TreeNode lcaDeepestLeaves(TreeNode root) {     this.dfs(root, 0);     return this.root;   }    private int dfs(TreeNode node, int depth) {     this.depth = Math.max(this.depth, depth);     if (node == null) {       return depth;     } else {       int left = this.dfs(node.left, depth + 1);       int right = this.dfs(node.right, depth + 1);       if (left == this.depth &amp;&amp; right == this.depth) {         this.root = node;       }       return Math.max(left, right);     }   }  }   결과  Link   설명          root의 가장 낮은 깊이의 리프 노드들의 공통된 부모 노드를 반환하는 문제이다.       문제 풀이에 필요한 전역 변수를 정의한다.            depth는 가장 낮은 깊이를 저장할 변수로, 0으로 초기화한다.       tree는 가장 낲은 깊이의 리프 노드들의 공통된 부모 노드를 저장할 변수이다.                4번에서 정의한 dfs(TreeNode node, int depth)를 수행한다.       DFS 방식으로 가장 낮은 깊이의 리프 노드를 저장하기 위한 dfs(TreeNode node, int depth) 메서드를 정의한다.            전역 변수 depth에 해당 값과 현재 깊이인 depth 중 큰 깊이를 저장해준다.       node가 null인 경우, 현재 depth를 반환한다.       node가 null이 아닌 경우, 아래를 수행한다.                    left와 right에 node의 left, right TreeNode와 $depth + 1$을 각각 재귀 호출한 결과를 넣어준다.           left와 right의 깊이가 전역 변수인 depth와 동일한 가장 깊은 노드들인 경우, 전역 변수 root에 node를 넣어준다.           left와 right 중 큰 깊이를 반환한다.                           4번을 통해 가장 깊은 깊이의 노드의 공통된 부모 노드가 저장된 전역 변수인 root의 노드를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/lowest-common-ancestor-of-deepest-leaves/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Well-Performing Interval",
        "excerpt":"문제  Link   코드  class Solution {    public int longestWPI(int[] hours) {     int result = 0;     int sum = 0;     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();     for (int i = 0; i &lt; hours.length; i++) {       sum += hours[i] &gt; 8 ? 1 : -1;       if (sum &gt; 0) {         result = i + 1;       } else {         map.putIfAbsent(sum, i);         if (map.containsKey(sum - 1)) {           result = Math.max(result, i - map.get(sum - 1));         }       }     }     return result;   }  }   결과  Link   설명     업무 시간이 저장된 hours를 이용하여 양호한 수행 구간의 길이를 반환하는 문제이다.            양호한 수행 기간은 업무 시간이 8시간 초과인 일자가 더 많은 구간이다.           문제 풀이에 필요한 변수를 정의한다.            result는 양호한 수행 구간의 길이를 저장할 변수로, 0으로 초기화한다.       sum은 양호한 수행 기간 중 8시간 초과인 일자의 수를 계산할 변수로, 0으로 초기화한다.       map은 양호한 수행 기간을 계산하기 위한 변수로, HashMap으로 초기화한다.           0부터 hours의 길이 미만까지 i를 증가시키며 아래를 반복한다.            sum을 hors[i]의 값이 8시간 초과이면 증가, 이하이면 감소시켜준다.       sum이 0보다 크면 양호한 수행 구간이므로, result에 $i + 1$을 넣어준다.       sum이 0과 같거나 작으면 양호한 수행 구간이 아니므로, 아래를 수행한다.                    map에 sum의 위치에 i를 넣어 저장해준다.           map에 $sum - 1$의 값이 존재하면 해당 위치부터 현재까지 값이 양호한 수행 구간을 만족하므로, result에 result와 $i - map.get(sum - 1)$에 대한 값을 뺀 차잇값 중 큰 값을 넣어준다.                           반복이 완료되면 양호한 수행 구간의 길이가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-well-performing-interval/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Equivalent Domino Pairs",
        "excerpt":"문제  Link   코드  class Solution {    public int numEquivDominoPairs(int[][] dominoes) {     int[] count = new int[100];     int result = 0;     for (int[] domino : dominoes) {       if (domino[0] &lt; domino[1]) {         result += count[domino[0] * 10 + domino[1]]++;       } else {         result += count[domino[1] * 10 + domino[0]]++;       }     }     return result;   }  }   결과  Link   설명     정수 배열인 dominoes 내 동일한 숫자들로 이루어진 도미노 쌍의 수를 구하는 문제이다.            dominoes[i] = [a, b] 이고 dominoes[j] = [c, d]일 때, $a == c &amp;&amp; b == d$를 만족하거나 $a == d &amp;&amp; b == c$를 만족하는 쌍을 의미한다.           주어진 문제 풀이에 필요한 변수를 정의한다.            count는 도미노의 두 값을 합쳐서 갯수를 계산할 변수로, 두 값을 연결할 때 값의 상한인 99가 포함되도록 100 크기의 정수 배열로 초기화한다.       result는 도미노 쌍의 수를 계산할 변수이다.           dominoes의 각 도미노들을 domino에 순차적으로 넣어 아래를 수행한다.            domino[0]의 값이 domino[1]의 값보다 큰 경우, count 내 domino[0]이 십의 자리 domino[1]이 일의 자리에 위치한 값을 증가시키고 해당 값을 result에 더해준다.       위의 경우가 아니라면 순서를 바꾸어 count 내 domino[1]이 십의 자리 domino[0]이 일의 자리에 위치한 값을 증가시키고 해당 값을 result에 더해준다.           계산이 완료되면 쌍의 수가 계산된 result를 주어진 문제의 결과로 반환한다.   해설     count는 쌍의 수를 증가시키며 result에 더하면 역순 Fatorial 계산이 수행되는 것과 같다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-equivalent-domino-pairs/",
        "teaser": null
      },{
        "title": "Leetcode Java Shortest Path with Alternating Colors",
        "excerpt":"문제  Link   코드  class Solution {    public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {     Set&lt;Integer&gt;[][] set = new Set[n][2];     for (int i = 0; i &lt; n; i++) {       set[i][0] = new HashSet&lt;&gt;();       set[i][1] = new HashSet&lt;&gt;();     }     for (int[] redEdge : redEdges) {       set[redEdge[0]][0].add(redEdge[1]);     }     for (int[] blueEdge : blueEdges) {       set[blueEdge[0]][1].add(blueEdge[1]);     }     int[][] paths = new int[n][2];     for (int i = 1; i &lt; n; i++) {       paths[i][0] = paths[i][1] = n * 2;     }     Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();     queue.offer(new int[] { 0, 0 });     queue.offer(new int[] { 0, 1 });     while (!queue.isEmpty()) {       int[] curr = queue.poll();       int row = curr[0];       int col = curr[1];       for (int node : set[row][1 - col]) {         if (paths[node][1 - col] == n * 2) {           paths[node][1 - col] = paths[row][col] + 1;           queue.offer(new int[] { node, 1 - col });         }       }     }     int[] result = new int[n];     for (int i = 0; i &lt; n; i++) {       int min = Math.min(paths[i][0], paths[i][1]);       result[i] = min == n * 2 ? -1 : min;     }     return result;   }  }   결과  Link   설명     n개의 노드의 각 색깔별 이동 경로가 저장된 redEdges와 blueEdges를 이용하여 색을 번갈아가면서 0번 노드에서 각 노드까지 최단 경로를 구하는 문제이다.            단, 경로가 존재하지 않으면 -1을 넣어준다.           문제 풀이에 필요한 변수를 정의한다.            set은 노드 별 도착 노드를 저장할 변수로, red와 blue를 순차적으로 넣기 위해 $n \\times 2$ 크기의 Set 배열로 정의하여 redEdges는 노드 별 첫 번째 HashSet에 blueEdges는 노드 별 두 번째 HashSet에 도착 노드를 넣어준다.       paths는 노드 별 색깔을 번갈아 이동하기 위한 횟수를 저장할 변수로, $n \\times 2$ 크기의 2차원 정수 배열로 초기화하고 모든 값에 최대 가능한 경우보다 큰 $n \\times 2$를 넣어준다.                    최대 가능한 경우는 노드로 이동하는 경로와 자기 자신을 회귀하는 아래의 경우와 같다.           n = 3, redEdges = [[0, 1], [1, 2]], blueEdges = [[1, 1]] 일때, 0에서 2까지 최소 3번의 단계를 거친다.           위를 기반으로 $(2 \\times(n - 2)) + 1 = (n \\times 2) - 3$이 최소 이동 횟수가 된다.                       queue는 redEdges와 blueEdges를 순차적으로 탐색하기 위한 변수로, LinkedList로 초기화 후 [0, 0]과 [0, 1]을 순차적으로 넣어준다.           queue가 비어있지 않을 때 까지 아래를 반복한다.            curr은 현재 순서를 저장할 변수로, queue의 첫 값을 빼서 넣어준다.       row와 col은 curr의 첫 번째 값과 두 번째 값을 순차적으로 넣은 변수이다.       set[row][$1 - col$]의 값을 순차적으로 node에 넣어 아래를 수행한다.                    paths[node][$1 - col$]의 값이 초기 값인 $n \\times 2$인 경우, paths[node][$1 - col$]의 위치에 path[row][col]의 값에 1을 더한 값을 넣어 준 후 queue에 [node, $1 - col$]을 넣어준다.                                result는 각 노드까지 최단 경로를 저장할 변수로, n 크기의 정수 배열로 초기화한다.       result의 i번째 위치에 paths의 i번째 위치에 해당하는 두 경로 중 작은 값을 넣은 후 주어진 문제의 결과로 반환한다.            단, 가장 작은 값이 초기값인 $n \\times 2$면 경로가 없으므로 -1을 넣어준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/shortest-path-with-alternating-colors/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Cost Tree From Leaf Values",
        "excerpt":"문제  Link   코드  class Solution {    public int mctFromLeafValues(int[] arr) {     int result = 0;     Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();     stack.push(Integer.MAX_VALUE);     for (int num : arr) {       while (stack.peek() &lt;= num) {         result += stack.pop() * Math.min(stack.peek(), num);       }       stack.push(num);     }     while (stack.size() &gt; 2) {       result += stack.pop() * stack.peek();     }     return result;   }  }   결과  Link   설명     arr은 리프 노드로 이루어진 값들로, 가장 작은 부모 노드들 값의 합을 구하는 문제이다.            부모 노드의 값은 아래 위치한 리프 노드들 중 가장 큰 값을 가진 두 노드 값의 곱으로 결정된다.           문제 풀이에 필요한 변수를 정의한다.            result는 부모 노드들 값의 합을 저장할 변수로, 0으로 초기화한다.       stack은 자식 노드들을 순회하여 부모 노드의 값을 설정하기 위한 변수로, 선입선출의 Stack으로 초기화하고 값의 구분을 위해 첫 값을 정수의 가장 큰 값으로 넣어준다.           arr의 각 값을 순차적으로 num에 넣고 아래를 수행한다.            stack 내 맨 앞의 값이 num보다 작거나 같은 부모 노드 생성이 가능한 값까지 result에 stack의 앞의 값을 꺼내 해당 값과 stack의 현재 맨 앞의 값과 num 중 작은 값을 곱해서 더해준다.       stack에 num을 넣어준다.                3번이 완료되고 stack의 크기가 2 초과인 잔여 값이 존재하는 경우, 마지막으로 root 노드의 값인 해당 두 값을 곱하여 result에 더해준다.       반복이 완료되면 가장 작은 부모 노드들 값의 합이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-cost-tree-from-leaf-values/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Number of Days to Make m Bouquets",
        "excerpt":"문제  Link   코드  class Solution {    public int minDays(int[] bloomDay, int m, int k) {     if ((long) m * k &gt; bloomDay.length) {       return -1;     }     int left = 1;     int right = (int) 1e9;     while (left &lt; right) {       int mid = left + (right - left) / 2;       if (this.isPossibleMakeBouquets(bloomDay, m, k, mid)) {         right = mid;       } else {         left = mid + 1;       }     }     return left;   }    private boolean isPossibleMakeBouquets(int[] bloomDay, int m, int k, int day) {     int total = 0;     int length = bloomDay.length;     for (int i = 0; i &lt; length; i++) {       int count = 0;       while (i &lt; length &amp;&amp; count &lt; k &amp;&amp; bloomDay[i] &lt;= day) {         count++;         i++;       }       if (count == k) {         total++;         i--;       }       if (total &gt;= m) {         return true;       }     }     return false;   }  }   결과  Link   설명     각 꽃의 개화일이 담긴 bloomDay를 이용하여 한 번씩만 사용하여 k개의 인접한 꽃을 이용하여 m개의 꽃다발을 만들 때, 만들 수 있는 최소 일수를 구하는 문제이다.            단, 만들 수 없는 경우 -1을 주어진 문제의 결과로 반환한다.                $m \\times k$가 bloomDay의 길이보다 커서 인접한 꽃을 한 번씩만 사용하여 꽃다발을 만들 수 없는 경우, -1을 주어진 문제의 결과로 반환한다.            일자 탐색에 필요한 변수인 left와 right에 left는 최소 개화일인 1, right는 최대 개화일인 $10^9$로 초기화한다.       left가 right 미만일 때 까지 아래를 반복한다.            mid에 $left + \\frac{right - left} / 2$인 중앙값을 넣어준다.       5번에서 정의한 isPossibleMakeBouquets(int[] bloomDay, int m, int k, int day)인 꽃다발을 만들 수 있는 경우, right에 mid를 아니면 left에 $mid + 1$을 넣어 개화일 탐색 범위을 좁혀준다.           bloomDay 내 k개의 인접한 꽃을 이용하여 m개의 꽃다발을 만들 수 있는지 검증하기 위한 isPossibleMakeBouquets(int[] bloomDay, int m, int k, int day) 메서드를 정의한다.            문제 풀이에 필요한 변수를 정의한다.                    total은 총 꽃다발의 갯수를 계산할 변수로, 0으로 초기화한다.           length는 bloomDay의 길이를 저장한 변수이다.                       0부터 length 미만까지 i를 증가시키며 아래를 반복한다.                    count는 꽃의 갯수를 계산할 변수로, 0으로 초기화한다.           i가 length 미만이면서 count가 k개 미만이고, bloomDay[i] 값이 day 이하인 꽃다발에 꽃을 넣을 수 있을 때 까지 count와 i를 증가시킨다.           count가 k인 꽃다발이 완성된 경우, total인 꽃다발의 갯수를 증가시키고 i를 감소시킨다.           total이 m 이상이면 m개의 꽃다발이 완성되었으므로, true를 반환한다.                       반복이 완료되면 꽃다발을 완성할 수 없으므로, false를 반환한다.           반복이 완료되면 최소 일수가 저장된 left를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-number-of-days-to-make-m-bouquets/",
        "teaser": null
      },{
        "title": "Leetcode Java Magnetic Force Between Two Balls",
        "excerpt":"문제  Link   코드  class Solution {    public int maxDistance(int[] position, int m) {     Arrays.sort(position);     int left = 0;     int right = position[position.length - 1];     int result = 0;     while (left &lt; right) {       int mid = left + (right - left) / 2;       if (this.isPossible(position, m, mid)) {         result = mid;         left = mid + 1;       } else {         right = mid;       }     }     return result;   }    private boolean isPossible(int[] positions, int m, int max) {     int count = 1;     int prev = positions[0];     for (int i = 1; i &lt; positions.length; i++) {       if (positions[i] - prev &gt;= max) {         prev = positions[i];         count++;       }     }     return count &gt;= m;   }  }   결과  Link   설명          n개의 바구니에 m개 공을 넣을 떄, 각 공 사이의 최소 거리가 최댓 값보다 크거나 같도록 위치할 때 각 공 사이의 최소 거리를 반환하는 문제이다.            position을 오름차순 정렬해준다.       문제 풀이에 필요한 변수를 정의한다.            left와 right는 탐색에 필요한 위치 변수로, 0과 position의 마지막 값으로 초기화해준다.       result는 각 공 사이의 최소 거리를 저장할 변수로, 0으로 초기화한다.           left가 right 미만일 때 까지 아래를 반복한다.            mid는 중앙값을 저장할 변수로, $left + \\frac{right - left}{2}$를 넣어준다.       5번에서 정의한 isPossible(int[] positions, int m, int max) 메서드의 max 자리에 mid를 넣어 수행한 결과가 만족하는지 여부에 따라 아래를 수행한다.                    위의 결과가 true이면 조건을 만족하도록 공을 바구니에 분배 가능하므로, result에 mid를 넣고 left에 $mid + 1$을 넣어 하단 범위를 높혀준다.           위의 결과가 false이면 조건을 만족하도록 공을 바구니에 분배할 수 없으므로, right에 mid를 넣어 상단 범위를 낮춰준다.                           주어진 조건에 따라 공을 바구니에 분배할 수 있는지 검증하기 위한 isPossible(int[] positions, int m, int max) 메서드를 정의한다.            검증에 필요한 변수를 정의한다.                    count는 바구니에 공을 넣은 갯수를 계산할 변수로, 첫 바구니는 반드시 포함되므로 1로 초기화한다.           prev는 이전 바구니의 값을 저장할 변수로, positions[0]의 값으로 초기화한다.                       1부터 positions의 길이 미만까지 i를 증가시키며 아래를 수행한다.                    $positions[i] - prev &gt;= max$이면 조건을 만족하므로 prev에 positions[i] 값을 넣고 count를 증가시켜준다.                       반복이 완료되면 count가 m 이상인 바구니에 공을 모두 분배 가능한지 검증한 결과를 반환한다.           모든 수행이 완료되면 최소 거리가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/magnetic-force-between-two-balls/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum of Absolute Value Expression",
        "excerpt":"문제  Link   코드  class Solution {    public int maxAbsValExpr(int[] arr1, int[] arr2) {     int result = Integer.MIN_VALUE;     int i1 = -arr1[0] - arr2[0];     int i2 = -arr1[0] + arr2[0];     int i3 = arr1[0] - arr2[0];     int i4 = arr1[0] + arr2[0];     for (int i = 1; i &lt; arr1.length; i++) {       result = Math.max(result           , Math.max(i1 + arr1[i] + arr2[i] + i               , Math.max(i2 + arr1[i] - arr2[i] + i,                   Math.max(i3 + -arr1[i] + arr2[i] + i                       , i4 + -arr1[i] - arr2[i] + i))));       i1 = Math.max(i1, -arr1[i] - arr2[i] - i);       i2 = Math.max(i2, -arr1[i] + arr2[i] - i);       i3 = Math.max(i3, arr1[i] - arr2[i] - i);       i4 = Math.max(i4, arr1[i] + arr2[i] - i);     }     return result;   }  }   결과  Link   설명     정수 배열인 arr1과 arr2가 주어지면 아래 계산 공식을 만족하는 최대 값을 반환하는 문제이다.                                                            계산 공식은 $               arr1[i] - arr1[j]               +               arr2[i] - arr2[j]               +               i - j               $이다.                                               0 &lt;= i, j &lt; arr1.legnth를 만족한다.           문제 풀이에 필요한 변수를 정의한다.            result는 결과를 저장할 변수로, 0으로 초기화한다.       i1은 $arr1[i] &lt;= arr1[j] &amp;&amp; arr2[i] &lt;= arr2[j]$를 만족하는 경우로, 아래의 공식을 활용하여 계산된다.                    $arr1[j] - arr1[i] + arr2[j] - arr2[i] + j - i = (arr1[j] + arr2[j] + j) + (-arr1[i] - arr2[i] - i)$           현재 위치의 값은 $-arr1[i] - arr2[i] - i$로 계산하여 첫 값인 $-arr1[0] - arr2[0]$을 넣어준다.                       i2는 $arr1[i] &lt;= arr1[j] &amp;&amp; arr2[i] &gt;= arr2[j]$를 만족하는 경우로, 아래의 공식을 활용하여 계산된다.                    $arr1[j] - arr1[i] + arr2[i] - arr2[j] + j - i = (arr1[j] - arr2[j] + j) + (-arr1[i] + arr2[i] - i)$           현재 위치의 값은 $-arr1[i] + arr2[i] - i$로 계산하여 첫 값인 $-arr1[0] + arr2[0]$을 넣어준다.                       i3는 $arr1[i] &gt;= arr1[j] &amp;&amp; arr2[i] &lt;= arr2[j]$를 만족하는 경우로, 아래의 공식을 활용하여 계산된다.                    $arr1[i] - arr1[j] + arr2[j] - arr2[i] + j - i = (-arr1[j] + arr2[j] + j) + (arr1[i] - arr2[i] - i)$           현재 위치의 값은 $arr1[i] - arr2[i] - i$로 계산하여 첫 값인 $arr1[0] - arr2[0]$을 넣어준다.                       i4는 $arr1[i] &gt;= arr1[j] &amp;&amp; arr2[i] &gt;= arr2[j]$를 만족하는 경우로, 아래의 공식을 활용하여 계산된다.                    $arr1[i] - arr1[j] + arr2[i] - arr2[j] + j - i = (-arr1[j] - arr2[j] + j) + (arr1[i] + arr2[i] - i)$           현재 위치의 값은 $arr1[i] - arr2[i] - i$로 계산하여 첫 값인 $arr1[0] + arr2[0]$을 넣어준다.                           1부터 arr1의 길이 미만까지 i를 증가시키며 아래를 반복한다.            result에 result와 아래의 각 경우 중 큰 값을 넣어준다.                    i1의 계산 공식인 이전 위치의 값과 현재 위치의 값의 합인 $i1 + arr1[i] + arr2[i] + i$의 값.           i2의 계산 공식인 이전 위치의 값과 현재 위치의 값의 합인 $i2 + arr1[i] - arr2[i] + i$의 값.           i3의 계산 공식인 이전 위치의 값과 현재 위치의 값의 합인 $i3 + -arr1[i] + arr2[i] + i$의 값.           i4의 계산 공식인 이전 위치의 값과 현재 위치의 값의 합인 $i4 + -arr1[i] - arr2[i] + i$의 값.                       i1부터 i4에 이전 위치에서 계산한 값과 현재 위치에서 계산한 값 중 큰 값을 각각 넣어준다.           반복이 완료되면 결과가 계산된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-of-absolute-value-expression/",
        "teaser": null
      },{
        "title": "Leetcode Java Alphabet Board Path",
        "excerpt":"문제  Link   코드  class Solution {    public String alphabetBoardPath(String target) {     int x = 0;     int y = 0;     StringBuilder sb = new StringBuilder();     for (char c : target.toCharArray()) {       int x1 = (c - 'a') / 5;       int y1 = (c - 'a') % 5;       while (x1 &lt; x) {         x--;         sb.append('U');       }       while (y1 &gt; y) {         y++;         sb.append('R');       }       while (y1 &lt; y) {         y--;         sb.append('L');       }       while (x1 &gt; x) {         x++;         sb.append('D');       }       sb.append('!');     }     return sb.toString();   }  }   결과  Link   설명     영문자 구성인 board의 (0, 0)위치에서 시작해서 target 문자열을 만들기 위한 과정을 순차적으로 문자열로 만들어 반환하는 문제이다.            board는 [“abcde”, “fghij”, “klmno”, “pqrst”, “uvwxy”, “z”]로 구성되어있다.       ‘U’는 위로, ‘D’는 아래로, ‘L’은 좌측으로, ‘R’은 우측으로 이동하는 것을 의미한다.       ’!’는 이동한 위치의 문자가 target 문자열 생성에 필요한 값임을 의미한다.           문제 풀이에 필요한 변수를 정의한다.            x와 y는 현재 위치값을 의미하며, 처음 위치인 0으로 둘 다 초기화한다.       sb는 이동 경로에 대한 문자를 동적으로 생성하기 위한 변수로, StringBuilder로 초기화한다.           target의 각 문자들을 순서대로 c에 넣어 아래를 수행한다.            x1과 y1은 c의 위치를 저장할 변수로, 문자의 순서인 $c - ‘a’$ 값을 한 행의 문자 갯수인 5로 나눈 몫을 x1에 나머지를 y1에 넣어준다.       x1이 x보다 작을 때 까지 x를 감소시키고 sb에 ‘U’문자를 이어 위로 이동했음을 표기한다.       y1이 y보다 클 때 까지 y를 증가시키고 sb에 ‘R’문자를 이어 우측으로 이동했음을 표기한다.       y1이 y보다 작을 때 까지 y를 감소시키고 sb에 ‘L’문자를 이어 좌측으로 이동했음을 표기한다.       x1이 x보다 클 때 까지 x를 증가시키며 sb에 ‘D’문자를 이어 아래로 이동했음을 표기한다.       목표 위치로 이동이 완료되면 sb에 ‘!’ 문자를 이어 목표 문자로 이동했음을 표기한다.           반복이 완료되면 target 문자열을 만들기 위한 과정이 저장된 sb를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/alphabet-board-path/",
        "teaser": null
      },{
        "title": "Leetcode Java Largest 1-Bordered Square",
        "excerpt":"문제  Link   코드  class Solution {    public int largest1BorderedSquare(int[][] grid) {     int result = 0;     int row = grid.length;     int col = grid[0].length;     int[][] rowDp = new int[row + 1][col + 1];     int[][] colDp = new int[row + 1][col + 1];     for (int i = 1; i &lt;= row; i++) {       for (int j = 1; j &lt;= col; j++) {         if (grid[i - 1][j - 1] == 0) {           continue;         }         rowDp[i][j] = rowDp[i - 1][j] + 1;         colDp[i][j] = colDp[i][j - 1] + 1;         for (int k = Math.min(rowDp[i][j], colDp[i][j]); k &gt;= 1; k--) {           if (rowDp[i][j + 1 - k] &gt;= k &amp;&amp; colDp[i + 1 - k][j] &gt;= k) {             result = Math.max(result, k * k);             break;           }         }       }     }     return result;   }  }   결과  Link   설명     grid에서 하나의 선으로 이루어진 정사각형의 최대 크기를 반환하는 문제이다.            grid의 1은 선을, 0은 빈 공간을 의미한다.           문제 풀이에 필요한 변수를 정의한다.            result는 정사각형의 최대 크기를 저장할 변수로, 0으로 초기화한다.       row와 col은 grid의 가로 세로의 길이를 저장한 변수이다.       rowDp와 colDp는 행과 열을 지나가며 정사각형의 크기를 계산하기 위한 변수로, 둘 다 $(row + 1) \\times (col + 1)$ 크기의 2차원 배열로 초기화한다.           1부터 row 이하까지 i를, 1부터 col 이하까지 j를 증가시키며 아래를 반복한다.            gird[$i - 1$][$j - 1$]의 값이 0인 빈 칸인 경우, 다음 반복을 수행한다.       rowDp[i][j]의 위치에 이전 위치 값인 rowDp[$i - 1$][j]의 값에 1을 더해 넣어준다.       colDp[i][j]의 위치에 이전 위치 값인 colDp[i][$j - 1$]의 값에 1을 더해 넣어준다.       k는 rowDp[i][j]의 값과 colDp[i][j]의 값 중 작은 정사각형이 가능한 가장 큰 값부터 1 이상일 때 까지 k를 감소시키며 아래를 반복한다.                    rowDp[i][$j + 1 - k$]의 값과 colDp[$i + 1 - k$][j]의 값이 k 이상인 정사각형이 가능한 최대 크기인 경우, result에 result와 $k \\times k$ 중 큰 값을 넣고 반복을 중지한다.                           반복이 완료되면 가능한 정사각형의 최대 크기가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/largest-1-bordered-square/",
        "teaser": null
      },{
        "title": "Leetcode Java Balance a Binary Search Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public TreeNode balanceBST(TreeNode root) {     List&lt;TreeNode&gt; list = new ArrayList&lt;&gt;();     this.addListInorder(root, list);     return this.createBalanceBST(list, 0, list.size() - 1);   }    private void addListInorder(TreeNode root, List&lt;TreeNode&gt; list) {     if (root != null) {       this.addListInorder(root.left, list);       list.add(root);       this.addListInorder(root.right, list);     }   }    private TreeNode createBalanceBST(List&lt;TreeNode&gt; list, int start, int end) {     if (start &gt; end) {       return null;     } else {       int mid = (start + end) / 2;       TreeNode root = list.get(mid);       root.left = this.createBalanceBST(list, start, mid - 1);       root.right = this.createBalanceBST(list, mid + 1, end);       return root;     }   }  }   결과  Link   설명          이진 탐색 트리인 root를 모든 리프 노드의 깊이 차이가 1 이하인 이진 탐색 트리로 반환하는 문제이다.            list는 이진 탐색 트리인 root의 모든 노드를 Inorder 순으로 저장할 변수로, root의 노드들의 값 오름차순으로 list에 노드들을 저장한다.            4번에서 정의한 createBalanceBST(List list, int start, int end) 메서드를 수행한 결과를 주어진 문제의 결과로 반환한다.            균형잡힌 BST로 만들기 위한 createBalanceBST(List list, int start, int end) 메서드를 정의한다.             start가 end 초과인 경우 균형잡힌 범위를 벗어 났으므로, null을 반환한다.       위의 경우가 아니라면 아래를 수행한다.                    mid에 $\\frac{start + end}{2}$인 [start, end] 사이의 중앙값을 넣어준다.           root에 list의 mid번째 값인 중앙에 위치할 노드를 선택하고, left와 right TreeNode에 순차적으로 [start, $mid - 1$], [$mid + 1$, end]를 이용하여 재귀 호출한 TreeNode를 넣어준다.           수행이 완료되면 [start, end] 범위 내 균형잡힌 BST로 만들어진 root를 반환한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/balance-a-binary-search-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Center of Star Graph",
        "excerpt":"문제  Link   코드  class Solution {    public int findCenter(int[][] edges) {     return edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1] ? edges[0][0] : edges[0][1];   }  }   결과  Link   설명          별모양으로 연결된 노드들의 연결 선 정보가 담긴 edges를 이용하여 중앙에 있는 노드의 값을 반환하는 문제이다.            중앙에 있는 노드의 값은 각 edge에 하나 씩 존재하므로, edges[0]과 edges[1]의 연결 선 정보를 이용하여 두 선에서 존재하는 노드 값을 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-center-of-star-graph/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Total Importance of Roads",
        "excerpt":"문제  Link   코드  class Solution {    public long maximumImportance(int n, int[][] roads) {     long result = 0;     long cost = 1;     long[] connections = new long[n];     for (int[] road : roads) {       connections[road[0]]++;       connections[road[1]]++;     }     Arrays.sort(connections);     for (long connection : connections) {       result += connection * (cost++);     }     return result;   }  }   결과  Link   설명          [0, $n - 1$] 범위 내 노드들과 각 노드간 연결 선이 저장된 roads를 이용하여 이용하여 [1, n] 범위의 값들을 각 노드의 이동 간 최대 점수가 될 수 있도록노드에 할당할 때, 최대 점수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 최대 점수를 구하기 위한 변수로, 0으로 초기화한다.       cost는 각 노드의 점수를 할당하기 위한 변수로, 최소 점수인 1로 초기화한다.       connections는 각 노드간 연결 횟수를 저장할 변수로, n 크기의 long 배열로 초기화하여 roads의 시작점과 종료점의 갯수를 각각 넣어준 후 오름차순 정렬해준다.           connections의 각 값을 connection에 순차적으로 넣어 아래를 수행한다.            result에 $connection \\times cost$ 값을 넣고 cost를 증가시켜준다.           반복을 통해 계산된 최대 점수인 result를 주어진 문제의 결과로 반환한다.   해설     연결 선의 수가 적은 노드인 경우, 이동 경로에 접점이 많이 발생하지 않으므로 점수를 순차적으로 연결 선의 수의 오름차순으로 할당한다.   위를 통하여 접점이 많은 노드는 최대 점수가 되어 각 이동 경로에 대한 점수 계산 시, 가장 많은 점수를 획득할 수 있다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-total-importance-of-roads/",
        "teaser": null
      },{
        "title": "Leetcode Java All Ancestors of a Node in a Directed Acyclic Graph",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; getAncestors(int n, int[][] edges) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     List&lt;List&lt;Integer&gt;&gt; childs = new ArrayList&lt;&gt;();     for (int i = 0; i &lt; n; i++) {       result.add(new ArrayList&lt;&gt;());       childs.add(new ArrayList&lt;&gt;());     }     for (int[] edge : edges) {       childs.get(edge[0]).add(edge[1]);     }     for (int i = 0; i &lt; n; i++) {       this.dfs(result, childs, i, i);     }     return result;   }    private void dfs(List&lt;List&lt;Integer&gt;&gt; result, List&lt;List&lt;Integer&gt;&gt; childs, int node, int curr) {     for (int child : childs.get(curr)) {       List&lt;Integer&gt; list = result.get(child);       if (list.size() == 0 || list.get(list.size() - 1) != node) {         list.add(node);         this.dfs(result, childs, node, child);       }     }   }  }   결과  Link   설명          노드 간 연결 선 목록인 edge를 이용하여 각 노드들로 이동 가능한 노드들의 목록을 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 각 노드들로 이동 가능한 노드들을 저장하기 위한 변수로, ArrayList로 초기화하고 n개의 ArrayList를 넣어준다.       childs는 각 노드가 이동하는 경로를 넣어줄 변수로, ArrayList로 초기화하고 edges를 이용하여 첫 번째 값에 해당하는 ArrayList에 두 번째 값을 넣어준다.                0부터 n까지 i를 증가시키며 4번에서 정의한 dfs(List&lt;List&gt; result, List&lt;List&gt; childs, int node, int curr) 메서드의 node와 curr에 i를 넣고 수행한다.       DFS 방식으로 각 노드로 이동 가능한 노드들을 탐색할 dfs(List&lt;List&gt; result, List&lt;List&gt; childs, int node, int curr) 메서드를 정의한다.            childs의 curr에 해당하는 노드들을 순차적으로 child에 넣어 아래를 수행한다.                    list에 result의 child번째 ArrayList를 꺼내 넣어준다.           list가 비어있거나 list의 마지막 값이 node가 아닌 이동 가능한 경로인 경우, list에 node를 넣고 curr 자리에 child를 넣어 재귀 호출을 수행한다.                           수행이 완료되어 모든 이동 가능한 노드들이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/all-ancestors-of-a-node-in-a-directed-acyclic-graph/",
        "teaser": null
      },{
        "title": "Leetcode Java Three Consecutive Odds",
        "excerpt":"문제  Link   코드  class Solution {    public boolean threeConsecutiveOdds(int[] arr) {     for (int i = 0, count = 0; i &lt; arr.length; i++) {       if (arr[i] % 2 == 0) {         count = 0;       } else if (++count == 3) {         return true;       }     }     return false;   }  }   결과  Link   설명          arr 내 연속된 값들 중 홀수가 3개 연달아 존재하는지 검증하는 문제이다.       count는 연속된 홀수의 갯수를 계산할 변수로 0으로, 0부터 arr의 길이 미만까지 i를 증가시키면서 아래를 반복한다.            arr[i]의 값을 짝수이면, count를 0으로 초기화한다.       arr[i]의 값이 홀수이면, count를 증가시키고 해당 값이 3이면 true를 주어진 문제의 결과로 반환한다.           반복이 완료되면 arr 내 연속된 값들 중 홀수가 3개 연달아 있지 않으므로, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/three-consecutive-odds/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL User Activity for the Past 30 Days I",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT activity_date AS day, COUNT(DISTINCT user_id) AS active_users FROM Activity WHERE activity_date &gt; '2019-07-27'::date - INTERVAL '30 days' AND activity_date &lt;= '2019-07-27' GROUP BY activity_date   결과  Link   설명          2019-07-27일 까지 최근 30일 동안 활성화 유저를 계산하는 문제이다.            2019-07-27일에서 30일을 차감한 날자 초과부터 해당 날 이전까지의 Activity 테이블 내 데이터가 문제의 활성 유저를 구하는 조건이 된다.            활성화 유저는 Activity 테이블에서 ‘open_session’과 ‘end_session’의 로그의 시간동안 세션이 유지되며 하루에 한 번의 활동을 수행해야 세션이 유지되므로, user_id가 중복되지 않은 일자까지가 활성 유저의 수가 된다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/user-activity-for-the-past-30-days-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Difference Between Largest and Smallest Value in Three Moves",
        "excerpt":"문제  Link   코드  class Solution {    public int minDifference(int[] nums) {     int length = nums.length;     if (length &lt; 5) {       return 0;     } else {       int result = Integer.MAX_VALUE;       Arrays.sort(nums);       for (int i = 0; i &lt; 4; i++) {         result = Math.min(result, nums[length - 4 + i] - nums[i]);       }       return result;     }   }  }   결과  Link   설명          nums 내 임의 값을 배열 내 값으로 세 번까지 변경하여 최댓값과 최솟값의 차이가 최소가 되는 값을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 nums의 결과를 저장한 변수로 5 미만이면 최댓값과 최솟값이 항상 0이 되므로, 0을 주어진 문제의 결과로 반환한다.       result는 결과를 저장할 변수로, 정수의 최댓값을 넣어 초기화한다.           nums의 값들을 오름차순 정렬 후 0부터 4 미만까지 i를 증가시키며 아래를 반복한다.            result에 result와 nums의 마지막 위치인 $length - 1$에서 $i - 3$번째 값에 nums[i]를 뺀 최댓값과 최솟값이 가능한 경우의 차잇값 중 작은 값을 넣어준다.           반복이 완료되면 최소 차잇값인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-difference-between-largest-and-smallest-value-in-three-moves/",
        "teaser": null
      },{
        "title": "Leetcode Java Merge Nodes in Between Zeros",
        "excerpt":"문제  Link   코드  class Solution {    public ListNode mergeNodes(ListNode head) {     ListNode temp = head.next;     ListNode next = temp;     while (next != null) {       int sum = 0;       while (next.val != 0) {         sum += next.val;         next = next.next;       }       temp.val = sum;       next = next.next;       temp.next = next;       temp = temp.next;     }     return head.next;   }  }   결과  Link   설명          head에서 노드의 값이 0인 노드들 사이의 값을 하나의 노드의 값으로 합쳐서 하나의 리스트 노드로 반환하는 문제이다.            temp와 next는 노드를 이동하며 하나의 리스트 노드로 값을 합치기 위한 변수로, 둘 다 처음 값이 0인 노드를 제외한 head의 다음 노드로 초기화한다.       next 노드가 null이 아닐 때 까지 아래를 반복한다.            sum은 0이 아닌 노드의 값을 합치기 위한 변수로, 0으로 초기화한다.       next 노드의 val 값이 0이 아닐 때 까지, next의 값을 더한 후 next에 next의 다음 노드를 넣어준다.       temp의 val의 값에 sum을 넣어 합계를 넣어준다.       next에 next의 다음 노드를 넣어, 값이 0인 노드를 넘어간다.       temp의 다음 노드에 next로 넣어준 후, temp에는 temp의 다음 노드를 넣어준다.           반복이 완료되면 temp를 통해 하나의 리스트 노드로 만든 head의 next 리스트 노드를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/merge-nodes-in-between-zeros/",
        "teaser": null
      },{
        "title": "Leetcode Java Water Bottles",
        "excerpt":"문제  Link   코드  class Solution {    public int numWaterBottles(int numBottles, int numExchange) {     int result = numBottles;     while (numBottles &gt;= numExchange) {       int newBottles = numBottles / numExchange;       result += newBottles;       numBottles = (numBottles % numExchange) + newBottles;     }     return result;   }  }   결과  Link   설명          numBottles 개의 물을 다 마신 후 numExchange 개의 빈 병을 하나의 새 물로 교환해줄 때, 마실 수 있는 물의 갯수를 구하는 문제이다.            result는 마실 수 있는 물의 갯수를 저장할 변수로, 처음 주어진 물인 numBottles 개의 물은 모두 마실수 있어 해당 갯수로 초기화한다.       numBottles가 numExchange보다 크거나 같을 때 까지 아래를 반복한다.            newBottles는 빈 병을 numExchange 개 단위로 교환한 새 물의 수를 나타내는 변수로, 최대 교환 가능한 $\\frac{numBottles}{numExchange}$의 몫에 대한 갯수를 넣어준다.       result에 교환한 새 물을 모두 마시는 경우인 newBottles을 더해준다.       numBottles에 교환하고 남은 $\\frac{numBottles}{numExchange}$의 나머지에 대한 갯수에 위에서 교환하여 다 마신 newBottles 개의 공병을 더해준다.           결과가 완료되면 물을 마신 병의 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/water-bottles/",
        "teaser": null
      },{
        "title": "Leetcode Java Find the Winner of the Circular Game",
        "excerpt":"문제  Link   코드  class Solution {    public int findTheWinner(int n, int k) {     int result = 0;     for (int i = 2; i &lt;= n; i++) {       result = (result + k) % i;     }     return result + 1;   }  }   결과  Link   설명     n명의 친구들끼리 원형 모양으로 앉아 아래의 규칙을 만족하는 게임을 수행 후 승자를 반환하는 문제이다.            i번째 친구에서 시계 방향으로 이동하면 1 &lt;= i &lt; n 을 만족하는 $i + 1$번째 친구로 이동하고, n번째 친구에서 시계 방향으로 이동하면 1번째 친구로 이동한다.       아래의 게임을 한 명이 남아 승리할 때 까지 반복한다.                    첫 번째 친구부터 시작하여 해당 친구를 포함하여 시계 방향으로 k명의 친구를 센다. 단, 동일한 친구를 두 번 이상 셀 수 있다.           마지막 세었던 친구는 게임에서 지고, 자리에서 떠난다.                                result는 승리할 친구의 위치를 저장할 변수로, 0으로 초기화한다.            게임의 최소 인원인 2부터 총 인원인 n 이하까지 i를 증가시키며, result에 현재 순서인 친구 위치인 result에 세어야 할 k를 더한 후 i로 나눈 나머지 값을 넣어준다.       반복이 완료되면 승리한 친구의 번호인 $result + 1$을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-the-winner-of-the-circular-game/",
        "teaser": null
      },{
        "title": "Leetcode Java Average Waiting Time",
        "excerpt":"문제  Link   코드  class Solution {    public double averageWaitingTime(int[][] customers) {     int time = 0;     double wait = 0;     for (int[] customer : customers) {       time = Math.max(time, customer[0]) + customer[1];       wait += time - customer[0];     }     return wait / customers.length;   }  }   결과  Link   설명     customers를 이용하여 모든 고객의 평균 대기 시간을 구하는 문제이다.            customers[i] = [arrivali, timei] 로, 각 값은 아래를 의미한다.                    arrivali는 i번째 고객의 도착 시간을 의미한다.           timei는 i번째 고객의 주문을 준비하는데 걸리는 시간을 의미한다.                       고객이 도착하면 요리사에게 바로 주문을 하고, 고객의 도착 순서대로 하나씩 요리한다.           문제 풀이에 필요한 변수를 정의한다.            time은 요리를 준비하는 시간을 저장할 변수로, 0으로 초기화한다.       wait는 요리를 준비하는데 걸리는 시간을 계산할 변수로, 실수형의 0으로 초기화한다.           customers의 각 값을 customer에 넣고 순차적으로 아래를 수행한다.            time에 time과 customer[0]의 값 중 큰 시작 시간에 customer[1]의 값인 요리하는데 걸리는 시간을 더해준다.       wait에 time과 customer[0]의 차잇값인 고객이 도착 후 요리를 받을 때 까지 걸리는 시간을 더해준다.           반복이 완료되면 저장된 wait에 customers의 길이를 나누어 평균 대기 시간을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/average-waiting-time/",
        "teaser": null
      },{
        "title": "Leetcode Java Crawler Log Folder",
        "excerpt":"문제  Link   코드  class Solution {    public int minOperations(String[] logs) {     int result = 0;     for (String log : logs) {       switch (log) {         case \"../\": result = Math.max(0, --result); break;         case \"./\": break;         default: result++; break;       }     }     return result;   }  }   결과  Link   설명          최상위 디렉토리에서 logs의 커맨드를 순차적으로 모두 입력했을 때, 위치한 폴더의 깊이를 반환하는 문제이다.            result는 위치한 폴더의 깊이를 저장할 변수로, 초기 위치인 0으로 초기화한다.       logs의 각 값을 log에 넣어 순차적으로 아래를 수행한다.            log가 “../”인 경우, 최상위 디렉토리의 위치인 0과 result에서 1 감소한 값 중 큰 값을 넣어준다.       log가 “./”인 경우, 무시하고 다음 반복을 수행한다.       그 외의 모든 경우에는 하위 폴더로 이동하므로, result를 증가시켜준다.           반복이 완료되면 깊이가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/crawler-log-folder/",
        "teaser": null
      },{
        "title": "Leetcode Java Reverse Substrings Between Each Pair of Parentheses",
        "excerpt":"문제  Link   코드  class Solution {    private int index;    public String reverseParentheses(String s) {     this.index = 0;     return this.reverseParentheses(s.toCharArray());   }    private String reverseParentheses(char[] charArray) {     StringBuilder sb = new StringBuilder();     while (this.index &lt; charArray.length) {       switch (charArray[this.index]) {         case ')': this.index++; return sb.reverse().toString();         case '(': this.index++; sb.append(this.reverseParentheses(charArray)); break;         default: sb.append(charArray[this.index++]); break;       }     }     return sb.toString();   }  }   결과  Link   설명          문자열 s를 괄호 안 문자열을 순서대로 거꾸로 문자열을 만들어 괄호가 제거된 상태로 반환하는 문제이다.            전역 변수인 index는 문자열 s의 위치를 저장할 변수이다.            index를 0으로 초기화하고 4번에서 정의한 reverseParentheses(char[] charArray) 메서드에 s를 문자 배열로 변환하여 수행한 결과를 반환한다.            재귀 호출을 통해 문자열을 생성할 reverseParentheses(char[] charArray) 메서드를 정의한다.             sb는 동적으로 문자열 생성하기 위한 변수로, StringBuilder로 초기화한다.       index가 charArray의 길이 미만까지 아래를 바놉ㄱ한다.                    charArray[index]가 ‘)’ 문자이면 문자열의 끝이므로, index를 증가시키고 sb를 거꾸로 반전시킨 문자열로 변환하여 반환한다.           charArray[index]가 ‘(‘ 문자이면 문자열의 시작이므로, index를 증가시키고 sb에 재귀 호출한 결과를 넣어준다.           그 외의 문자인 경우, sb에 charArray[index]의 문자를 넣고 index를 증가시켜준다.                       반복이 완료되면 sb를 문자열로 변환하여 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reverse-substrings-between-each-pair-of-parentheses/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Score From Removing Substrings",
        "excerpt":"문제  Link   코드  class Solution {    public int maximumGain(String s, int x, int y) {     StringBuilder sb = new StringBuilder(s);     if (x &gt; y) {       return this.maximumGain(sb, \"ab\", x) + this.maximumGain(sb, \"ba\", y);     } else {       return this.maximumGain(sb, \"ba\", y) + this.maximumGain(sb, \"ab\", x);     }   }    private int maximumGain(StringBuilder sb, String keyword, int point) {     int result = 0;     int i = 0;     for (int j = 0; j &lt; sb.length(); j++) {       sb.setCharAt(i++, sb.charAt(j));       if (i &gt; 1 &amp;&amp; keyword.equals(sb.substring(i - 2, i))) {         i -= 2;         result += point;       }     }     sb.setLength(i);     return result;   }  }   결과  Link   설명     문자열 s에서 아래 규칙대로 수행하여 발생할 수 있는 최대 점수를 구하는 문제이다.            s에서 “ab” 문자열을 제거하는 경우, x 점수를 얻는다.       s에서 “ba” 문자열을 제거하는 경우, y 점수를 얻는다.                sb는 동적으로 문자열 제거를 위한 변수로, StringBuilder에 s를 넣어 초기화한다.            x가 y보다 크면 “ab”를 변환한 점수가 더 크므로 “ab” -&gt; “ba” 순으로, 아니면 “ba”를 변환한 점수가 더 크거나 같으므로 “ba” -&gt; “ab” 순으로 4번에서 정의한 maximumGain(StringBuilder sb, String keyword, int point) 메서드를 수행한 결과를 주어진 문제의 결과로 반환한다.       문자열에서 키워드별 점수를 계산하기 위한 maximumGain(StringBuilder sb, String keyword, int point) 메서드를 정의한다.            점수 계산에 필요한 변수를 정의한다.                    result는 점수의 합계를 위한 변수로, 0으로 초기화한다.           i는 수정한 문자열의 마지막 위치를 저장할 변수로, 0으로 초기화한다.                       0부터 sb의 길이 미만까지 j를 증가시키면서 아래를 수행한다.                    sb의 i번째 위치에 j번째 문자를 넣어 순서를 당겨주고 i를 증가시켜준다.           i가 1 초과이면서 keyword와 sb의 $i - 2$ 위치의 두 문자가 동일하면, i를 2 감소시켜 해당 문자열을 삭제하고 result에 point를 더해 점수를 계산해준다.                       반복이 완료되면 sb에 최종 문자열 길이인 i를 넣어 문자열을 수정해주고, 계산된 점수인 result를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-score-from-removing-substrings/",
        "teaser": null
      },{
        "title": "Leetcode Java Robot Collisions",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; survivedRobotsHealths(int[] positions, int[] healths, String directions) {     int length = positions.length;     Integer[] indices = new Integer[length];     for (int i = 0; i &lt; length; i++) {       indices[i] = i;     }     Arrays.sort(indices, (l, r) -&gt; Integer.compare(positions[l], positions[r]));     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();     for (int curr : indices) {       if (directions.charAt(curr) == 'R') {         stack.push(curr);       } else {         while (!stack.isEmpty() &amp;&amp; healths[curr] &gt; 0) {           int top = stack.pop();           if (healths[top] &gt; healths[curr]) {             healths[top] -= 1;             healths[curr] = 0;             stack.push(top);           } else if (healths[top] &lt; healths[curr]) {             healths[curr] -= 1;             healths[top] = 0;           } else {             healths[curr] = 0;             healths[top] = 0;           }         }       }     }     for (int health : healths) {       if (health &gt; 0) {         result.add(health);       }     }     return result;   }  }   결과  Link   설명     직선 상 로봇의 각 위치를 나타내는 positions과 체력을 나타내는 healths을 이용하여 directions로 각각 이동을 할 때, 남아있는 로봇의 상태를 반환하는 문제이다.            두 로봇이 충돌하면 체력이 높은 로봇이 살아남으며, 살아남은 로봇의 체력은 1 차감된다.           문제 풀이에 필요한 변수를 정의한다.            length는 로봇의 수를 저장할 변수로, positions의 길이로 초기화한다.       indices는 로봇의 위치를 저장할 변수로, length까지 각 값을 넣어주고 positions를 이용하여 로봇의 상대적 위치를 순서대로 넣어준다.       result는 남아있는 로봇의 상태를 저장할 변수로, ArrayList로 초기화한다.       stack은 로봇의 이동에 사용될 변수로, Stack으로 초기화한다.           indices를 순차적으로 curr에 넣어 아래를 수행한다.            directions의 curr번째 문자가 ‘R’인 우측으로 이동하는 경우, stack에 curr을 넣어준다.       directions의 curr번째 문자가 ‘L’인 좌측으로 이동하는 경우, stack이 비어있지 않고 healths[curr]의 값이 0 초과일 때 까지 아래를 반복한다.                    top에 stack에서 로봇 위치 값을 넣어준다.           healths[top]의 값이 healths[curr]의 값보다 크면 top번째 로봇이 살아남으므로, healths[top]의 값을 감소시키고 healths[curr]의 위치에 0을 넣어준 후 stack에 다시 top을 넣어준다.           healths[top]의 값이 healths[curr]의 값보다 작으면 curr번째 로봇이 살아남으므로, healths[curr]의 값을 감소시키고 healths[top]의 위치에 0을 넣어준다.           healths[top]의 값이 healths[curr]의 값과 같으면 두 로봇은 같이 죽으므로, healths의 두 위치 값에 0을 넣어준다.                           healths의 각 값을 순차적으로 반복하여 0 초과인 경우에 result에 넣어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/robot-collisions/",
        "teaser": null
      },{
        "title": "Leetcode Java Create Binary Tree From Descriptions",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public TreeNode createBinaryTree(int[][] descriptions) {     Map&lt;Integer, TreeNode&gt; map = new HashMap&lt;&gt;();     Set&lt;Integer&gt; children = new HashSet&lt;&gt;();     for (int[] description : descriptions) {       int parent = description[0];       int child = description[1];       int isLeft = description[2];       children.add(child);       TreeNode node = map.getOrDefault(parent, new TreeNode(parent));       if (isLeft == 1) {         node.left = map.getOrDefault(child, new TreeNode(child));         map.put(child, node.left);       } else {         node.right = map.getOrDefault(child, new TreeNode(child));         map.put(child, node.right);       }       map.put(parent, node);     }     for (int[] description : descriptions) {       if (!children.contains(description[0])) {         return map.get(description[0]);       }     }     return null;   }  }   결과  Link   설명     2차원 정수 배열인 descriptions가 주어지면 아래의 규칙에 따라 TreeNode를 만들어 반환하는 문제이다.            descriptions[i] = [parenti, childi, isLefti] 를 만족한다.       TreeNode 내 parenti는 childi의 고유한 부모를 나타낸다.       isLefti가 1이면 부모 노드의 좌측, 0이면 부모 우측 노드임을 나타낸다.           문제 풀이에 필요한 변수를 정의한다.            map은 각 값에 대한 노드를 저장할 변수로, HashMap으로 초기화한다.       children은 각 값들이 자식 노드에 대한 값인지 저장할 변수로, 중복을 제거하기 위하여 HashSet으로 초기화한다.           descriptions의 각 값들을 description에 순차적으로 넣어 아래를 수행한다.            문제 풀이에 필요한 변수를 정의한다.                    parent, child, isLeft에 description의 각 값들을 순서대로 넣어준다.           node는 부모 노드를 저장할 변수로, map에서 parent에 해당하는 노드를 꺼내 넣어주고, 존재하지 않으면 새 TreeNode를 parent 값으로 초기화하여 넣어준다.                       children에 child를 넣어 자식 노드의 값을 추가해준다.       isLeft가 1이면 node의 left에, 0이면 node의 right에 map에서 child에 해당하는 노드가 존재하면 꺼내 넣어주고, 존재하지 않으면 새 TreeNode를 child 값으로 초기화하여 넣어 준다.       위의 각 경우에 따른 node를 map 내 child의 값으로 저장시켜준다.       map 내 parent의 값으로 node를 저장시켜준다.           위의 반복이 완료되면 다시 descriptions 내 각 배열들의 첫 번째 값이 children에 존재하지 않은 값을 찾아 map에서 해당 노드를 찾아 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/create-binary-tree-from-descriptions/",
        "teaser": null
      },{
        "title": "Leetcode Java Step-By-Step Directions From a Binary Tree Node to Another",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public String getDirections(TreeNode root, int startValue, int destValue) {     StringBuilder start = new StringBuilder();     StringBuilder dest = new StringBuilder();     this.findPaths(root, startValue, start);     this.findPaths(root, destValue, dest);     int count = 0;     for (int i = start.length(), j = dest.length(); i &gt; 0 &amp;&amp; j &gt; 0 &amp;&amp; start.charAt(i - 1) == dest.charAt(j - 1); i--, j--) {       count++;     }     return \"U\".repeat(start.length() - count) + dest.reverse().substring(count).toString();   }    private boolean findPaths(TreeNode node, int value, StringBuilder sb) {     if (node.val == value) {       return true;     } else if (node.left != null &amp;&amp; this.findPaths(node.left, value, sb)) {       sb.append(\"L\");     } else if (node.right != null &amp;&amp; this.findPaths(node.right, value, sb)) {       sb.append(\"R\");     }     return sb.length() &gt; 0;   }  }   결과  Link   설명     [1, n] 값을 가진 n개의 이진 트리 노드 root와 시작 위치 startValue, 목표 위치 destValue를 이용하여 시작 노드에서 목표 노드까지 가장 짧은 경로로 이동하기 위한 아래의 명령어를 반환하는 문제이다.            ‘L’은 노드에서 왼쪽 자식 노드로 가는 것을 의미한다.       ‘R’은 노드에서 오른쪽 자식 노드로 가는 것을 의미한다.       ‘U’는 노드에서 부모 노드로 가는 것을 의미한다.                start와 dest는 순차적으로 root노드에서 각각 startValue와 destValue로 도착하기 위한 경로를 만들 변수로, 모두 동적 문자열 생성을 위한 StringBuilder로 초기화한다.            3번의 findPaths(TreeNode node, int value, StringBuilder sb) 메서드에 root와 startValue, start 변수와 destValue, dest 변수를 넣어 각각 수행한다.       root 노드에서 각자 목표의 값으로 이동하기 위한 명령어 생성을 위한 findPaths(TreeNode node, int value, StringBuilder sb) 메서드를 초기화한다.            node의 val 값이 value이 목표 지점인 경우, true를 반환한다.       node의 left 노드가 null이 아니면서 해당 노드로 재귀 호출한 결과가 true이면 이동 가능하므로, sb에 ‘L’ 문자를 이어준다.       node의 right 노드가 null이 아니면서 해당 노드로 재귀 호출한 결과가 true이면 이동 가능하므로, sb에 ‘R’ 문자를 이어준다.       위의 모든 경우가 아니라면, sb가 0 초과인 이동한 이력이 있는지 여부를 반환한다.                위의 수행이 완료되면 count에 root에서 start와 dest가 만나는 depth를 계산하여 넣어준다.       아래의 두 문자열을 합쳐 주어진 문제의 결과로 반환한다.            startValue 위치에서는 root 방향으로 올라가야하므로, ‘U’ 문자를 start의 길이에서 count를 뺀 횟수만큼 반복한 문자열을 먼저 위치한다.       destValue 위치에서는 startValue가 내려올 위치를 저장해야 하므로, 아래의 문자열을 뒤에 이어준다.                    root 방향으로 올라가기 위한 방향인 ‘L’과 ‘R’ 문자가 저장된 dest를 역순으로 변환한다.           startValue가 root로 이동하다 destValue로 내려가는 위치인 노드에서 count번 이동하므로, 위의 역순 변환된 문자열의 count 위치 이후의 문자들을 문자열로 만들어준다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/step-by-step-directions-from-a-binary-tree-node-to-another/",
        "teaser": null
      },{
        "title": "Leetcode Java Decrease Elements To Make Array Zigzag",
        "excerpt":"문제  Link   코드  class Solution {    public int movesToMakeZigzag(int[] nums) {     int[] result = new int[2];     int length = nums.length;     for (int i = 0, left = 0, right = 0; i &lt; length; i++) {       left = i &gt; 0 ? nums[i - 1] : 1001;       right = i + 1 &lt; length ? nums[i + 1] : 1001;       result[i % 2] += Math.max(0, nums[i] - Math.min(left, right) + 1);     }     return Math.min(result[0], result[1]);   }  }   결과  Link   설명     nums를 아래의 조건을 만족하는 지그재그 형태로 값을 변경 할 때, 걸리는 최소 횟수를 구하는 문제이다.            모든 짝수 인덱스 값은 인접한 값들보다 크다, $A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; …$를 만족한다.       혹은 모든 홀수 인덱스 값은 인접한 값들보다 크다, $A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; …$를 만족한다.           문제 풀이에 필요한 변수를 정의한다.            result는 지그재그 형태로 값을 넣어가며 값 변경 횟수 계산을 수행할 변수로, 2 크기의 정수 배열로 초기화한다.       length는 nums의 길이를 저장한 변수이다.           0부터 length 미만까지 i를 증가시키고, 지그재그 값을 저장할 left와 right는 0으로 초기화 하여 아래를 반복한다.            left에 i가 0보다 크면 nums의 $i - 1$번째 값을 넣어주고, 아니면 값의 상한인 1001을 넣어준다.       right에 $i + 1$이 length보다 작으면 nums의 $i + 1$번째 값을 넣어주고, 아니면 값의 상한인 1001을 넣어준다.       result의 $\\frac{i}{2}$ 몫의 해당하는 위치에 0과 nums[i]에 left와 right 중 작은 값을 뺀 후 1을 더한 값 중 큰 값을 넣어준다.           위의 반복이 완료되면 result의 두 값 중 가장 작은 횟수를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/decrease-elements-to-make-array-zigzag/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Good Leaf Nodes Pairs",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    private int result;    public int countPairs(TreeNode root, int distance) {     this.result = 0;     this.dfs(root, distance);     return this.result;   }    private int[] dfs(TreeNode root, int distance) {     if (root == null) {       return new int[distance + 1];     } else if (root.left == null &amp;&amp; root.right == null) {       int[] result = new int[distance + 1];       result[1]++;       return result;     } else {       int[] left = this.dfs(root.left, distance);       int[] right = this.dfs(root.right, distance);       for (int i = 1; i &lt; left.length; i++) {         for (int j = distance - 1; j &gt;= 0; j--) {           if (i + j &lt;= distance) {             this.result += left[i] * right[j];           }         }       }       int[] result = new int[distance + 1];       for (int i = result.length - 2; i &gt;= 1; i--) {         result[i + 1] = left[i] + right[i];       }       return result;     }   }  }   결과  Link   설명          이진 트리 노드인 root의 리프 노드에서 root 노드까지 distance 이하만큼의 거리를 가진 좋은 노드 쌍을 찾는 문제이다.            전역 변수인 result는 리프 노드 쌍을 계산할 변수로, 0으로 초기화한다.            4번에서 정의한 dfs(TreeNode root, int distance) 메서드를 수행해준다.       DFS 방식으로 리프 노드 쌍을 탐색할 dfs(TreeNode root, int distance)를 정의한다.            root가 null인 탐색이 불가능한 경우, $distance + 1$ 크기의 빈 배열을 반환한다.       root의 자식 노드가 없는 경우, $distance + 1$ 크기의 배열에 두 번째 값만 증가시킨 후 해당 배열을 반환한다.       위의 모든 경우가 아닌 경우, 아래를 수행한다.                    left와 right에 각 자식 노드를 이용하여 재귀 호출한 결과를 넣어준다.           1부터 left 길이 미만까지 i를 증가시키며, $distance - 1$부터 0 이상 까지 j를 감소시키며 전역 변수인 result에 좋은 노드 쌍의 갯수인 $left[i] \\times right[j]$의 값을 더해준다.           위의 수행이 완료되면 $distance + 1$ 크기의 정수 배열에 역순으로 left와 right의 처음부터 값의 합을 넣어준 후 해당 배열을 반환한다.                           4번의 수행이 완료되면 좋은 노드 쌍이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-good-leaf-nodes-pairs/",
        "teaser": null
      },{
        "title": "Leetcode Java Lucky Numbers in a Matrix",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; luckyNumbers(int[][] matrix) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     for (int i = 0; i &lt; matrix.length; i++) {       int index = this.getIndexOfMinValue(matrix[i]);       int value = matrix[i][index];       if (this.checkMaxValue(matrix, index, value)) {         result.add(value);       }     }     return result;   }    private int getIndexOfMinValue(int[] row) {     int index = 0;     for (int i = 1, min = row[index]; i &lt; row.length; i++) {       if (row[i] &lt; min) {         min = row[i];         index = i;       }     }     return index;   }    private boolean checkMaxValue(int[][] matrix, int i, int value) {     for (int[] row : matrix) {       if (row[i] &gt; value) {         return false;       }     }     return true;   }  }   결과  Link   설명          각자 다른 값을 가진 $m \\times n$ 크기의 2차원 배열이 주어지면 행의 최솟값이면서 열의 최댓값인 값을 모두 찾는 문제이다.            result는 결과를 저장할 변수로, ArrayList로 초기화한다.       0부터 matrix의 길이 미만까지 i를 증가시키며 아래를 반복한다.            index에 matrix[i]의 값 중 최솟값의 위치를 넣어준다.       value에 matrix[i][index]의 값을 넣어준다.       value가 matrix의 index번째 열의 최댓값이면 조건을 만족하므로, result에 value를 넣어준다.           반복이 완료되면 조건을 만족하는 값들을 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/lucky-numbers-in-a-matrix/",
        "teaser": null
      },{
        "title": "Leetcode Java Lucky Numbers in a Matrix",
        "excerpt":"문제  Link   코드  class Solution {    public String[] sortPeople(String[] names, int[] heights) {     int length = names.length;     Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();     for (int i = 0; i &lt; length; i++) {       map.put(heights[i], names[i]);     }     Arrays.sort(heights);     String[] result = new String[length];     for (int index = 0, i = length - 1; i &gt;= 0; i--, index++) {       result[index] = map.get(heights[i]);     }     return result;   }  }   결과  Link   설명          heights의 키를 이용하여 names를 키가 큰 사람 순서대로 정렬하여 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 names의 길이를 저장한 변수이다.       map은 사람 별 키를 저장할 변수로, 순차적으로 키와 이름을 쌍으로 넣어준다.       result는 정렬된 사람의 이름을 넣을 변수로, length 크기의 문자열 배열로 초기화한다.           index는 0으로, $length - 1$부터 0 이상일 때 까지 i를 감소시키고 index를 증가시키며 result[index]에 map에서 heights[i]의 값인 이름을 꺼내 넣어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sort-the-people/",
        "teaser": null
      },{
        "title": "Leetcode Java Sort Array by Increasing Frequency",
        "excerpt":"문제  Link   코드  class Solution {    public int[] frequencySort(int[] nums) {     int[] counts = new int[201];     for (int num : nums) {       counts[num + 100]++;     }     for (int i = nums.length - 1; i &gt;= 0;) {       int max = 0;       int index = -1;       for (int j = 0; j &lt; 201; j++) {         if (counts[j] &gt; max) {           max = counts[j];           index = j;         }       }       int num = index - 100;       while (max-- &gt; 0) {         nums[i--] = num;       }       counts[index] = 0;     }     return nums;   }  }   결과  Link   설명          [-100, 100] 범위의 값들 들어있는 nums 내 값의 갯수 별로 오름차순, 동일 갯수 내에서는 내림차순 순으로 값들을 정렬하여 반환하는 문제이다.            counts는 nums 내 숫자들의 갯수를 계산할 변수로, 값의 갯수인 201 크기의 정수 배열로 초기화하여 nums내 각 값들에 100을 더한 위치에 해당 숫자의 갯수를 넣어준다.       nums의 길이보다 1 작은 위치부터 0 이상일 때 까지 아래를 반복한다.            max와 index는 갯수의 최댓값과 위치를 저장할 변수로, counts의 모든 값들을 탐색하여 최댓갑과 해당 위치를 넣어준다.       nums의 i번째 위치에 i를 감소시키며 max번 $index - 100$인 변환 전의 값을 넣어준 후, counts[index]의 값을 0으로 바꿔준다.           반복이 완료되면 정렬된 nums를 주어진 문제의 결과로 반환한다.   해설     nums 내 값의 갯수가 큰 순으로 nums를 채우기 위해서, i는 nums의 거꾸로 시작한다.   동일한 값의 갯수가 발생하면 작은 순으로 nums를 채우기 위해서, j는 0부터 탐색하며 가장 많이 발생한 위치를 먼저 max와 index에 넣어준다.   위에서 발생한 순서대로 nums를 max번 반복해서 채워주고 counts[index]에 0을 넣음으로써, 해당 값은 다음 탐색에서 무시하게 된다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sort-array-by-increasing-frequency/",
        "teaser": null
      },{
        "title": "Leetcode Java Binary Tree Coloring Game",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public boolean btreeGameWinningMove(TreeNode root, int n, int x) {     if (root == null) {       return false;     } else if (root.val == x) {       int left = this.getCount(root.left);       int right = this.getCount(root.right);       int parent = n - (left + right + 1);       return parent &gt; (left + right) || left &gt; (parent + right) || right &gt; (left + parent);     } else {       return this.btreeGameWinningMove(root.left, n, x) || this.btreeGameWinningMove(root.right, n, x);     }   }    private int getCount(TreeNode node) {     if (node == null) {       return 0;     } else {       return this.getCount(node.left) + this.getCount(node.right) + 1;     }   }  }   결과  Link   설명     [1, n]개의 노드가 존재하는 root를 이용하여 아래의 각 턴제 게임을 수행할 때, 이길 수 있는지 검증하는 문제이다.            상대 플레이어가 먼저 [1, n] 사이의 노드를 색칠하고, 동일한 노드를 제외한 노드를 색칠한다.       각 차례에서 각자 색칠한 노드에서 색칠되지 않은 이웃 노드(자식, 부모 노드) 중 하나를 선택 색칠 하여 더 이상 색칠할 수 없는 노드들이 존재하면, 색칠한 노드가 많으면 게임에서 이긴다.                root가 null인 경우, false를 반환한다.       위의 경우가 아니면서, root의 val 값이 x인 경우 아래를 검증한 결과를 반환한다.            left와 right의 각 노드의 자식 노드들 갯수를 넣어준다.       parent는 $n - (left + right + 1)$의 결과인 현재 노드 이하를 제외한 잔여 노드의 수를 넣어준다.       left, right, parent 중 어떤 하나의 값이 다른 두 값보다 큰 이길 가능성이 있으면 true를, 아니면 false를 반환한다.           위의 각 경우가 아니라면 root의 left와 right 노드를 이용하여 재귀 호출한 결과가 하나라도 만족하면 true를, 아니면 false를 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/binary-tree-coloring-game/",
        "teaser": null
      },{
        "title": "Leetcode Java Find the City With the Smallest Number of Neighbors at a Threshold Distance",
        "excerpt":"문제  Link   코드  class Solution {    public int findTheCity(int n, int[][] edges, int distanceThreshold) {     int[][] distance = new int[n][n];     int result = 0;     int min = n;     for (int[] row : distance) {       Arrays.fill(row, 10001);     }     for (int[] edge : edges) {       distance[edge[0]][edge[1]] = distance[edge[1]][edge[0]] = edge[2];     }     for (int i = 0; i &lt; n; i++) {       distance[i][i] = 0;     }     for (int k = 0; k &lt; n; k++) {       for (int i = 0; i &lt; n; i++) {         for (int j = 0; j &lt; n; j++) {           distance[i][j] = Math.min(distance[i][j], distance[i][k] + distance[k][j]);         }       }     }     for (int i = 0; i &lt; n; i++) {       int count = 0;       for (int j = 0; j &lt; n; j++) {         if (distance[i][j] &lt;= distanceThreshold) {           count++;         }       }       if (count &lt;= min) {         result = i;         min = count;       }     }     return result;   }  }   결과  Link   설명     n개의 도시간 연결 정보가 있는 edges를 이용하여, 도시 간 이동이 distanceThreshold 이내로 이동하여 도달할 수 있는 가장 적은 도시 중 큰 숫자의 도시를 반환하는 문제이다.            edges[i] = [fromi, toi, weighti] 로, from번째 도시에서 to번째 도시까지 거리가 weight임 의미한다.           문제 풀이에 필요한 변수를 정의한다.            distance는 Floyd Warshall 알고리즘을 이용하여 거리를 계산하기 위한 변수로, $n \\times n$ 크기의 2차원 정수 배열로 초기화 후 아래를 수행한다.                    distance의 모든 위치에 최댓값인 10000 보다 1 큰 10001을 넣어준다.           edges의 각 값들을 이용하여 distance[edge[0]][edge[1]], distance[edge[1]][edge[0]] 두 위치에 거리인 edge[2] 값을 넣어준다.           자기 자신으로 가는 경우인 출발지와 도착지가 동일한 경우, 값을 0으로 초기화해준다.           노드의 경유를 고려하여 i번째 도시에서 j번째 도시로 가는 distance[i][j]와 k를 경유하는 경우인 $distance[i][k] + distance[k][j]$ 중 최단 거리를 넣어준다.                       result는 결과를 저장하기 위한 변수로, 0으로 초기화한다.       최솟값을 저장하기 위한 min을 가능한 최대 도시의 값인 n으로 초기화한다.           0부터 n 미만까지 i를 증가시키면서 아래를 반복한다.            count는 각 도시로 이동 가능한 도시의 갯수를 저장할 변수로, 0으로 초기화한다.       0부터 n 미만까지 j를 증가시키면서 distance[i][j]의 값이 distanceThreshold 이하인 도시의 갯수를 계산한다.       count가 min 이하이면 result에 i를, min에 count를 넣어 준다.           반복이 완료되면 이동 가능한 도시가 적으면서 도시의 숫자가 가장 큰 result를 주어진 문제의 결과로 반환한다.   해설     여느 문제와 같이 도시의 숫자가 작은 값부터 이동 가능한 도시의 갯수가 동일한 경우를 포함하는 이유는, 문제의 조건인 도시의 숫자가 큰 경우만 남기기 위함이다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Cost to Convert String I",
        "excerpt":"문제  Link   코드  class Solution {    public long minimumCost(String source, String target, char[] original, char[] changed, int[] cost) {     long result = 0;     long[][] costs = new long[26][26];     for (long[] row : costs) {       Arrays.fill(row, Integer.MAX_VALUE);     }     for (int i = 0; i &lt; original.length; i++) {       int num1 = original[i] - 'a';       int num2 = changed[i] - 'a';       costs[num1][num2] = Math.min(costs[num1][num2], cost[i]);     }     for (int i = 0; i &lt; 26; i++) {       costs[i][i] = 0;     }     for (int k = 0; k &lt; 26; k++) {       for (int i = 0; i &lt; 26; i++) {         for (int j = 0; j &lt; 26; j++) {           costs[i][j] = Math.min(costs[i][j], costs[i][k] + costs[k][j]);         }       }     }     for (int i = 0; i &lt; source.length(); i++) {       int num1 = source.charAt(i) - 'a';       int num2 = target.charAt(i) - 'a';       if (num1 == num2) {         continue;       }       if (costs[num1][num2] == Integer.MAX_VALUE) {         return -1L;       } else {         result += costs[num1][num2];       }     }     return result;   }  }   결과  Link   설명     source 문자열을 target 문자열로 변경할 때 발생하는 최소 비용을 계산하는 문제이다.            original[i] 문자를 changed[i] 문자로 바꿀 때 발생하는 비용은 cost[i] 이다.       source 문자열을 target 문자열로 변경이 불가능한 경우, -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            result는 결과를 저장하기 위한 변수로, 0으로 초기화한다.       costs Floyd Warshall 알고리즘을 이용하여 거리를 계산하기 위한 변수로, 문자열의 갯수인 26을 이용하여 $26 \\times 26$ 크기의 2차원 정수 배열로 초기화 후 아래를 수행한다.                    costs의 모든 위치에 정수의 최댓값을 넣어준다.           original과 changed를 costs의 위치에 현재 값과 cost 값 중 작은 값을 넣어준다.           자기 자신의 값을 변경하는 경우의 위치에는 값을 0으로 초기화해준다.           값을 여러 번 바꿔 비용이 발생하는 경우를 위해서 costs[i][j]에 기존 비용인 자기 자신의 값과 k번째 문자를 거쳐 바꿔지는 경우인 $costs[i][k] + costs[k][j]$ 중 최소 비용을 넣어준다.                           0부터 26 미만까지 i를 증가시키면서 아래를 반복한다.            source의 i번째 문자가 target의 i번째 문자와 동일하면 바꿀 필요가 없으므로, 다음 반복을 수행한다.       costs의 source의 i번째 문자 순서와 target의 i번째 문자 순서의 값이 동일하여 변경이 불가능한 경우, -1을 주어진 문제의 결과로 반환한다.       costs의 source의 i번째 문자 순서와 target의 i번째 문자 순서의 값이 동일하여 변경이 가능한 경우, result에 해당 값을 더해준다.           반복이 완료되면 최소 비용인 result를 주어진 문제의 결과로 반환한다.   해설     여느 문제와 같이 도시의 숫자가 작은 값부터 이동 가능한 도시의 갯수가 동일한 경우를 포함하는 이유는, 문제의 조건인 도시의 숫자가 큰 경우만 남기기 위함이다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-cost-to-convert-string-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Number of Teams",
        "excerpt":"문제  Link   코드  class Solution {    public int numTeams(int[] rating) {     int length = rating.length;     int[][] dp = new int[length][2];     int result = 0;     for (int i = 1; i &lt; length; i++) {       for (int j = 0; j &lt; i; j++) {         if (rating[i] &gt; rating[j]) {           dp[i][0]++;           result += dp[j][0];         } else {           dp[i][1]++;           result += dp[j][1];         }       }     }     return result;   }  }   결과  Link   설명     각 고유한 등급이 저장된 rating을 이용하여 아래의 규칙을 만족하는 팀의 갯수를 계산하는 문제이다.            한 팀은 세 병사로 구성된다.       0 &lt;= i &lt; j &lt; k &lt; n 의 세 값인 i, j, k는 $rating[i] &lt; rating[j] &lt; rating[k]$ 혹은 $rating[i] &gt; rating[j] &gt; rating[k]$을 만족한다.           문제 풀이에 필요한 변수를 정의한다.            length는 rating의 길이로 저장한 변수이다.       dp는 팀의 갯수를 계산하기 위해 사용할 배열로, $length \\times 2$ 크기의 2차원 정수 배열로 초기화한다.       result는 팀의 갯수를 저장할 변수로, 0으로 초기화한다.           1부터 length 미만까지 i를 증가시키고, 0부터 i 미만까지 j를 증가시키며 아래를 수행한다.            rating[i]가 rating[j]보다 큰 경우, 아래를 수행한다.                    dp[i][0]을 증가시켜 i 위치 아래로 작은 값의 갯수를 증가시켜준다.           result에 rating[j]보다 작은 rating[k]가 가능한 갯수인 dp[j][0]의 값을 더해준다.                       rating[i]가 rating[j]보다 작은 경우, 아래를 수행한다.                    dp[i][1]을 증가시켜 i 위치 아래로 큰 값의 갯수를 증가시켜준다.           result에 rating[j]보다 큰 rating[k]가 가능한 갯수인 dp[j][1]의 값을 더해준다.                           반복이 완료되면 가능한 팀의 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-number-of-teams/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Deletions to Make String Balanced",
        "excerpt":"문제  Link   코드  class Solution {    public int minimumDeletions(String s) {     int result = 0;     int count = 0;     for (char c : s.toCharArray()) {       if (c == 'b') {         count++;       } else {         result = Math.min(result + 1, count);       }     }     return result;   }  }   결과  Link   설명     s의 문자열을 아래의 조건을 만족하는 문자열로 바꿀 최소 횟수를 계산하는 문제이다.            i &lt; j 를 만족할 때, s[i] = ‘b’ 이고 s[j] = ‘a’ 인 문자열이 없어야 한다.           문제 풀이에 필요한 변수를 정의한다.            result는 최소 횟수를 저장할 변수로, 0으로 초기화한다.       count는 a로 변환할 갯수를 계산할 변수로, 0으로 초기화한다.           s의 각 문자들을 처음부터 c에 넣어 아래를 수행한다.            c가 ‘b’ 문자인 경우, ‘a’로 변환하는 횟수인 count를 증가시켜준다.       c가 ‘a’ 문자인 경우, result에 ‘b’로 변환하는 경우로 result를 증가시킨 값과 변환시키지 않고 ‘a’로 변환된 갯수인 count 중 작은 값을 넣어준다.           반복이 완료되면 최소 횟수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-deletions-to-make-string-balanced/",
        "teaser": null
      },{
        "title": "Leetcode Java Snapshot Array",
        "excerpt":"문제  Link   코드  class SnapshotArray {    private TreeMap&lt;Integer, Integer&gt;[] snapshotArray;   private int snapId;    @SuppressWarnings(\"unchecked\")   public SnapshotArray(int length) {     this.snapshotArray = new TreeMap[length];     for (int i = 0; i &lt; length; i++) {       this.snapshotArray[i] = new TreeMap&lt;Integer, Integer&gt;();       this.snapshotArray[i].put(0, 0);     }   }    public void set(int index, int val) {     this.snapshotArray[index].put(this.snapId, val);   }    public int snap() {     return this.snapId++;   }    public int get(int index, int snap_id) {     return this.snapshotArray[index].floorEntry(snap_id).getValue();   }  }  /**  * Your SnapshotArray object will be instantiated and called as such:  * SnapshotArray obj = new SnapshotArray(length);  * obj.set(index,val);  * int param_2 = obj.snap();  * int param_3 = obj.get(index,snap_id);  */   결과  Link   설명     아래의 기능을 제공하는 SnapshotArray를 완성하는 문제이다.            생성자인 SnapshotArray(int length)는 length 크기의 배열을 가진 데이터 구조를 초기화한다.       메서드인 set(index, val)은 index번째 요소를 val 값으로 넣어준다.       메서드인 snap()은 배열의 스냅샷을 생성하고 생성한 횟수에서 1뺀 값인 snap_id를 반환한다.       메서드인 get(index, snap_id)은 index번째 배열의 snap_id에 해당하는 값을 반환한다.           SnapshotArray의 기능을 수행하기 위한 전역 변수를 정의한다.            snapshotArray는 index번째 요소 별 스냅샷을 찍은 결과를 저장할 변수이다.       snapId는 스냅샷을 찍은 횟수를 저장할 변수이다.           생성자인 SnapshotArray(int length)를 완성한다.            전역 변수인 snapshotArray에 length 크기의 TreeMap으로 초기화한다.       snapshotArray의 모든 값에 TreeMap을 넣고 키와 값이 0인 초기값을 넣어준다.           메서드인 set(index, val)을 완성한다.            snapshotArray의 index번째 TreeMap에 snapId가 키인 위치에 val을 넣어준다.           메서드인 snap()을 완성한다.            snapId인 스냅샷을 찍은 횟수를 증가시켜준다.           메서드인 get(index, snap_id)을 완성한다.            snapshotArray의 index번째 TreeMap에 snap_id와 같거나 작은 값이 키인 값을 가져와 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/snapshot-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Senior Citizens",
        "excerpt":"문제  Link   코드  class Solution {    public int countSeniors(String[] details) {     int result = 0;     for (String detail : details) {       char ten = detail.charAt(11);       if (ten &gt; '6' || (ten == '6' &amp;&amp; detail.charAt(12) &gt; '0')) {         result++;       }     }     return result;   }  }   결과  Link   설명     details의 승객 정보를 이용하여 60세 초과인 승객 수를 계산하는 문제이다.            승객 정보의 처음 10자리는 핸드폰 번호를 의미한다.       승객 정보의 다음 문자는 성별을 의미한다.       승객 정보의 다음 두 문자는 나이를 의미한다.       승객 정보의 마지막 두 문자는 좌석을 의미한다.                result는 60세 초과인 승객의 수를 계산할 변수로, 0으로 초기화한다.       details의 각 값을 차례대로 detail에 넣어 아래를 수행한다.            ten은 10의 자리에 해당하는 값을 저장할 변수로, detail의 11번째 위치 문자를 넣어준다.       ten이 ‘6’ 초과인 70세 이상이거나 ‘6’이면서 1의 자리에 해당하는 detail의 12번째 위치 문자가 ‘0’ 초과인 경우, result를 증가시켜준다.           반복이 완료되면 계산된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-senior-citizens/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Swaps to Group All 1's Together II",
        "excerpt":"문제  Link   코드  class Solution {    public int minSwaps(int[] nums) {     int length = nums.length;     int ones = 0;     for (int num : nums) {       if (num == 1) {         ones++;       }     }     int max = 0;     for (int i = 0, count = 0; i &lt; length + ones; i++) {       if (i &gt;= ones &amp;&amp; nums[i - ones] == 1) {         count--;       }       if (nums[i % length] == 1) {         count++;       }       max = Math.max(max, count);     }     return ones - max;   }  }   결과  Link   설명          nums 내 1의 값들을 각자 뭉쳐있게 재배치하기 위한 최소 이동 횟수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       ones는 nums내 1의 갯수를 저장할 변수로, nums를 반복하여 1의 갯수를 넣어준다.       max는 Sliding Window 방식으로 Window 내 1의 최대 갯수를 저장할 변수로, 0으로 초기화한다.           0부터 length 미만까지 i를 증가시키며, 범위 내 1의 갯수인 count는 0으로 초기화하여 아래를 반복한다.            i가 ones 이상이면서 nums[$i - ones$]의 값이 1인 연결된 1의 갯수가 ones와 동일한 경우, count를 감소시켜준다.       nums의 $\\frac{i}{length}$의 나머지 값에 해당하는 값이 1인 Window 내 1의 갯수가 증가하는 경우, count를 증가시켜준다.       max에 max와 count 중 큰 값인 Window 내 1의 최대 갯수를 넣어준다.           반복이 완료되면 조건을 만족하기 위해 1과 0을 스왑해야 하는 최소 횟수인 $ones - max$를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-swaps-to-group-all-1s-together-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Make Two Arrays Equal by Reversing Subarrays",
        "excerpt":"문제  Link   코드  class Solution {    public boolean canBeEqual(int[] target, int[] arr) {     int[] counts = new int[1001];     for (int i = 0; i &lt; target.length; i++) {       counts[target[i]]++;       counts[arr[i]]--;     }     for (int count : counts) {       if (count != 0) {         return false;       }     }     return true;   }  }   결과  Link   설명          arr 배열로 target 배열과 동일한 형태로 만들 수 있는지 검증하는 문제이다.       counts는 target과 arr 배열 내 값들의 갯수를 계산하기 위한 변수로, 최댓값인 1000보다 1 큰 크기의 정수 배열로 초기화하고 아래를 수행한다.            target 배열 내 값에 해당하는 위치의 값을 각각 증가시켜준다.       arr 배열 내 값에 해당하는 위치의 값을 각각 감소시켜준다.                counts 내 모든 값이 0이 아닌 경우, 변환이 불가능하므로 false를 주어진 문제의 결과로 반환한다.       반복이 완료되면 변환이 가능하므로 true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/make-two-arrays-equal-by-reversing-subarrays/",
        "teaser": null
      },{
        "title": "Leetcode Java Range Sum of Sorted Subarray Sums",
        "excerpt":"문제  Link   코드  class Solution {    public int rangeSum(int[] nums, int n, int left, int right) {     int mod = 1000000007;     int result = 0;     Queue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;(n, (p1, p2) -&gt; p1[0] - p2[0]);     for (int i = 0; i &lt; n; i++) {       queue.offer(new int[] { nums[i], i });     }     for (int i = 1; i &lt;= right; i++) {       int[] pair = queue.poll();       if (i &gt;= left) {         result = (result + pair[0]) % mod;       }       if (pair[1] &lt; n - 1) {         pair[1]++;         pair[0] = (pair[0] + nums[pair[1]]) % mod;         queue.offer(pair);       }     }     return result;   }  }   결과  Link   설명     n 크기의 nums를 이용하여 모든 부분 배열의 합을 계산하여 오름차순으로 정렬하여 $n \\times \\frac{n + 1}{2}$의 새 배열로 만들 때, [left, right] 범위 내 값들의 합을 반환하는 문제이다.            단, 답이 매우 클 수 있으므로 모듈러 $10^9 + 7$를 적용한 결과를 반환한다.           문제 풀이에 필요한 변수를 정의한다.            mod는 모듈러 $10^9 + 7$를 적용하기 위한 변수로, $10^9 + 7$ 값으로 초기화한다.       result는 결과를 저장할 변수로, 0으로 초기화한다.       queue는 반복을 통해 부분 배열을 생성하기 위한 변수로, 오름차순으로 정렬해서 저장하기 위해 n 크기의 PriorityQueue로 초기화하고 nums의 각 값을 순차적으로 값과 위치를 배열로 넣어준다.           1부터 right 미만까지 i를 증가시키며 아래를 수행한다.            pair에 queue에서 값을 꺼내 넣어준다.       i가 left 이상인 경우, result에 pair의 값을 더해 mod로 나눈 나머지 값을 넣어준다.       pair[1]의 값이 $n - 1$인 범위 내인 경우, 아래를 수행한다.                    pair[1]인 위치 값을 증가시켜준다.           pair[0]인 값의 위치에 pair[0]과 nums[pair[1]]의 값을 더해준 후 mod로 나눈 값을 넣어준다.           queue에 수정된 pair를 다시 넣어준다.                           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/range-sum-of-sorted-subarray-sums/",
        "teaser": null
      },{
        "title": "Leetcode Java Kth Distinct String in an Array",
        "excerpt":"문제  Link   코드  class Solution {    public String kthDistinct(String[] arr, int k) {     Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();     for (String s : arr) {       map.put(s, map.getOrDefault(s, 0) + 1);     }     for (String s : arr) {       if (map.get(s) == 1 &amp;&amp; --k == 0) {         return s;       }     }     return \"\";   }  }   결과  Link   설명          arr 내 고유하게 존재하는 k번째 문자열을 반환하는 문제이다.            map은 문자열의 갯수를 젖아할 변수로, HashMap으로 초기화하여 arr을 반복하여 s를 키로 arr 내 동일 문자열 갯수를 값으로 넣어준다.       arr의 값들을 s에 순차적으로 넣어 아래를 수행한다.            map에서 s의 값이 1인 고유 문자열이면서 k를 감소시킨 값이 0이 되는 k번째 문자열이면, s를 주어진 문제의 결과로 반환한다.           위의 반복이 완료되면 만족하는 문자열이 없으므로 빈 문자열(““)을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/kth-distinct-string-in-an-array/",
        "teaser": null
      },{
        "title": "Leetcode Minimum Number of Pushes to Type Word II",
        "excerpt":"문제  Link   코드  class Solution {    public int minimumPushes(String word) {     int[] counts = new int[26];     for (char c : word.toCharArray()) {       counts[c - 'a']++;     }     Arrays.sort(counts);     int result = 0;     for (int i = 25, multiplier = 1, count = 0; i &gt;= 0 &amp;&amp; counts[i] &gt; 0; i--) {       result += multiplier * counts[i];       count++;       if (count == 8) {         multiplier++;         count = 0;       }     }     return result;   }  }   결과  Link   설명     영문자로 이루어진 옛날 전화기 키패드를 이용하여 주어진 word를 입력하기 위한 횟수를 최소로 하기 위해 재배열하여 해당 횟수를 반환하는 문제이다.            일반적으로 영문 전화기 키패드는 아래와 같다.                                      1    2 abc    3 def           4 ghi    5 abc    6 def           7 pqrs    8 tuv    9 wxyz           *    0    #       &lt;/table&gt;      문제 풀이에 필요한 변수를 정의한다.            counts는 문자열의 갯수를 저장할 변수로, 26 크기의 정수 배열로 초기화하여 word 내 각 문자의 갯수를 계산하여 오름차순으로 정렬해준다.       result는 결과를 저장할 변수로, 0으로 초기화한다.           동일 버튼을 누르는 횟수를 계산할 multiplier는 1로, 문자열이 존재하는 버튼의 이동을 저장할 count는 0으로, i는 25부터 0 이상이면서 counts[i]의 갯수가 0 초과일 때 까지 아래를 반복한다.            result에 $multiplier * counts[i]$인 푸시 횟수를 더해준다.       count를 증가시켜 다음 버튼 위치로 이동시킨다.       count가 8인 다시 처음 버튼으로 이동해야 하는 경우, multiplier를 증가시켜 버튼을 누르는 횟수의 가중치를 증가시키고 count를 0으로 초기화한다.           반복이 완료되면 최소 푸시 횟수가 계산된 result를 주어진 문제의 결과로 반환한다.   해설     영문 전화기 키패드의 문자를 재배열 할 수 있으므로, 문자가 존재하는 2 ~ 9까지 버튼의 수인 8 기반으로 문자열을 재배치한다.   재배치는 한 번 눌러야 하는 위치에 많이 존재하는 문자를 순차적으로 넣어야 버튼을 누르는 횟수가 최소가 된다.   위를 바탕으로 8개 단위로 가중치를 둔 이유는, 각 숫자열 임의 위치에 순차적으로 앞의 한 번 눌러야 입력되는 문자에 넣고 다음 가중치에 다시 순차적으로 넣기 위함이다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-number-of-pushes-to-type-word-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Chunked Palindrome Decomposition",
        "excerpt":"문제  Link   코드  class Solution {    public int longestDecomposition(String text) {     int length = text.length();     for (int i = 0; i &lt; length / 2; i++) {       if (text.substring(0, i + 1).equals(text.substring(length - 1 - i, length))) {         return 2 + this.longestDecomposition(text.substring(i + 1, length - 1 - i));       }     }     return length == 0 ? 0 : 1;   }  }   결과  Link   설명     text가 주어지면 비어있지 않은 k개의 부분 문자열로 아래를 만족하는 최대 k를 구하는 문제이다.            text는 각 부분 문자열의 조합으로 완성할 수 있다.       1 &lt;= i &lt;= k를 만족할 때, i번째 부분 문자열은 $k - i + 1$번째 부분 문자열과 동일하다.           length에 text의 길이를 넣어준 후, 0부터 $\\frac{length}{2}$까지 i를 증가시키면서 아래를 반복한다.            text의 처음 위치부터 $i + 1$ 위치 미만까지 문자열과 $length - 1 - i$ 위치부터 마지막 위치까지 문자열이 동일한 두 번째 조건을 만족하는 경우, 아래의 두 값의 합을 반환한다.                    두 번째 조건을 만족하는 부분 문자열의 갯수인 2.           두 문자열 사이의 문자열을 재귀 호출한 결과.                           반복이 완료되면 length가 0인 text가 빈 문자열이면 0을, 아니면 하나의 부분 문자열이므로 1을 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-chunked-palindrome-decomposition/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Article Views I",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT DISTINCT viewer_id AS id FROM Views WHERE viewer_id = author_id ORDER BY viewer_id   결과  Link   설명          자기가 작성한 기사를 읽은 작성자의 아이디를 오름차순 반환하는 문제이다.            viewer_id와 author_id가 동일한 데이터의 중복을 제거한 viewer_id를 오름차순으로 정렬한다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/article-views-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Day of the Year",
        "excerpt":"문제  Link   코드  class Solution {    private static int[] DAYS = new int[] { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };    public int dayOfYear(String date) {     int months = Integer.parseInt(date.substring(5, 7));     int result = months &gt; 2 &amp;&amp; this.isLeapYears(Integer.parseInt(date.substring(0, 4))) ? 1 : 0;     for (int i = 0; i &lt; months - 1; i++) {       result += DAYS[i];     }     return result + Integer.parseInt(date.substring(8));   }    private boolean isLeapYears(int year) {     return year % 4 == 0 &amp;&amp; (year % 400 == 0 || year % 100 != 0);   }  }   결과  Link   설명          “YYYY-MM-DD” 날자 포멧으로 date가 주어지면 해당 연도의 몇 번째 일자인지 구하는 문제이다.            DAYS는 월별 기준 일수를 저장한 변수로 윤달인 경우를 제외하고 값을 넣어 저장한 변수이다.       문제 풀이에 필요한 변수를 정의한다.            months는 date의 월을 정수로 변환한 변수이다.       result는 해당 연도의 일자를 저장할 변수로, 아래의 각 경우에 따라 값을 초기화한다.                    months가 2보다 큰 윤달 일자가 포함되면서 date의 연도가 윤달에 해당하면 1로 초기화한다.           위의 경우가 아니라면 0으로 초기화한다.                                0부터 $months - 1$까지 i를 증가시키면서 result에 DAYS[i]의 값을 누계한다.       반복이 완료되면 result에 현재 일자를 더해서 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/day-of-the-year/",
        "teaser": null
      },{
        "title": "Leetcode Java Swap For Longest Repeated Character Substring",
        "excerpt":"문제  Link   코드  class Solution {    public int maxRepOpt1(String s) {     int[] counts = new int[26];     char[] charArray = s.toCharArray();     int length = charArray.length;     for (int i = 0; i &lt; length; i++) {       counts[charArray[i] - 'a']++;     }     int result = 0;     for (int i = 0; i &lt; length; i++) {       char curr = charArray[i];       int j = i;       int count = 0;       int diff = 0;       while (j &lt; length &amp;&amp; (curr == charArray[j] || diff == 0) &amp;&amp; count &lt; counts[curr - 'a']) {         if (curr != charArray[j]) {           diff++;         }         count++;         j++;       }       if (count &lt; counts[charArray[i] - 'a'] &amp;&amp; diff == 0) {         count++;       }       result = Math.max(result, count);     }     return result;   }  }   결과  Link   설명          문자열 s에서 최대 두 문자의 위치를 바꿔 동일한 문자로 이루어진 가장 긴 부분 문자열의 길이를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            counts는 문자의 갯수를 저장할 변수로, 영문자 갯수인 26 크기의 정수 배열로 초기화하고 아래 두 변수를 활용하여 s의 각 문자 갯수를 넣어준다.       charArray는 s를 문자 배열로 변환한 변수이다.       length는 charArray의 길이를 저장한 변수이다.       result는 동일한 문자로 이루어진 가장 긴 부분 문자열의 길이를 저장할 변수로, 0으로 초기화한다.           0부터 length 미만까지 i를 증가시키며 아래를 반복한다.            반복에 필요한 변수를 정의한다.                    curr은 charArray에서 현재 위치인 i번째 문자를 넣은 변수이다.           j는 이후 문자열 탐색을 위한 변수로, i로 초기화한다.           count는 동일한 문자로 이루어진 문자열의 갯수를 저장할 변수로, 0으로 초기화한다.           diff는 다른 문자의 갯수를 저장할 변수로, 0으로 초기화한다.                       j가 length 미만이면서 curr이 charArray[j]와 동일한 문자이거나 diff가 0이면서 count가 counts의 curr 문자 순서에 해당하는 값보다 작은 경우, 아래를 수행한다.                    curr이 charArray[j]와 다른 문자인 경우, diff를 증가시켜준다.           동일한 문자의 수인 count와 탐색 위치인 j를 증가시켜준다.                       count가 counts의 $charArray[i] - ‘a’$번째 값보다 작고 diff가 0인 경우, 연결된 값을 변경하는 경우인 count를 증가시켜준다.       result에 이전까지 최대 길이인 result와 현재 길이인 count 중 큰 값을 넣어준다.           반복이 완료되면 동일한 문자로 이루어진 가장 긴 부분 문자열의 길이가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/swap-for-longest-repeated-character-substring/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Market Analysis I",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT Users.user_id AS buyer_id \t, Users.join_date \t, COUNT(Orders.order_id) AS orders_in_2019 FROM Users LEFT OUTER JOIN Orders ON Users.user_id = Orders.buyer_id AND DATE_PART('year', Orders.order_date) = '2019' GROUP BY Users.user_id \t, Users.join_date   결과  Link   설명          사용자 별 가입 일자와 2019년도 주문 횟수를 조회하는 문제이다.            Orders 테이블의 이력이 없을 수 있으므로 LEFT OUTER JOIN을 사용하되, Users 테이블의 user_id와 Orders 테이블의 구매자 정보인 buyer_id가 동일하면서 2019년도 주문인 경우만 대상으로 한다.            Users 테이블의 사용자 기반으로, user_id를 buyer_id로 join_date 기준으로 Orders 테이블의 데이터 갯수를 계산해준다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/market-analysis-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Level Sum of a Binary Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public int maxLevelSum(TreeNode root) {     int result = 1;     int max = Integer.MIN_VALUE;     Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();     queue.offer(root);     for (int i = 1; !queue.isEmpty(); i++) {       int sum = 0;       for (int size = queue.size(); size &gt; 0; size--) {         TreeNode node = queue.poll();         sum += node.val;         if (node.left != null) {           queue.offer(node.left);         }         if (node.right != null) {           queue.offer(node.right);         }       }       if (max &lt; sum) {         max = sum;         result = i;       }     }     return result;   }  }   결과  Link   설명          root의 동일한 레벨 별 노드들 값의 합이 최대인 레벨을 찾는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 동일한 레벨 별 노드들 값의 합이 최대인 레벨을 저장할 변수로, root 노드의 레벨인 1로 초기화한다.       max는 동일한 레벨 별 노드들 값의 합을 저장할 변수로, 정수의 가장 작은 값으로 초기화한다.       queue는 레벨 별 노드들을 넣어 계산에 활용할 변수로, LinkedList로 초기화하고 root를 넣어준다.           1부터 queue가 비어있지 않을 때 까지 i를 증가시키며 아래를 반복한다.            sum은 현재 레벨의 합계를 저장할 변수로 0으로 초기화한다.       size는 queue의 크기부터 size가 0 초과일 때 까지 감소시키며 아래를 반복한다.                    node에 queue의 앞의 값을 꺼내 넣어준다.           sum에 node의 값을 넣어준다.           node left와 right 자식 노드가 존재하면 순차적으로 queue에 넣어준다.                       max가 sum보다 작은 현재 레벨의 합계가 가장 큰 경우, max에 sum을 result에 i를 넣어준다.           반복이 완료되면 동일한 레벨 별 노드들 값의 합이 최대인 레벨이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-level-sum-of-a-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java As Far from Land as Possible",
        "excerpt":"문제  Link   코드  class Solution {    private static final int[][] DIRECTIONS = {     { 0, 1 },     { 0, -1 },     { 1, 0 },     { -1, 0 }   };    public int maxDistance(int[][] grid) {     int length = grid.length;     Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();     for (int i = 0; i &lt; length; i++) {       for (int j = 0; j &lt; length; j++) {         if (grid[i][j] == 1) {           queue.offer(new int[] { i, j });         }       }     }     int result = -1;     if (!queue.isEmpty() &amp;&amp; queue.size() != length * length) {       while (!queue.isEmpty()) {         int size = queue.size();         result++;         while (size-- &gt; 0) {           int[] point = queue.poll();           int x = point[0];           int y = point[1];           for (int[] direction : DIRECTIONS) {             int nx = x + direction[0];             int ny = y + direction[1];             if (nx &gt;= 0 &amp;&amp; nx &lt; length &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; length &amp;&amp; grid[nx][ny] == 0) {               grid[nx][ny] = 1;               queue.offer(new int[] { nx, ny });             }           }         }       }     }     return result;   }  }   결과  Link   설명     0인 물과 1인 육지로 이루어진 정사각형의 grid를 이용하여 각 육지에서 최대 거리가 되는 위치를 구하여 육지별 최대 거리를 반환하는 문제이다.                                                            위의 거리는 Manhattan distance를 의미하며, 해당 거리는 (x0, y0)과 (x1, y1) 두 지점에 대해서 $               x0 - x1               +               y0 - y1               $로 측정된다.                                               해당 조건을 만족하는 위치가 존재하지 않으면 -1을 주어진 문제의 결과로 반환한다.                전역 변수인 DIRECTIONS는 상하좌우를 탐색하기 위한 변수로 현재 위치에서 이동하는 x와 y축의 네 쌍을 저장한 변수이다.       문제 풀이에 필요한 변수를 정의한다.            length는 grid의 길이를 저장한 변수로, 정사각형이므로 하나의 길이만 저장한다.       queue는 육지의 각 위치를 저장할 변수로, grid에서 육지에 해당 하는 위치를 queue에 (x, y) 형태의 2차원 정수 배열로 넣어준다.       result는 육지별 최대 거리를 저장할 변수로, 위치가 존재하지 않는 경우의 결과인 -1로 초기화한다.           queue가 비어있지 않거나 grid가 모두 육지로 되어있지 않은 경우, queue가 비어있지 않을 때 까지 아래를 반복한다.            size에 현재 queue의 크기를 넣어준다.       result를 증가하여 이동하는 거리를 증가시킨 후, size가 0보다 클 때 까지 아래를 반복하고 size를 감소시켜준다.                    point에 queue의 첫 값을 넣은 후 x와 y에 각 위치를 넣어준다.           DIRECTIONS를 순차적으로 direction에 넣어 x와 y에 더한 후, grid 범위 내 물의 위치이면 해당 값을 1을 넣어 육지로 변환 후 다음 탐색의 경우의 수인 해당 위치를 queue에 넣어준다.                           반복이 완료되면 최대 거리가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/as-far-from-land-as-possible/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Distance in Arrays",
        "excerpt":"문제  Link   코드  class Solution {    public int maxDistance(List&lt;List&lt;Integer&gt;&gt; arrays) {     int result = 0;     List&lt;Integer&gt; list = arrays.get(0);     int min = list.getFirst();     int max = list.getLast();     for (int i = 1; i &lt; arrays.size(); i++) {       list = arrays.get(i);       int first = list.getFirst();       int last = list.getLast();       result = Math.max(result, Math.max(Math.abs(last - min), Math.abs(first - max)));       min = Math.min(min, first);       max = Math.max(max, last);     }     return result;   }  }   결과  Link   설명                                     각 값들이 오름차순으로 정렬된 arrays 내 배열들을 이용하여 두 개의 다른 배열에서 각각 한 값을 꺼내 $           a - b           $인 거리가 가장 큰 최대 거리를 찾는 문제이다.                           문제 풀이에 필요한 변수를 정의한다.            result는 최대 거리를 저장할 변수로, 0으로 초기화한다.       min과 max는 arrays의 첫 List에서 첫 값과 마지막 값인 최솟값과 최댓값을 넣은 변수이다.           1부터 arrays의 길이 미만까지 i를 증가시키며 아래를 반복한다.            first와 last에 arrays의 i번째 List에서 첫 값과 마지막 값인 최솟값과 최댓값을 넣어준다.                                                       result에 result, $               last - min               $, $               first - max               $ 중 가장 큰 거리의 값을 넣어준다.                                               min에 min과 first 중 작은 값을, max에 max와 last 중 큰 값을 넣어준다.           반복이 완료되면 최대 거리가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-distance-in-arrays/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Number of Points with Cost",
        "excerpt":"문제  Link   코드  class Solution {    public long maxPoints(int[][] points) {     int row = points.length;     int col = points[0].length;     long[] dp = new long[col];     long result = 0;     for (int i = 0; i &lt; row; i++) {       for (int j = 0; j &lt; col; j++) {         dp[j] += points[i][j];       }       for (int j = 1; j &lt; col; j++) {         dp[j] = Math.max(dp[j], dp[j - 1] - 1);       }       for (int j = col - 2; j &gt;= 0; j--) {         dp[j] = Math.max(dp[j], dp[j + 1] - 1);       }     }     for (int i = 0; i &lt; col; i++) {       result = Math.max(result, dp[i]);     }     return result;   }  }   결과  Link   설명     $m \\times n$ 크기의 points의 각 행의 점수 중 하나를 골라 달성할 수 있는 최대 점수를 계산하는 문제이다.            단, 앞 열에서 너무 떨어진 열의 점수를 선택하면 점수를 잃게된다.       $0 &lt;= r &lt; m - 1$을 만족하는 r과 $r + 1$의 인접한 행 에서 (r, c1), ($r + 1$, c2)에서 셀을 선택하는 경우, $abs(c1 - c2)$의 값을 차감한다.       abs(x)는 x &gt;= 0인 경우 x를, x &lt; 0인 경우 -x를 반환한다.           문제 풀이에 필요한 변수를 정의한다.            row와 col은 points의 행과 열의 수를 저장한 변수이다.       dp는 점수 계산을 위한 변수로, long형의 col 크기 정수 배열로 초기화한다.       result는 점수 계산을 위한 변수로, 0으로 초기화한다.           0부터 row 미만일 때 까지 i를 증가시키며 아래를 반복한다.            0부터 col 미만까지 j를 증가시키며, dp[j]에 points[i][j]를 더해 기본 점수를 넣어준다.       1부터 col 미만까지 j를 증가시키며, dp[j]에 현재 값과 $dp[j - 1] - 1$ 중 큰 값인 최대 점수를 넣어준다.       $col - 2$부터 0 이상일 때 까지 j를 감소시키며, dp[j]에 현재 값과 $dp[j + 1] - 1$ 중 큰 값인 최대 점수를 넣어준다.           위의 반복으로 계산된 dp 내 최대 점수를 result에 넣어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-number-of-points-with-cost/",
        "teaser": null
      },{
        "title": "Leetcode Java Last Substring in Lexicographical Order",
        "excerpt":"문제  Link   코드  class Solution {    public String lastSubstring(String s) {     char[] charArray = s.toCharArray();     int length = charArray.length;     int i = 0;     int j = 1;     int k = 0;     while (j + k &lt; length) {       if (charArray[i + k] == charArray[j + k]) {         k++;       } else {         if (charArray[i + k] &gt; charArray[j + k]) {           j += k + 1;         } else {           i = Math.max(i + k + 1, j);           j = i + 1;         }         k = 0;       }     }     return s.substring(i);   }  }   결과  Link   설명          문자열 s의 부분 문자열 중 사전적 순서가 가장 큰 부분 문자열을 찾는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            charArray는 s를 문자 배열로 변환한 변수이다.       length는 charArray의 길이를 저장한 변수이다.       i와 j는 부분 문자열 탐색에 필요한 위치 값으로, 0과 1로 초기화한다.       k는 동일 문자열인 갯수를 넣어 보정치로 사용할 변수로, 0으로 초기화한다.           $j + k$가 length 미만일 때까지 아래를 반복한다.            charArray의 $i + k$번째 문자와 $j + k$번째 문자가 동일한 경우, k를 증가시켜준다.       위의 경우가 아니라면 아래의 각 경우 별 수행을 하고 k를 0으로 초기화한다.                    charArray의 $i + k$번째 문자가 $j + k$번째 문자보다 사전적 순서가 큰 경우, j에 $k + 1$을 더해준다.           charArray의 $i + k$번째 문자가 $j + k$번째 문자보다 사전적 순서가 작은 경우, i에 $i + k + 1$과 j 중 큰 값을 넣어주고 j에 $i + 1$을 넣어준다.                           반복이 완료되면 s의 사전적 순서가 큰 시작 위치인 i번째 이후 문자열을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/last-substring-in-lexicographical-order/",
        "teaser": null
      },{
        "title": "MinIO Object Storage",
        "excerpt":"개요     MinIO는 고성능 Enterprise Object Store(EOS)로 Amazon Web Services S3 기능을 모두 지원하는 객체 스토리지 솔루션이다.   주요 라이센스로는 AGPLv3 라이센스로 Open Source 버전과 비교적 자유적인 이점을 제공하는 상용 라이센스인 MinIO Commercial License가 존재한다.   주요 특징  S3 Compatible Storage  Amazon S3 API와 완벽하게 호환되도록 설계되었으므로 스토리지 및 ID 관리를 위해 동일한 API 구성을 지원한다.   Multi-Site, Active Active Replication for Object Storage  고가용성(HA) 구성을 지원하여 스토리지 용량과 성능을 확장하고, 다중 클러스터 구성을 통해 대규모 데이터 활용과 장애와 같은 불가항력적인 상황에 데이터를 보호할 수 있다.   Bucket and Object Versioning  버전 관리를 통해 사용자는 동일한 버킷에 저장된 모든 객체의 모든 버전을 유지, 검색 및 복원이 가능하다. 설정을 통해 버전 관리 시작 및 중지를 자유롭게 수행하여 의도치 않은 작업으로 부터 데이터를 보호할 수 있다.   Enterprise Grade Object Storage Encryption  디스크에 저장되거나 네트워크를 통해 전송 될 때 데이터를 AES-256-GCM, ChaCha20-Poly1305 및 AES-CBC와 같은 최신 산업 표준 암호화 알고리즘을 사용하여 암호화하며, AWS 외 Hashicorp Vault, Google Secrets Manager 등의 Key Management Services(KMS)와 연동이 가능하다.   MinIO Enterprise Console: A Window Into Your Data Infrastructure   CLI 뿐 아니라 WEB GUI를 제공하여, 각 기능에 대한 권한을 제어할 수 있으며 모니터링과 이벤트를 실시간으로 확인할 수 있다.   Create An In-Memory Object Store for Ultra High Performance Workloads  객체를 캐싱할 수 있는 기능을 자체적으로 제공하여 빠른 검색과 잦은 요청에 대한 부하를 절감할 수 있으며, 노드가 추가되거나 제거될 때 시스템을 정렬하기 위한 셔플링이 최소화된다.   Data Lifecycle Management and Tiering  오브젝트의 생명 주기인 만료를 지정함으로써, 버킷 별 오브젝트 및 태그의 조합을 통해 스토리지 관리를 최적화 할 수 있다.   구조       분산 구성의 다중 MinIO를 구성하면, 각 클러스터끼리 RESTful API로   독립 구성의 MinIO는 크게 세 부분으로 구성되어 있다.            S3 Layer는 Application으로부터 S3 API를 통해 요청을 수행받는 영역이다.       Object Layer는 MinIO에서 제공하는 기능들을 수행하는 영역이다.       Storage Layer는 File System에 직접적으로 접근하는 영역이다.           각 Layer간 통신하기 위해 내부적으로 Object API와 Storage API로 통신된다.   저장 방식  File System  특정 로컬 스토리지의 위치에 저장 경로를 지정하여 MinIO 서비스를 실행하는 방식으로, 해당  시스템에 대한 독점적인 엑세스가 불가능하므로 권장하는 방식이 아니다.  Erasure Code(EC)     객체를 데이터와 패리티 셀로 분할하여 오브젝트의 손상을 복구할 때 사용하는 기법을 제공하는 방법으로, 저장소 공간을 절약하면서 안정적으로 저장 및 복원이 가능한 방식이다.   Quickstart for Containers  Make directory for storage  mkdir -p /data     MinIO 오브젝트 저장소와 볼륨 마운트할 디렉토리를 생성한다.   Run container using podman  docker run \\    -p 9000:9000 \\    -p 9001:9001 \\    -e \"MINIO_ROOT_USER=gracefulsoul\" \\    -e \"MINIO_ROOT_PASSWORD=LeIabo33@!\" \\    -v /home/minio/data:/data \\    --user $(id -u):$(id -g) \\    --name minio \\    quay.io/minio/minio server /data --console-address \":9001\"     9000은 Server, 9001은 Console Port를 의미힌다.   위에서 만든 Directory Path를 컨테이너 내부 데이터 저장소 Path인 “/data”와 볼륨 마운트를 해준다.   “MINIO_ROOT_USER”와 “MINIO_ROOT_PASSWORD”는 콘솔 관리자 계정 정보를 넣어준다.   현재 유저로 서비스를 수행하기 위하여 “–user” 옵션에 현재 계정의 uid:gid를 넣어준다.   Docker Hub 내 “quay.io/minio/minio:latest” 이미지를 기반의 minio 컨테이너를 ‘server /data –console-address “:9001”’ 커맨드로 실행한다.   Login   도커 실행에 사용한 “MINIO_ROOT_USER”와 “MINIO_ROOT_PASSWORD”를 이용하여 로그인을 수행한다.   다음  MinIO Object Storage II - JAVA Sample   참고  The MinIO Enterprise Object Store  ","categories": ["Storage"],
        "tags": ["Programming","Storage","MinIO"],
        "url": "/storage/minio/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Product Price at a Given Date",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT Products.product_id, COALESCE(MIN(product_price.new_price), 10) AS price FROM (   SELECT DISTINCT product_id FROM Products ) AS Products LEFT OUTER JOIN (   SELECT product_id, new_price FROM Products   WHERE (product_id, change_date) IN (     SELECT product_id, MAX(change_date) AS date FROM Products     WHERE change_date &lt;= '2019-08-16'     GROUP BY product_id   ) ) AS product_price ON Products.product_id = product_price.product_id GROUP BY Products.product_id   결과  Link   설명     제품별 가격 변경 이력이 저장된 Products를 이용하여 ‘2019-08-16’일 기준으로 각 제품의 가격을 구하는 문제이다.            각 제품의 초기 가격은 10이라고 가정한다.                각 제품 이력 별 고유한 product_id를 먼저 구한다.       제품 별 ‘2019-08-16’ 이전까지의 제품 별 마지막 가격 변경 이력을 구한다.            Products 테이블에서 ‘2019-08-16’ 이전까지 product_id 별 가장 최근 변경 이력을 구한다.       위의 product_id 별 가장 최근 변경 이력에 대한 가격을 다시 Products에서 검색한다.           2번과 3번을 통해서 구해진 두 값을 조인하되, 가격 정보가 없는 경우 10을 기본 값으로 설정하여 검색을 수행한다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/product-price-at-a-given-date/",
        "teaser": null
      },{
        "title": "Leetcode Java Invalid Transactions",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; invalidTransactions(String[] transactions) {     Map&lt;String, List&lt;String[]&gt;&gt; map = new HashMap&lt;&gt;();     for (String transaction : transactions) {       String[] split = transaction.split(\",\");       map.putIfAbsent(split[0], new ArrayList&lt;&gt;());       map.get(split[0]).add(split);     }     List&lt;String&gt; result = new ArrayList&lt;&gt;();     for (String transaction : transactions) {       String[] split = transaction.split(\",\");       if (Integer.parseInt(split[2]) &gt; 1000) {         result.add(transaction);       } else {         for (String[] curr : map.get(split[0])) {           if (Math.abs(Integer.parseInt(split[1]) - Integer.parseInt(curr[1])) &lt;= 60 &amp;&amp; !split[3].equals(curr[3])) {             result.add(transaction);             break;           }         }       }     }     return result;   }  }   결과  Link   설명     이름, 시간, 금액, 도시의 순서의 값을 쉼표(“,”)단위로 구분한 값들이 저장된 transactions 내 아래의 조건을 하나라도 만족하는 유효하지 않는 거래들을 찾는 문제이다.            금액이 $1000를 초과하는 경우.       60분 이내에 같은 이름의 다른 도시에서 거래가 발생한 경우.           문제 풀이에 필요한 변수를 정의한다.            map은 transactions의 각 값을 이름 별 분리하여 저장한 변수로, transactions의 각 값의 이름에 대한 분리된 배열을 넣어준다.       result는 유효하지 않는 거래를 저장할 변수로, ArrayList로 초기화한다.           transactions를 순차적으로 transaction에 넣어 아래를 반복한다.            split에 transaction를 쉼표(“,”) 단위로 분리하여 넣어준다.       금액인 split[2]가 1000을 초과하는 경우, result에 transction을 넣어준다.       위의 경우가 아니라면 map의 split[0]인 도시에 해당하는 값을 꺼내 curr에 넣은 후 모든 값을 아래를 반복한다.                    $split[1] - curr[1]$의 값이 60 이하인 다른 거래가 존재하면서 split[3]와 curr[3]의 값이 다른 도시인 경우, result에 transction을 넣고 반복을 중지한다.                           반복이 완료되면 유효하지 않은 거래가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/invalid-transactions/",
        "teaser": null
      },{
        "title": "Leetcode Java Compare Strings by Frequency of the Smallest Character",
        "excerpt":"문제  Link   코드  class Solution {    public int[] numSmallerByFrequency(String[] queries, String[] words) {     int[] counts = new int[11];     for (String word : words) {       counts[this.getCount(word)]++;     }     for (int i = 0; i &lt; counts.length - 1; i++) {       counts[i + 1] += counts[i];     }     int[] result = new int[queries.length];     for (int i = 0; i &lt; queries.length; i++) {       result[i] = counts[counts.length - 1] - counts[this.getCount(queries[i])];     }     return result;   }    private int getCount(String word) {     int[] counts = new int[26];     for (char c : word.toCharArray()) {       counts[c - 'a']++;     }     for (int count : counts) {       if (count != 0) {         return count;       }     }     return 0;   }  }   결과  Link   설명          f(s)는 문자열 s의 사전적 순서가 가장 작은 문자의 갯수를 반환하는 함수로, words의 각 문자열 W에 대해 $f(query[i]) &lt; f(W)$를 만족하는 갯수를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            counts는 words 내 사전적 순서가 가장 작은 문자의 갯수를 계산할 변수로, words의 최대 갯수보다 큰 11 크기의 정수 배열로 초기화 후 아래를 수행한다.                    words의 문자를 반복하여 사전적 순서가 작은 문자의 갯수에 해당하는 위치의 값을 증가시킨다.           counts를 순차적으로 다음 위치에 현재 위치 값을 더한 누계를 합산해준다.                       result는 $f(query[i]) &lt; f(W)$를 만족하는 갯수를 저장할 변수로, queries의 크기와 동일한 정수 배열로 초기화한다.           0부터 queries의 크기 미만까지 i를 증가시키며 아래를 수행한다.            result[i]에 counts의 마지막 값에서 counts의 queries[i]의 사전적 순서가 작은 위치의 값을 뺀, words 중 사전적 순서가 queries[i]보다 큰 갯수를 넣어준다.           반복이 완료되어 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/compare-strings-by-frequency-of-the-smallest-character/",
        "teaser": null
      },{
        "title": "Leetcode Java Dinner Plate Stacks",
        "excerpt":"문제  Link   코드  class DinnerPlates {    private List&lt;Stack&lt;Integer&gt;&gt; stacks;   private TreeSet&lt;Integer&gt; treeSet;   private int capacity;    public DinnerPlates(int capacity) {     this.stacks = new ArrayList&lt;&gt;();     this.treeSet = new TreeSet&lt;&gt;();     this.capacity = capacity;   }    public void push(int val) {     if (this.treeSet.isEmpty()) {       this.stacks.add(new Stack&lt;&gt;());       this.treeSet.add(this.stacks.size() - 1);     }     Stack&lt;Integer&gt; stack = this.stacks.get(this.treeSet.first());     stack.push(val);     if (stack.size() == this.capacity) {       this.treeSet.pollFirst();     }   }    public int pop() {     if (this.stacks.isEmpty()) {       return -1;     } else {       int val = this.stacks.getLast().pop();       this.treeSet.add(this.stacks.size() - 1);       while (!this.stacks.isEmpty() &amp;&amp; this.stacks.getLast().isEmpty()) {         this.stacks.removeLast();         this.treeSet.pollLast();       }       return val;     }   }    public int popAtStack(int index) {     if (index &gt;= this.stacks.size()) {       return -1;     } else if (index == this.stacks.size() - 1) {       return this.pop();     } else {       this.treeSet.add(index);       Stack&lt;Integer&gt; stack = this.stacks.get(index);       return stack.isEmpty() ? -1 : stack.pop();     }   }  }  /**  * Your DinnerPlates object will be instantiated and called as such:  * DinnerPlates obj = new DinnerPlates(capacity);  * obj.push(val);  * int param_2 = obj.pop();  * int param_3 = obj.popAtStack(index);  */   결과  Link   설명     0부터 좌측에서 우측으로 값을 최대 capacity 만큼 수용 가능한 스택을 무한히 많이 보유한 DinnerPlates 객체를 완성하는 문제이다.            생성자인 DinnerPlates(int capacity)는 객체를 초기화 하며 최대 capacity 만큼 수용 가능할 스택을 만들어준다.       메서드인 push(int val)는 val 값을 capacity 미만의 값을 보유한 스택에 값을 좌측부터 넣어준다.       메서드인 pop()은 가장 처음의 스택에서 오른쪽의 비어있지 않은 값을 꺼내서 반환한다. 단, 값이 존재하지 않으면 -1을 반환한다.       메서드인 popAtStack(int index)은 가장 위에 있는 스택에서 index번째 값을 꺼내서 반환한다. 단, 값이 존재하지 않으면 -1을 반환한다.           각 연산에 필요한 전역 변수를 정의한다.            stacks는 각 스택을 저장할 변수이다.       treeSet은 각 스택의 크기를 저장할 변수이다.       capacity는 생성자를 통해 주입되는 스택의 최대 크기를 저장할 변수이다.           생성자인 DinnerPlates(int capacity)를 완성한다.            stacks에 ArrayList를, treeSet에 TreeSet을, capacity에 주입된 capacity를 넣어준다.           메서드인 push(int val)를 완성한다.            treeSet이 비어있는 초기 수행인 경우, stacks에 새 Stack을 넣어준 후, treeSet에 현재 스택의 갯수를 저장한다.       stack에 stacks에서 treeSet의 첫 값에 해당하는 스택을 꺼내 넣어준다.       stack에 val을 넣어준 후, stack의 크기가 capacity와 동일한 경우, treeSet에 우선 순위가 높은 값을 꺼내 제거한다.           메서드인 pop()을 정의한다.            stacks가 비어있는 경우, 꺼낼 값이 없으므로 -1을 반환한다.       위의 경우가 아니라면 아래를 수행한다.                    val에 stacks의 마지막 스택의 우선 순위가 높은 값을 꺼내준다.           treeSet에 해당 뺀 값을 제외한 현재 스택의 크기를 저장해준다.           stacks가 비어있지 않거나 stacks의 마지막 스택이 비어있지 않을 때 까지, stacks의 마지막 스택을 삭제하고 treeSet에서 마지막으로 우선 순위가 낮은 값을 값을 제거하여 빈 스택과 저장된 크기 정보를 삭제한다.           val 값을 반환해준다.                           메서드인 popAtStack(int index)을 정의한다.            index가 stacks 크기보다 크거나 같은 경우, 꺼낼 수 없으므로 -1을 반환한다.       위의 경우가 아니면서 index가 stacks의 마지막 위치인 경우, 5번의 pop() 메서드를 수행한다.       위의 모든 경우가 아니라면 아래를 수행한다.                    treeSet에 index를 추가하여 신규 스택의 위치인 꺼낸 값의 위치를 저장해준다.           stack에 stacks에서 index번째 스택을 꺼내 넣어준다.           stack이 버이었으면 -1을, 아니면 마지막 값을 꺼내 반환한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/dinner-plate-stacks/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Immediate Food Delivery II",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT ROUND(AVG(CASE WHEN order_date = customer_pref_delivery_date THEN 1 ELSE 0 END) * 100, 2) AS immediate_percentage FROM Delivery WHERE (customer_id, order_date) IN (   SELECT customer_id, MIN(order_date)   FROM Delivery   GROUP BY customer_id )   결과  Link   설명     고객별 첫 배송이 즉시 배송한 비율을 찾는 문제이다.            비율을 소수점 2자리까지 반환한다.                Delivery에서 고객 별 처음 배송을 찾기 위해서 customer_id를 기준으로 최소 order_date를 찾는다.       찾은 배송일 중에서 order_date과 customer_pref_delivery_date이 동일한 경우에 대한 평균 값을 소수점 두 자리까지 계산한다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/immediate-food-delivery-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Prime Arrangements",
        "excerpt":"문제  Link   코드  class Solution {    public int numPrimeArrangements(int n) {     boolean[] primes = new boolean[n + 1];     Arrays.fill(primes, 2, n + 1, true);     for (int i = 2; i * i &lt;= n; i++) {       if (primes[i]) {         for (int j = i * i; j &lt;= n; j += i) {           primes[j] = false;         }       }     }     int count = 0;     for (boolean prime : primes) {       if (prime) {         count++;       }     }     long result = 1;     for (int i = 2; i &lt;= count; i++) {       result = (result * i) % 1000000007;     }     for (int i = 2; i &lt;= n - count; i++) {       result = (result * i) % 1000000007;     }     return (int) result;   }  }   결과  Link   설명     소수가 소수 지수가 되도록 1부터 n까지 순열의 수를 반환하는 문제이다.            단, 답이 매우 클 수 있으므로 모듈러 $10^9 + 7$을 이용해 계산한다.           문제 풀이에 필요한 변수를 정의한다.            primes는 각 위치가 소수인지 저장할 변수로, $n + 1$ 크기의 부울 변수로 초기화하여 소수가 아닌 위치에 false를 넣어준다.       count는 소수의 갯수를 저장할 변수로, primes를 반복하여 소수의 갯수를 저장해준다.       result는 결과 값을 저장할 변수로, long형의 1로 초기화한다.           아래의 각 경우를 이용하여 순열의 수를 계산 후 result를 int형으로 변경하여 주어진 문제의 결과로 반환한다.            소수인 값들을 연속으로 나열하는 경우인 2부터 count 이하까지 i를 증가시키며, result에 $result \\times i$에 모듈러 $10^9 + 7$를 적용한 결과를 넣어준다.       수사가 아닌 값들을 연속으로 나열하는 경우인 2부터 $n - count$ 이하까지 i를 증가시키며, result에 $result \\times i$에 모듈러 $10^9 + 7$를 적용한 결과를 넣어준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/prime-arrangements/",
        "teaser": null
      },{
        "title": "Leetcode Java Path with Maximum Probability",
        "excerpt":"문제  Link   코드  class Solution {    public double maxProbability(int n, int[][] edges, double[] succProb, int start_node, int end_node) {     double[] max = new double[n];     max[start_node] = 1.0;     for (int i = 0; i &lt; n - 1; i++) {       boolean updated = false;       for (int j = 0; j &lt; edges.length; j++) {         int a = edges[j][0];         int b = edges[j][1];         double probability = succProb[j];         if (max[a] * probability &gt; max[b]) {           max[b] = max[a] * probability;           updated = true;         }         if (max[b] * probability &gt; max[a]) {           max[a] = max[b] * probability;           updated = true;         }       }       if (!updated) {         break;       }     }     return max[end_node];   }  }   결과  Link   설명     n개의 edges와 succProb를 이용하여 start_node에서 end_node까지 갈 수 있는 최대 확률을 반환하는 문제이다.            edges[i] = [a, b]로, a노드에서 b노드까지 도착할 확률이 succProb[i]를 나타낸다.       start_node에서 end_node까지 갈 수 없는 경우, 0을 반환한다.                max는 도착할 확률이 최대인 값을 구하기 위한 변수로, n 크기의 double형 배열로 정의하고 첫 값을 1.0으로 초기화한다.       0부터 $n - 1$까지 i를 증가시키며 아래를 수행한다.            updated는 값이 수정되었는지 검증하기 위한 변수로, false로 초기화한다.       0부터 edges의 길이 미만까지 j를 증가시키며 아래를 수행한다.                    a와 b에 edges[j]의 값을 순차적으로 넣어준다.           probability에 succProb[j]값인 도착 확률을 넣어준다.           $max[a] \\times probability$ 값이 max[b]보다 큰 도착 확률이 높은 경우, max[b]에 $max[a] \\times probability$ 값을 저장하고 updated를 true를 넣어준다.           $max[b] \\times probability$ 값이 max[a]보다 큰 도착 확률이 높은 경우, max[a]에 $max[b] \\times probability$ 값을 저장하고 updated를 true를 넣어준다.                       updated가 false인 변경되지 않은 경우 더 이상의 최대 확률이 존재하지 않으므로, 반복을 중단한다.           반복이 완료되면 start_node에서 end_node까지 도착할 최대 확률이 저장된 max[end_node]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/path-with-maximum-probability/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Sub Islands",
        "excerpt":"문제  Link   코드  class Solution {    public int countSubIslands(int[][] grid1, int[][] grid2) {     int result = 0;     for (int i = 0; i &lt; grid2.length; i++) {       for (int j = 0; j &lt; grid2[0].length; j++) {         if (grid2[i][j] == 1 &amp;&amp; this.dfs(grid1, grid2, i, j)) {           result++;         }       }     }     return result;   }    private boolean dfs(int[][] grid1, int[][] grid2, int i, int j) {     boolean result = true;     if (0 &lt;= i &amp;&amp; i &lt; grid2.length &amp;&amp; 0 &lt;= j &amp;&amp; j &lt; grid2[0].length &amp;&amp; grid2[i][j] == 1) {       if (grid1[i][j] != grid2[i][j]) {         result = false;       }       grid2[i][j] = 0;       result &amp;= this.dfs(grid1, grid2, i - 1, j);       result &amp;= this.dfs(grid1, grid2, i + 1, j);       result &amp;= this.dfs(grid1, grid2, i, j - 1);       result &amp;= this.dfs(grid1, grid2, i, j + 1);     }     return result;   }  }   결과  Link   설명          0은 물, 1은 땅을 나타내는 값을 가진 grid2의 육지가 grid1의 육지와 완전히 겹쳐지는 육지의 갯수를 저장하는 문제이다.            result는 grid2의 육지가 grid1의 육지와 완전히 겹처지는 육지의 갯수를 저장할 변수로, 0으로 초기화한다.       0부터 grid2 행의 길이 미만까지 i를, 0부터 grid2 열의 길이 미만까지 j를 증가시키며 아래를 수행한다.            grid2[i][j]가 1이면서 4번에서 정의한 dfs(int[][] grid1, int[][] grid2, int i, int j) 메서드를 수행한 결과가 참인 경우, result를 증가시킨다.           DFS 방식으로 육지를 탐색할 dfs(int[][] grid1, int[][] grid2, int i, int j) 메서드를 정의한다.            result는 grid2의 육지가 grid1의 육지와 겹쳐지는지 검증하기 위한 변수로, true로 초기화한다.       i와 j가 grid2 범위 내 있으면서 grid2[i][j]의 값이 1인 육지인 경우, 아래를 수행한다.                    grid1[i][j]의 값과 grid2[i][j]의 값이 동일하지 않으면 겹쳐지는 육지가 아니므로, result에 false를 넣어준다.           grid2[i][j]에 0을 넣어 이미 탐색한 위치임을 표시해준다.           result에 현재 위치에서 상하좌우로 재귀 호출한 결과를 순차적으로 AND(&amp;) 비트 연산을 수행한 결과를 넣어준다.                       수행이 완료되면 result를 반환한다.           반복이 완료되어 조건을 만족하는 육지의 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-sub-islands/",
        "teaser": null
      },{
        "title": "Leetcode Java Can Make Palindrome from Substring",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Boolean&gt; canMakePaliQueries(String s, int[][] queries) {     int[] counts = new int[s.length() + 1];     for (int i = 0; i &lt; s.length(); i++) {       counts[i + 1] = counts[i] ^ (1 &lt;&lt; (s.charAt(i) - 'a'));     }     List&lt;Boolean&gt; result = new ArrayList&lt;&gt;();     for (int[] query : queries) {       result.add(((((query[1] - query[0]) % 2) + Integer.bitCount(counts[query[1] + 1] ^ counts[query[0]])) / 2) &lt;= query[2]);     }     return result;   }  }   결과  Link   설명     문자열 s가 주어지면 queries를 이용하여 각 조건이 회문 문자열을 만들 수 있는지 검증하는 문제이다.            queries[i] = [lefti, righti, ki]일때, s의 [lefti, righti] 범위 내 문자들을 ki개 문자를 변경할 수 있다.           문제 풀이에 필요한 변수를 정의한다.            counts는 문자가 존재하는지 여부를 저장할 변수로, s의 길이보다 1 큰 정수 배열로 초기화하고 s를 순차적으로 반복하여 아래를 수행한다.                    counts[$i + 1$]에 counts[i]와 1을 현재 문자의 영문자 순서만큼 좌측으로 이동한 비트와 XOR(^) 연산을 수행한 결과를 넣어 홀수번 반복된 문자들을 기준으로 숫자로 넣어준다.                       result는 결과를 순차적으로 넣을 변수로, ArrayList로 초기화한다.           queries를 순차적으로 query에 넣어 아래를 수행한다.            result에 아래의 XOR(^) 연산 결과에 2를 나눈 결과가 query[2]인 변경 가능한 문자 갯수보다 작으면 true를, 아니면 false를 넣어준다.                    $query[1] - query[0]$을 2로 나눈 나머지 값에 counts의 $query[1] + 1$번째 값의 비트 값이 1인 갯수를 더한 결과.           counts의 query[0]번째 값.                           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   해설     비트 값이 1인 홀수 갯수의 문자들 중 절반을 바꾸는 경우, 회문이 가능하다.   위의 기준으로 XOR(^) 연산 결과인 홀수개의 문자의 절반이 query[2]인 변경 가능한 문자 갯수보다 큰지 적은지에 따라서 회문 문자열 생성의 여부가 결정된다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/can-make-palindrome-from-substring/",
        "teaser": null
      },{
        "title": "Leetcode Java Convert 1D Array Into 2D Array",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] construct2DArray(int[] original, int m, int n) {     if (original.length == m * n) {       int[][] result = new int[m][n];       for (int i = 0; i &lt; original.length; i++) {         result[i / n][i % n] = original[i];       }       return result;     } else {       return new int[0][0];     }   }  }   결과  Link   설명     original 배열을 $m \\times n$ 크기의 배열로 변환하는 문제이다.            단, 변환이 불가능한 경우 빈 배열을 반환한다.           original의 길이와 $m \\times n $이 동일한 경우, 아래를 수행하여 $m \\times n$ 크기의 배열로 변환하여 주어진 문제의 결과로 반환한다.            result를 $m \\times n$ 크기의 배열로 정의한다.       0부터 original의 길이 미만까지 i를 증가시키며 n개씩 넣어야 하므로, result의 $\\frac{i}{n}$의 몫에 해당하는 행의 나머지에 해당하는 열에 original[i]를 넣어준다.       변환된 result를 주어진 문제의 결과로 반환한다.           original의 길이와 $m \\times n $이 동일하지 않은 경우, 빈 2차원 배열을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/convert-1d-array-into-2d-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Find the Student that Will Replace the Chalk",
        "excerpt":"문제  Link   코드  class Solution {    public int chalkReplacer(int[] chalk, int k) {     long sum = 0;     for (int c : chalk) {       sum += c;     }     k %= sum;     for (int i = 0; i &lt; chalk.length; i++) {       if ((k -= chalk[i]) &lt; 0) {         return i;       }     }     return -1;   }  }   결과  Link   설명          각 학생 별 문제 풀이에 필요한 분필의 갯수가 저장된 chalk를 이용하여 k개의 분필을 모두 사용할 때, 마지막으로 사용할 학생 위치를 반환하는 문제이다.            sum은 학생들이 한 번씩 문제를 풀 때 필요한 분필의 갯수를 저장할 변수로, chalk의 분필 갯수를 모두 더해서 넣어준다.            k에 k를 sum을 나눈 나머지인 반복으로 소모되는 분필을 제거한 갯수를 넣어준다.            0부터 chalk의 길이 미만까지 i를 증가시키면서 k에 chalk[i]의 값을 빼줄 때 0보다 작아지는 위치를 찾아 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-the-student-that-will-replace-the-chalk/",
        "teaser": null
      },{
        "title": "Leetcode Java Sum of Digits of String After Convert",
        "excerpt":"문제  Link   코드  class Solution {    public int getLucky(String s, int k) {     int result = 0;     for (char c : s.toCharArray()) {       int num = c - 96;       if (num &gt; 9) {         result += (num / 10) + (num % 10);       } else {         result += num;       }     }     while (--k &gt; 0 &amp;&amp; result &gt; 9) {       int sum = 0;       while (result &gt; 0) {         sum += result % 10;         result /= 10;       }       result = sum;     }     return result;   }  }   결과  Link   설명          주어진 문자열 s의 영문자 순서(1부터 시작)를 순서대로 이어준 후, k번 각 자리 숫자를 더해준 결과를 반환하는 문제이다.       result는 결과를 저장할 변수로, 0으로 초기화 후 아래를 수행한다.            s의 각 문자를 순서대로 c에 넣어 96을 뺀 1부터 시작하는 영문자 순서를 이용하여 result에 각 자리 숫자를 더해준다.           k를 감춘 값이 0보다 크거나 result가 9 초과인 2자리 수일 때 까지 아래를 반복한다.            sum은 result의 각 자리 숫자를 더해줄 변수로, result가 0 초과일 때 까지 sum에 result를 10을 나눈 나머지 값을 더해준 후 result에 10을 나눈 몫을 넣어준다.       result에 각 자리수를 더한 sum을 넣어준다.           반복이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sum-of-digits-of-string-after-convert/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Valid Words for Each Puzzle",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; findNumOfValidWords(String[] words, String[] puzzles) {     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();     for (String word : words) {       int mask = 0;       for (char c : word.toCharArray()) {         mask |= 1 &lt;&lt; (c - 'a');       }       map.put(mask, map.getOrDefault(mask, 0) + 1);     }     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     for (String puzzle : puzzles) {       int mask = 0;       for (char c : puzzle.toCharArray()) {         mask |= 1 &lt;&lt; (c - 'a');       }       int count = 0;       int i = puzzle.charAt(0) - 'a';       for (int j = mask; j &gt; 0; j = (j - 1) &amp; mask) {         if ((j &gt;&gt; i &amp; 1) == 1) {           count += map.getOrDefault(j, 0);         }       }       result.add(count);     }     return result;   }  }   결과  Link   설명     puzzles 배열 내 아래의 규칙을 만족하는 words의 갯수를 계산하는 문제이다.            이하부터 puzzles의 임의 문자열은 puzzle, words의 임의 문자열은 word로 한다.       puzzle의 첫 문자은 word 문자열 내 존재해야 한다.       puzzle의 각 문자들로 word 문자열을 만들 수 있어야 한다.           문제 풀이에 필요한 변수를 정의한다.            map은 문자열을 만들 수 있는 비트의 갯수를 저장할 변수로, HashMap으로 초기화하여 words의 각 값을 bit 숫자열로 변환하여 갯수를 계산해 비트 별 갯수를 넣어준다.       result는 puzzle로 주어진 조건을 만족하는 word의 갯수를 넣어줄 변수로, ArrayList로 초기화한다.           puzzles의 각 값을 순차적으로 puzzle에 넣어 아래를 수행한다.            만족하는 갯수 계산에 필요한 변수를 정의한다.                    mask는 puzzle를 bit 숫자열로 변환한 변수이다.           count는 만족하는 word의 갯수를 계산하기 위한 변수로, 0으로 초기화한다.           i는 puzzle의 첫 문자 위치를 저장한 변수이다.                       mask부터 0 초과까지 j에 $j - 1$과 mask의 AND(&amp;) 비트 연산을 수행한 결과를 넣어가며 아래를 반복한다.                    i를 j번 우측으로 이동한 비트와 1의 AND(&amp;) 비트 연산을 수행한 결과가 1인 경우, count에 map의 j번째 값을 더해준다. 값이 없으면 0을 더해준다.                       result에 count를 넣어 갯수를 저장해준다.           반복이 완료되면 각자 만족하는 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-valid-words-for-each-puzzle/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Missing Observations",
        "excerpt":"문제  Link   코드  class Solution {    public int[] missingRolls(int[] rolls, int mean, int n) {     int sum = 0;     for (int roll : rolls) {       sum += roll;     }     int less = (mean * (n + rolls.length)) - sum;     if (less &lt; n || (6 * n) &lt; less) {       return new int[0];     } else {       int quotient = less / n;       int remainder = less % n;       int[] result = new int[n];       Arrays.fill(result, quotient);       for (int i = 0; i &lt; remainder; i++) {         result[i] = quotient + 1;       }       for (int i = remainder; i &lt; n; i++) {         result[i] = quotient;       }       return result;     }   }  }   결과  Link   설명     정육면체 주사위를 이용하여 이미 굴린 주사위의 값인 rolls을 중앙값인 mean을 만들기 위해서 주사위를 n번 굴린 결과의 조합을 찾는 문제이다.            단, 불가능하면 빈 배열을 주어진 문제의 결과로 반환한다.                less는 mean을 만들기 위해 부족한 값을 저장할 변수로, maen을 $n + rolls.length$인 중앙값이 되기 위한 값에 rolls의 값을 더한 부족한 값을 넣어준다.            less가 n보다 작거나 $6 \\times n$인 추가로 굴린 값이 모두 6이어도 중앙값을 초과하는 경우, 빈 배열을 주어진 문제의 결과로 반환한다.       3번의 경우가 아니라면 아래를 수행한다.            결과를 구하기 위한 변수를 정의한다.                    quotient와 remainder는 부족한 less 값을 n으로 나눈 몫과 나머지를 저장한 변수이다.           result는 추가로 굴려서 나와야 하는 값을 저장할 변수로, n 크기의 정수 배열로 초기화하고 quotient를 모든 위치에 넣어준다.                       0부터 remainder 미만까지 i를 증가시키며, result[i]에 $quotient + 1$의 값을 순차적으로 더해 부족한 값들을 채워준다.       나머지 위치에 quotient를 넣어주고 result를 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-missing-observations/",
        "teaser": null
      },{
        "title": "Leetcode Java Delete Nodes From Linked List Present in Array",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode modifiedList(int[] nums, ListNode head) {     int max = -1;     for (int num : nums) {       max = num &gt; max ? num : max;     }     boolean[] frequency = new boolean[max + 1];     for (int num : nums) {       frequency[num] = true;     }     ListNode temp = new ListNode();     ListNode curr = temp;     while (head != null) {       if (head.val &gt; max || frequency[head.val] == false) {         curr.next = head;         curr = curr.next;       }       head = head.next;     }     curr.next = null;     return temp.next;   }  }   결과  Link   설명          head에서 nums 내 값들을 제거하고 반환하는 문제이다.       문제 풀이에 필요한 변수이다.            max는 nums 내 가장 큰 값을 저장한 변수이다.       frequency는 nums 내 값의 존재 유무를 저장할 배열로, $max + 1$ 크기의 배열로 초기화하여 nums의 값 위치에 true를 넣어준다.       temp는 결과를 임시 저장할 변수로, 새 ListNode로 초기화한다.       curr은 현재 노드를 저장할 변수로 temp로 초기화한다.           head가 null이 아닐 때 까지 아래를 반복한다.            haed의 val 값이 max보다 크거나 frequency에 존재하지 않는 경우, curr의 next에 head를 넣고 curr에 curr의 next 노드를 넣어 현재 노드를 제거해준다.       head에 haed의 next 노드를 넣어 다음 반복을 수행한다.           curr의 next 노드를 null로 바꾸어 마지막 노드로 만든 후, temp의 next 노드인 제거된 노드를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/delete-nodes-from-linked-list-present-in-array/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Reformat Department Table",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT   id,   SUM(CASE WHEN month = 'Jan' THEN revenue END) AS Jan_Revenue,   SUM(CASE WHEN month = 'Feb' THEN revenue END) AS Feb_Revenue,   SUM(CASE WHEN month = 'Mar' THEN revenue END) AS Mar_Revenue,   SUM(CASE WHEN month = 'Apr' THEN revenue END) AS Apr_Revenue,   SUM(CASE WHEN month = 'May' THEN revenue END) AS May_Revenue,   SUM(CASE WHEN month = 'Jun' THEN revenue END) AS Jun_Revenue,   SUM(CASE WHEN month = 'Jul' THEN revenue END) AS Jul_Revenue,   SUM(CASE WHEN month = 'Aug' THEN revenue END) AS Aug_Revenue,   SUM(CASE WHEN month = 'Sep' THEN revenue END) AS Sep_Revenue,   SUM(CASE WHEN month = 'Oct' THEN revenue END) AS Oct_Revenue,   SUM(CASE WHEN month = 'Nov' THEN revenue END) AS Nov_Revenue,   SUM(CASE WHEN month = 'Dec' THEN revenue END) AS Dec_Revenue FROM Department GROUP BY id   결과  Link   설명     Department 테이블에서 월 별 수익을 계산하는 문제이다.            month 필드의 값은 [“Jan”,”Feb”,”Mar”,”Apr”,”May”,”Jun”,”Jul”,”Aug”,”Sep”,”Oct”,”Nov”,”Dec”]가 존재한다.           각 월별 revenue를 id 기준으로 그룹지어 합계를 계산한다.            단, 데이터가 없는 경우에 대한 기본 값은 0이 아니라 null이므로 “ELSE 0”으로 기본 값을 치환하지 않아도 된다.          ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/reformat-department-table/",
        "teaser": null
      },{
        "title": "Leetcode Java Spiral Matrix IV",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public int[][] spiralMatrix(int m, int n, ListNode head) {     int[][] result = new int[m][n];     for (int[] row : result) {       Arrays.fill(row, -1);     }     int top = 0;     int bottom = m - 1;     int left = 0;     int right = n - 1;     while (head != null) {       for (int col = left; col &lt;= right &amp;&amp; head != null; col++) {         result[top][col] = head.val;         head = head.next;       }       top++;       for (int row = top; row &lt;= bottom &amp;&amp; head != null; row++) {         result[row][right] = head.val;         head = head.next;       }       right--;       for (int col = right; col &gt;= left &amp;&amp; head != null; col--) {         result[bottom][col] = head.val;         head = head.next;       }       bottom--;       for (int row = bottom; row &gt;= top &amp;&amp; head != null; row--) {         result[row][left] = head.val;         head = head.next;       }       left++;     }     return result;   }  }   결과  Link   설명     head의 값들을 $m \\times n$ 크기의 배열을 만들어 나선형으로 이동하면서 값을 넣어주는 문제이다.            값을 채운 나머지 위치에는 -1을 넣어준다.           문제 풀이에 필요한 변수를 정의한다.            result는 결과를 넣을 변수로, $m \\times n$ 크기의 2차원 정수 배열로 초기화하고 모든 위치에 -1을 넣어준다.       top, bottom, left, right는 각각 result의 각 위치를 저장할 변수로, 0, $m - 1$, 0, $n - 1$로 초기화한다.           head가 null이 아닐 때 까지 아래를 반복한다.            result의 top번째 행의 좌측에서 우측으로 head의 값을 꺼내 넣어준 후, top을 증가시켜 아래 줄로 이동한다.       result의 right번째 열의 위에서 아래로 head의 값을 꺼내 넣어준 후, right를 감소하여 왼쪽 열로 이동한다.       result의 bottom번째 행의 우측에서 좌측으로 head의 값을 꺼내 넣어준 후, bottom을 감소시켜 윗 줄로 이동한다.       result의 left번째 열의 아래에서 위로 head의 값을 꺼내 넣어준 후, left를 증가시켜 오른쪽 열로 이동한다.           3번의 반복이 완료되어 head의 값이 순차적으로 입력된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/spiral-matrix-iv/",
        "teaser": null
      },{
        "title": "Leetcode Java Insert Greatest Common Divisors in Linked List",
        "excerpt":"문제  Link   코드  /**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {    public ListNode insertGreatestCommonDivisors(ListNode head) {     if (head.next != null) {       ListNode node = head;       while (node.next != null) {         ListNode temp = new ListNode(this.getGcd(node.val, node.next.val), node.next);         node.next = temp;         node = temp.next;       }     }     return head;   }    private int getGcd(int m, int n) {     if (n == 0) {       return m;     } else {       return this.getGcd(n, m % n);     }   }  }   결과  Link   설명          head의 각 노드 사이에 최대 공약수를 넣어주는 문제이다.       head의 next 노드가 null이 아닌, 두 노드 이상인 경우만 아래를 수행한다.            node의 next 노드가 null이 아닐 때 까지 node의 val 값과 node.next 노드의 val 값을 이용한 최대 공약수를 두 노드 사이에 이어준다.           반복이 완료되면 각 노드 사이에 최대 공약수가 들어간 head를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/insert-greatest-common-divisors-in-linked-list/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Bit Flips to Convert Number",
        "excerpt":"문제  Link   코드  class Solution {    public int minBitFlips(int start, int goal) {     int result = 0;     int bit = start ^ goal;     while (bit != 0) {       result += bit &amp; 1;       bit &gt;&gt;= 1;     }     return result;   }  }   결과  Link   설명          start에서 goal가 되기까지 비트 변환의 최소 횟수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 비트 변환의 최소 횟수를 저장할 변수로, 0으로 초기화한다.       bit는 start와 goal의 XOR(^) 비트 연산의 결과를 저장한 변수이다.                bit가 0이 아닐 때 까지 result에 bit와 1의 AND(&amp;) 비트 연산인 변경 횟수를 더한 후 bit를 우측으로 한 칸 이동한다.       위를 통해 계산된 횟수인 result를 주어진 문제의 결과로 반환한다.   해설     start와 goal의 XOR(^) 비트 연산의 결과는 두 숫자의 비트 값이 일치하지 않는 비트만 추려낸 동일하게 변경하기 위한 갯수이다.   bit와 1을 AND(&amp;) 비트 연산을 통해 result에 값을 더한 후 bit를 우측으로 한 칸 이동하는 이유는, 위를 통해 변경해야 할 1 비트의 갯수를 계산하기 위함이다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-bit-flips-to-convert-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Count the Number of Consistent Strings",
        "excerpt":"문제  Link   코드  class Solution {    public int countConsistentStrings(String allowed, String[] words) {     int result = words.length;     int[] count = new int[26];     for (char c : allowed.toCharArray()) {       count[c - 'a']++;     }     for (String word : words) {       for (char c : word.toCharArray()) {         if (count[c - 'a'] == 0) {           result--;           break;         }       }     }     return result;   }  }   결과  Link   설명          allowed 문자열 내 존재하는 문자들로만 이루어진 words 내 문자열 갯수를 계산하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 조건을 만족하는 words 내 문자열의 갯수를 저장할 변수로, 우선 words의 모든 문자열의 갯수로 초기화한다.       count는 allowed 내 문자 갯수를 저장할 변수로, 영문자 갯수인 26 크기의 정수 배열로 초기화하여 allowed 내 문자 갯수를 넣어준다.           words의 각 문자열을 순차적으로 word에 넣어 아래를 수행한다.            word의 각 문자들을 순차적으로 c에 넣어 아래를 수행한다.                    count 내 해당 문자열 순서 위치 값이 0인 allowed 내 존재하지 않는 문자인 경우, 허용되지 않는 문자가 포함된 문자열이므로 result를 감소시키고 반복을 중지한다.                           반복이 완료되면 words 내 allowed 내 문자로 이루어진 문자열 의 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-the-number-of-consistent-strings/",
        "teaser": null
      },{
        "title": "Leetcode Java XOR Queries of a Subarray",
        "excerpt":"문제  Link   코드  class Solution {    public int[] xorQueries(int[] arr, int[][] queries) {     int[] result = new int[queries.length];     for (int i = 1; i &lt; arr.length; i++) {       arr[i] ^= arr[i - 1];     }     for (int i = 0; i &lt; queries.length; i++) {       int[] query = queries[i];       result[i] = query[0] &gt; 0 ? arr[query[0] - 1] ^ arr[query[1]] : arr[query[1]];     }     return result;   }  }   결과  Link   설명          arr 내 값들을 이용하여 queries 범위에 해당하는 숫자들의 XOR 값을 반환하는 문제이다.            result는 결과를 저장할 변수로, queries의 길이 크기의 정수 배열로 초기화 후 arr의 우측 값으로 이동하면서 좌측 값과의 XOR 결과를 순차적으로 넣어준다.       0부터 queries의 길이 미만까지 i를 증가시키며 아래를 수행한다.            query에 queries[i] 값을 꺼내 넣어준다.       result[i]에 경우에 따라 해당하는 값을 넣어준다.                    query[0]인 시작 위치가 0인 경우, 이미 XOR 연산을 누계한 arr[query[1]]의 값을 넣어준다.           위의 경우가 아니라면 누계된 arr[query[1]]의 값에서 시작 위치 이전까지 누계된 값인 arr[$query[0] - 1$] 값을 XOR 연산한 결과를 넣어준다.                           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/xor-queries-of-a-subarray/",
        "teaser": null
      },{
        "title": "Leetcode Java Distance Between Bus Stops",
        "excerpt":"문제  Link   코드  class Solution {    public int distanceBetweenBusStops(int[] distance, int start, int destination) {     int length = distance.length;     int forward = 0;     int reverse = 0;     for (int i = start; i != destination; i = (i + 1) % length) {       forward += distance[i];     }     for (int i = destination; i != start; i = (i + 1) % length) {       reverse += distance[i];     }     return Math.min(forward, reverse);   }  }   결과  Link   설명          n개의 버스 정류장 사이의 거리가 각각 distance라고 할 때, start에서 destination까지 이동하기 위한 최단 거리를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            legnth는 distnace의 길이를 저장한 변수이다.       forward는 start에서 destination까지 이동하면서 거리를 계산할 변수로, distance의 start부터 destination까지 거리의 합계를 넣어준다.       reverse는 destination에서 start까지 이동하면서 거리를 계산할 변수로, distacne의 destiantion에서 start까지 거리의 합게를 넣어준다.           forward와 reverse 중 가장 빠른 경로를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/distance-between-bus-stops/",
        "teaser": null
      },{
        "title": "Leetcode Java Day of the Week",
        "excerpt":"문제  Link   코드  class Solution {    private String[] days = new String[] { \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" };    public String dayOfTheWeek(int day, int month, int year) {     if (month &lt; 3) {       month += 12;       year -= 1;     }     int century = year / 100;     year %= 100;     return days[((((century / 4) - (2 * century) + year + (year / 4) + ((13 * (month + 1)) / 5) + day - 1) % 7) + 7) % 7];   }  }   결과  Link   설명          year년 month월 day일자가 무슨 요일인지 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            전역 변수인 days는 요일에 따라 반환할 결과를 저장한 변수이다.       month가 3 미만인 경우, month에 12를 더하고 yaer에 1을 감소시킨다.       century는 세기를 저장할 변수로, year을 100으로 나눈 몫을 저장한다.       year에 세기를 제외한 100을 나눈 나머지를 넣어준다.           Zeller’s congruence 방식으로 days에서 $\\frac{century}{4} - (2 \\times century) + year + \\frac{year}{4} + \\frac{13 \\times (month + 1)}{5} + day - 1$의 결과에 7을 나눈 나머지에 7을 더한 후 다시 7을 나눈 나머지 번째 값을 꺼내 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/day-of-the-week/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Subarray Sum with One Deletion",
        "excerpt":"문제  Link   코드  class Solution {    public int maximumSum(int[] arr) {     int oneDeletion = 0;     int noDeletion = arr[0];     int result = arr[0];     for (int i = 1; i &lt; arr.length; i++) {       oneDeletion = Math.max(oneDeletion + arr[i], noDeletion);       noDeletion = Math.max(noDeletion + arr[i], arr[i]);       result = Math.max(result, Math.max(oneDeletion, noDeletion));     }     return result;   }  }   결과  Link   설명     arr에서 연속된 값들로 이루어진 부분 배열에서 최대 하나의 값을 제거한 후 합이 가장 큰 값을 반환하는 문제이다.            단, 부분 배열은 하나의 값을 제거한 후에 비어있을 수 없다.           문제 풀이에 핑료한 변수를 정의한다.            oneDeletion은 한 값을 제거한 부분 배열의 합계를 계산할 변수로, 0으로 초기화한다.       noDeletion은 값을 제거하지 않은 부분 배열의 합계를 계산할 변수로, arr[0] 값으로 초기화한다.       result는 가능한 가장 큰 합계를 저장할 변수로, arr[0] 값으로 초기화한다.           1부터 arr의 길이 미만까지 i를 증가시키며 아래를 반복한다.            oneDeletion에 아래의 두 값 중 큰 값을 넣어준다.                    oneDeletion의 값에 arr[i]를 더한 누계한 값.           현재 값을 포함하지 않은 noDeletion의 값.                       noDeletion에 아래의 두 값 중 큰 값을 넣어준다.                    noDeletion의 값에 arr[i]를 더한 누계한 값.           다시 연속된 값이 시작되는 경우인 arr[i]의 값.                       result에 result와 위의 각 경우인 oneDeletion과 noDeletion 중 큰 값을 넣어준다.           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-subarray-sum-with-one-deletion/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Number of Balloons",
        "excerpt":"문제  Link   코드  class Solution {    public int maxNumberOfBalloons(String text) {     int[] count = new int[26];     for (char c : text.toCharArray()) {       count[c - 'a']++;     }     int result = count[1];     result = Math.min(result, count[0]);     result = Math.min(result, count[11] / 2);     result = Math.min(result, count[14] / 2);     result = Math.min(result, count[13]);     return result;   }  }   결과  Link   설명          text 문자열 내 문자들을 이용하여 “balloon” 문자열 몇 개를 만들 수 있는지 검증하는 문제이다.            count는 text의 문자들을 계산할 변수로, 영문자 갯수인 26 크기의 정수 배열로 초기화하여 text를 처음부터 끝까지 문자 갯수를 계산해 넣어준다.            result는 결과를 저장할 변수로, b 문자의 갯수인 count[1]을 넣고 아래 규칙에 따라 만들 수 있는 “balloon” 문자열의 갯수를 주어진 문제의 결과로 반환한다.             result에 result와 a 문자의 갯수인 count[0] 중 작은 값을 넣어준다.       result에 result와 l 문자의 갯수인 count[11]를 두 번 들어가므로 2로 나눈 값 중 작은 값을 넣어준다.       result에 result와 o 문자의 갯수인 count[14]를 두 번 들어가므로 2로 나눈 값 중 작은 값을 넣어준다.       result에 result와 n 문자의 갯수인 count[0] 중 작은 값을 넣어준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-number-of-balloons/",
        "teaser": null
      },{
        "title": "Leetcode Java K-Concatenation Maximum Sum",
        "excerpt":"문제  Link   코드  class Solution {    public int kConcatenationMaxSum(int[] arr, int k) {     long currentMax = arr[0] &gt; 0 ? arr[0] : 0L;     long max = currentMax;     long sum = arr[0];     int length = arr.length;     for (int i = 1; i &lt; Math.min(k, 2) * length; i++) {       currentMax = Math.max(currentMax + arr[i % length], arr[i % length]);       max = Math.max(currentMax, max);       if (i &lt; length) {         sum += arr[i];       }     }     while (sum &gt; 0 &amp;&amp; --k &gt;= 2) {       max = (max + sum) % 1000000007;     }     return (int) max % 1000000007;   }  }   결과  Link   설명     arr의 값이 k번 이어진 배열에서 부분 배열의 합이 최대인 값을 구하는 문제이다.            부분 배열의 값이 없는 경우, 합은 0이다.       부분 배열의 합이 매우 클 수 있으므로, 모듈러 $10^9 + 7$을 적용한다.           문제 풀이에 필요한 변수를 정의한다.            currentMax와 max는 Kadane’s algorithm방식으로 문제 풀이를 하기 위한 변수로, 첫 값이 0보다 크면 해당 값을 아니면 빈 부분 배열의 합인 0을 넣어준다.       sum은 arr의 값을 더해줄 변수로, arr[0]의 값을 넣어준다.           1부터 k가 2보다 크면 $2 \\times k$, 아니면 length까지 i를 증가시키며 아래를 반복한다.            currentMax에 아래 중 큰 값을 넣어준다.                    currentMax에 arr의 $\\frac{i}{length}$ 값의 몫 위치 값을 더한 값인 현재값까지 최대 합.           arr의 $\\frac{i}{length}$ 값의 몫 위치 값.                       max에 두 값 중 큰 값을 넣어준다.                    이전까지 최대 값인 max.           현재까지 최대 값인 currentMax.                       i가 length 미만인 경우, sum에 arr[i] 값을 누계해준다.                반복이 완료되면 sum이 0보다 크면서 k를 감소한 값이 2보다 클 때 까지, max에 $max + sum$에 모듈러 $10^9 + 7$를 적용한 값을 넣어준다.       최종 결과가 저장된 max애 모듈러 $10^9 + 7$를 적용한 값을 반환 목표인 int형으로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/k-concatenation-maximum-sum/",
        "teaser": null
      },{
        "title": "MinIO Object Storage II - JAVA Sample",
        "excerpt":"개요  지난 번 MinIO를 설명하면서 S3와 완벽히 호환한다고 이야기 하였으므로, 이에 대해 AWS S3 JAVA SDK v2를 이용한 샘플 코드를 설명한다.   설정     S3의 CredentialsProvider는 여러 가지가 존재하지만 application.properties를 활용한 설정을 사용하는 방법과 DefaultProvider 사용하는 방법을 유연하게 전환할 수 있는 샘플 코드를 설명한다.   S3Properties.java  @Data @Configuration @ConfigurationProperties(prefix = \"s3\") public class S3Properties {    private String endpointUrl;   private String accessKeyId;   private String secretAccessKey;   private String region;  }     ConfigurationProperties를 이용하여 “application.properties”에 설정한 아래의 설정들을 가져와 설정한다.            s3.endpoint-url : S3 API URL을 설정한다.       s3.access-key-id : S3에서 발급한 Access Key를 설정한다.       s3.secret-access-key : 위의 Access key의 Secrey Key를 설정한다.       s3.region : S3 연결 리전 명칭을 설정한다.           S3Config.java  private AwsCredentialsProvider getAwsCredentialsProvider() {   if (StringUtils.isNotBlank(this.s3Properties.getAccessKeyId()) &amp;&amp; StringUtils.isNotBlank(this.s3Properties.getSecretAccessKey())) {     return StaticCredentialsProvider.create(         AwsBasicCredentials.create(this.s3Properties.getAccessKeyId(), this.s3Properties.getSecretAccessKey()));   } else {     return DefaultCredentialsProvider.create();   } }     S3Properties에서 설정한 정보를 이용하여 CredentialsProvider를 동적으로 설정한다.            “AccessKeyId”와 “SecretAccessKey”를 설정한 경우, AwsBasicCredentials를 이용한 설정을 사용하도록한다.           DefaultCredentialsProvider는 SDK 내에서 동적으로 어떤 CredentialsProvider를 사용할지 아래의 순서대로 확인하여 인증 가능하도록 한다.            SystemPropertyCredentialsProvider : JAVA 시스템 설정 내 “aws.accessKeyId”와 “aws.secretAccessKey”를 이용한다.       EnvironmentVariableCredentialsProvider : 환경 변수로 설정된 “AWS_ACCESS_KEY_ID”와 “AWS_SECRET_ACCESS_KEY”를 사용한다.       WebIdentityTokenFileCredentialsProvider : JAVA 시스템 설정 내 혹은 환경 변수에 존재하는 Web ID 토큰을 사용한다.       ProfileCredentialsProvider : AWS 인증 정보를 저장하는 기본 파일인 ‘~/.aws/credentials’를 이용해 AWS SDK와 CLI와 설정을 공유한다.       ContainerCredentialsProvider : security manager가 해당 변수에 접근할 권한을 가진 경우, Amazon EC2 컨테이너 서비스에 “AWS_CONTAINER_CREDENTIALS_RELATIVE_URI” 환경 변수가 설정하여 사용한다.       InstanceProfileCredentialsProvider : Amazon EC2 메타 서비스를 이용하여 인스턴스 프로필을 가져온다.           public S3Client s3Client() {   S3ClientBuilder s3ClientBuilder = S3Client.builder().credentialsProvider(this.getAwsCredentialsProvider());   if (StringUtils.isNotBlank(this.s3Properties.getEndpointUrl())) {     s3ClientBuilder.endpointOverride(URI.create(this.s3Properties.getEndpointUrl()));   }   if (StringUtils.isNotBlank(this.s3Properties.getRegion())) {     s3ClientBuilder.region(Region.of(this.s3Properties.getRegion()));   }   return s3ClientBuilder.build(); }     S3ClientBuilder를 이용하여 위에서 사용된 기본 방법을 이용하여 CredentialsProvider를 설정한다.   “application.properties” 내 “EndpointUrl”, “Region” 정보가 있을 때는 해당 정보를 보도록 하고 없으면 위에서 설명한 DefaultCredentialsProvider에서 제공하는 방법으로 주입 받도록 처리한다.            “EndpointUrl”을 설정하지 않으면 “Region” 내 “EndpointUrl” 사용하기 때문에 “Region”은 반드시 설정해야 하며, 설정되지 않은 경우 오류가 발생한다.           실행  S3Service.java  listObjects  public List&lt;S3Object&gt; listObjects(String bucket, int size) {   try {     return this.s3Client.listObjects(ListObjectsRequest.builder().bucket(bucket).maxKeys(size).build())         .contents();   } catch (Exception e) {     e.printStackTrace();     return Collections.emptyList();   } }     S3의 특정 bucket에 존재하는 Object 정보 size 단위로 페이징 처리하여 가져오는 listObjects를 이용한 샘플 코드이다.   getObject  public ResponseEntity&lt;ByteArrayResource&gt; getObject(String bucket, String key) {   try {     ResponseInputStream&lt;GetObjectResponse&gt; responseInputStream = this.s3Client.getObject(GetObjectRequest.builder().bucket(bucket).key(key).build());     GetObjectResponse getObjectResponse = responseInputStream.response();     return ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION, \"attachment; filename=\" + key)         .contentType(MediaType.valueOf(responseInputStream.response().contentType()))         .contentLength(getObjectResponse.contentLength())         .lastModified(getObjectResponse.lastModified())         .body(new ByteArrayResource(responseInputStream.readAllBytes()));   } catch (Exception e) {     e.printStackTrace();     return ResponseEntity.internalServerError().build();   } }     S3에 생성된 bucket 내 key에 해당하는 Object 정보를 가져와서 Reponse로 해당 파일을 반환하는 getObject를 활용한 샘플 코드이다.   GetObjectResponse를 반환하여 Object 정보를 여러 방법거나, OutputStream을 이용해 파일 생성 등 다양하게 활용 가능하다.   putObject  public boolean putObject(String bucket, String key, String path) {   try {     return this.s3Client.putObject(PutObjectRequest.builder().bucket(bucket).key(key).build(), Paths.get(path))         .sdkHttpResponse()         .isSuccessful();   } catch (Exception e) {     e.printStackTrace();     return false;   } }     S3에 생성된 bucket 내 key에 해당하는 Object를 시스템 내 path에 위치한 파일로 덮어쓰는 putObject를 이용한 샘플 코드이다.   S3는 기본적으로 key에 Object를 설정하므로, Versioning 설정을 하지 않은 상태라면 기존 파일 정보를 백업하지 않고 덮어써진다.   copyObject  public boolean copyObject(String sourceBucket, String sourceKey, String destinationBucket, String destinationKey) {   try {     return this.s3Client         .copyObject(CopyObjectRequest.builder()             .sourceBucket(sourceBucket).sourceKey(sourceKey)             .destinationBucket(destinationBucket).destinationKey(destinationKey).build())         .sdkHttpResponse()         .isSuccessful();   } catch (Exception e) {     e.printStackTrace();     return false;   } }     S3에 생성된 sourceBucket 내 sourceKey에 해당하는 Object를 destinationBucket의 destinationKey로 복사하는 putObject를 이용한 샘플 코드이다.   deleteObject  public boolean deleteObject(String bucket, String key) {   try {     return this.s3Client.deleteObject(DeleteObjectRequest.builder().bucket(bucket).key(key).build())         .sdkHttpResponse()         .isSuccessful();   } catch (Exception e) {     e.printStackTrace();     return false;   } }     S3에 생성된 bucket 내 key에 해당하는 Object를 삭제하는 deleteObject를 이용한 샘플 코드이다.   여담     Spring Boot 3.2 버전에서는 Spring Framework 6.1 버전을 도입하여 “@RequestMapping”과 관련한 어노테이션들에서 “@PathVariable” 어노테이션을 사용할 때, “name”과 “value”으로 어느 값을 변수에 할당할지 명시하지 않으면 “Ensure that the compiler uses the ‘-parameters’ flag.” 오류가 발생한다.   Spring Framework가 5에서 6으로 버전이 올라가면서 “LocalVariableTableParameterNameDiscoverer”가 삭제되어 컴파일 단계에서 매개 변수 이름을 추론하는 기능을 기본적으로 제공하지 않으므로, 사용하고자 하는 경우 컴파일 설정에 Java 8 이상에서는 ‘-parameters’, Kotlin은 ‘-java-parameters’ 플래그를 추가하여 해당 기능을 사용할 수 있도록 변경되었다.   소스  Sample Code는 여기에서 확인 가능합니다.   이전  MinIO Object Storage   참고     AWS SDK for Java - Developer Guide for version 2.x   Spring GitHub - Upgrading to Spring Framework 6.x #Parameter Name Retention  ","categories": ["Storage"],
        "tags": ["Programming","Storage","MinIO"],
        "url": "/storage/minio-II/",
        "teaser": null
      },{
        "title": "Leetcode Java Critical Connections in a Network",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; criticalConnections(int n, List&lt;List&lt;Integer&gt;&gt; connections) {     List&lt;Integer&gt;[] graph = new ArrayList[n];     for (int i = 0; i &lt; n; i++) {       graph[i] = new ArrayList&lt;&gt;();     }     for (List&lt;Integer&gt; connection : connections) {       graph[connection.get(0)].add(connection.get(1));       graph[connection.get(1)].add(connection.get(0));     }     List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;();     this.dfs(results, graph, 0, 0, new int[n], 1);     return results;   }    private void dfs(List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt;[] graph, int parent, int node, int[] times, int time) {     times[node] = time;     for (int neighbor : graph[node]) {       if (neighbor == parent) {         continue;       }       if (times[neighbor] == 0) {         this.dfs(results, graph, node, neighbor, times, time + 1);       }       times[node] = Math.min(times[node], times[neighbor]);       if (times[neighbor] &gt; time) {         results.add(Arrays.asList(node, neighbor));       }     }   }  }   결과  Link   설명          n개의 서버들의 서버 간 연결 정보를 나타내는 connections을 이용하여 한 연결 정보를 삭제하는 경우, 둘 중 하나의 서버로 접근이 불가능한 치명적인 연결 정보를 찾는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            graph는 서버들 간 연결 정보를 저장할 변수로, n개의 ArrayList 배열로 초기화 후 connections를 모두 반복하여 각 서버의 위치에 연결된 서버 번호를 넣어준다.       results는 치명적인 연결 정보를 저장하기 위한 변수로, ArrayList로 초기화한다.                4번에서 정의한 dfs(List&lt;List&gt; results, List[] graph, int parent, int node, int[] times, int time) 메서드를 수행하여 치명적인 연결 정보가 저장된 result를 주어진 문제의 결과로 반환한다.       DFS 방식으로 치명적인 연결 정보를 탐색할 dfs(List&lt;List&gt; results, List[] graph, int parent, int node, int[] times, int time) 메서드를 정의한다.            times[node]의 위치에 time을 넣어준다.       graph[node]의 값들을 순차적으로 neighbor에 넣고 아래를 수행한다.                    neighbor와 parent가 동일한 이전 경로인 경우, 다음 반복을 수행한다.           times[neighbor]의 값이 0인 수행되지 않은 노드인 경우, parent에 node, node에 neighbor를 넣고 time을 증가시켜 재귀 호출을 수행한다.           times[node]에 times[node]와 times[neighbor] 중 작은 값을 넣어준다.           current가 times[neighbor]보다 작은 치명적인 경로인 경우, node와 neighbor 조합을 result에 넣어준다.                           해설     치명적인 연결이 A 서버와 B 서버인 경우, B 서버로 가기 위한 연결은 반드시 A 서버를 거치는 방법이어야 한다.   위의 설명을 기반으로 A 서버까지 걸린 현재 시간인 current가 B가 수행되었던 times[B]보다 큰 경우, B로 갈 수 있는 서버가 또 존재하므로 치명적인 연결이 아니게 된다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/critical-connections-in-a-network/",
        "teaser": null
      },{
        "title": "Leetcode Java Find the Length of the Longest Common Prefix",
        "excerpt":"문제  Link   코드  class Solution {    public int longestCommonPrefix(int[] arr1, int[] arr2) {     Set&lt;Integer&gt; set = new HashSet&lt;&gt;();     for (int num : arr1) {       while (!set.contains(num) &amp;&amp; num &gt; 0) {         set.add(num);         num /= 10;       }     }     int result = 0;     for (int num : arr2) {       while (!set.contains(num) &amp;&amp; num &gt; 0) {         num /= 10;       }       if (num &gt; 0) {         result = Math.max(result, (int) Math.log10(num) + 1);       }     }     return result;   }  }   결과  Link   설명          arr1과 arr2의 값들 중 가장 긴 접두 문자의 길이를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            set은 각 가능한 숫자들을 넣어줄 변수로, 중복을 배제하기 위해서 HashSet로 초기화 후 아래를 수행한다.                    arr1의 값들을 순차적으로 num에 넣어 set에 num이 존재하지 않으면서 num이 0 초과일 때까지, set에 num을 넣고 num에 자기 자신을 10으로 나눈 몫을 넣어준다.                       result는 가장 긴 접두 문자의 길이를 저장하기 위한 변수로, 0으로 초기화한다.           arr2의 값을 순차적으로 num에 넣어 아래를 수행한다.            set에 num이 존재하지 않으면서 num이 0 초과일 때까지, num에 10을 나눈 값을 넣어준다.       num이 0 초과인 접두사가 가능한 길이인 경우, result에 result와 num을 log10한 결과에 1을 더한 길이 중 큰 값을 넣어준다.           반복이 완료되면 가장 긴 접두 문자의 길이가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-the-length-of-the-longest-common-prefix/",
        "teaser": null
      },{
        "title": "Leetcode Java Sum of Prefix Scores of Strings",
        "excerpt":"문제  Link   코드  class Solution {    public int[] sumPrefixScores(String[] words) {     TrieNode trieNode = new TrieNode();     for (String word : words) {       TrieNode temp = trieNode;       for (char c : word.toCharArray()) {         int num = c - 'a';         if (temp.children[num] == null) {           temp.children[num] = new TrieNode();         }         temp.children[num].sum++;         temp = temp.children[num];       }     }     int i = 0;     int[] result = new int[words.length];     for (String word : words) {       TrieNode temp = trieNode;       int sum = 0;       for (char c : word.toCharArray()) {         int num = c - 'a';         sum += temp.children[num].sum;         temp = temp.children[num];       }       result[i++] = sum;     }     return result;   }  } class TrieNode {  \tpublic int sum; \tpublic TrieNode[] children;  \tpublic TrieNode() { \t\tthis.sum = 0; \t\tthis.children = new TrieNode[26]; \t}  }   결과  Link   설명          words 내 각 단어 별 접두사가 동일한 words의 문자 갯수를 동일한 위치의 배열로 반환하는 문제이다.       TrieNode는 각 단어에 해당하는 문자 갯수를 저장할 객체이다.            sum은 현재 위치에 해당하는 문자의 합계를 계산할 변수이다.       children은 현재 위치 이후로 존재하는 문자를 이어주기 위한 변수이다.       생성자인 TrieNode()는 객체를 초기화할 메서드로, sum에 0, children에 영문자 갯수인 26 크기의 TrieNode 배열로 초기화한다.           문제 풀이에 필요한 변수를 정의한다.            trieNode는 words의 문자들 내 접두사를 순차적으로 Trie를 활용하여 넣을 변수로, words의 각 단어들로 해당 객체를 초기화한다.       i는 결과 문자열의 위치 변수로, 0으로 초기화한다.       result는 결과를 저장할 배여롤, words 길이의 정수 배열로 초기화한다.           words를 순차적으로 word에 넣어 trieNode에서 접두사 별 합계를 더해 result의 각 위치에 넣어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sum-of-prefix-scores-of-strings/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Monthly Transactions I",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT   TO_CHAR(trans_date, 'YYYY-MM') AS month,   country,   COUNT(*) AS trans_count,   SUM(CASE WHEN state = 'approved' THEN 1 ELSE 0 END) AS approved_count,   SUM(amount) AS trans_total_amount,   SUM(CASE WHEN state = 'approved' THEN amount ELSE 0 END) AS approved_total_amount FROM Transactions GROUP BY TO_CHAR(trans_date, 'YYYY-MM'), country   결과  Link   설명     Transactions 테이블에서 월, 지역 별 아래의 산술 지표를 구하는 문제이다.            trans_count는 두 조건 내 해당하는 데이터의 갯수이다.       approved_count는 두 조건 내 해당하는 데이터 중 state가 approved인 갯수이다.                    state가 approved인 값을 1, 나머지를 0으로 설정하였기 때문에 SUM인 합계를 활용하여 갯수를 계산한다.                       trans_total_amount는 두 조건 내 해당하는 amount의 합이다.       approved_total_amount는 두 조건 내 해당하는 데이터 중 state가 approved인 amount의 합이다.          ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/monthly-transactions-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Fizz Buzz Multithreaded",
        "excerpt":"문제  Link   코드  class FizzBuzz {    private int n;   private int count = 1;    public FizzBuzz(int n) {     this.n = n;   }    // printFizz.run() outputs \"fizz\".   public synchronized void fizz(Runnable printFizz) throws InterruptedException {     while (this.count &lt;= this.n) {       if (this.count % 3 != 0 || this.count % 5 == 0) {         wait();         continue;       }       printFizz.run();       this.count++;       notifyAll();     }   }    // printBuzz.run() outputs \"buzz\".   public synchronized void buzz(Runnable printBuzz) throws InterruptedException {     while (this.count &lt;= this.n) {       if (this.count % 5 != 0 || this.count % 3 == 0) {         wait();         continue;       }       printBuzz.run();       this.count++;       notifyAll();     }   }    // printFizzBuzz.run() outputs \"fizzbuzz\".   public synchronized void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException {     while (this.count &lt;= this.n) {       if (this.count % 15 != 0) {         wait();         continue;       }       printFizzBuzz.run();       this.count++;       notifyAll();     }   }    // printNumber.accept(x) outputs \"x\", where x is an integer.   public synchronized void number(IntConsumer printNumber) throws InterruptedException {     while (this.count &lt;= this.n) {       if (this.count % 3 == 0 || this.count % 5 == 0) {         wait();         continue;       }       printNumber.accept(this.count);       this.count++;       notifyAll();     }   }  }   결과  Link   설명     아래의 규칙대로 [1, n] 범위 내에서 “fizz”, “buzz”, “fizzbuzz”, 위치 값을 찍는 FizzBuzz 객체를 완성하는 문제이다.            생성자인 FizzBuzz(int n)는 n까지 각 값들을 출력하기 위한 객체를 초기화한다.       메서드인 fizz(printFizz)는 3의 배수이면서 5의 배수가 아닌 경우, printFizz를 호출하여 “fizz”를 출력한다.       메서드인 buzz(printBuzz)는 5의 배수이면서 3의 배수가 아닌 경우, printBuzz를 호출하여 “buzz”를 출력한다.       메서드인 fizzbuzz(printFizzBuzz)는 3과 5의 배수인 경우, printFizzBuzz를 호출하여 “fizzbuzz”를 출력한다.       메서드인 number(printNumber)는 3과 5의 배수가 아닌 경우, printnumber를 호출하여 현재 위치 값을 출력한다.           순차적인 출력을 위한 전역 변수들을 정의한다.            n은 생성자를 통해 주입된 출력의 상한 값을 저장한다.       count는 현재 번호를 저장할 변수이다.           생성자인 FizzBuzz(int n)를 완성한다.            전역 변수인 n에 전달된 n을 저장한다.       전역 변수인 count를 시작 숫자인 1로 초기화한다.           메서드인 fizz(printFizz)를 완성한다.            하나의 쓰레드만 접근 가능하도록 synchronized 키워드를 추가한다.       count가 n 이하일 때 까지 아래를 반복한다.                    count가 3의 배수가 아니거나 5의 배수인 경우, 현재 쓰레드를 일시 중지시키고 다음 반복을 수행한다.           printFizz를 수행하여 “fizz”를 출력하고, count인 번호를 증가시킨다.           현재 일시 중지된 모든 쓰레드를 깨운다.                           메서드인 buzz(printBuzz)를 완성한다.            하나의 쓰레드만 접근 가능하도록 synchronized 키워드를 추가한다.       count가 n 이하일 때 까지 아래를 반복한다.                    count가 3의 배수이거나 5의 배수가 아닌 경우, 현재 쓰레드를 일시 중지시키고 다음 반복을 수행한다.           printBuzz를 수행하여 “buzz”를 출력하고, count인 번호를 증가시킨다.           현재 일시 중지된 모든 쓰레드를 깨운다.                           메서드인 fizzbuzz(printFizzBuzz)를 완성한다.            하나의 쓰레드만 접근 가능하도록 synchronized 키워드를 추가한다.       count가 n 이하일 때 까지 아래를 반복한다.                    count가 15의 배수가 아닌 경우, 현재 쓰레드를 일시 중지시키고 다음 반복을 수행한다.           printFizzBuzz를 수행하여 “fizzbuzz”를 출력하고, count인 번호를 증가시킨다.           현재 일시 중지된 모든 쓰레드를 깨운다.                           메서드인 number(printNumber)를 완성한다.            하나의 쓰레드만 접근 가능하도록 synchronized 키워드를 추가한다.       count가 n 이하일 때 까지 아래를 반복한다.                    count가 3의 배수이거나 5의 배수인 경우, 현재 쓰레드를 일시 중지시키고 다음 반복을 수행한다.           printNumber를 수행하여 현재 번호를 출력하고, count인 번호를 증가시킨다.           현재 일시 중지된 모든 쓰레드를 깨운다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/fizz-buzz-multithreaded/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Absolute Difference",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; minimumAbsDifference(int[] arr) {     Arrays.sort(arr);     int min = Integer.MAX_VALUE;     for (int i = 1; i &lt; arr.length; i++) {       min = Math.min(min, arr[i] - arr[i - 1]);     }     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     for (int i = 1; i &lt; arr.length; i++) {       int diff = arr[i] - arr[i - 1];       if (min == diff) {         result.add(Arrays.asList(arr[i - 1], arr[i]));       }     }     return result;   }  }   결과  Link   설명          arr 내 값들의 최소 차잇값에 대한 값들을 한 쌍씩 묶어서 반환하는 문제이다.            arr의 값들을 오름차순으로 정렬해준다.       문제 풀이에 필요한 변수를 정의한다.            min은 최소 차잇값을 저장하기 위한 변수로, 두 값의 차잇값이 최소인 값을 넣어준다.       result는 결과를 저장하기 위한 변수로, ArrayList로 초기화한다.           1부터 arr의 길이 미만까지 i를 증가시키며 아래를 반복한다.            diff는 $arr[i] - arr[i - 1]$인 인접한 두 값의 차잇값을 저장한다.       min과 diff가 동일한 최소 차잇값을 만족하는 경우, result에 arr[$i - 1$]의 값과 arr[i]의 값을 쌍으로 넣어준다.           반복이 완료되면 주어진 조건을 만족하는 결과만 저장한 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-absolute-difference/",
        "teaser": null
      },{
        "title": "Leetcode Java Ugly Number III",
        "excerpt":"문제  Link   코드  class Solution {    public int nthUglyNumber(int n, int a, int b, int c) {     int left = 0;     int right = (int) 2e9;     int result = 0;     while (left &lt;= right) {       int mid = left + (right - left) / 2;       if (this.getCount(mid, a, b, c) &gt;= n) {         result = mid;         right = mid - 1;       } else {         left = mid + 1;       }     }     return result;   }    private int getCount(long num, long a, long b, long c) {     long bc = this.getLcm(b, c);     return (int) ((num / a) + (num / b) + (num / c)         - (num / this.getLcm(a, b)) - (num / bc) - (num / this.getLcm(a, c))         + (num / (this.getLcm(a, bc))));   }    private long getGcd(long m, long n) {     if (n == 0) {       return m;     } else {       return this.getGcd(n, m % n);     }   }    private long getLcm(long a, long b) {     return (a * b) / this.getGcd(a, b);   }  }   결과  Link   설명     a, b, c의 n번째 못생긴 숫자를 구하는 문제이다.            못생긴 숫자는 a, b 또는 c로 나눌 수 있는 양의 정수를 의미한다.           문제 풀이에 필요한 변수를 정의한다.            left와 right는 가능한 숫자의 범위로, 0과 상한값인 $2 \\times 10^9$로 초기화한다.       result는 결과를 저장할 변수로, 0으로 초기화한다.           left가 right 이하일 때 까지 아래를 반복여 이진 탐색을 수행한다.            mid는 중앙값을 저장할 변수로, $left + \\frac{right - left}{2}$의 값을 넣어준다.       4번에서 정의한 getCount(long num, long a, long b, long c)의 결과에 따라 아래를 수행한다.                    결과가 참인 경우, result에 mid를 넣은 후 right에 $mid - 1$을 넣어 상한값을 낮춰준다.           결과가 거짓인 경우, left에 $mid + 1$을 넣어 하한값을 증가시켜준다.                           배수의 갯수를 찾을 getCount(long num, long a, long b, long c) 메서드를 정의한다.            아래의 값들을 모두 계산하여 a와 b, c를 나눈 숫자의 갯수를 모두 만족하는 결과를 계산하여 반환한다.                    num을 a와 b, c로 각각 나눈 값을 모두 더한다.           num을 a와 b, b와 c, a와 c의 최소 공배수로 각각 나눈 값을 뺴준다.           num을 a와 b, c의 최소 공배수로 나눈 결과를 다시 더해준다.                           반복이 완료되면 n번째 못생긴 숫자가 저장된 result를 주어진 문제의 결과로 반환한다.   해설       왼쪽 그림과 같이 a, b, c로 나눌 수 있는 영역을 모두 더한 경우에 겹치는 부분이 존재한다.   그렇기 때문에 가운데 그림과 같이 a와 b, b와 c, a와 c에 대한 최소 공배수에 대한 결과를 제거하면 공통 부분이 제거된다.   마지막으로 a, b, c의 최소 공배수에 대한 결과를 더하면 모든 값에 대해서 중복을 제거한 값들의 갯수를 구할 수 있다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/ugly-number-iii/",
        "teaser": null
      },{
        "title": "Leetcode Java Design a Stack With Increment Operation",
        "excerpt":"문제  Link   코드  class CustomStack {    private int[] stack;   private int top = -1;    public CustomStack(int maxSize) {     this.stack = new int[maxSize];   }    public void push(int x) {     if (this.top &lt; this.stack.length - 1) {       this.top++;       this.stack[this.top] = x;     }   }    public int pop() {     if (this.top != -1) {       return this.stack[this.top--];     }     return -1;   }    public void increment(int k, int val) {     for (int i = 0; i &lt; Math.min(k, this.top + 1); i++) {       this.stack[i] += val;     }   }  }  /**  * Your CustomStack object will be instantiated and called as such:  * CustomStack obj = new CustomStack(maxSize);  * obj.push(x);  * int param_2 = obj.pop();  * obj.increment(k,val);  */   결과  Link   설명     increment 연산자를 제공하는 스택인 CustomStack을 만드는 문제이다.            생성자인 CustomStack(int maxSize)은 maxSize 크기의 스택을 초기화한다.       메서드인 push(int x)는 스택의 위에 x를 추가한다.       메서드인 pop()은 스택의 위에 해당하는 값을 반환한다. 단, 스택이 비어있을 경우 -1을 반환한다.       메서드인 increment(int k, int val)는 아래에서 k번째 값까지 val만큼 증가시켜준다. 값이 k개 미만인 경우 모든 값들을 증가시켜준다.           CustomStack에 필요한 전역 변수를 정의한다.            stack은 값을 저장할 변수이다.       top은 값을 저장한 위치를 저장할 변수이다.           생성자인 CustomStack(int maxSize)을 정의한다.            stack을 maxSize의 정수 배열로 초기화한다.       top을 -1로 초기화한다.           메서드인 push(int x)를 정의한다.            top이 stack의 마지막 위치보다 작은 경우, top을 증가시키고 stack[top]에 x를 넣어준다.           메서드인 pop()을 정의한다.            top이 -1이 아닌 경우, stack[top]을 반환하고 top을 감소시킨다.       top이 -1인 경우, 스택의 값이 없으므로 -1을 반환한다.           메서드인 increment(int k, int val)를 정의한다.            0부터 k 혹은 $top + 1$ 중 작은 범위 내 값들에 val을 더해준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/design-a-stack-with-increment-operation/",
        "teaser": null
      },{
        "title": "Leetcode Java Check If Array Pairs Are Divisible by k",
        "excerpt":"문제  Link   코드  class Solution {    public boolean canArrange(int[] arr, int k) {     int[] counts = new int[k];     for (int num : arr) {       counts[((num % k) + k) % k]++;     }     if (counts[0] % 2 != 0) {       return false;     }     for (int i = 1; i &lt;= k / 2; i++) {       if (counts[i] != counts[k - i]) {         return false;       }     }     return true;   }  }   결과  Link   설명          arr의 값 중 두 숫자씩 쌍을 이룬 값들의 합이 k로 나눌 수 있는 검증하는 문제이다.            counts는 arr의 값을 k로 나누기 위한 값을 저장할 변수로, k 크기의 정수 배열로 초기화한 후 arr의 모든 값을 순차적으로 k로 나눈 나머지 값에 k를 더한 후 다시 k로 나눈 나머지 값에 해당하는 값을 증가시켜준다.            counts[0]의 값을 2로 나눈 결과가 0이 아닌 k 배수가 홀수인 경우, 각 값들의 합이 k로 나눌 수 없으므로 false를 주어진 문제의 결과로 반환한다.            1부터 $\\frac{k}{2}$ 이하까지 i를 증가시키며 counts[i]의 값이 counts[$k -i$]의 값과 다른 두 값을 합친 경우, k의 배수가 되지 않는 경우 false를 주어진 문제의 결과로 반환하다.            모든 검증이 끝나면 조건을 만족하므로 true를 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/check-if-array-pairs-are-divisible-by-k/",
        "teaser": null
      },{
        "title": "Leetcode Java Rank Transform of an Array",
        "excerpt":"문제  Link   코드  class Solution {    public int[] arrayRankTransform(int[] arr) {     int[] sortedArr = arr.clone();     Arrays.sort(sortedArr);     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();     int rank = 1;     for (int val : sortedArr) {       if (!map.containsKey(val)) {         map.put(val, rank++);       }     }     int length = arr.length;     int[] result = new int[length];     for (int i = 0; i &lt; length; i++) {       result[i] = map.get(arr[i]);     }     return result;   }  }   결과  Link   설명          arr의 값들을 작은 순서대로 동일 위치에 1부터 시작하는 순위를 배열로 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            sortedArr는 arr을 정렬하여 저장할 변수로, arr을 복사하여 넣어준 후 오름차순 정렬한다.       map은 값과 순위를 키와 값으로 저장할 변수로, HashMap으로 초기화한다.       rank는 순위를 계산할 변수로, 시작 순위인 1로 초기화 후 아래를 수행한다.                    soaredArr의 각 값을 순차적으로 val에 넣어 map의 val에 해당하는 값이 없으면 해당 값에 rank를 넣고 rank를 증가시켜준다.                       length는 arr의 길이를 저장한 변수이다.       result는 결과를 반환하기 위한 변수로, length 크기의 정수 배열로 초기화한다.           0부터 length 미만까지 i를 증가시키며 result[i]에 map의 arr[i]에 해당 하는 값인 순위를 넣어준 후 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/rank-transform-of-an-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Make Sum Divisible by P",
        "excerpt":"문제  Link   코드  class Solution {    public int minSubarray(int[] nums, int p) {     int remainder = 0;     for (int num : nums) {       remainder = (remainder + num) % p;     }     if (remainder == 0) {       return 0;     }     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();     map.put(0, -1);     int length = nums.length;     int min = length;     int curr = 0;     for (int i = 0; i &lt; length; i++) {       curr = (curr + nums[i]) % p;       map.put(curr, i);       min = Math.min(min, i - map.getOrDefault((curr - remainder + p) % p, -length));     }     return min &lt; length ? min : -1;   }  }   결과  Link   설명          nums의 모든 값의 합이 p가 되도록 nums 내 연속된 값들을 제거하기 위한 최소 갯수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            remainder에 nums 모든 값을 더하면서 p를 나눈 나머지 값을 넣어주고, 0인 경우 합이 p로 나누어 떨어지므로 주어진 문제의 결과로 0을 반환한다.       map은 값과 위치를 저장할 변수로, HashMap으로 초기화하고 키가 0인 값에 -1을 넣어준다.       length는 nums의 길이를 저장한 변수이다.       min은 최소 갯수를 계산할 변수로, 가능한 큰 갯수인 length로 초기화한다.       curr은 현재까지 부족한 값을 저장할 변수로, 0으로 초기화한다.           0부터 length 미만까지 i를 증가시키면서 아래를 반복한다.            curr에 $curr + nums[i]$의 값에 p를 나눈 나머지 값을 넣어준다.       map의 curr이 키인 위치에 i를 넣어 해당 위치에 부족한 값을 저장한다.       min에 min과 i에 map 내 $curr - remainer + p$를 p로 나눈 나머지 위치의 값 혹은 값이 없으면 -length를 빼준 값 중 작은 값을 넣어준다.           반복이 완료되면 min이 length보다 작은 제거 가능한 숫자가 존재하면 min을, 아니면 불가능하므로 -1을 주어진 문제의 결과로 반환한다.   해설     제거할 숫자의 갯수를 탐색하기 위한 방법은 아래와 같다.   현재 위치인 i에서 $curr - remainer + p$를 p로 나눈 값이 키인 값의 위치 값을 빼면 그 사이 위치 값들을 제거한 갯수를 계산할 수 있다.   위의 경우가 아니라면 map 내 부족한 값에 대한 위치가 존재하지 않으므로, i에 nums의 숫자 갯수인 length를 더한 min보다 큰 값을 비교하여 min을 그대로 남겨준다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/make-sum-divisible-by-p/",
        "teaser": null
      },{
        "title": "Leetcode Java Divide Players Into Teams of Equal Skill",
        "excerpt":"문제  Link   코드  class Solution {    public long dividePlayers(int[] skill) {     int[] count = new int[1001];     int sum = 0;     for (int s : skill) {       count[s]++;       sum += s;     }     int teams = skill.length / 2;     if (sum % teams != 0) {       return -1;     } else {       long result = 0;       int divide = sum / teams;       for (int s : skill) {         int diff = divide - s;         if (count[diff] == 0) {           return -1;         }         result += (long) s * diff;         count[diff]--;       }       return result / 2;     }   }  }   결과  Link   설명     skill을 두 값씩 팀을 지어 동일한 합의 값을 만들 때, 각 팀 값들에 대한 곱을 누계한 값을 반환한다.            단, 팀을 이뤄 값을 반환할 수 없으면 -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            count는 skill 값의 갯수를 더할 배열로, 값의 범위보다 1 큰 1001 크기의 정수 배열로 초기화하고 갯수를 넣어준다.       sum은 skill 값의 총합을 넣을 변수로, 각 값의 합을 더해서 넣어준다.       teams는 skill 값으로 구성할 수 있는 팀의 갯수로, skill 길이를 2로 나눈 값을 넣어준다.                sum을 teams로 나눈 값이 0이 아니면 팀을 이룰 수 없으므로, -1을 주어진 문제의 결과로 반환한다.       3번의 경우가 아니라면 아래를 수행한다.            결과를 구하기 위한 변수를 정의한다.                    result는 팀을 이룰 수 있는 값들에 대한 곱을 누계할 변수로, 반환 타입인 long 형태의 0으로 초기화한다.           divide는 각 팀이 가능한 값의 합을 저장할 변수로, $\\frac{sum}{teams}$로 초기화한다.                       skill을 순차적우로 s에 넣어 아래를 수행한다.                    diff에 $divide - s$의 팀을 이룰 수 있는 값을 넣어준다.           count[diff]가 0인 팀을 이룰 수 없는 경우, -1을 주어진 문제의 결과로 반환한다.           result에 s와 diff를 곱한 값을 더한 후 count[diff]의 값을 감소시킨다.                       반복이 완료되면 각 팀의 값을 두 번 곱해진 result를 2로 나눈 $\\frac{result}{2}$를 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/divide-players-into-teams-of-equal-skill/",
        "teaser": null
      },{
        "title": "Leetcode Java Smallest String With Swaps",
        "excerpt":"문제  Link   코드  class Solution {    public String smallestStringWithSwaps(String s, List&lt;List&lt;Integer&gt;&gt; pairs) {     char[] charArray = s.toCharArray();     int length = charArray.length;     int[] parent = new int[length];     Map&lt;Integer, Queue&lt;Character&gt;&gt; map = new HashMap&lt;&gt;();     for (int i = 0; i &lt; length; i++) {       parent[i] = i;     }     for (List&lt;Integer&gt; pair : pairs) {       this.union(parent, pair.get(0), pair.get(1));     }     for (int i = 0; i &lt; length; i++) {       map.computeIfAbsent(this.find(parent, i), k -&gt; new PriorityQueue&lt;&gt;());       map.get(parent[i]).offer(charArray[i]);     }     StringBuilder sb = new StringBuilder();     for (int i = 0; i &lt; length; i++) {       sb.append(map.get(parent[i]).poll());     }     return sb.toString();   }    private void union(int[] parent, int i, int j) {     int pi = this.find(parent, i);     int pj = this.find(parent, j);     if (pi &gt; pj) {       parent[pi] = pj;     } else {       parent[pj] = pi;     }   }    private int find(int[] parent, int i) {     if (i != parent[i]) {       parent[i] = this.find(parent, parent[i]);     }     return parent[i];   }  }   결과  Link   설명          s를 pairs 내 임의 순서의 문자 위치를 스왑하여 사전적으로 가장 작은 문자열을 만들어 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            charArray와 length는 s를 문자 배열로 변환한 배열과 길이를 저장한 변수이다.       parent는 각 위치 별 부모 위치를 저장하기 위한 배열로, length 길이의 정수 배열로 초기화하여 각 자리에 현재 위치를 넣어준다.       map은 위치 별 가능한 문자들을 저장할 변수로, HashMap으로 초기화한다.                pairs를 순차적으로 pair에 넣어 4번에서 정의한 union(int[] parent, int i, int j) 메서드에 parent와 pair의 각 값을 넣어 수행한다.       Union-Find 알고리즘으로 문제해결하기 위한 union(int[] parent, int i, int j) 메서드를 정의한다.            pi와 pj에 5번에서 정의한 find(int[] parent, int i) 메서드를 수행한 결과를 넣어준다.       pi가 pj보다 큰 경우, parent[pi]에 pj를 아니면 parent[pj]에 pi를 넣어 병합한다.           Union-Find 알고리즘으로 문제해결하기 위한 find(int[] parent, int i) 메서드를 정의한다.            i와 parent[i]가 다른 경우, parent[i]에 parent와 parent[i]로 재귀 호출한 결과인 부모 위치의 값을 넣어준다.       parent[i]를 반환한다.           0부터 length까지 i를 증가시키며 아래를 수행한다.            map의 5번에서 정의한 find(int[] parent, int i) 메서드를 수행한 결과에 대한 값이 존재하지 않으면, 오름차순 정렬된 값을 저장할 PriorityQueue를 넣어준다.       map의 parent[i]에 해당하는 PriorityQueue에 charArray[i]를 넣어 저장한다.                동적으로 결과를 조합할 StringBuilder인 sb를 정의하고, map에서 parent[i]에 해당하는 PriorityQueue의 사전적으로 가장 작은 값인 첫 값을 꺼내 sb에 이어준다.       위의 반복을 통해 완성된 sb를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/smallest-string-with-swaps/",
        "teaser": null
      },{
        "title": "Leetcode Java Sentence Similarity III",
        "excerpt":"문제  Link   코드  class Solution {    public boolean areSentencesSimilar(String sentence1, String sentence2) {     String[] words1 = sentence1.split(\" \");     String[] words2 = sentence2.split(\" \");     int length1 = words1.length;     int length2 = words2.length;     if (length1 == length2) {       for (int i = 0; i &lt; length1; i++) {         if (!words1[i].equals(words2[i])) {           return false;         }       }       return true;     }     int i = 0;     int j = 0;     while (i &lt; length1 &amp;&amp; i &lt; length2 &amp;&amp; words1[i].equals(words2[i])) {       i++;     }     while (j &lt; length1 - i &amp;&amp; j &lt; length2 - i &amp;&amp; words1[length1 - 1 - j].equals(words2[length2 - 1 - j])) {       j++;     }     return i + j &gt;= Math.min(length1, length2);   }  }   결과  Link   설명          sentence1에 특정 문자열을 추가할 때 sentence2를 만들 수 있는지 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            words1과 words2는 sentence1과 sentence2를 공백 문자(“ “) 기준으로 분리한 문자열을 저장한 변수이다.       length1과 length2는 sentence1과 sentence2의 길이를 저장한 변수이다.                length1과 length2가 같은 경우, 각 문자열이 동일한지 여부를 주어진 문제의 결과로 반환한다.            i와 j는 동일한 문자열 탐색에 필요한 변수로, 0으로 초기화한다.            i는 length1와 length2 미만이면서 words1와 words2의 동일한 문자열의 갯수를 계산한다.            j는 문자열의 마지막 위치인 $length1 - i$과 $length2 - i$ 미만이면서 words1와 words2의 마지막 문자열 부터 동일한 문자열의 갯수를 계산한다.       아래의 각 경우에 대한 결과를 주어진 문제의 결과로 반환한다.            $i + j$가 length1과 length2 중 작은 값보다 큰 경우, 문자열을 추가하여 만들 수 있으므로 true를 주어진 문제의 결과로 반환한다.       $i + j$가 length1과 length2 중 작은 값보다 작거나 같은 경우, 문자열이 다르거나 만들 수 없으므로 false를 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sentence-similarity-iii/",
        "teaser": null
      },{
        "title": "Leetcode Minimum String Length After Removing Substrings",
        "excerpt":"문제  Link   코드  class Solution {    public int minLength(String s) {     Stack&lt;Character&gt; stack = new Stack&lt;&gt;();     for (char c : s.toCharArray()) {       if (!stack.isEmpty() &amp;&amp; ((c == 'B' &amp;&amp; stack.peek() == 'A') || (c == 'D' &amp;&amp; stack.peek() == 'C'))) {         stack.pop();       } else {         stack.push(c);       }     }     return stack.size();   }  }   결과  Link   설명          영문 대문자로 이루어진 s에서 “AB”와 “CD”를 계속 제거하고 남은 문자열의 길이를 구하는 문제이다.            stack은 s의 문자들을 순차적으로 넣었다가 뺄 변수로, Stack으로 초기화한다.       s의 문자를 순차적으로 c에 넣어 아래를 반복한다.            stack이 비어있지 않으면서 아래 두 조건 중 하나라도 만족하는 경우, stack에서 마지막 문자를 제거한다.                    c가 ‘B’ 문자이면서 stack의 마지막 문자가 ‘A’인 “AB” 문자열인 경우.           c가 ‘D’ 문자이면서 stack의 마지막 문자가 ‘C’인 “CD” 문자열인 경우.                       위의 경우가 아니라면, stack에 c를 넣어준다.           반복이 완료되면 남은 문자열의 길이인 stack의 길이를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-string-length-after-removing-substrings/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Last Person to Fit in the Bus",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT person_name FROM (   SELECT person_name, weight, turn, SUM(weight) OVER (ORDER BY turn) AS sum   FROM Queue ) AS Queue WHERE sum &lt;= 1000 ORDER BY turn DESC  LIMIT 1   결과  Link   설명          Queue 테이블의 사람들이 turn 순서대로 버스를 탑승할 때, weight의 합산이 1000kg 초과하지 않고 탑승할 수 있는 마지막 person_name을 탐색하는 문제이다.            서브 쿼리로 weight의 합계를 turn 순서대로 수행한다.            turn 순서대로 내림차순 정렬하여 sum이 1000 이하인 마지막 탑승한 한 사람을 탐색한다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/last-person-to-fit-in-the-bus/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove All Adjacent Duplicates in String II",
        "excerpt":"문제  Link   코드  class Solution {    public String removeDuplicates(String s, int k) {     int[] count = new int[s.length()];     StringBuilder sb = new StringBuilder();     for (char c : s.toCharArray()) {       sb.append(c);       int length = sb.length();       int i = length - 1;       count[i] = 1 + (i &gt; 0 &amp;&amp; sb.charAt(i) == sb.charAt(i - 1) ? count[i - 1] : 0);       if (count[i] &gt;= k) {         sb.delete(length - k, length);       }     }     return sb.toString();   }  }   결과  Link   설명          문자열 s에서 k번 반복되는 문자열을 모두 제거한 문자열을 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            count는 문자열 갯수를 계산할 변수로, 최대 길이인 문자열 s의 길이로 초기화한다.       sb는 동적으로 문자열 생성하기 위한 변수로, StringBuilder로 초기화한다.           s의 문자들을 순차적으로 c에 넣어 아래를 반복한다.            sb에 c를 넣어준다.       length에 sb의 길이를 넣고, i에 $length - 1$인 sb 마지막 위치를 넣어준다.       count[i]에 1과 아래의 경우에 따른 값을 더한 값을 넣어준다.                    i가 0보다 크면서 sb의 i번째 위치의 문자가 이전과 동일한 경우 이전 연속된 값인, count[$i - 1$]을 더하여 갯수를 증가시켜준다.           위의 경우가 아니라면 0을 넣어 값을 초기화한다.                       count[i]가 k 이상인 경우, sb에서 $length - k$번째 위치부터 length까지 문자들을 제거한다.           반복이 완료되어 완성된 sb를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-all-adjacent-duplicates-in-string-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java The Number of the Smallest Unoccupied Chair",
        "excerpt":"문제  Link   코드  class Solution {    public int smallestChair(int[][] times, int targetFriend) {     int result = -1;     int start = times[targetFriend][0];     Arrays.sort(times, (x, y) -&gt; x[0] - y[0]);     Queue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;((x, y) -&gt; x[0] - y[0]);     Queue&lt;Integer&gt; chairs = new PriorityQueue&lt;&gt;();     for (int i = 0, j = 0; i &lt; times.length; i++) {       while (!queue.isEmpty() &amp;&amp; queue.peek()[0] &lt;= times[i][0]) {         chairs.offer(queue.poll()[1]);       }       result = chairs.isEmpty() ? j++ : chairs.poll();       queue.offer(new int[] { times[i][1], result });       if (times[i][0] == start) {         break;       }     }     return result;   }  }   결과  Link   설명     n명의 친구가 times의 순서대로 의자에 앉았다 일어날 때, targetFriend 번째 친구가 앉는 의자의 번호를 반환하는 문제이다.            times[i] = [arrivali, leavingi]를 의미하며, arrivali는 앉는 시간 leavingi는 떠나는 시간을 뜻한다.       targetFriend와 의자의 번호는 0-index이다.           문제 풀이에 필요한 변수를 정의한다.            result는 targetFriend 번째 친구가 앉는 의자의 번호를 저장할 변수로, -1로 초기화한다.       start는 targetFriend 번째 친구가 앉기 시작하는 시간을 저장한 변수로, target[targetFriend][0]의 값으로 초기화한다.       times는 의자에 앉는 시간 기준으로 오름차순 정렬한다.       queue는 의자에서 떠나는 시간을 의자 번호와 같이 저장할 변수로, 떠나는 시간의 오름차순 정렬되는 PriorityQueue로 초기화한다.       chairs는 앉아있는 의자를 저장할 변수로, 의자 순서대로 저장할 PriorityQueue로 초기화한다.           times탐색을 위한 위치인 i는 0부터 times 길이 미만까지 증가시키며, chairs가 비어있을 때 의자 시작 위치를 저장할 j는 0으로 초기화하여 아래를 수행한다.            queue가 비어있지 않으면서 queue의 첫 친구가 의자에 앉는 시간이 times[i]의 의자에 앉는 시간 이하일 때까지, chairs에 queue에서 해당 친구가 의자를 떠나는 시간을 넣어준다.       result에 chairs가 비어있으면 다음 의자인 j를 넣고 j를 증가시켜주고, 비어있지 않으면 chairs에서 현재 앉을 수 있는 의자를 배정시켜준다.       queue에 i번째 친구가 의자를 떠나는 시간인 times[i][1]와 의자 번호인 result를 넣어준다.       times[i][0]인 i번째 친구가 의자를 앉는 시간이 targetFriend 번째 친구가 앉는 시간인 start인 경우, 반복을 중지한다.           위의 반복이 완료되면 의자의 번호가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/the-number-of-the-smallest-unoccupied-chair/",
        "teaser": null
      },{
        "title": "Leetcode Java Divide Intervals Into Minimum Number of Groups",
        "excerpt":"문제  Link   코드  class Solution {    public int minGroups(int[][] intervals) {     int length = intervals.length;     int[] left = new int[length];     int[] right = new int[length];     for (int i = 0; i &lt; length; i++) {       left[i] = intervals[i][0];       right[i] = intervals[i][1];     }     Arrays.sort(left);     Arrays.sort(right);     int result = 0;     for (int i = 0, j = 0; i &lt; length; i++) {       if (left[i] &lt;= right[j]) {         result++;       } else {         j++;       }     }     return result;   }  }   결과  Link   설명     intervals를 이용하여 각 구간이 겹치지 않도록 나눌 수 있는 최소 그룹의 수를 구하는 문제이다.            intervals[i] = [lefti, righti]로, [left, right] 구간을 의미한다.           문제 풀이에 필요한 변수를 정의한다.            length는 intervals의 길이를 저장한 변수이다.       left와 right는 각 intervals의 left, right 값을 저장할 변수로, length 크기의 정수 배열로 초기화하고 intervals를 이용하여 순차적으로 값을 넣어준 후 오름차순 정렬을 수행한다.       result는 나눌 수 있는 최소 그룹의 수 저장할 변수로, 0으로 초기화한다.           i는 0부터 length 미만까지, j는 0으로 초기화하여 아래를 반복한다.            left[i]의 값이 right[j]의 값보다 작은 경우, 그룹을 나눌 수 있으므로 result를 증가시킨다.       위의 경우가 아니라면 기존 그룹에 넣을 수 있으므로, j를 증가시켜준다.           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/divide-intervals-into-minimum-number-of-groups/",
        "teaser": null
      },{
        "title": "Leetcode Java Design Skiplist",
        "excerpt":"문제  Link   코드  class Skiplist {    private Node head;   private Random random;    public Skiplist() {     this.head = new Node(-1, null, null);     this.random = new Random();   }    public boolean search(int target) {     Node curr = this.head;     while (curr != null) {       while (curr.next != null &amp;&amp; curr.next.val &lt; target) {         curr = curr.next;       }       if (curr.next != null &amp;&amp; curr.next.val == target) {         return true;       }       curr = curr.down;     }     return false;   }    public void add(int num) {     Stack&lt;Node&gt; stack = new Stack&lt;&gt;();     Node curr = this.head;     while (curr != null) {       while (curr.next != null &amp;&amp; curr.next.val &lt; num) {         curr = curr.next;       }       stack.push(curr);       curr = curr.down;     }     boolean insert = true;     Node down = null;     while (insert &amp;&amp; !stack.isEmpty()) {       curr = stack.pop();       curr.next = new Node(num, curr.next, down);       down = curr.next;       insert = this.random.nextDouble() &lt; 0.5;     }     if (insert) {       this.head = new Node(-1, null, this.head);     }   }    public boolean erase(int num) {     Node curr = this.head;     boolean found = false;     while (curr != null) {       while (curr.next != null &amp;&amp; curr.next.val &lt; num) {         curr = curr.next;       }       if (curr.next != null &amp;&amp; curr.next.val == num) {         found = true;         curr.next = curr.next.next;       }       curr = curr.down;     }     return found;   }  }  class Node {    public int val;   public Node next;   public Node down;    public Node() {   }    public Node(int val) {     this.val = val;   }    public Node(int val, Node next, Node down) {     this.val = val;     this.next = next;     this.down = down;   }  } /**  * Your Skiplist object will be instantiated and called as such:  * Skiplist obj = new Skiplist();  * boolean param_1 = obj.search(target);  * obj.add(num);  * boolean param_3 = obj.erase(num);  */   결과  Link   설명     아래의 기능을 만족하는 다중 레이어가 존재하는 Skiplist 객체를 만드는 문제이다.            생성자인 Skiplist()는 Skiplist 객체를 초기화한다.       메서드인 search(int target)는 target 값이 Skiplist에 존재하는지 유무를 반환한다.       메서드인 add(int num)는 Skiplist에 num을 추가한다.       메서드인 erase(int num)는 Skiplist에 num을 삭제한 결과를 반환한다. 단, num이 여러 개 존재하는 경우 하나만 삭제해도 괜찮다.           문제 풀이에 필요한 Node 객체를 정의한다.            val은 현재 노드의 값을 저장한 변수이다.       next는 다음 노드, down은 다음 계층의 노드를 연결할 변수이다.           문제 풀이에 필요한 전역 변수를 정의한다.            head는 SkipList를 구성하기 위한 첫 계층의 노드이다.       random은 계층 생성을 하기 위한 변수이다.           생성자인 Skiplist()를 정의한다.            head에 값이 -1이고 next와 down이 null인 Node를 생성하여 넣어준다.       random에 임의 값을 생성하기 위한 Random 객체를 생성하여 넣어준다.           메서드인 search(int target)를 정의한다.            curr에 SkipList가 구성된 head를 넣어준다.       curr이 존재할 때 까지 아래를 반복한다.                    curr의 next 노드가 존재하면서 해당 노드의 val 값이 target 미만일 때 까지, curr에 next 노드를 넣어 다음 노드로 이동한다.           curr의 next 노드가 조재하면서 해당 노드가 val 값이 target일 경우, true를 반환한다.           curr에 curr의 down 노드인 다음 계층의 노드를 넣어준다.                       반복이 모두 완료되면 탐색된 값이 없으므로, false를 반환한다.           메서드인 add(int num)를 완성한다.            메서드 수행에 필요한 변수를 정의한다.                    curr에 SkipList가 구성된 head를 넣어준다.           stack은 계층별 해당 값의 미만까지 노드를 넣어줄 변수로, curr을 반복하여 각 계층에서 num 이하의 마지막 노드를 stack에 넣어준다.           insert는 신규 계층을 생성할지 검증할 변수로, true로 초기화한다.           down은 다음 계층 노드를 넣기 위한 변수로, null로 초기화한다.                       insert이면서 stack이 비어있지 않을 때 까지 아래를 반복한다.                    curr에 stack에서 꺼낸 노드를 넣어준다.           curr의 다음 노드에 num, curr의 next 노드, down을 이용하여 새 노드를 생성하여 이어준다.           down에 curr의 next를 넣은 후 insert를 확률적으로 다음 계층을 생성할지 여부를 넣어준다.                       insert true인 경우, 신규 노드를 상위 계층으로 추가한다.           메서드인 erase(int num)를 완성한다.            메서드 수행에 필요한 변수를 정의한다.                    curr에 SkipList가 구성된 head를 넣어준다.           found는 삭제할 대상을 찾았는지 검증할 변수로, false로 초기화한다.                       curr이 존재할 때 까지 아래를 반복한다.                    curr의 next 노드가 존재하면서 해당 노드의 val 값이 target 미만일 때 까지, curr에 next 노드를 넣어 다음 노드로 이동한다.           curr의 next 노드가 존재하지 않으면서 해당 노드의 val 값이 num과 동일한 경우, found에 true를 넣고 curr의 next 노드에 해당 노드의 next 노드를 넣어 curr의 next 노드를 제거한다.           curr에 curr의 down 노드인 다음 계층의 노드를 넣어준다.                       반복이 완료되었으면 found를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/design-skiplist/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximal Score After Applying K Operations",
        "excerpt":"문제  Link   코드  class Solution {    public long maxKelements(int[] nums, int k) {     Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(Collections.reverseOrder());     for (int num : nums) {       queue.add(num);     }     long result = 0;     while (k-- &gt; 0) {       int num = queue.poll();       result += num;       queue.add((num + 2) / 3);     }     return result;   }  }   결과  Link   설명          nums 내 값들 중 k번 가장 큰 값을 3으로 나눈 값의 올림 값으로 치환할 때, 치환 대상 값들의 합을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            queue는 내림차순으로 값들을 저장할 변수로, PriorityQueue로 초기화하여 nums의 각 값들을 내림차순으로 넣어준다.       result는 치환 대상 값들의 합을 저장할 변수로, long 형의 0으로 초기화한다.           k가 0 초과일 때 까지 아래를 반복하며 k를 감소시켜준다.            num에 queue의 가장 앞의 큰 값을 꺼내 넣어준다.       result에 num을 더하여 변환 대상의 값을 더해준다.       queue에 올림을 위해서 $\\frac{num + 2}{3}$의 값을 넣어준다.                    ceil()은 올림 처리이므로, 3보다 1 작은 2를 더한 값에 3을 나눠 올림 처리와 같은 효과를 수행한다.                           반복이 완료되면 치환 대상 값들의 합이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximal-score-after-applying-k-operations/",
        "teaser": null
      },{
        "title": "Leetcode Java Separate Black and White Balls",
        "excerpt":"문제  Link   코드  class Solution {    public long minimumSteps(String s) {     char[] charArray = s.toCharArray();     long result = 0;     for (int i = 0, j = 0; i &lt; charArray.length; i++) {       if (charArray[i] == '0') {         result += i - (j++);       }     }     return result;   }  }   결과  Link   설명          문자열 s 내 검정색 공은 ‘1’, 흰 공은 ‘0’을 뜻하며 인접한 공을 선택하여 교체할 때 검정색 공을 오른쪽으로, 흰 공은 왼쪽으로 모으기 위한 최소 횟수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            charArray는 s를 문자 배열로 변환한 변수이다.       result는 최소 교체 횟수를 계산할 변수로, 0으로 초기화한다.           0부터 charArray의 길이 미만까지 i를 증가시키며, 흰 공의 갯수은 j는 0으로 초기화하여 아래를 반복한다.            charArray[i]가 ‘0’인 흰 공인 경우, result에 $i - j$인 현재 위치에서 흰 공을 좌측으로 이동하기 위한 변환 횟수를 더해준 후 흰 공의 갯수인 j를 증가시켜준다.           반복이 완료되면 최소 교체 횟수가 계산된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/separate-black-and-white-balls/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Happy String",
        "excerpt":"문제  Link   코드  class Solution {    public String longestDiverseString(int a, int b, int c) {     StringBuilder sb = new StringBuilder();     int length = a + b + c;     int countA = 0;     int countB = 0;     int countC = 0;     for (int i = 0; i &lt; length; i++) {       if ((a &gt;= b &amp;&amp; a &gt;= c &amp;&amp; countA != 2) || (countB == 2 &amp;&amp; a &gt; 0) || (countC == 2 &amp;&amp; a &gt; 0)) {         sb.append(\"a\");         a--;         countA++;         countB = countC = 0;       } else if ((b &gt;= a &amp;&amp; b &gt;= c &amp;&amp; countB != 2) || (countA == 2 &amp;&amp; b &gt; 0) || (countC == 2 &amp;&amp; b &gt; 0)) {         sb.append(\"b\");         b--;         countB++;         countA = countC = 0;       } else if ((c &gt;= a &amp;&amp; c &gt;= b &amp;&amp; countC != 2) || (countA == 2 &amp;&amp; c &gt; 0) || (countB == 2 &amp;&amp; c &gt; 0)) {         sb.append(\"c\");         c--;         countC++;         countA = countB = 0;       }     }     return sb.toString();   }  }   결과  Link   설명     아래의 규칙을 만족하는 문자열을 만드는 문제이다.            ‘a’, ‘b’, ‘c’는 각자 세 번 이상 반복될 수 없다.       s에는 ‘a’, ‘b’, ‘c’가 최대 a, b, c번 사용된다.           문제 풀이에 필요한 변수를 정의한다.            sb는 동적으로 문자열을 구성하기 위한 변수로, StringBuilder로 초기화한다.       length는 문자열의 최대 길이인 $a + b + c$를 저장한 변수이다.       countA, countB, countC는 ‘a’, ‘b’, ‘c’의 연속된 갯수를 저장한 변수로, 모두 0으로 초기화한다.           0부터 length 미만까지 i를 증가시키며 아래를 반복한다.            아래 중 하나라도 만족하는 경우, sb에 “a”를 이어준 후 a를 감소시키고, countA를 증가, countB와 countC를 0으로 초기화한다.                    a가 b와 c보다 크거나 같으면서 countA가 2가 아닌 “a”를 더 이어줄 수 있는 경우.           countB가 2이면서 a가 0보다 커서 “a”로 “b”의 연속을 끊어야하는 경우.           countC가 2이면서 a가 0보다 커서 “a”로 “c”의 연속을 끊어야하는 경우.                       위의 경우가 아니면서 아래 중 하나라도 만족하는 경우, sb에 “b”를 이어준 후 b를 감소시키고, countB를 증가, countA와 countC를 0으로 초기화한다.                    b가 a와 c보다 크거나 같으면서 countB가 2가 아닌 “b”를 더 이어줄 수 있는 경우.           countA가 2이면서 b가 0보다 커서 “b”로 “a”의 연속을 끊어야하는 경우.           countC가 2이면서 b가 0보다 커서 “b”로 “c”의 연속을 끊어야하는 경우.                       위의 경우가 아니면서 아래 중 하나라도 만족하는 경우, sb에 “c”를 이어준 후 c를 감소시키고, countC를 증가, countA와 countB를 0으로 초기화한다.                    c가 a와 c보다 크거나 같으면서 countC가 2가 아닌 “c”를 더 이어줄 수 있는 경우.           countA가 2이면서 c가 0보다 커서 “c”로 “a”의 연속을 끊어야하는 경우.           countB가 2이면서 c가 0보다 커서 “c”로 “b”의 연속을 끊어야하는 경우.                           위의 반복이 완료되어 완성된 sb를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-happy-string/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Queries Quality and Percentage",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT query_name     , ROUND(AVG(rating::DECIMAL / position), 2) AS quality     , ROUND(SUM(CASE WHEN rating &lt; 3 THEN 1 ELSE 0 END)::DECIMAL / count(*) * 100, 2) AS poor_query_percentage FROM Queries WHERE query_name IS NOT NULL GROUP BY query_name   결과  Link   설명     Queries 테이블에서 아래의 규칙의 값들을 query_name 기준으로 통계내는 문제이다.            quality는 $\\frac{rating}{position}$의 평균을 나타낸다.       poor_query_percentage는 rating이 3 미만인 쿼리의 비율을 나타낸다.       각 결과는 임의 순서대로 반환하며, 통계 결과는 소수점 2자리까지 표현한다.                quality와 poor_query_percentage를 산출할 때 각 값은 int 형이므로, 소수점을 반환하기 위하여 분자를 DECIMAL 형으로 변경한다.            query_name이 nullable 필드이므로, NULL이 아닌 경우만 대상으로 한다.       query_name 기준으로 GROUP BY 수행하여 각 결과를 query_name 기준으로 통계내준다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/queries-quality-and-percentage/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Number of Maximum Bitwise-OR Subsets",
        "excerpt":"문제  Link   코드  class Solution {    public int countMaxOrSubsets(int[] nums) {     int max = 0;     for (int num : nums) {       max |= num;     }     return this.dfs(nums, 0, 0, max);   }    private int dfs(int[] nums, int i, int num, int max) {     if (i == nums.length) {       return num == max ? 1 : 0;     } else {       return this.dfs(nums, i + 1, num | nums[i], max) + this.dfs(nums, i + 1, num, max);     }   }  }   결과  Link   설명                                     nums의 부분 집합의 OR(‘           ’) 비트 연산을 수행한 결과가 최대인 부분 집합의 갯수를 구하는 문제이다.                                max는 OR 비트 연산의 값이 최대인 값을 구하기 위한 변수로, nums의 모든 값을 반복하여 OR의 최댓값을 넣어준다.            4번에서 정의한 dfs(int[] nums, int i, int num, int max)를 i에 0, num에 0을 채워 수행한 결과를 주어진 문제의 결과로 반환한다.       DFS 방식으로 갯수를 계산할 dfs(int[] nums, int i, int num, int max) 메서드를 정의한다.            i가 nums의 길이와 동일한 마지막 위치인 경우, num과 max가 동일하면 1을 아니면 0ㅇ을 반환한다.       위의 경우가 아니라면 아래의 두 결과를 더한 값을 반환한다.                    i의 위치에 $i + 1$을 넣고 num의 위치에 num과 nums[i]를 재귀 호출한 결과인 현재 값을 포함한 부분 배열의 경우에 대한 값.           i의 위치에 $i + 1$을 넣어 재귀 호출 한 결과인 현재 값을 제외한 부분 배열의 경우에 대한 값.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-number-of-maximum-bitwise-or-subsets/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Kth Bit in Nth Binary String",
        "excerpt":"문제  Link   코드  class Solution {    public char findKthBit(int n, int k) {     int flips = 0;     while (n &gt; 1) {       int length = (1 &lt;&lt; n) - 1;       int mid = (length + 1) / 2;       if (k == mid) {         return flips == 0 ? '1' : '0';       } else if (k &gt; mid) {         flips ^= 1;         k = length - k + 1;       }       n -= 1;     }     return flips == 0 ? '0' : '1';   }  }   결과  Link   설명     n을 이용하여 아래의 규칙대로 수행하였을 때, k번쨰 비트 문자를 반환하는 문제이다.            S0 = 0 으로 시작하여, Si = Si - 1 + “1” + reverse(invert(Si - 1))를 만족한다.       invert(x)는 x의 비트의 값을 1은 0으로, 0은 1로 반전시키는 역할을 수행하는 함수이다.       reverse(x)는 x의 비트 값을 뒤에서 앞으로 반전 시키는 열할을 수행하는 함수이다.                flips는 반전시키는 횟수를 계산하기 위한 변수로, 0으로 초기화한다.       n이 1 초과일 때까지 아래를 반복한다.            반복에 필요한 변수를 정의한다.                    length는 길이를 계산하기 위한 변수로, 1의 비트를 n번 좌측으로 이동시킨 후 1을 감소시킨다.           mid는 중앙 값을 저장할 변수로, $\\frac{length + 1}{2}$의 값을 넣어준다.                       k가 mid인 목표 지점이면서 flips가 홀수인 경우, 기본 문자열인 ‘1’을 아니면 ‘0’을 주어진 문제의 결과로 반환한다.       위의 경우가 아니면서 k가 mid보다 큰 경우, flips에 1의 XOR(‘^’) 비트연산의 결과를 넣어주고, k에 $length - k + 1$인 값을 넣어준다.       n을 감소시키고 다음 반복을 수행한다.           반복이 완료되면 flips가 짝수인 경우, ‘0’을 아니면 ‘1’을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-kth-bit-in-nth-binary-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Split a String Into the Max Number of Unique Substrings",
        "excerpt":"문제  Link   코드  class Solution {    public int maxUniqueSplit(String s) {     return this.dfs(s, 0, new HashSet&lt;&gt;());   }    private int dfs(String s, int i, Set&lt;String&gt; seen) {     if (i == s.length()) {       return 0;     } else {       int max = 0;       for (int end = i + 1; end &lt;= s.length(); end++) {         String substring = s.substring(i, end);         if (!seen.contains(substring)) {           seen.add(substring);           max = Math.max(max, 1 + this.dfs(s, end, seen));           seen.remove(substring);         }       }       return max;     }   }  }   결과  Link   설명          s를 이용하여 연속된 문자들을 고유한 문자열의 부분 배열로 나눌 때, 가능한 최대 갯수를 계산하는 문제이다.            3번에서 정의한 dfs(String s, int i, Set seen) 메서드를 i에 0, seen에 새 HashSet을 초기화하여 넣어 수행한 결과를 반환한다.            DFS 방식으로 부분 문자열의 갯수를 계산할 dfs(String s, int i, Set seen) 메서드를 정의한다.             i가 s의 길이와 동일한 마지막 문자인 경우, 0을 반환한다.       위의 경우가 아니라면 아래를 수행한다.                    max는 부분 배열의 갯수를 계산할 변수로, 0으로 초기화한다.           $i + 1$부터 s의 길이 이하까지 end를 증가시키며 s의 [i, end] 사이의 문자열이 seen에 포함되지 않은 경우, 다음을 수행한다.           seen에 해당 문자열을 넣고, max에 i의 자리에 end를 넣고 재귀 호출한 결과에 현재 경우인 1을 더한 값 중 큰 값을 넣어준 후 넣은 문자열을 다시 제거하여 다음 반복을 재개한다.                       위의 반복으로 계산된 max를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/split-a-string-into-the-max-number-of-unique-substrings/",
        "teaser": null
      },{
        "title": "Leetcode Java Kth Largest Sum in a Binary Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public long kthLargestLevelSum(TreeNode root, int k) {     Queue&lt;Long&gt; result = new PriorityQueue&lt;&gt;();     Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();     queue.add(root);     while (!queue.isEmpty()) {       int size = queue.size();       long sum = 0;       while (size-- &gt; 0) {         TreeNode temp = queue.poll();         sum += temp.val;         if (temp.left != null) {           queue.add(temp.left);         }         if (temp.right != null) {           queue.add(temp.right);         }       }       result.add(sum);       if (result.size() &gt; k) {         result.poll();       }     }     return result.size() &lt; k ? -1 : result.peek();   }  }   결과  Link   설명     이진 트리인 root의 레벨 별 값들의 합계를 구할 때, k번째 큰 합계를 반환하는 문제이다.            단, 트리의 레벨이 k 이하인 k번째 큰 합계가 존재하지 않으면 -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            result는 레벨 별 합계를 오름차순으로 관리하기 위한 변수로, PriorityQueue로 초기화한다.       queue는 각 노드를 순차적으로 넣어 합계를 계산하기 위한 변수로, LinkedList로 초기화하고 root를 넣어준다.           queue가 비어있지 않을 때 까지 아래를 반복한다.            size에 queue의 크기를 저장한 변수이고, 합계를 저장할 sum은 0으로 초기화한다.       size가 0 초과일 때 까지 size를 감소시키며 아래를 반복한다.                    temp에 queue의 노드를 꺼내 넣어준다.           sum에 temp의 val 값을 더해 합계를 계산한다.           queue에 temp의 left와 right 노드가 존재하면 순차적으로 넣어준다.                       result에 현재 레벨의 합계인 sum을 넣어준다.       result의 크기가 k 초과이면 result에서 첫 값인 가장 작은 k 범위를 초과한 값을 제거해준다.           반복이 완료되면 result의 길이가 k보다 작으면 k번째 값이 없으므로 -1을, 그렇지 않은 경우 result의 첫 값인 k번째 큰 합계를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/kth-largest-sum-in-a-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Cousins in Binary Tree II",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class Solution {    public TreeNode replaceValueInTree(TreeNode root) {     Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();     queue.offer(root);     int curr = root.val;     while (!queue.isEmpty()) {       int next = 0;       int size = queue.size();       while (size-- &gt; 0) {         TreeNode node = queue.poll();         TreeNode left = node.left;         TreeNode right = node.right;         node.val = curr - node.val;         if (left != null) {           queue.offer(left);           next += left.val;         }         if (right != null) {           queue.offer(right);           next += right.val;         }         if (left != null &amp;&amp; right != null) {           int sum = left.val + right.val;           left.val = right.val = sum;         }       }       curr = next;     }     return root;   }  }   결과  Link   설명          이진 트리인 root에서 부모가 다른 동일한 레벨 내 노드들 값의 합을 각 노드에 넣어주는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            queue는 각 레벨 별 노드를 넣어 보관할 변수로, LinkedList로 초기화하여 root를 넣어준다.       curr은 노드의 값을 설정하기 위한 변수로, root의 val 값으로 초기화한다.           queue가 비어있지 않을 때 까지 아래를 반복한다.            반복에 필요한 변수를 정의한다.                    next는 curr에 넣을 값을 저장할 변수로, 0으로 초기화한다.           size는 현재 queue에 존재하는 값의 갯수를 저장할 변수이다.                       size가 0 초과일 때 까지 size를 감소시키며 아래를 반복한다.                    node에 queue 맨 앞의 노드를 넣어주고, left와 right에 각 left와 right 노드를 넣어준다.           node의 val 값에 $curr - node.val$인 차감된 노드의 값을 넣어준다.           left가 null이 아닌 경우, queue에 left 노드를 넣고 next에 left 노드의 val 값을 더해준다.           right가 null이 아닌 경우, queue에 right 노드를 넣고 next에 right 노드의 val 값을 더해준다.           left 노드와 right 노드가 존재하는 경우, left 노드와 right 노드에 두 노드 val 값의 합을 넣어준다.                       위의 반복이 완료되면 curr에 next를 넣어 다음 노드 계산에 자식 노드 합계로 계산하도록 한다.           반복이 완료되면 root를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/cousins-in-binary-tree-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove Sub-Folders from the Filesystem",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; removeSubfolders(String[] folder) {     Arrays.sort(folder);     List&lt;String&gt; result = new ArrayList&lt;&gt;();     for (String path : folder) {       if (result.isEmpty() || !path.startsWith(result.get(result.size() - 1) + \"/\")) {         result.add(path);       }     }     return result;   }  }   결과  Link   설명          folder 중에서 하위 폴더를 제외한 상위 폴더들을 찾는 문제이다.            folder를 사전 기준 오름차순으로 정렬해준다.            result는 결과를 넣을 변수로, ArrayList로 초기화한다.       folder의 각 값들을 순차적으로 path에 넣고 아래를 수행한다.            아래의 각 경우 중 하나라도 해당하면 result에 path를 넣어준다.                    result가 비어있는 첫 수행인 경우, 사전적으로 가장 작은 폴더 경로이므로 추가한다.           path가 result에 마지막으로 들어간 값과 동일하게 시작되지 않는 하위 폴더가 아닌 경우.                           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-sub-folders-from-the-filesystem/",
        "teaser": null
      },{
        "title": "Leetcode Java Height of Binary Tree After Subtree Removal Queries",
        "excerpt":"문제  Link   코드  class Solution {    private int[] heights;   private int max;    public int[] treeQueries(TreeNode root, int[] queries) {     this.heights = new int[100001];     this.max = 0;     this.calculateLeftToRight(root, 0);     this.max = 0;     this.calculateRightToLeft(root, 0);     int length = queries.length;     int[] result = new int[length];     for (int i = length - 1; i &gt;= 0; i--) {       result[i] = this.heights[queries[i]];     }     return result;   }    private void calculateLeftToRight(TreeNode node, int height) {     if (node != null) {       this.heights[node.val] = this.max;       this.max = Math.max(this.max, height);       this.calculateLeftToRight(node.left, height + 1);       this.calculateLeftToRight(node.right, height + 1);     }   }    private void calculateRightToLeft(TreeNode node, int height) {     if (node != null) {       this.heights[node.val] = Math.max(this.heights[node.val], this.max);       this.max = Math.max(this.max, height);       this.calculateRightToLeft(node.right, height + 1);       this.calculateRightToLeft(node.left, height + 1);     }   }  }   결과  Link   설명          이진 트리인 root에서 queries 내 각 값에 대한 노드를 제거했을 때 트리의 길이를 각각 구하는 문제이다.       문제 풀이에 필요한 전역 변수를 정의한다.            heights는 각 위치 값에 해당하는 노드를 제거하였을 때 길이를 저장할 변수이다.       max는 root의 가장 긴 높이를 저장한 변수이다.           문제 풀이에 필요한 전역 변수를 초기화한다.            heights에 값의 상한 값보다 1 큰 $10^5 + 1$ 크기의 정수 배열로 초기화한다.       max를 0으로 초기화한다.           좌측에서 우측으로 탐색하기 위한 calculateLeftToRight(TreeNode node, int height)를 아래와 같이 정의 후 height에 0을 넣어 수행한다.            node가 null이 아닌 경우만 계속 진행한다.       heights 내 node의 val 값에 해당하는 위치에 max 값을 넣어준다.       max에 이전까지 최대 높이인 max와 현재 위치의 높이인 height 중 큰 값을 넣어준다.       node의 left 노드와 right 노드를 이용하여 height를 증가시켜 순차적으로 재귀 호출을 수행한다.           max를 0으로 초기화하고 우측에서 좌측으로 탐색하기 위한 calculateRightToLeft(TreeNode node, int height)를 아래와 같이 정의 후 height에 0을 넣어 수행한다.            node가 null이 아닌 경우만 계속 진행한다.       heights 내 node의 val 값에 해당하는 위치에 해당 위치의 값과 max 값 중 큰 높이를 넣어준다.       max에 이전까지 최대 높이인 max와 현재 위치의 높이인 height 중 큰 값을 넣어준다.       node의 right 노드와 left 노드를 이용하여 height를 증가시켜 순차적으로 재귀 호출을 수행한다.           result는 결과를 저장할 배열로, queries 길이의 정수 배열로 초기화하여 동일한 위치에 heights 내 queries 값을 꺼내 넣어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/height-of-binary-tree-after-subtree-removal-queries/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Square Submatrices with All Ones",
        "excerpt":"문제  Link   코드  class Solution {    public int countSquares(int[][] matrix) {     int result = 0;     int row = matrix.length;     int col = matrix[0].length;     for (int i = 0; i &lt; row; i++) {       for (int j = 0; j &lt; col; j++) {         if (matrix[i][j] &gt; 0 &amp;&amp; i &gt; 0 &amp;&amp; j &gt; 0) {           matrix[i][j] = Math.min(matrix[i - 1][j - 1], Math.min(matrix[i - 1][j], matrix[i][j - 1])) + 1;         }         result += matrix[i][j];       }     }     return result;   }  }   결과  Link   설명          matrix에 1로 이루어진 정사각형의 갯수를 계산하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 갯수를 계산하기 위한 변수로, 0으로 초기화한다.       row와 col은 matrix는 행과 열을 저장한 변수이다.           i는 0부터 row 미만까지 j는 0부터 col 미만까지 i와 j를 증가시키면서 아래를 반복한다.            matirx[i][j]의 위치에 아래 중 가장 작은 값에 1을 더한 값을 넣어준다.                    matrix[$i - 1$][$j - 1$]           matrix[$i - 1$][j]           matrix[i][$j - 1$]                       result에 matirx[i][j]의 값을 더해준다.           반복이 완료되면 계산된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-square-submatrices-with-all-ones/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Square Streak in an Array",
        "excerpt":"문제  Link   코드  class Solution {    public int longestSquareStreak(int[] nums) {     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();     Arrays.sort(nums);     int result = -1;     for (int num : nums) {       int sqrt = (int) Math.sqrt(num);       if (sqrt * sqrt == num &amp;&amp; map.containsKey(sqrt)) {         map.put(num, map.get(sqrt) + 1);         result = Math.max(result, map.get(num));       } else {         map.put(num, 1);       }     }     return result;   }  }   결과  Link   설명     아래의 조건을 만족하는 가장 긴 정수 배열의 길이를 반환하는 문제이다.            정수 배열은 최소 2개 이상의 요소를 가진 배열이어야 한다.       값을 오름차순으로 정렬하였을 때, 이전 값의 제곱 값이 다음 값으로 존재한다.           문제 풀이에 필요한 변수를 정의한다.            map은 각 값을 넣어 저장할 변수로, HashMap으로 초기화한다.       result는 가장 긴 정수 배열의 길이를 저장할 변수로, -1로 초기화한다.           nums를 오름차순 정렬하고 num에 순차적으로 넣어 아래를 수행한다.            sqrt는 num을 제곱근한 값을 저장한 변수이다.       sqrt의 제곱 값이 nu과 동일하고 map에 sqrt의 값이 존재하면 map의 해당 값에 해당하는 값을 증가시키고, result에 result와 map의 num이 키인 값 중 큰 값인 최대 길이를 넣어준다.       위의 경우가 아니라면 map의 num이 키인 값에 1을 넣어준다.           반복이 완료되면 최대 길이가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-square-streak-in-an-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Number of Moves in a Grid",
        "excerpt":"문제  Link   코드  class Solution {    public int maxMoves(int[][] grid) {     int row = grid.length;     int col = grid[0].length;     int[][] dp = new int[row][col];     int result = 0;     for (int j = col - 2; j &gt;= 0; j--) {       for (int i = 0; i &lt; row; i++) {         int num = grid[i][j];         if (i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j + 1] &gt; num) {           dp[i][j] = Math.max(dp[i][j], dp[i - 1][j + 1] + 1);         }         if (grid[i][j + 1] &gt; num) {           dp[i][j] = Math.max(dp[i][j], dp[i][j + 1] + 1);         }         if (row &gt; i + 1 &amp;&amp; grid[i + 1][j + 1] &gt; num) {           dp[i][j] = Math.max(dp[i][j], dp[i + 1][j + 1] + 1);         }       }     }     for (int i = 0; i &lt; row; i++) {       result = Math.max(result, dp[i][0]);     }     return result;   }  }   결과  Link   설명          grid의 좌측 상단 위치에서 시작하여 오른쪽, 오른쪽 아래 대각선, 아래 중 현재 값보다 큰 위치로 이동할 수 있는 최대 횟수를 계산하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            row와 col은 행과 열의 갯수를 저장한 변수이다.       dp는 최대 이동 횟수를 계산하기 위한 배열로, $row \\times col$ 크기의 2차원 정수 배열로 초기화한다.       result는 최대 이동 횟수를 저장할 변수로, 0으로 초기화한다.           $col - 2$부터 0 이상까지 j를 감소시키고, 0부터 row 미만까지 i를 증가시키며 아래를 반복한다.            num에 grid[i][j] 값을 넣어준다.       $i - 1$이 0 이상이면서 grid[$i - 1$][$j + 1$]이 num보다 커 해당 위치로 이동 가능한 경우, dp[i][j]의 위치에 해당 값과 dp[$i - 1$][$j + 1$]의 값에 1을 더한 값 중 큰 값을 넣어준다.       grid[i][$j + 1$]의 값이 num보다 커 해당 위치로 이동 가능한 경우, dp[i][j]의 위치에 해당 값과 grid[i][$j + 1$]의 값에 1을 더한 값 중 큰 값을 넣어준다.       row가 $i + 1$보다 크고 grid[$i + 1$][$j + 1$]의 값이 num보다 커 해당 위치로 이동 가능한 경우, dp[i][j]의 위치에 해당 값과 grid[$i + 1$][$j + 1$]의 값에 1을 더한 값 중 큰 값을 넣어준다.           반복이 완료되면 dp의 이동 횟수가 저장된 각 행의 첫 열 중 큰 값을 result에 넣어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-number-of-moves-in-a-grid/",
        "teaser": null
      },{
        "title": "Leetcode Java Delete Characters to Make Fancy String",
        "excerpt":"문제  Link   코드  class Solution {    public String makeFancyString(String s) {     char[] charArray = s.toCharArray();     StringBuilder sb = new StringBuilder();     int count = 1;     for (int i = 0; i &lt; charArray.length; i++) {       if (0 &lt; i &amp;&amp; charArray[i - 1] == charArray[i]) {         count++;       } else {         count = 1;       }       if (count &lt; 3) {         sb.append(charArray[i]);       }     }     return sb.toString();   }  }   결과  Link   설명          문자열 s 내 동일한 문자가 연속해서 세 번 이상 발생하지 않도록 문자열을 재구성하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            charArray는 s를 문자 배열로 변환한 변수이다.       sb는 동적 문자열 생성을 위한 변수로, StringBuilder로 초기화한다.       count는 연속된 문자열의 갯수를 계산할 변수로, 1로 초기화한다.           0부터 charArray의 길이 미만까지 i를 증가시키면서 아래를 반복한다.            i가 0보다 크면서 이전 문자와 현재 문자가 동일한 경우, count를 증가시킨다.       위의 경우가 아니라면 count를 1로 초기화시킨다.       위에서 계산된 count가 3 미만인 경우, sb에 현재 문자를 넣어준다.           반복이 완료되면 완성된 sb를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/delete-characters-to-make-fancy-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Circular Sentence",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isCircularSentence(String s) {     char[] charArray = s.toCharArray();     int length = charArray.length;     for (int i = 0; i &lt; length; i++) {       if (charArray[i] == ' ' &amp;&amp; charArray[i - 1] != charArray[i + 1]) {         return false;       }     }     return charArray[0] == charArray[length - 1];   }  }   결과  Link   설명          s의 각 띄어쓰기 단위로 문자열들을 분해해서 처음부터 마지막 문자열을 원형으로 이었을 때 이전 문자열의 마지막 문자와 다음 문자열의 처음 문자가 동일한 끝말잇기가 가능한지를 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            charArray는 s를 문자 배열로 변환한 변수이다.       length는 charArray의 길이를 저장한 변수이다.           0부터 length 미만까지 i를 증가시키며 아래를 반복한다.            charArray[i]가 띄어쓰기 문자인 ‘ ‘인 경우에 그 앞뒤 문자가 동일하지 않으면 false를 주어진 문제의 결과로 반환한다.           charArray의 처음 문자와 마지막 문자가 동일한 마지막 문자열의 마지막 문자와 처음 문자열의 처음 문자가 다른지 여부를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/circular-sentence/",
        "teaser": null
      },{
        "title": "Leetcode Java String Compression III",
        "excerpt":"문제  Link   코드  class Solution {    public String compressedString(String word) {     StringBuilder sb = new StringBuilder();     int count = 1;     char c = word.charAt(0);     for (int i = 1; i &lt; word.length(); i++) {       if (c == word.charAt(i) &amp;&amp; count &lt; 9) {         count++;       } else {         sb.append(count).append(c);         c = word.charAt(i);         count = 1;       }     }     return sb.append(count).append(c).toString();   }  }   결과  Link   설명          word의 각 문자들을 반복 횟수 + 문자 형태로 변환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            sb는 동적 문자열 생성에 필요한 변수로, StringBuilder로 초기화한다.       count는 문자의 갯수를 계산할 변수로, 1로 초기화한다.       c는 반복되는 문자를 임시 저장할 변수로, word의 첫 문자로 초기화한다.           1부터 word의 길이 미만까지 i를 증가시키며 아래를 반복한다.            c와 word의 i번째 문자가 동일한 경우, count를 증가시킨다.       c와 word의 i번째 문자가 다른 경우, 아래를 수행한다.                    sb에 count와 c를 순차적으로 넣어준다.           c에 word의 i번째 문자를 넣고, count를 1로 초기화한다.                           반복이 완료되면 마지막으로 sb에 count와 c를 다시 넣어준 후 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/string-compression-iii/",
        "teaser": null
      },{
        "title": "Custom JRE로 경령화된 Dockering I",
        "excerpt":"개요     Java 애플리케이션은 JVM(Java Virtual Machine)이 함께 컨테이너에 배포되어야 하기 때문에 비교적 타 언어로 배포되는 컨테이너보다 용량이 매우 크므로, 이 부분을 해소하기 위한 경량화된 Dockerizng1을 Amazon Crretto JDK2를 이용하여 설명하고자한다.   여기서는 Custom JRE를 생성하는 Docker의 Multi-Stage builds3를 활용하여 실제 빌드하는 JAVA 애플리케이션을 경량화한다.   Stage 1     Stage 1에서는 애플리케이션 의존 관계를 분석하여 경량화된 Custom JRE를 만드는 부분에 중점을 둔다.   부가적으로 빌드된 jar 파일을 필요한 파일들만 사용하기 위하여 압축 해제한다.   # Stage 1. Create custom JRE FROM amazoncorretto:21-alpine AS jrebuilder  # Add the application jar to the container COPY ./build/libs/hello-docker-*-SNAPSHOT.jar /app.jar  # Install binutils RUN apk add --no-cache binutils  # Extract jar file and generate custom JRE using dependency RUN mkdir -p /app &amp;&amp; (cd /app; jar -xf /app.jar) \\ \t&amp;&amp; DEPENDENCY=$(jdeps --ignore-missing-deps --print-module-deps --recursive --multi-release 21 --class-path=\"/app/BOOT-INF/lib/*\" /app.jar) \\ \t&amp;&amp; ${JAVA_HOME}/bin/jlink \\ \t\t--verbose \\ \t\t--add-modules ${DEPENDENCY} \\ \t\t--strip-debug \\ \t\t--no-man-pages \\ \t\t--no-header-files \\ \t\t--compress=2 \\ \t\t--output \\ \t\tcustomjre   Image     Custom JRE는 JDK에서 필요한 의존성만 추출해야 하므로 기본 이미지는 JDK 이미지로 사용하고, jrebuilder로 명명한다.   Copy application     Gradle을 이용하여 빌드된 jar파일은 /build/libs/ 경로 아래 생성되며, 해당 jar 파일을 사용하기 위해 컨테이너 내부로 복사한다.   Install Binutils4     컨테이너 내부에서 jlink 명령어를 사용하기 위해서 objcopy가 필요한데, 이는 binutils를 설치하여 사용할 수 있다.   만일 해당 부분을 설치하지 않는다면 아래의 오류를 마주할 수 있다.     Error: java.io.IOException: Cannot run program \"objcopy\": error=2, No such file or directory           Generate custom JRE     이제 가장 중요한 Custom JRE를 만드는 부분이다.   “/app” 폴더를 만든 후 해당 경로에 애플리케이션 jar 파일을 압축 해제해준다.   빌드된 jar 파일 구성은 아래와 같다.     ./hello-docker ├─ /BOOT-INF │  ├─ /classes ## Folder where the class file where the │  │           ## JAVA file is compiled is stored. │  └─ /lib     ## Folder where the dependency injected jar │              ## library is stored. ├─ /META-INF   ## Folder where the meta data and setting data. └─ /org           Jdeps5     Jdeps는 JAVA Class의 의존성 분석을 위한 도구로, 모듈화가 적용된 JAVA 9 버전 이상부터 사용이 가능하다.                  Option       Description                       –ignore-missing-deps       외존성이 존재하지 않는 모듈은 제외.                 –print-module-deps       Jlink에서 요구하는 포멧에 맞는 쉼표로 구분된 모듈 의존성 목록을 출력.                 –recursive       모든 런타임 종속성을 재귀적으로 탐색.                 –multi-release ${VERSION}       의존성을 분석할 JAVA 버전을 ${VERSION}에 명시. 단, 모듈화가 적용된 9 버전 이상만 적용.                 –class-path=”${PATH}”       의존성을 분석할 class 파일들을 찾을 위치를 ${PATH}에 지정.           Jlink6     Jlink는 Jdeps를 이용하여 분석된 의존성을 활용하여 최적화된 Custom JRE를 구성할 수 있는 도구이다.                  Option       Description                       –verbose       진행 중 상세 내역을 출력.                 –add-modules ${DEPENDENCY}       jdeps를 이용하여 분석한 쉼표로 구분된 모듈 의존성 목록                 –strip-debug       디버그 정보를 제거.                 –no-man-pages       man page(특정 명령이나 자원들의 메뉴얼을 출력하는 영역) 미사용.                 –no-header-files       header files(로직이 저장된 파일) 미사용.                 –compress=2       리소스 압축 여부. 0 : 미사용, 1 : 상수 문자열 공유, 2 : 압축을 의미하며, 보편적으로 2를 사용.                 –output=${PATH}       리소스를 저장할 위치를 ${PATH}에 지정.           Stage 2     Stage 2에서는 Stage 1에서 분석된 의존성을 통해 완성된 Custom JRE와 압축 해제한 jar에서 필요한 파일로 이미지를 구성하여 경량화된 JAVA 애플리케이션 컨테이너를 구성한다.   # Stage 2. Make container for application FROM alpine:3.20 ENV JAVA_HOME=/jre ENV PATH=\"${JAVA_HOME}/bin:${PATH}\" ARG DEPENDENCY=/app  # Add Maintainer Info LABEL maintainer=\"GracefulSoul on &lt;gracefulsoul@github.com&gt;\"  # Copy custom JRE COPY --from=jrebuilder /customjre ${JAVA_HOME}  # Copy extract files in jar COPY --from=jrebuilder ${DEPENDENCY}/BOOT-INF/lib ${DEPENDENCY}/lib COPY --from=jrebuilder ${DEPENDENCY}/META-INF ${DEPENDENCY}/META-INF COPY --from=jrebuilder ${DEPENDENCY}/BOOT-INF/classes ${DEPENDENCY}  # Move work directory WORKDIR ${DEPENDENCY}  # Run application ENTRYPOINT [ \"java\", \"-cp\", \"${DEPENDENCY}:${DEPENDENCY}/lib/*\", \"gracefulsoul.HelloDockerApplication\" ]   Image     Stage 1에서 Custom JRE를 만들었으므로, 경량화된 Alpine Linux7 이미지를 아래의 환경 설정을 이용하여 사용한다.   JAVA_HOME 환경 변수를 추가하기 위하여 JAVA_HOME은 “/jre”로 준 후 PATH에 “JAVA_HOME/bin”을 추가한다.   “/app” 폴더를 전역 변수로 사용하기 위한 DEPENDENCY를 정의한다.   Copy custom JRE     Stage 1에서 생성한 Custom JRE가 저장된 “/customjre” 폴더를 “/jre”로 복사한다.   Copy extract files in jar     jar 파일에서 JAVA 애플리케이션 구동을 위해 필요한 아래의 폴더들을 복사한다.   의존성 주입된 Library가 저장된 “/app/BOOT-INF/lib” 폴더를 “/app/lib” 폴더로 복사한다.   메타 데이터와 설정 정보를 저장된 “/app/META-INF” 폴더를 “/app/META-INF” 폴더로 복사한다.   컴파일된 class 파일이 저장된 “/app/BOOT-INF/classes” 폴더를 “/app” 폴더로 복사한다.   Move work directory     JAVA 애플리케이션 실행 위치인 “/app” 위치를 컨테이너 기본 위치로 설정한다.   Run application     ENTRYPOINT인 컨테이너가 실행될 때 기본으로 동작하는 명령어는 아래의 조합으로 완성한다.   “java” 명령어는 JAVA 애플리케이션 실행을 위한 명령어이다.   “-cp /app:/app/lib/“은 classpath를 지정하는 명령어로, 컴파일된 class 파일 루트 위치인 “/app”과 의존성으로 추가된 Library들을 포함하는 “/app/lib/“을 이어준다.   실행하고자 하는 Main Class 이름을 “package.className” 형태인 “gracefulsoul.HelloDockerApplication”로 정의한다.   정리     위에서 하나씩 살펴본 JAVA 애플리케이션 경량화 Docker Conatiner는 MSA 구성에 있어서 아주 기본적인 서비스 빌드 방법의 하나를 살펴보았다.   애플리케이션을 돌리기 위한 컨테이너는 동작에 필요한 최소한의 리소스를 이용한 컨테이너 경량화는 배포 크기의 감소와 성능 향상, 비용 감소 등의 이점이 있으므로 선택이 아닌 필수이다.   다음  Custom JRE로 경령화된 Dockering II   Reference  ※ Sample Code는 여기에서 확인 가능합니다.                 Spring-Boot-Docker_Springio-Guides &#8617;                  Amazon-Crretto &#8617;                  Multi-Stage-builds-Docker &#8617;                  Binutils &#8617;                  Jdeps_Oracle-Document &#8617;                  Jlink_Oracle-Document &#8617;                  Alpine_Linux-Wiki &#8617;           ","categories": ["Java"],
        "tags": ["Programming","Docker","Java","Spring","Jdeps","Jlink"],
        "url": "/java/lightweight-jdk-docker-I/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Number of Changes to Make Binary String Beautiful",
        "excerpt":"문제  Link   코드  class Solution {    public int minChanges(String s) {     char[] charArray = s.toCharArray();     int result = 0;     for (int i = 0; i &lt; charArray.length - 1; i += 2) {       if (charArray[i] != charArray[i + 1]) {         result++;       }     }     return result;   }  }   결과  Link   설명          s의 각 문자열을 두 문자씩 잘라서 둘 다 1 혹은 0으로 만들기 위한 최소 횟수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            charArray는 s를 문자 배열로 변환한 변수이다.       result는 최소 횟수를 계산할 변수로, 0으로 초기화한다.           0부터 charAaray의 길이보다 1 작은 값 미만까지 2씩 증가시키며 아래를 수행한다.            charArray[i]와 charArray[$i + 1$]이 다르면 둘 중 하나의 값을 바꿔야 하므로, result를 증가시킨다.           반복이 완료되면 최소 횟수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-number-of-changes-to-make-binary-string-beautiful/",
        "teaser": null
      },{
        "title": "Leetcode Java Find if Array Can Be Sorted",
        "excerpt":"문제  Link   코드  class Solution {    public boolean canSortArray(int[] nums) {     int prevMax = 0;     int currMin = 0;     int currMax = 0;     int prevCount = 0;     for (int num : nums) {       int currCount = Integer.bitCount(num);       if (prevCount == currCount) {         currMin = Math.min(currMin, num);         currMax = Math.max(currMax, num);       } else if (currMin &lt; prevMax) {         return false;       } else {         prevMax = currMax;         currMin = currMax = num;         prevCount = currCount;       }     }     return currMin &gt;= prevMax;   }  }   결과  Link   설명     nums를 아래 조건에 따라서 정렬을 수행할 경우, 오름차순으로 정렬이 가능한지 검증하는 문제이다.            연결된 두 숫자의 비트 중 1의 갯수가 동일한 경우에만 순서를 바꿀 수 있다.           문제 풀이에 필요한 변수를 정의한다.            prevMax는 이전까지의 최댓값을 저장한 변수로, 0으로 초기화한다.       currMin과 currMax는 이전까지의 최솟값과 최댓값을 저장할 변수로, 둘 다 0으로 초기화한다.       prevCount는 이전 숫자의 비트 중 1의 갯수를 저장한 변수로, 0으로 초기화한다.           nums의 각 숫자를 순차적으로 num을 넣어 아래를 수행한다.            currCount는 num의 비트 중 1의 갯수를 저장한 변수이다.       prevCount와 currCount가 동일한 교체가 가능한 경우, 아래를 수행한다.                    currMin에 해당 값과 현재 값인 num 중 작은 값을 넣어준다.           currMax에 해당 값과 현재 값인 num 중 큰 값을 넣어준다.                       currMin이 prevMax보다 작은 오름차순이 성립되지 않는 경우, false를 주어진 문제의 결과로 반환한다.       위의 각 경우가 아니라면 아래를 수행한다.                    prevMax에 currMax를 넣어 현재까지 가장 큰 값을 저장한다.           currMin과 currMax에 num을 넣어준다.           prevCount에 currCount를 넣어 현재 숫자의 비트 중 1의 갯수를 저장한다.                           반복이 완료되면 마지막으로 currMin이 prevMax보다 크거나 같은 오름차순 정렬이 성립 가능한지 여부를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-if-array-can-be-sorted/",
        "teaser": null
      },{
        "title": "Leetcode Java Largest Combination With Bitwise AND Greater Than Zero",
        "excerpt":"문제  Link   코드  class Solution {    public int largestCombination(int[] candidates) {     int result = 0;     for (int i = 0; i &lt; 32; i++) {       int count = 0;       for (int candidate : candidates) {         if ((candidate &amp; (1 &lt;&lt; i)) != 0) {           count++;         }       }       result = Math.max(result, count);     }     return result;   }  }   결과  Link   설명          candidates의 AND(&amp;) 비트 연산의 결과가 가장 크게 되는 부분 배열의 크기가 가장 큰 값을 찾는 문제이다.            result는 부분 배열의 크기를 저장할 변수로, 0으로 초기화한다.       0부터 정수 길이의 최대 길이보다 작은 32 미만까지 i를 증가시키면서 아래를 반복한다.            count는 해당되는 갯수를 계산하기 위한 변수로 0으로 초기화한다.       candidates의 모든 값을 순차적으로 candidate에 넣고 아래를 반복한다.                    candidate와 1을 i번 좌측으로 이동 시킨 비트의 값을 AND(&amp;) 비트 연산한 결과가 0이 아닌 값이 존재하는 경우, count를 증가시킨다.                       result에 이전까지 최대 갯수인 result와 현재 갯수인 count 중 큰 값을 넣어준다.           반복이 완료되면 부분 배열의 크기가 가장 큰 값이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/largest-combination-with-bitwise-and-greater-than-zero/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum XOR for Each Query",
        "excerpt":"문제  Link   코드  class Solution {    public int[] getMaximumXor(int[] nums, int maximumBit) {     int length = nums.length;     int[] result = new int[length];     int num = (1 &lt;&lt; maximumBit) - 1;     for (int i = 0; i &lt; length; i++) {       num ^= nums[i];       result[(length - 1) - i] = num;     }     return result;   }  }   결과  Link   설명          nums의 각 위치 별 값부터 마지막 값까지 값들과 k까지 XOR(^) 비트 연산을 수행한 결과가 최대인 값이 되기 위한 $2^maximumBit$ 미만인 k를 각 수행 별 찾는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       result는 결과를 반환하기 위한 변수로, length 크기의 정수 배열로 초기화한다.       num은 각 위치 별 k를 저장할 변수로, $2^maximumBit - 1$인 값의 범위에서 1 작은 값을 넣어준다.           0부터 length 미만까지 i를 증가시키면서 아래를 반복한다.            num에 nums[i]의 값을 XOR(^) 비트 연산을 수행한다.       result[$(length - 1) - i$]인 현재 위치에서 반대 위치의 result에 num을 넣어준다.           반복이 완료되면 각 결과가 저장된 result를 주어진 문제의 결과로 반한한다.   해설     n 크기의 배열 nums의 $k = nums[0] ^ nums[1] ^ … ^ nums[n - 1] ^ k$의 결과가 최대인 결과인 $2^maximumBit - 1$이 되어야 한다는 것은, k = $2^maximumBit - 1$이 된다는 것이다.   위의 이야기대로 처음 위치에서는 k가 반드시 $2^maximumBit - 1$가 되어야 한다.   그 다음 값부터는 nums[i]의 값을 num과 XOR(^) 비트연산을 수행한 결과가 k가 된다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-xor-for-each-query/",
        "teaser": null
      },{
        "title": "Leetcode Java Prime Subtraction Operation",
        "excerpt":"문제  Link   코드  class Solution {    public boolean primeSubOperation(int[] nums) {     for (int i = 0; i &lt; nums.length; i++) {       int num;       if (i == 0) {         num = nums[0];       } else {         num = nums[i] - nums[i - 1];         if (num &lt;= 0) {           return false;         }       }       int max = 0;       for (int j = num - 1; j &gt;= 2; j--) {         if (this.isPrime(j)) {           max = j;           break;         }       }       nums[i] -= max;     }     return true;   }    private boolean isPrime(int num) {     for (int i = 2; i &lt;= Math.sqrt(num); i++) {       if (num % i == 0) {         return false;       }     }     return true;   }  }   결과  Link   설명          nums의 각 위치의 값보다 작은 소수를 현재 값에서 빼서 점층적으로 증가하는 배열을 만들 수 있는지 검증하는 문제이다.       0부터 nums의 길이 미만까지 아래를 반복한다.            num에 아래의 조건에 해당하는 값을 할당한다.                    i가 0인 첫 수행인 경우, nums[0]을 넣어준다.           위의 경우가 아니라면 nums[i] - nums[$i - 1$]의 값을 넣은 후, 해당 값이 0 이하인 점층적으로 증가하는 배열을 만들 수 없는 경우 false를 주어진 문제의 결과로 반환한다.                       max는 가능한 소수값을 저장하기 위한 변수로, $num - 1$부터 2 이상까지 j를 감소시키면서 소수인 값을 찾아 넣어준다.       nums[i]에 max를 빼서 감소된 값을 저장한다.           반복이 완료되면 점층적으로 증가하는 배열을 만들 수 있으므로, true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/prime-subtraction-operation/",
        "teaser": null
      },{
        "title": "Leetcode Java Most Beautiful Item for Each Query",
        "excerpt":"문제  Link   코드  class Solution {    public long countFairPairs(int[] nums, int lower, int upper) {     Arrays.sort(nums);     return this.countLess(nums, upper) - this.countLess(nums, lower - 1);   }    private long countLess(int[] nums, int sum) {     long result = 0;     int left = 0;     int right = nums.length - 1;     while (left &lt; right) {       if (nums[left] + nums[right] &lt;= sum) {         result += right - left++;       } else {         right--;       }     }     return result;   }  }   결과  Link   설명          nums 내 두 값의 합이 lower 이상, upper 이하인 조합의 갯수를 구하는 문제이다.            nums를 오름차순으로 정렬한다.       4번에서 정의한 countLess(int[] nums, int sum) 메서드를 아래 두 값의 차잇값을 주어진 문제의 결과로 반환한다.            sum에 upper를 넣어 수행한 결과인 값의 합이 upper 이하인 조합의 갯수.       sum에 $lower - 1$을 넣어 수행한 결과인 값의 합이 $lower - 1$ 이하인 조합의 갯수.           nums 내 sum 이하까지 조합의 갯수를 계산하기 위한 countLess(int[] nums, int sum) 메서드를 정의한다.            메서드 풀이에 필요한 변수를 정의한다.                    result는 갯수 계산에 필요한 변수로, 0으로 초기화한다.           left와 right는 nums의 좌측과 우측의 위치 값을 저장할 변수로, 0과 nums의 길이보다 1 작은 마지막 위치의 값으로 초기화한다.                       left가 right 미만일 때 까지 아래를 반복한다.                    $nums[left] + nums[right]$의 결과가 sum 아래인 경우, result에 $right - left$인 가능한 범위 내 갯수를 더해준 후 left를 증가시켜준다.           위의 결과가 아니라면 right를 감소시켜 범위를 좁혀준다.                       반복이 완료되어 계산된 result를 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/most-beautiful-item-for-each-query/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimized Maximum of Products Distributed to Any Store",
        "excerpt":"문제  Link   코드  class Solution {    public int minimizedMaximum(int n, int[] quantities) {     int left = 1;     int right = 100000;     while (left &lt; right) {       int mid = (left + right) / 2;       int sum = 0;       for (int quantity : quantities) {         sum += (quantity + (mid - 1)) / mid;       }       if (sum &gt; n) {         left = mid + 1;       } else {         right = mid;       }     }     return left;   }  }   결과  Link   설명     제품 유형 별 갯수가 저장된 quantities를 n개 상점에 아래의 규칙대로 배포할때, 배포할 수 있는 최대 가능한 갯수를 반환하는 문제이다.            각 상점에는 한 가지 유형의 제품만 취급 가능하다.       각 상점에 제공하는 제품 갯수는 최소화하여 제공해야한다.                left와 right는 quantities의 탐색 위치를 저장할 변수로, 제품 유형의 범위인 1과 100000으로 초기화한다.       left가 right 미만일 때 까지 아래를 반복한다.            mid는 중앙값을 저장할 변수로, $\\frac{left + right}{2}$의 값으로 초기화한다.       sum은 제품의 합계를 저장할 변수로, quantities를 반복하여 $\\frac{quantity + (mid - 1)}{mid}$인 mid개씩 제품을 분배할 때 가능한 상점의 수를 계산한다.       위의 반복이 완료되면 sum이 n보다 큰 경우, left에 $mid + 1$을 아니면 right에 mid를 넣어 제품 분배 갯수를 조절한다.           반복이 완료되면 분배 갯수가 저장된 left를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimized-maximum-of-products-distributed-to-any-store/",
        "teaser": null
      },{
        "title": "Leetcode Java Shortest Subarray to be Removed to Make Array Sorted",
        "excerpt":"문제  Link   코드  class Solution {    public int findLengthOfShortestSubarray(int[] arr) {     int length = arr.length;     int left = 0;     int right = length - 1;     while (left + 1 &lt; length &amp;&amp; arr[left] &lt;= arr[left + 1]) {       left++;     }     if (left == length - 1) {       return 0;     }     while (0 &lt; right &amp;&amp; arr[right - 1] &lt;= arr[right]) {       right--;     }     int i = 0;     int j = right;     int result = Math.min(length - left - 1, right);     while (i &lt;= left &amp;&amp; j &lt; length) {       if (arr[i] &lt;= arr[j]) {         result = Math.min(result, j - i - 1);         i++;       } else {         j++;       }     }     return result;   }  }   결과  Link   설명          arr 내 값들이 감소하지 않는 순서로 만들기 위해 삭제할 부분 문자열의 길이를 반환하는 문제이다.       사전 범위를 계산하기 위한 변수를 정의한다.            length는 arr의 길이를 저장한 변수이다.       left와 right는 arr의 위치를 저장할 변수로, 시작 위치인 0과 종료 위치인 $length - 1$로 초기화한다.                $left + 1$이 length 미만이면서 arr[left]의 값이 arr[$left + 1$]의 값 이하인 감소하지 않는 순서를 만족할 때 까지 left를 증가시켜준다.            left가 $length - 1$인 마지막 위치인 경우 삭제할 숫자가 없으므로, 0을 주어진 문제의 결과로 반환한다.            right가 0 초과이면서 arr[$right - 1$]의 값이 arr[right]의 값 이하인 감소하지 않는 순서를 만족할 때 까지 right를 감소시켜준다.       arr에서 삭제할 부분 문자열의 길이를 확인하기 위한 변수를 정의한다.            i와 j는 부분 문자열 삭제하기 위한 위치를 탐색할 변수로, 0과 right로 초기화한다.       result는 결과를 저장할 변수로, $length - left - 1$과 right 중 작은 값을 넣어준다.           i는 left 이하이고 j는 length 이하일 때 까지 아래를 반복한다.            arr[i]의 값이 arr[j] 이하인 경우 조건을 만족하므로, result에 result와 $j - i - 1$인 현재 부분 문자열 길이 중 작은 값을 넣어주고 i를 증가시켜준다.       위를 만족하지 않으면 arr[j]도 삭제해야하므로, j를 증가시켜준다.           반복이 완료되면 삭제할 부분 문자열의 길이가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/shortest-subarray-to-be-removed-to-make-array-sorted/",
        "teaser": null
      },{
        "title": "Leetcode Java Find the Power of K-Size Subarrays I",
        "excerpt":"문제  Link   코드  class Solution {    public int[] resultsArray(int[] nums, int k) {     int length = nums.length;     int[] result = new int[length - k + 1];     int sum = 0;     for (int i = 0; i &lt; k - 1; i++) {       sum += nums[i];     }     int index = 0;     for (int i = 0, j = k - 1; j &lt; length; i++, j++, index++) {       sum += nums[j];       if ((k * (nums[i] + nums[i] + k - 1) / 2) == sum &amp;&amp; nums[i] &lt;= nums[j]) {         result[index] = nums[j];       } else {         result[index] = -1;       }       sum -= nums[i];     }     return result;   }  }   결과  Link   설명     nums를 이용하여 연속된 k 개의 요소로 이루어진 부분 배열이 아래의 조건을 만족하는지 여부를 배열로 각각 반환하는 문제이다.            k개의 요소는 오름차순으로 구성될 때, 최댓값을 넣는다.       오름차순이 성립되지 않으면 -1을 넣는다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       result는 결과를 넣을 변수로, k개의 연속된 요소의 부분 배열의 갯수인 $length - k + 1$ 크기의 정수 배열로 초기화한다.       sum은 k개의 합계를 저장할 변수로, nums의 처음 k개의 값들의 합을 넣어준다.       index는 result의 위치를 저장항 변수로, 처음 위치인 0으로 초기화한다.           i는 0부터, j는 $k - 1$부터 length 미만까지 i, j, index를 증가시키면서 아래를 반복한다.            sum에 nums[j]의 값을 더해준다.       만일 $\\frac{k \\times (nums[i] + nums[i] + k - 1)}{2} = sum$을 만족하면서 nums[i]의 값이 nums[j] 이하인 증가하는 배열인 경우, result[index]에 가장 큰 nums[j]의 값을 넣어준다.       위의 조건을 만족하지 않는 경우, result[index]에 -1을 넣어준다.       sum에 nums[i]의 값을 빼준다.           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-the-power-of-k-size-subarrays-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Cost to Move Chips to The Same Position",
        "excerpt":"문제  Link   코드  class Solution {    public int minCostToMoveChips(int[] position) {     int[] count = new int[2];     for (int p : position) {       count[p % 2]++;     }     return Math.min(count[0], count[1]);   }  }   결과  Link   설명     position에 있는 각 코인들을 아래의 규칙대로 하나의 위치에 모으기 위한 비용을 계산하는 문제이다.            현재 위치에서 2 칸을 앞뒤로 움직이는 경우, 비용을 0으로 계산한다.       현재 위치에서 1 칸을 앞뒤로 움직이는 경우, 비용을 1로 계산한다.                count는 홀수와 짝수 위치를 계산하기 위한 변수로, 2 크기의 정수 배열로 초기화한다.            position의 각 값을 순차적으로 짝수인지 홀수인지에 따라 count에 값을 넣어준다.       반복이 완료되면 짝수의 위치인 count[0]의 값과 홀수의 위치인 count[1]의 값 중 작은 값을 주어진 문제의 결과로 반환한다.   해설     위치의 값이 짝수인 값이 많은 경우, 짝수의 임의 한 지점 위치의 값을 앞뒤 인접한 위치까지 2칸 씩 비용 0으로 모아 홀수인 갯수만큼 이동시키면 된다.   위치의 값이 홀수인 값이 많은 경우, 홀수의 임의 한 지점 위치의 값을 앞뒤 인접한 위치까지 2칸 씩 비용 0으로 모아 짝수인 갯수만큼 이동시키면 된다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-cost-to-move-chips-to-the-same-position/",
        "teaser": null
      },{
        "title": "Leetcode Java Defuse the Bomb",
        "excerpt":"문제  Link   코드  class Solution {    public int[] decrypt(int[] code, int k) {     if (k == 0) {       return new int[code.length];     }     int length = code.length;     int start = 1;     int end = k;     if (k &lt; 0) {       start = length + k;       end = length - 1;     }     int sum = 0;     for (int i = start; i &lt;= end; i++) {       sum += code[i];     }     int[] result = new int[length];     for (int i = 0; i &lt; length; i++) {       result[i] = sum;       sum -= code[start++ % length] - code[++end % length];     }     return result;   }  }   결과  Link   설명     code에서 아래의 규칙대로 합계를 각 위치에서 계산하여 반환하는 문제이다.            k가 0보다 큰 경우, 현재 값의 위치에서 다음 k개 숫자의 합을 넣는다.       k가 0보다 작은 경우, 현재 값의 위치에서 이전 k개 숫자의 합을 넣는다. (여기서 k는 절댓값 k이다.)       k가 0인 경우, 모든 위치의 값은 0이다.                k가 0인 경우, code 길이의 정수 배열을 정의하여 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            length는 code의 길이를 저장한 변수이다.       start와 end는 시작 위치와 종료 위치를 저장할 변수로, 아래의 경우에 따라 값을 넣어준다.                    k가 0보다 큰 경우, start에 1과 end에 k를 넣어준다.           k가 0보다 작은 경우, start에 $length + k$와 end에 $length - 1$을 넣어준다.                       sum은 위치에 따라 k개 값의 합을 저장할 변수로, start부터 end까지 code 내 값의 합을 넣어준다.       result는 결과를 저장할 변수로, length 크기의 정수 배열로 초기화한다.           0부터 length 미만까지 i를 증가시키면서 아래를 수행한다.            result[i]의 위치에 사전 계산된 sum을 먼저 넣어준다.       sum에 code에서 start를 length로 나눈 나머지 값의 위치에 해당하는 값을 뺀 후 start를 증가시키고, end를 증가시킨 후 length 나눈 나머지 값의 위치에 해당하는 값을 더해준다.           반복이 완료되면 각 위치별 조건에 해당하는 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/defuse-the-bomb/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Sum of Distinct Subarrays With Length K",
        "excerpt":"문제  Link   코드  class Solution {    public long maximumSubarraySum(int[] nums, int k) {     boolean[] visited = new boolean[100001];     long sum = 0L;     long result = 0L;     for (int i = 0, j = 0; j &lt; nums.length; j++) {       int num = nums[j];       while (visited[num] || (j - i + 1 &gt; k &amp;&amp; i &lt; j)) {         sum -= nums[i];         visited[nums[i++]] = false;       }       sum += num;       if (j - i + 1 == k) {         result = Math.max(result, sum);       }       visited[num] = true;     }     return result;   }  }   결과  Link   설명     nums와 k를 이용하여 아래의 조건을 만족하는 가능한 부분 배열의 합이 최대인 값을 구하는 문제이다.            부분 배열의 크기는 k이다.       모든 요소는 동일한 값이 존재하지 않는다.       위 두 조건을 만족하는 부분 배열이 없는 경우, 0을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            visited는 방문한 값을 체크하기 위한 변수로, 값의 최대 가능한 범위인 $10^5$보다 1 큰 크기의 부울 배열로 초기화한다.       sum은 합계를 계산하기 위한 변수로, 0으로 초기화한다.       result는 조건을 만족하는 합이 최대인 값을 저장할 변수로, 0으로 초기화한다.           i는 0부터, j는 0부터 nums의 길이 미만까지 j를 증가시키면서 아래를 반복한다.            num에 nums[j]의 값을 저장한다.       visited[num]이 true인 사용한 값인 경우이거나, $j - i + 1$이 k를 초과하면서 i가 j 미만일 때 까지 sum에 nums[i]의 값을 빼주고, visited[nums[i]]의 값을 false로 바꾼 뒤 i를 증가시켜준다.       sum에 num을 더해 현재 위치의 값을 더해준다.       $j - i + 1$이 k인 부분 배열 크기에 만족하면, result에 result와 sum 중 큰 값을 넣어준다.       visited[num]에 true를 넣어 사용한 값을 체크해준다.           반복이 완료되면 최대 합계가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-sum-of-distinct-subarrays-with-length-k/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Unguarded Cells in the Grid",
        "excerpt":"문제  Link   코드  class Solution {    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {     int[][] grid = new int[m][n];     for (int[] wall : walls) {       grid[wall[0]][wall[1]] = 1;     }     for (int[] guard : guards) {       grid[guard[0]][guard[1]] = 1;     }     int count = (m * n) - guards.length - walls.length;     for (int[] guard : guards) {       int x = guard[0] - 1;       int y = guard[1];       while (x &gt;= 0 &amp;&amp; grid[x][y] != 1) {         if (grid[x][y] != -1) {           count--;           grid[x][y] = -1;         }         x--;       }       x = guard[0] + 1;       while (x &lt; m &amp;&amp; grid[x][y] != 1) {         if (grid[x][y] != -1) {           count--;           grid[x][y] = -1;         }         x++;       }       x = guard[0];       y = guard[1] - 1;       while (y &gt;= 0 &amp;&amp; grid[x][y] != 1) {         if (grid[x][y] != -1) {           count--;           grid[x][y] = -1;         }         y--;       }       y = guard[1] + 1;       while (y &lt; n &amp;&amp; grid[x][y] != 1) {         if (grid[x][y] != -1) {           count--;           grid[x][y] = -1;         }         y++;       }     }     return count;   }  }   결과  Link   설명          $n \\times m$ 크기의 2차원 배열에서 경비원의 좌표가 저장된 guards를 이용하여 벽의 좌표가 저장된 walls 중 하나 혹은 배열의 끝에 다다를 때 까지 이동 가능할 때 마주치지 않을 수 있는 공간의 갯수를 계산하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            grid는 경비원을 마주치지 않을 수 있는 공간을 계산하기 위한 변수로, $n \\times m$ 크기의 2차원 배열로 초기화하고 walls와 guards의 위치에 1을 넣어준다.       count는 경비원을 마주치지 않을 수 있는 공간의 수를 저장할 변수로, 위의 값을 제외한 빈 공간의 갯수로 초기화한다.           guards를 순차적으로 guard에 넣어 아래를 수행한다.            x와 y는 좌표를 저장할 변수로, 경비원의 좌측인 $guard[0] - 1$과 guard[1]의 값으로 초기화한다.       x가 0 이상이면서 grid[x][y]가 1이 아닌 이동 불가능한 위치가 아닐 때 까지 아래를 수행한다.                    grid[x][y]의 값이 -1이 아닌 이동한 경로가 아닌 경우, count를 감소시키고 grid[x][y]에 -1을 넣어 이동한 위치임을 표시한다.           x를 감소시켜 좌측으로 이동한다.                       x에 $gurad[0] + 1$을 넣어, 경비원의 오른쪽 위치로 이동한다.       x가 m 미만이면서 grid[x][y]가 1이 아닌 이동 불가능한 위치가 아닐 때 까지 아래를 수행한다.                    grid[x][y]의 값이 -1이 아닌 이동한 경로가 아닌 경우, count를 감소시키고 grid[x][y]에 -1을 넣어 이동한 위치임을 표시한다.           x를 증가시켜 우측으로 이동한다.                       x에 guard[0]를, y에 $guard[1] - 1$를 넣어, 경비원의 아래 위치로 이동한다.                    grid[x][y]의 값이 -1이 아닌 이동한 경로가 아닌 경우, count를 감소시키고 grid[x][y]에 -1을 넣어 이동한 위치임을 표시한다.           y를 감소시켜 아래로 이동한다.                       y에 $guard[1] + 1$을 넣어, 경비원의 위 위치로 이동한다.                    grid[x][y]의 값이 -1이 아닌 이동한 경로가 아닌 경우, count를 감소시키고 grid[x][y]에 -1을 넣어 이동한 위치임을 표시한다.           y를 증가시켜 위로 이동한다.                           반복이 완료되면 계산된 마주치지 않는 공간의 수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-unguarded-cells-in-the-grid/",
        "teaser": null
      },{
        "title": "Custom JRE로 경령화된 Dockering II",
        "excerpt":"개요     이전 포스트인 Custom JRE로 경령화된 Dockering I에서 이야기한 내용과 절차는 동일하지만, 공식적으로 제공하는 Layered Jars1를 사용하는 방법을 설명한다.   이 포스트에서는 기존 방식과 차별화된 방식에 대한 설명을 진행하므로, 기본 절차를 이해하고 싶다면 이전 포스트를 읽은 다음에 보는 것을 추천한다.   Layered Jars     Layered Jars는 기존의 Fat jars의 형태인 모든 의존성과 리소스 파일들을 단일 jar 파일로 패키징 하는 방법을 아래와 같이 필요한 레이어로 패키징을 활용하는 기능이다.     ./app ├─ /dependencies           ## for any dependency whose version does not contain SNAPSHOT. ├─ /spring-boot-loader     ## for the jar loader classes. ├─ /snapshot-dependencies  ## for any dependency whose version contains SNAPSHOT. └─ /application            ## for application classes and resources.           Setting     Layered 기능을 사용하기 위해서는 아래와 같이 빌드 툴 별 설정이 필요하지만, Spring Boot 2.3.0 부터 빌드 툴의 설정 없이 사용이 가능하다.   Maven(pom.xml)  &lt;project&gt;   &lt;build&gt;     &lt;plugins&gt;       &lt;plugin&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;         &lt;version&gt;{maven-project-version}&lt;/version&gt;         &lt;configuration&gt;         &lt;layers&gt;           &lt;enabled&gt;true&lt;/enabled&gt;         &lt;/layers&gt;         &lt;/configuration&gt;       &lt;/plugin&gt;     &lt;/plugins&gt;   &lt;/build&gt; &lt;/project&gt;   Gradle(build.gradle)  bootJar {   layered() }   Structure     기본적으로 사용하는 구조는 “/BOOT-INF/layers.idx”에 아래와 같이 정의된다.   - \"dependencies\":   - \"BOOT-INF/lib/\" - \"spring-boot-loader\":   - \"org/\" - \"snapshot-dependencies\": - \"application\":   - \"BOOT-INF/classes/\"   - \"BOOT-INF/classpath.idx\"   - \"BOOT-INF/layers.idx\"   - \"META-INF/\"   Customizing     필요에 따라 각 빌드 툴 별 설정 방식으로 layer를 정의하여 사용할 수 있다.   Maven(layer.xml)  &lt;layers xmlns=\"http://www.springframework.org/schema/boot/layers\"               xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"               xsi:schemaLocation=\"http://www.springframework.org/schema/boot/layers               https://www.springframework.org/schema/boot/layers/layers-{spring-boot-xsd-version}.xsd\"&gt;   &lt;application&gt;     &lt;into layer=\"spring-boot-loader\"&gt;       &lt;include&gt;org/springframework/boot/loader/**&lt;/include&gt;     &lt;/into&gt;     &lt;into layer=\"application\" /&gt;   &lt;/application&gt;   &lt;dependencies&gt;     &lt;into layer=\"snapshot-dependencies\"&gt;       &lt;include&gt;*:*:*SNAPSHOT&lt;/include&gt;     &lt;/into&gt;     &lt;into layer=\"company-dependencies\"&gt;       &lt;include&gt;com.acme:*&lt;/include&gt;     &lt;/into&gt;     &lt;into layer=\"dependencies\"/&gt;   &lt;/dependencies&gt;   &lt;layerOrder&gt;     &lt;layer&gt;spring-boot-loader&lt;/layer&gt;     &lt;layer&gt;application&lt;/layer&gt;     &lt;layer&gt;company-dependencies&lt;/layer&gt;     &lt;layer&gt;snapshot-dependencies&lt;/layer&gt;     &lt;layer&gt;dependencies&lt;/layer&gt;   &lt;/layerOrder&gt; &lt;/layers&gt;   Gradle(build.gradle)  bootJar {   layered {     application {       intoLayer(\"spring-boot-loader\") {         include \"org/springframework/boot/loader/**\"       }       intoLayer(\"application\")     }     dependencies {       intoLayer(\"snapshot-dependencies\") {         include \"*:*:*SNAPSHOT\"       }       intoLayer(\"company-dependencies\") {         include \"com:gracefulsoul:*\"       }       intoLayer(\"dependencies\")     }     layerOrder = [\"spring-boot-loader\", \"application\", \"company-dependencies\", \"snapshot-dependencies\", \"dependencies\"]   } }   Dockerfile     기존 방식과 Layered Jars와 차이를 분석한다.   Stage 1  # Stage 1. Create custom JRE FROM amazoncorretto:21-alpine AS jrebuilder  # Add the application jar to the container COPY ./build/libs/hello-docker-*-SNAPSHOT.jar app.jar  # Install binutils RUN apk add --no-cache binutils  # Extract jar file and generate custom JRE using dependency RUN java -Djarmode=tools -jar app.jar extract --layers --launcher \\   &amp;&amp; DEPENDENCY=$(jdeps --ignore-missing-deps --print-module-deps --recursive --multi-release 21 --class-path=\"/app/dependencies/BOOT-INF/lib/*\" /app.jar) \\   &amp;&amp; ${JAVA_HOME}/bin/jlink \\     --verbose \\     --add-modules ${DEPENDENCY} \\     --strip-debug \\     --no-man-pages \\     --no-header-files \\     --compress=2 \\     --output customjre          이전에는 jar 명령어를 이용하여 압축 해제한 폴더를 사용했다면, 이번에는 java 명령어 내 “jarmode” 중 “tools”를 사용하여 압축을 해제한다.                                  Option           Description                                           –launcher           스프링 부트 런처 추출.                             –layers           레이어를 활용한 추출.                           Stage 2  # Stage 2. Make container for application FROM alpine:3.20 ENV JAVA_HOME=/jre ENV PATH=\"${JAVA_HOME}/bin:${PATH}\" ARG DEPENDENCY=/app  # Add Maintainer Info LABEL maintainer=\"GracefulSoul on &lt;gracefulsoul@github.com&gt;\"  # Copy custom JRE COPY --from=jrebuilder /customjre ${JAVA_HOME}  # Copy extract files in jar COPY --from=jrebuilder ${DEPENDENCY}/dependencies/ ${DEPENDENCY}/ COPY --from=jrebuilder ${DEPENDENCY}/snapshot-dependencies/ ${DEPENDENCY}/ COPY --from=jrebuilder ${DEPENDENCY}/spring-boot-loader/ ${DEPENDENCY}/ COPY --from=jrebuilder ${DEPENDENCY}/application/ ${DEPENDENCY}/  # Move work directory WORKDIR ${DEPENDENCY}  # Run application ENTRYPOINT [ \"java\", \"org.springframework.boot.loader.launch.JarLauncher\" ]     기존 BOOT-INF, META-INF에서 필요한 폴더를 나누어 썼듯이 Layer로 분리된 각 폴더에서 필요한 폴더를 사용한다.   애플리케이션 실행은 기존과 다르게 Main Class를 실행하는 것이 아닌, Layered Jars를 같이 추출된 Launcher를 사용하여 Main Class를 실행한다.   정리     코드를 보면 이전 화와 크게 다를 바 없는 내용이지만, 복잡한 구성의 애플리케이션에서는 단순 빌드된 Fat Jars를 원하는 형태로 배치하기 위해 소모되는 자원과 시간은 개발자에게 불필요하다.   Spring Boot는 초기 사상과 같이 개발자는 비즈니스 로직에 더 집중할 수 있는 다양한 환경을 구성해주며, 이러한 기능들은 실무에 다양하게 활용할 수 있다.   여담     Layered Jars는 Spring Boot 3.3부터 공식적으로 지원하는 Class Data Sharing(CDS) [^Spring-Boot-3.3-Release-Notes]를 사용하기 위해 공유할 자원을 분리하여 애플리케이션을 실행 할 때에도 사용된다.   jarmode의 경우도, 해당 버전부터 layertools가 deprecated 되었으로 아래 내용을 참고하였으면한다.            3.3 이상 : java -Djarmode=tools -jar app.jar extract –layers –launcher       3.3 미만 : java -Djarmode=layertools -jar app.jar           이전  Custom JRE로 경령화된 Dockering I   Reference  ※ Sample Code는 여기에서 확인 가능합니다.                 Creating-Efficient-Docker-Images-with-Spring-Boot-2.3_Spring-Blog &#8617;           ","categories": ["Java"],
        "tags": ["Programming","Docker","Java","Spring","Jdeps","Jlink","Layered Jars"],
        "url": "/java/lightweight-jdk-docker-II/",
        "teaser": null
      },{
        "title": "Leetcode Java Rotating the Box",
        "excerpt":"문제  Link   코드  class Solution {    public char[][] rotateTheBox(char[][] box) {     int row = box.length;     int col = box[0].length;     char[][] result = new char[col][row];     for (int i = 0; i &lt; row; i++) {       for (int j = col - 1, k = col - 1; j &gt;= 0; j--) {         result[j][row - i - 1] = '.';         if (box[i][j] != '.') {           if (box[i][j] == '*') {             k = j;           }           result[k--][row - i - 1] = box[i][j];         }       }     }     return result;   }  }   결과  Link   설명     box를 우측으로 90도 기울인 배열을 반환하는 문제이다.            box내 값들 중 ‘#’는 돌, ‘*‘는 장애물, ‘.’는 빈 공간을 의미한다.       box를 우측으로 기울였을 때 돌은 장애물을 만나기 전까지 아래로 이동할 수 있다.           문제 풀이에 필요한 변수를 정의한다.            row와 col은 bot의 행과 열 갯수를 저장한 변수이다.       result는 결과를 저장할 변수로, 행과 열의 길이를 반대로한 $col \\times row$ 크기의 문자 배열로 초기화한다.           0부터 row 미만까지 i를 증가시키고, j와 k를 $col - 1$로 초기화 후 j가 0 이상일 때 까지 감소시키면서 아래를 반복한다.            result[j][$row - i - 1$]의 자리에 ‘.’를 넣어 빈공간으로 초기화한다.       box[i][j]의 값이 ‘.’이 아닌 경우, 아래를 수행한다.                    box[i][j]의 값이 ‘*‘인 장애물인 경우, k에 j를 넣어 result에 넣을 위치인 k를 이동한다.                       result[k][$row - i - 1$]의 자리에 box[i][j]의 값을 그대로 넣어주고 k를 감소시킨다.           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/rotating-the-box/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Matrix Sum",
        "excerpt":"문제  Link   코드  class Solution {    public long maxMatrixSum(int[][] matrix) {     int row = matrix.length;     int col = matrix[0].length;     long result = 0;     long negative = 0;     long min = Long.MAX_VALUE;     for (int i = 0; i &lt; row; i++) {       for (int j = 0; j &lt; col; j++) {         if (matrix[i][j] &lt; 0) {           negative++;         }         int absolute = Math.abs(matrix[i][j]);         result += absolute;         min = Math.min(min, absolute);       }     }     if (negative % 2 == 0) {       return result;     } else {       return result - (2 * min);     }   }  }   결과  Link   설명          정사각형 모양의 matrix에 아래의 연산을 이용하여 계산한 합계가 최대인 값을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            row와 col은 행과 열의 길이를 저장한 변수이다.       result는 합계를 저장할 변수로, 0으로 초기화한다.       negative는 음수의 갯수를 계산할 변수로, 0으로 초기화한다.       min은 최솟값을 저장할 변수로, Long의 가장 큰 값으로 초기화한다.           0부터 row 미만까지 i를 증가시키고, 0부터 col 미만까지 j를 증가시키며 아래를 반복한다.            matrix[i][j]의 값이 음수라면 nagative 값을 증가시킨다.       absolute는 matrix의 절댓값을 넣어준다.       result에 absolute를 더해준 후 min에 min과 absolute 중 작은 값을 넣어준다.           negative가 짝수인지 여부에 따라 아래 결과를 반환한다.            짝수인 음수가 모두 양수로 전환되는 경우, result를 주어진 문제의 결과로 반환한다.       홀수인 한 값이 음수로 존재하는 경우, result에 가장 작은 값이 저장된 min을 2로 곱한 값을 빼준 값을 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-matrix-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Champion II",
        "excerpt":"문제  Link   코드  class Solution {    public int findChampion(int n, int[][] edges) {     boolean[] weak = new boolean[n];     for (int[] edge : edges) {       weak[edge[1]] = true;     }     int result = -1;     for (int i = 0; i &lt; n; i++) {       if (!weak[i]) {         if (result == -1) {           result = i;         } else {           return -1;         }       }     }     return result;   }  }   결과  Link   설명     n개의 팀이 있는 DAG(순환되지 않는 연결 선)이 저장된 edges를 이용하여 아래 규칙대로 토너먼트에서 우승할 팀을 구하는 문제이다.            edges 내 임의 값인 edge = [i, j]로, i 팀이 j 팀보다 강한 것을 의미한다.       우승할 한 팀이 존재하지 않는 경우, -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            weak는 약한 팀을 구분할 변수로, n 크기의 부울 배열로 초기화하고 edges의 각 두 번째 값들의 위치에 true를 넣어준다.       result는 토너먼트 우승 팀을 저장할 변수로, 존재하지 않을 경우 반환할 값인 -1로 초기화한다.           0부터 n 미만까지 i를 감소시키며 아래를 반복한다.            weak[i]의 값이 false인 자신보다 강한 팀이 없는 경우, 아래를 수행한다.                    result가 -1인 지금까지 우승할 팀이 존재하지 않으면, 현재 위치인 i를 넣어준다.           위의 경우가 아니라면 강한 척도를 구분할 수 없는 팀이 둘 이상이므로, -1을 주어진 문제의 결과로 반환한다.                           반복이 완료되면 토너먼트 우승할 팀이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-champion-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Shortest Distance After Road Addition Queries I",
        "excerpt":"문제  Link   코드  class Solution {    public int[] shortestDistanceAfterQueries(int n, int[][] queries) {     List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();     for (int i = 0; i &lt; n; i++) {       list.add(new ArrayList&lt;&gt;());       list.get(i).add(i + 1);     }     int length = queries.length;     int[] result = new int[length];     for (int i = 0; i &lt; length; i++) {       int[] query = queries[i];       list.get(query[0]).add(query[1]);       result[i] = this.getShortestDistance(list, n);     }     return result;   }    private int getShortestDistance(List&lt;List&lt;Integer&gt;&gt; list, int n) {     Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();     queue.offer(new int[] { 0, 0 });     boolean[] visited = new boolean[n];     visited[0] = true;     while (!queue.isEmpty()) {       int[] curr = queue.poll();       if (curr[0] == n - 1) {         return curr[1];       }       for (int neighbor : list.get(curr[0])) {         if (!visited[neighbor]) {           queue.offer(new int[] { neighbor, curr[1] + 1 });           visited[neighbor] = true;         }       }     }     return -1;   }  }   결과  Link   설명          앞 도시와 뒤 도시가 연결된 n개의 도시와 신규 도로의 정보가 담긴 queries를 순서대로 완공할 때, 각 도로가 완성될 때마다 0번 도시에서 $n - 1$번 도시까지 도착하는 가장 짧은 거리를 각각 계산하여 배열로 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            list는 각 도시 별 연결된 도시를 저장할 변수로, ArrayList로 초기화하고 list의 각 도시에 해당하는 위치를 ArrayList를 넣어 다음 도시 번호를 초기값으로 넣어준다.       length는 queries의 길이를 저장한 변수이다.       result는 queries의 도로가 생성될 때 마다 최소 길이를 저장할 변수로, length 크기의 정수 배열로 초기화한다.           0부터 length 미만까지 i를 증가시키며 아래를 반복한다.            query에 queries[i]의 값을 넣어준다.       list에서 query[0]의 값에 해당하는 위치에 query[1]의 값을 넣어준다.       result[i]에 4번에서 정의한 getShortestDistance(List&lt;List&gt; list, int n) 메서드를 수행한 결과를 넣어준다.           0번 도시에서 $n - 1$번 도시까지 최단 경로를 구하기 위한 getShortestDistance(List&lt;List&gt; list, int n) 메서드를 정의한다.            queue는 도시의 각 경로를 넣어 최단 경로를 구하기 위한 변수로, LinkedList로 초기화하고 [0, 0]을 초기 값으로 넣어준다.       visited는 도시 방문 여부를 저장할 변수로, 도시 갯수인 n 크기의 부울 배열로 초기화하고 처음 도시의 위치인 visited[0]을 true로 넣어준다.       queue의 값이 비어있지 않을 때 까지 아래를 반복한다.                    curr에 queue의 첫 값을 꺼내 넣어준다.           curr[0]의 값이 $n - 1$인 마지막 도시인 경우, curr[1]의 값인 현재까지 거리를 반환한다.           list의 curr[0]의 값을 순차적으로 neighbor에 넣고, visited[neighbor]의 값이 false인 방문하지 않은 경우만 queue에 neighbor의 값과 거리를 증가시킨 $curr[1] + 1$의 값을 배열로 넣고 visited[neighbor]의 값을 true로 초기화한다.                       반복이 완료되면 마지막 도시까지 이동이 불가능하므로, -1을 반환한다.           3번의 반복이 완료되면 각 도로가 완공될 때 마다 최단 거리가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/shortest-distance-after-road-addition-queries-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Obstacle Removal to Reach Corner",
        "excerpt":"문제  Link   코드  class Solution {    private static final int[][] DIRECTIONS = {     { 0, 1 },     { 1, 0 },     { 0, -1 },     { -1, 0 }   };    public int minimumObstacles(int[][] grid) {     int row = grid.length;     int col = grid[0].length;     Deque&lt;int[]&gt; deque = new ArrayDeque&lt;&gt;();     deque.add(new int[] { 0, 0, 0 });     grid[0][0] = -1;     while (!deque.isEmpty()) {       int[] curr = deque.pollFirst();       int x = curr[0];       int y = curr[1];       int obstacle = curr[2];       if (x == row - 1 &amp;&amp; y == col - 1) {         return obstacle;       }       for (int[] direction : DIRECTIONS) {         int dx = x + direction[0];         int dy = y + direction[1];         if (0 &lt;= dx &amp;&amp; dx &lt; row &amp;&amp; 0 &lt;= dy &amp;&amp; dy &lt; col &amp;&amp; grid[dx][dy] != -1) {           if (grid[dx][dy] == 0) {             deque.addFirst(new int[] { dx, dy, obstacle });           } else {             deque.addLast(new int[] { dx, dy, obstacle + 1 });           }           grid[dx][dy] = -1;         }       }     }     return -1;   }  }   결과  Link   설명     이차원 배열 grid에서 아래 규칙을 따라 좌측 상단의 [0, 0] 위치에서 우측 하단의 [$m - 1$, $n - 1$]로 이동하기 위해 제거할 최소 장애물 갯수를 구하는 문제이다.            grid[i]의 값이 0이면 빈 셀을 의미한다.       grid[i]의 값이 1이면 장애물을 의미한다.       빈 셀에서 상하좌우로 이동이 가능하다.                DIRECTIONS는 grid에서 이동하기 위한 상하좌우 방향의 가감치를 저장한 전역 변수이다.       문제 풀이에 필요한 변수를 정의한다.            row와 col은 grid의 행과 열의 길이를 저장한 변수이다.       deque는 위치를 이동하며 제거할 최소 장애물을 계산하기 위한 변수로, ArrayDeque로 초기화하여 첫 값을 시작 위치와 이동 거리인 [0, 0, 0]으로 초기화한다.       grid[0][0] 위치에 -1을 넣어 방문한 위치를 표시한다.           deque의 값이 존재할 때 까지 아래를 반복한다.            curr에 deque의 처음 배열을 꺼내 행 위치인 x에 curr[0], 열 위치인 y에 curr[1], 제거할 장애물 갯수인 obstacle에 curr[2]를 넣어준다.       [x, y]의 값이 우측 하단의 목표 지점인 경우, 제거할 장애물의 갯수인 obstacle을 주어진 문제의 결과로 반환한다.       DIRECTIONS의 각 값을 순차적으로 direction에 넣어 아래를 수행한다.                    dx에 $x + direction[0]$, dy에 $y + direction[1]$의 값을 넣어준다.           dx와 dy가 범위 내에 존재하면서 grid[dx][dy]의 값이 -1이 아닌 방문하지 않은 위치인 경우, grid[dx][dy]가 빈 셀인 0이면 deque의 첫 위치에 [dx, dy, obstacle]을, 1이면 deque의 마지막 위치에 제거할 장애물이 추가되었으므로 [dx, dy, $obstacle + 1$]을 넣어준다.                       grid[dx][dy]에 -1을 넣어 방문한 위치를 표시한다.           위의 수행에서 제거할 장애물 갯수에 제한이 없어 반드시 결과가 반환되므로, 임의 값인 -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-obstacle-removal-to-reach-corner/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Time to Visit a Cell In a Grid",
        "excerpt":"문제  Link   코드  class Solution {    private static final int[][] DIRECTIONS = new int[][] {     { 1, 0 },     { -1, 0 },     { 0, 1 },     { 0, -1 }   };    public int minimumTime(int[][] grid) {     if (grid[0][1] &gt; 1 &amp;&amp; grid[1][0] &gt; 1) {       return -1;     }     int row = grid.length;     int col = grid[0].length;     Queue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;((a, b) -&gt; a[2] - b[2]);     queue.offer(new int[] { 0, 0, 0 });     boolean[][] visited = new boolean[row][col];     visited[0][0] = true;     while (!queue.isEmpty()) {       int[] curr = queue.poll();       int x = curr[0];       int y = curr[1];       int time = curr[2];       for (int[] direction : DIRECTIONS) {         int dx = x + direction[0];         int dy = y + direction[1];         if (0 &lt;= dx &amp;&amp; dx &lt; row &amp;&amp; 0 &lt;= dy &amp;&amp; dy &lt; col &amp;&amp; !visited[dx][dy]) {           int currTime = time + 1;           if (grid[dx][dy] &gt; currTime) {             currTime += ((grid[dx][dy] - currTime + 1) / 2) * 2;           }           if (dx == row - 1 &amp;&amp; dy == col - 1) {             return currTime;           }           queue.offer(new int[] { dx, dy, currTime });           visited[dx][dy] = true;         }       }     }     return -1;   }  }   결과  Link   설명     이차원 정수 배열인 grid의 좌측 상단인 첫 위치에서 우측 하단의 마지막 위치까지 아래의 규칙으로 이동하기 위한 최소 시간을 계산하는 문제이다.            0초부터 시작하여 상하좌우 네 방향으로 이동이 가능하며, 이동에는 1초가 소요된다.       이동은 현재 시간 이하의 값인 위치로만 이동이 가능하다.       마지막 위치로 이동이 불가능한 경우, -1을 주어진 문제의 결과로 반환한다.                DIRECTIONS는 grid에서 이동하기 위한 상하좌우 방향의 가감치를 저장한 전역 변수이다.            grid[0][1] 혹은 grid[1][0]의 값이 1보다 큰 이동이 불가능한 경우, -1을 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            row와 col은 grid의 행과 열의 갯수를 저장한 변수이다.       queue는 위치 별 소요 시간을 저장하기 위한 변수로, 오름차순으로 정렬하여 보관하기 위해 PriorityQueue로 정의하고 초기 값인 [0, 0, 0]을 넣어준다.       visited는 방문한 위치를 저장하기 위한 변수로, $row \\times col$ 크기의 2차원 부울 배열로 초기화하여 첫 위치인 visited[0][0] 위치를 true로 바꿔준다.           queue의 값이 존재할 때 까지 아래를 반복한다.            curr에 queue의 첫 값을 꺼내 넣어주고, 위치를 저장할 x와 y에 curr[0], curr[1]의 값을 시간을 저장할 time에 curr[2]의 값을 넣어준다.       DIRECTIONS의 각 값을 순차적으로 direction에 넣어 아래를 수행한다.                    dx에 $x + direction[0]$을, dy에 $y + direction[1]$을 넣어준다.           dx와 dy가 grid 내 존재하면서 visited[dx][dy]가 false인 방문하지 않는 경우 아래를 계속 수행한다.           currTime에 $time + 1$인 현재 위치로 이동한 시간을 저장한다.           grid[dx][dy]의 값이 currTime보다 큰 경우, currTime에 이전 위치를 이동했다 돌아와서 시간을 소요하는 값인 $\\frac{grid[dx][dy] - currTime + 1}{2} \\times 2$를 더해준다.           queue에 [dx, dy, currTime]을 넣어준 후, visited[dx][dy]에 true를 넣어 방문하였음을 체크해준다.                           반복이 완료되면 마지막 위치까지 이동이 불가능하므로, -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-time-to-visit-a-cell-in-a-grid/",
        "teaser": null
      },{
        "title": "Leetcode Java Check If N and Its Double Exist",
        "excerpt":"문제  Link   코드  class Solution {    public boolean checkIfExist(int[] arr) {     Set&lt;Integer&gt; set = new HashSet&lt;&gt;();     for (int num : arr) {       if (set.contains(num * 2) || (num % 2 == 0 &amp;&amp; set.contains(num / 2))) {         return true;       } else {         set.add(num);       }     }     return false;   }  }   결과  Link   설명          arr 내 임의 값과 해당 값의 두 배가 되는 값이 존재하는지 찾는 문제이다.            set은 중복되지 않은 값을 저장하기 위한 변수로, HashSet으로 초기화한다.       arr의 값을 순차적으로 num에 넣어 아래를 수행한다.            아래의 경우 중 하나라도 만족하면 true를 주어진 문제의 결과로 반환한다.                    set에 $num \\times 2$의 값이 존재하는 경우.           num이 짝수이면서, set에 2로 나눈 값이 존재하는 경우.                       위의 경우가 아니라면, set에 num을 더해준다.           위의 반복이 완료되면 조건을 만족하는 값들이 존재하지 않으므로, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/check-if-n-and-its-double-exist/",
        "teaser": null
      },{
        "title": "Leetcode Java Check If a Word Occurs As a Prefix of Any Word in a Sentence",
        "excerpt":"문제  Link   코드  class Solution {    public int isPrefixOfWord(String sentence, String searchWord) {     String[] words = sentence.split(\" \");     for (int i = 0; i &lt; words.length; i++) {       if (words[i].startsWith(searchWord)) {         return i + 1;       }     }     return -1;   }  }   결과  Link   설명     sentence의 단어들 중 searchWord로 시작하는 단어의 위치를 1-index로 반환하는 문제이다.            단, searchWrod로 시작하는 단어가 존재하지 않으면 -1을 주어진 문제의 결과로 반환한다.                words는 sentence를 띄어쓰기(“ “) 단위로 분리하여 저장한 문자열 배열이다.       0부터 words 길이 미만까지 i를 증가시키며 아래를 반복한다.            words[i]가 searchWrod로 시작하는 경우, $i + 1$을 주어진 문제의 결과로 반환한다.           반복이 완료되면 searchWrod로 시작하는 단어가 존재하지 않으므로, -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/",
        "teaser": null
      },{
        "title": "Leetcode Java Adding Spaces to a String",
        "excerpt":"문제  Link   코드  class Solution {    public String addSpaces(String s, int[] spaces) {     StringBuilder sb = new StringBuilder();     char[] charArray = s.toCharArray();     int i = 0;     for (int space : spaces) {       while (i &lt; space) {         sb.append(charArray[i++]);       }       sb.append(' ');     }     while (i &lt; charArray.length) {       sb.append(charArray[i++]);     }     return sb.toString();   }  }   결과  Link   설명          문자열 s에서 각 spaces의 값들의 위치에 띄어쓰기(“ “)를 추가하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            sb는 동적인 문자열 생성에 필요한 변수로, StringBuilder로 초기화한다.       charArray는 문자열 s를 문자 배열로 변환한 변수이다.       i는 문자열 위치를 저장할 변수로, 0으로 초기화한다.           spaces의 각 값을 space에 순차적으로 넣어 아래를 수행한다.            i가 space 미만일 때 까지 sb에 charArray[i] 문자를 넣어준 후 i를 증가시켜준다.       반복이 완료되면 sb에 띄어쓰기(“ “)를 추가한다.                공백이 모두 추가되면 i가 charArray의 길이 미만까지 sb에 나머지 문자를 넣어준다.       모든 반복이 완료되어 완성된 sb를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/adding-spaces-to-a-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Make String a Subsequence Using Cyclic Increments",
        "excerpt":"문제  Link   코드  class Solution {    public boolean canMakeSubsequence(String str1, String str2) {     int i = 0;     int length = str2.length();     for (char c : str1.toCharArray()) {       if (i &lt; length &amp;&amp; (str2.charAt(i) - c + 26) % 26 &lt;= 1) {         i++;       }     }     return i == length;   }  }   결과  Link   설명     영소문자로 이루어진 str1의 각 문자를 아래의 규칙으로 변경하여 str2가 부분 문자열로 포함되는지 검증하는 문제이다.            str1의 임의 위치인 i번째 문자인 str1[i]를 앞뒤 문자 중 하나로 변경 가능하다.       a 다음 문자는 b, z 다음 문자는 a가 되는 a ~ z까지 문자들이 계속 반복된다.           문제 풀이에 필요한 변수를 정의한다.            i는 str2의 위치를 저장할 변수로, 0으로 초기화한다.       length는 str2의 길이를 저장한 변수이다.           st1의 각 문자들을 c에 순차적으로 넣고 아래를 수행한다.            i가 length 미만이면서 str의 i번째 문자에 c를 뺀 문자의 차잇값이 1 이하일 때, i를 증가시킨다.           i가 length와 동일한 부분 배열이 가능한지 여부를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/make-string-a-subsequence-using-cyclic-increments/",
        "teaser": null
      },{
        "title": "Leetcode Java Move Pieces to Obtain a String",
        "excerpt":"문제  Link   코드  class Solution {    public boolean canChange(String start, String target) {     char[] startCharArray = start.toCharArray();     char[] targetCharArray = target.toCharArray();     int length = targetCharArray.length;     int i = 0;     int j = 0;     while (i &lt;= length &amp;&amp; j &lt;= length) {       while (i &lt; length &amp;&amp; targetCharArray[i] == '_') {         i++;       }       while (j &lt; length &amp;&amp; startCharArray[j] == '_') {         j++;       }       if (i == length || j == length) {         return i == length &amp;&amp; j == length;       }       if (targetCharArray[i] != startCharArray[j]) {         return false;       }       if (targetCharArray[i] == 'L') {         if (j &lt; i) {           return false;         }       } else {         if (i &lt; j) {           return false;         }       }       i++;       j++;     }     return true;   }  }   결과  Link   설명     ‘L’, ‘R’, ‘_’ 문자로 이루어진 문자열 start를 target으로 변경 가능한지 검증하는 문제이다.            문자 ‘L’, ‘R’은 왼쪽과 오른쪽 방향을 뜻하며, 각 방향에 빈 공간인 ‘_’ 문자가 존재해야 해당 방향으로 이동 가능하다.           문제 풀이에 필요한 변수를 정의한다.            startCharArray와 targetCharArray는 start와 target을 문자 배열로 변환한 변수이다.       length는 target의 길이를 저장한 변수이다.       i와 j는 target과 start의 위치를 저장할 변수로, 둘 다 0으로 초기화한다.           i와 j가 length 이하일 때 까지 아래를 반복한다.            i가 length 미만이면서 targetCharArray[i] 문자가 ‘_‘인 이동 가능할 때 까지 i를 증가시켜 이동 가능한 마지막 위치로 이동시킨다.       j가 length 미만이면서 startCharArray[j] 문자가 ‘_‘인 이동 가능할 때 까지 j를 증가시켜 이동 가능한 마지막 위치로 이동시킨다.       i 혹은 j가 length에 도달하는 경우, i와 j가 마지막 위치인지 여부를 주어진 문제의 결과로 반환한다.       targetCharArray[i] 문자와 startCharArray[j] 문자가 다른 변경이 불가능한 경우, false를 주어진 문제의 결과로 반환한다.       targetCharArray[i] 문자가 ‘L’이면서 j가 i 미만인 변환이 불가능한 경우, false를 주어진 문제의 결과로 반환한다.       targetCharArray[i] 문자가 ‘R’이면서 i가 j 미만인 변환이 불가능한 경우, false를 주어진 문제의 결과로 반환한다.       i와 j를 증가시켜 다음 위치로 이동시킨다.           반복이 완료되어 변환이 가능한 경우, true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/move-pieces-to-obtain-a-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Number of Integers to Choose From a Range I",
        "excerpt":"문제  Link   코드  class Solution {    public int maxCount(int[] banned, int n, int maxSum) {     boolean[] ban = new boolean[10001];     for (int num : banned) {       ban[num] = true;     }     long sum = 0;     int count = 0;     for (int i = 1; i &lt;= n; i++) {       if (!ban[i]) {         sum += i;         if (sum &gt; maxSum) {           break;         }         count++;       }     }     return count;   }  }   결과  Link   설명          [1, n] 범위의 숫자들 중 banned 내 숫자들을 제외하고 maxSum 이하의 합계를 구하기 위한 숫자들의 최대 갯수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            ban은 banned의 값 유무를 저장하기 위한 변수로, 상한값인 $10^4$보다 1 큰 크기의 부울 배열로 초기화하여 존재하는 값의 위치를 true로 변경한다.       sum은 합계를 저장할 변수로, 0으로 초기화한다.       count는 합계를 수행한 숫자 갯수를 저장할 변수로, 0으로 초기화한다.           1부터 n 이하까지 i를 증가시키면서 아래를 반복한다.            ban[i]가 false인 금지된 숫자가 아닌 경우, 아래를 수행한다.                    sum에 i를 더한 후 sum이 maxSum보다 큰 경우, 반복을 중지한다.           count를 증가시켜 더한 값의 갯수를 증가시켜준다.                           반복이 완료되면 계산된 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-number-of-integers-to-choose-from-a-range-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Limit of Balls in a Bag",
        "excerpt":"문제  Link   코드  class Solution {    public int minimumSize(int[] nums, int maxOperations) {     int left = 1;     int right = 1_000_000_000;     while (left &lt; right) {       int mid = (left + right) / 2;       int count = 0;       for (int num : nums) {         count += (num - 1) / mid;       }       if (count &gt; maxOperations) {         left = mid + 1;       } else {         right = mid;       }     }     return left;   }  }   결과  Link   설명     nums의 각 가방에 들어있는 공들의 갯수를 이용하여 아래의 규칙을 이용하여 maxOperations 횟수 내 나눌 수 있는 가방 별 공의 최소 갯수를 계산하는 문제이다.            nums의 각 가방 내 값은 중복되지 않는 임의 두 갯수의 공으로 나누어 새 가방에 담는다.       각 수행 별 최대 갯수의 공으로 가방을 분배해야 한다.                left와 right는 공을 적정한 갯수로 나누기 위한 공의 갯수인 하한값과 상한 값을 저장한 값으로, 1과 1000000000으로 초기화한다.       left가 right미만일 때 까지 아래를 반복한다.            mid에 $\\frac{left + rigt}{2}$인 중앙값을 넣어준 후, count인 나눈 횟수를 0으로 초기화한다.       nums내 각 값을을 순차적으로 num에 넣어 count에 ${num - 1}{mid}$ 값을 더해 mid로 나눌 경우 나눌 수 있는 갯수를 계산한다.       count가 maxOperations보다 큰 가능 횟수를 초과하는 경우, left에 $mid + 1$을 넣어 범위를 축소시킨다.       위의 경우가 아니라면, rigt에 mid를 넣어 범위를 축소시킨다.           반복이 완료되면 공의 최소 갯수가 저장된 left를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-limit-of-balls-in-a-bag/",
        "teaser": null
      },{
        "title": "Leetcode Java Two Best Non-Overlapping Events",
        "excerpt":"문제  Link   코드  class Solution {    public int maxTwoEvents(int[][] events) {     Arrays.sort(events, (a, b) -&gt; a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);     Queue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;((a, b) -&gt; a[0] - b[0]);     int max = 0;     int result = 0;     for (int[] event : events) {       int start = event[0];       while (!queue.isEmpty() &amp;&amp; queue.peek()[0] &lt; start) {         max = Math.max(max, queue.remove()[1]);       }       result = Math.max(result, event[2] + max);       queue.add(new int[] { event[1], event[2] });     }     return result;   }  }   결과  Link   설명     아래의 구성으로 된 events를 이용하여 중첩되지 않은 event로 구성된 value 값의 합이 최대인 조합을 찾는 문제이다.            events[i] = [starti, endi, valuei]로 구성되어있다.                events를 시작 시간과 종료 시간에 대한 순차적인 오름차순으로 정렬해준다.       문제 풀이에 필요한 변수를 정의한다.            queue는 시작 시간 별 정렬된 값들을 저장할 변수로, PriorityQueue로 초기화한다.       max는 중첩된 events 중 가장 큰 value를 저장할 변수로, 0으로 초기화한다.       result는 value 합이 최대인 결과를 저장하기 위한 변수로, 0으로 초기화한다.           events를 순차적으로 event에 넣어 아래를 수행한다.            start에 event[0]의 값을 넣어준다.       queue가 비어있지 않거나 queue의 첫 값의 종료 시간이 start 이하인 경우, max에 max와 queue의 값을 꺼낸 후 해당 value 중 큰 값을 넣어준다.       result에 이전까지 최대 값인 result와 $event[2] + max$인 두 event의 value 합 중 큰 값을 넣어준다.       queue에 종료시간과 value인 [event[1], event[2]]의 값을 배열로 넣어준다.           반복이 완료되면 value 값의 합이 최대가 되는 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/two-best-non-overlapping-events/",
        "teaser": null
      },{
        "title": "Leetcode Java Special Array II",
        "excerpt":"문제  Link   코드  class Solution {    public boolean[] isArraySpecial(int[] nums, int[][] queries) {     boolean[] result = new boolean[queries.length];     int[] counts = new int[nums.length];     for (int i = 1; i &lt; nums.length; i++) {       counts[i] = counts[i - 1];       if (nums[i - 1] % 2 == nums[i] % 2) {         counts[i]++;       }     }     for (int i = 0; i &lt; queries.length; i++) {       int[] query = queries[i];       result[i] = counts[query[1]] - counts[query[0]] == 0;     }     return result;   }  }   결과  Link   설명          nums내 queries의 각 구간 별 숫자들이 홀수와 짝수가 번갈아 나오는지 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 결과를 저장할 변수로, queries 길이의 boolean 배열로 초기화한다.       counts는 nums 내 연속된 짝수 갯수를 저장할 변수로, nums 길이의 정수 배열로 초기화한다.           1부터 nums 길이 미만까지 i를 증가시키며 아래를 반복한다.            counts[i]에 이전까지 갯수인 counts[$i - 1$]의 값을 넣어준다.       nums[$i - 1$]과 nums[i]가 짝수인 경우, count[i]를 증가시켜준다.           0부터 queries의 길이 미만까지 i를 증가시키면서 아래를 반복한다.            query에 queries[i]의 값을 넣어준다.       result[i]의 위치에 $counts[query[1]] - counts[query[0]]$의 값이 0인 연속으로 짝수가 존재하는 구간이 유지되는지 여부를 넣어준다.           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/special-array-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Longest Special Substring That Occurs Thrice I",
        "excerpt":"문제  Link   코드  class Solution {    public int maximumLength(String s) {     int length = s.length();     int start = 1;     int end = length;     if (!this.isLeastThriceOccurs(s, length, start)) {       return -1;     }     while (start + 1 &lt; end) {       int mid = (start + end) / 2;       if (this.isLeastThriceOccurs(s, length, mid)) {         start = mid;       } else {         end = mid;       }     }     return start;   }    private boolean isLeastThriceOccurs(String s, int length, int num) {     int[] counts = new int[26];     int start = 0;     for (int i = 0; i &lt; length; i++) {       while (s.charAt(start) != s.charAt(i)) {         start++;       }       int index = s.charAt(i) - 'a';       if (i - start + 1 &gt;= num) {         counts[index]++;       }       if (counts[index] &gt; 2) {         return true;       }     }     return false;   }  }   결과  Link   설명          문자열 s에서 동일 문자로 이루어진 부분 문자열이 해당 문자열에서 최소 세 번 반복되기 위한 최대 길이를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 문자열 s의 길이를 저장한 변수이다.       start와 end는 문자열 탐색에 필요한 변수로, 1과 length로 초기화한다.           최소 세 번 이상 문자열에 존재하는지 검증하는 메서드인 isLeastThriceOccurs(String s, int length, int num)를 정의한다.            검증에 필요한 변수를 정의한다.                    counts는 영문자 갯수를 저장할 변수로, 26 크기의 정수 배열로 초기화한다.           start는 탐색 시작에 필요한 변수로, 0으로 초기화한다.                       0부터 length 미만까지 i를 증가시키면서 아래를 반복한다.                    s의 start번째 문자와 i번째 문자가 다른 경우, start를 증가시키며 동일한 문자 위치까지 이동시킨다.           index에 s의 i번째 영문자의 0-index 순서를 넣어준다.           $i - start + 1$이 num 이상인 부분 문자열에 해당하는 경우, counts[index]를 증가시켜준다.           counts[index]가 2 초과인 조건을 만족하는 경우, true를 반환한다.                       반복이 완료되면 조건을 만족하지 않으므로, false를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-longest-special-substring-that-occurs-thrice-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Beauty of an Array After Applying Operation",
        "excerpt":"문제  Link   코드  class Solution {    public int maximumBeauty(int[] nums, int k) {     Arrays.sort(nums);     int start = 0;     int end = 0;     while (end &lt; nums.length) {       if (nums[end++] - nums[start] &gt; k * 2) {         start++;       }     }     return end - start;   }  }   결과  Link   설명     nums로 아래 규칙을 이용하여 만들어진 배열 내 제거 혹은 그대로 유지했을 때 동일한 값들로 구성된 부분 배열의 가장 긴 길이를 구하는 문제이다.            임의 i번째 값인 nums[i]를 [$nums[i] - k$, $nums[i] + k$] 범위 내 값으로 한 번 변경이 가능하다.                nums의 값들을 오름차순 정렬해준다.            start와 end는 nums 내 시작과 종료 위치를 저장할 변수로, 둘 다 0으로 초기화한다.       end가 nums의 길이 미만일 때 까지 아래를 반복한다.            nums[end] - nums[start]의 값이 $k \\times 2$보다 큰 변환 가능한 범위 밖인 경우, start를 증가시켜 범위를 좁혀준다.           반복이 완료되면 $end - start$인 가장 긴 길이를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-beauty-of-an-array-after-applying-operation/",
        "teaser": null
      },{
        "title": "Leetcode Java Take Gifts From the Richest Pile",
        "excerpt":"문제  Link   코드  class Solution {    public long pickGifts(int[] gifts, int k) {     Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);     for (int gift : gifts) {       queue.add(gift);     }     while (k-- &gt; 0) {       queue.add((int) Math.sqrt(queue.poll()));     }     long result = 0;     while (!queue.isEmpty()) {       result += queue.poll();     }     return result;   }  }   결과  Link   설명          gifts 내에서 k번 수행마다 가장 큰 값을 제곱근된 값으로 치환 후 남은 선물 갯수의 합을 반환하는 문제이다.            queue는 gifts 내 값을 내림차순으로 저장하기 위한 변수로, PriorityQueue로 초기화하고 gifts의 모든 값을 넣어준다.       k가 0 초과일 때 까지 아래를 반복하며 k를 감소시킨다.            queue에 가장 큰 값인 앞의 값을 꺼내 제곱근 계산 후 다시 넣어준다.           result에 queue의 모든 값을 더한 후 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/take-gifts-from-the-richest-pile/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Score of an Array After Marking All Elements",
        "excerpt":"문제  Link   코드  class Solution {    public long findScore(int[] nums) {     int length = nums.length;     Integer[] dp = new Integer[length];     for (int i = 0; i &lt; length; i++) {       dp[i] = i;     }     Arrays.sort(dp, (a, b) -&gt; nums[a] - nums[b]);     long result = 0;     boolean[] marked = new boolean[length + 2];     for (int i : dp) {       if (!marked[i + 1]) {         marked[i] = marked[i + 2] = true;         result += nums[i];       }     }     return result;   }  }   결과  Link   설명     nums에서 아래 순서대로 반복할 때 선택된 값들의 합을 구하는 문제이다.            가장 작은 값 하나를 선택하고 마크한다.       해당 값 좌우 값 중 존재하는 값들을 마크한다.       마크되지 않은 값들 중 가장 작은 값을 선택하여 마크하고 바로 위 순서를 모든 값들이 마크될 때 까지 반복한다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       dp는 각 순서에 대한 값을 저장할 배열로, 정수 배열로 초기화하여 각 위치별 0-index 값을 넣은 후 nums의 크기 순 오름차순으로 정렬해준다.       result는 합계를 저장할 변수로, 0으로 초기화한다.       marked는 마크된 값을 저장할 변수로, $length + 2$ 크기로 초기화한다.           dp의 값들을 순차적으로 i에 넣어 아래를 수행한다.            marked[i + 1]의 값이 false인 마크되지 않은 값인 경우, 아래를 수행한다.                    marked의 i번째 값과 $i + 2$번째 값인 좌우 값을 true를 넣어 마크한다.           result에 nums[i]인 선택된 값을 더해준다.                           반복이 완료되면 합계가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-score-of-an-array-after-marking-all-elements/",
        "teaser": null
      },{
        "title": "Leetcode Java Continuous Subarrays",
        "excerpt":"문제  Link   코드  class Solution {    public long continuousSubarrays(int[] nums) {     long result = 0;     Deque&lt;Integer&gt; ascending = new LinkedList&lt;&gt;();     Deque&lt;Integer&gt; descending = new LinkedList&lt;&gt;();     for (int i = 0, j = -1; i &lt; nums.length; i++) {       while (!ascending.isEmpty() &amp;&amp; ascending.peekLast() &gt; nums[i]) {         ascending.pollLast();       }       ascending.add(nums[i]);       while (!descending.isEmpty() &amp;&amp; descending.peekLast() &lt; nums[i]) {         descending.pollLast();       }       descending.add(nums[i]);       while (descending.peekFirst() - ascending.peekFirst() &gt; 2) {         j++;         if (ascending.peekFirst() == nums[j]) {           ascending.pollFirst();         }         if (descending.peekFirst() == nums[j]) {           descending.pollFirst();         }       }       result += i - j;     }     return result;   }  }   결과  Link   설명     nums에서 아래 조건을 만족하는 연속된 부분 배열의 갯수를 계산하는 문제이다.                                                            i &lt;= i1, i2 &lt;= j일 때, $0 &lt;=               nums[i1] - nums[i2]               &lt;= 2$를 만족한다.                                               자기 자신은 부분 배열에 속하지 않는다.           문제 풀이에 필요한 변수를 정의한다.            result는 부분 배열의 갯수를 계산할 변수로, 0으로 초기화한다.       ascending과 descending은 오름차순, 내림차순으로 값들을 저장하기 위한 변수로, LinkedList로 초기화한다.           0부터 nums의 길이 미만까지 i를 증가시키고, j는 -1로 초기화 하여 아래를 반복한다.            ascending이 비어있지 않고 ascending의 마지막 값이 nums[i]보다 큰 경우, ascending에서 마지막 값을 꺼내준 후 마지막으로 nums[i]를 넣어준다.       descending이 비어있지 않고 descending의 마지막 값이 nums[i]보다 큰 경우, descending에서 마지막 값을 꺼내준 후 마지막으로 nums[i]를 넣어준다.       descending의 첫 값과 ascending의 첫 값의 차이가 2보다 큰 조건이 만족하지 않는 경우까지 아래를 반복한다.                    j를 증가시켜 위치를 이동한다.           ascending의 첫 값이 nums[j]의 값과 동일하면 해당 값을 제거한다.           descending의 첫 값이 nums[j]의 값과 동일하면 해당 값을 제거한다.                       result에 [i, j] 범위 내 부분 배열의 갯수인 $i - j$를 더해준다.           반복이 완료되면 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/continuous-subarrays/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Average Pass Ratio",
        "excerpt":"문제  Link   코드  class Solution {    public double maxAverageRatio(int[][] classes, int extraStudents) {     Queue&lt;double[]&gt; queue = new PriorityQueue&lt;&gt;(Comparator.comparingDouble(c -&gt; -c[2]));     for (int[] c : classes) {       double a = c[0];       double b = c[1];       queue.offer(new double[] { a, b, this.getRatio(a, b) });     }     while (extraStudents-- &gt; 0) {       double[] curr = queue.poll();       double a = curr[0];       double b = curr[1];       queue.offer(new double[] { a + 1, b + 1, this.getRatio(a + 1, b + 1) });     }     double result = 0.0d;     while (!queue.isEmpty()) {       double[] curr = queue.poll();       result += curr[0] / curr[1];     }     return result / classes.length;   }    private double getRatio(double a, double b) {     return ((a + 1) / (b + 1)) - (a / b);   }  }   결과  Link   설명     아래의 규칙으로 구성된 classes로 extraStudents를 추가 배정하여 가능한 최대 평균 합격률을 구하는 문제이다.            classes[i] = [passi, totali]로, total인원 중 pass만큼의 인원만 합격 가능하다.       학급의 합격률은 시험에 합격할 학생 수를 총 학생 수로 나눈 값이다.       평균 합격률은 모든 학급의 합격률을 학급의 수로 나눈 값이다.           합격할 학생의 수인 a와 총 학생의 수인 b를 이용하여 한 학생이 추가되는 경우, 추가될 합격률을 구하기 위한 getRatio(double a, double b)를 정의한다.            $\\frac{a + 1}{b + 1}$에 $\\frac{a}{b}$를 뺀 값을 반환한다.                queue는 합격률을 기준으로 정렬하여 저장할 변수로, PriorityQueue로 초기화 후 classes[i][0], classes[i][1], 2번에서 정의한 getRatio(double a, double b)메서드에 앞의 두 값을 수행한 결과 세 값을 배열로 넣어준다.       extraStudents가 0 초과일 때 까지 아래를 수행 후 extraStudents를 감소시켜준다.            curr에 queue의 맨 앞값을 꺼내준다.       queue에 $a + 1$, $b + 1$, 2번에서 정의한 getRatio(double a, double b)메서드에 앞의 두 값을 수행한 결과 세 값을 배열로 넣어준다.                결과를 넣을 result를 정의하고, queue를 반복하여 합격할 학생의 수인 첫 번째 값에 총 학생의 수인 두 번째 값을 나눈 결과를 더해준다.       앞에서 더한 결과를 classes의 길이인 학급의 수로 나눈 평균 합격률을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-average-pass-ratio/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Arithmetic Subsequence of Given Difference",
        "excerpt":"문제  Link   코드  class Solution {    public int longestSubsequence(int[] arr, int difference) {     int[] map = new int[40001];     int result = 1;     for (int num : arr) {       int index = 20000 + num;       map[index] = map[index - difference] + 1;       result = Math.max(result, map[index]);     }     return result;   }  }   결과  Link   설명     arr의 값들을 이용하여 부분 배열의 각 값의 차이가 difference씩인 최대 부분 배열의 길이를 구하는 문제이다.            부분 배열은 임의 요소들을 제거하여 구성할 수 있다.           문제 풀이에 필요한 변수를 정의한다.            map은 arr의 순차적인 값의 차이가 difference인 위치의 값을 저장할 변수로, 값의 최대 갯수인 $2 * 10^4$에서 difference 또한 동일 범위 내 값이 가능하므로 다시 두 배를 한 크기보다 1 큰 $4 * 10^4 + 1$ 크기의 정수 배열로 초기화한다.       result는 부분 배열의 갯수를 저장할 변수로, 최소 갯수인 1로 초기화한다.           arr의 값들을 순차적으로 num에 넣어 아래를 수행한다.            index은 위치 값을 저장할 변수로, map의 중앙 값인 20000에 num을 더한 값을 넣어준다.       map[index]에 이전 difference 위치의 값인 map[$index - difference$] 값에 1을 더해 넣어준다.       result에 이전까지 최대 길이인 result와 현재까지 최대 길이인 map[index] 중 큰 값을 넣어준다.           반복이 완료되면 부분 배열의 길이가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-arithmetic-subsequence-of-given-difference/",
        "teaser": null
      },{
        "title": "Leetcode Java Reverse Odd Levels of Binary Tree",
        "excerpt":"문제  Link   코드  class Solution {    public TreeNode reverseOddLevels(TreeNode root) {     this.dfs(root.left, root.right, 1);     return root;   }    private void dfs(TreeNode node1, TreeNode node2, int level) {     if (node1 != null &amp;&amp; node2 != null) {       if (level % 2 == 1) {         int temp = node1.val;         node1.val = node2.val;         node2.val = temp;       }       this.dfs(node1.left, node2.right, level + 1);       this.dfs(node1.right, node2.left, level + 1);     }   }  }   결과  Link   설명          이진 트리 노드인 root의 짝수번째 레벨에 해당하는 자식 노드들의 값을 바꾸는 문제이다.            3번에서 정의한 dfs(TreeNode node1, TreeNode node2, int level)를 root의 left와 right 노드와 1을 순서대로 넣어 수행 후, 완성된 root를 주어진 문제의 결과로 반환한다.            DFS 방식으로 이진 트리 노드를 재 구성할 dfs(TreeNode node1, TreeNode node2, int level) 메서드를 정의한다.             node1과 node2가 null이 아닌 경우만 아래를 수행한다.                    level이 홀수이면 현재 node1과 node2는 짝수 레벨이므로, 두 노드의 val 값을 바꿔준다.           node1의 left 노드와 node2의 right 노드, level을 1 증가시킨 후 재귀 호출을 수행한다.           node1의 right 노드와 node2의 left 노드, level을 1 증가시킨 후 재귀 호출을 수행한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reverse-odd-levels-of-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Vowels Permutation",
        "excerpt":"문제  Link   코드  class Solution {    private static final int MOD = 1000000007;    public int countVowelPermutation(int n) {     long a = 1;     long e = 1;     long i = 1;     long o = 1;     long u = 1;     for (int j = 1; j &lt; n; j++) {       long nextA = e;       long nextE = (a + i) % MOD;       long nextI = (a + e + o + u) % MOD;       long nextO = (i + u) % MOD;       long nextU = a;       a = nextA;       e = nextE;       i = nextI;       o = nextO;       u = nextU;     }     return (int) ((a + e + i + o + u) % MOD);   }  }   결과  Link   설명     n 길이로 아래 규칙을 만족하게 만들 수 있는 문자열 갯수를 구하는 문제이다.            단, 값이 매울 클 수 있으므로 모듈러 $10^9 + 7$을 적용한다.       문자열은 소문자 ‘a’, ‘e’, ‘i’, ‘o’, ‘u’으로 구성된다.       ‘a’ 문자 뒤에는 ‘e’ 문자만 이어 붙일 수 있다.       ‘e’ 문자 뒤에는 ‘a’ 문자 또는 ‘i’ 문자만 이어 붙일 수 있다.       ‘i’ 문자 뒤에는 ‘i’ 문자를 이어 붙일 수 없다.       ‘o’ 문자 뒤에는 ‘i’ 문자 또는 ‘u’ 문자만 이어 붙일 수 있다.       ‘u’ 문자 뒤에는 ‘a’ 문자만 이어 붙일 수 있다.                MOD는 모듈러 $10^9 + 7$ 값을 저장한다.            a, e, i, o, u는 각 문자의 갯수를 계산하기 위한 변수로, 값이 int보다 클 수 있으므로 long 타입으로 정의 후 1로 초기화한다.       1부터 n 미만까지 j를 증가시키며 아래를 반복한다.            nextA는 a로 시작하는 문자 갯수를 계산할 변수로, 다음에 올 수 있는 문자인 e의 갯수를 넣어준다.       nextE는 e로 시작하는 문자 갯수를 계산할 변수로, 다음에 올 수 있는 문자인 a와 i의 갯수를 더해 MOD로 나눈 값을 넣어준다.       nextI는 i로 시작하는 문자 갯수를 계산할 변수로, 다음에 올 수 없는 문자인 i를 제외한 모든 값을 더해 MOD로 나눈 값을 넣어준다.       nextO는 o로 시작하는 문자 갯수를 계산할 변수로, 다음에 올 수 있는 문자인 i와 u의 갯수를 더해 MOD로 나눈 값을 넣어준다.       nextU는 u로 시작하는 문자 갯수를 계산할 변수로, 다음에 올 수 있는 문자인 a의 갯수를 넣어준다.       a, e, i, o, u에 현재까지 가능한 다음 문자 길이인 nextA, nextE, nextI, nextO, nextU를 넣어준다.           반복이 완료되면 a, e, i, o, u를 더한 값을 MOD로 나눈 후 int형으로 바꿔 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-vowels-permutation/",
        "teaser": null
      },{
        "title": "Leetcode Java Split a String in Balanced Strings",
        "excerpt":"문제  Link   코드  class Solution {    public int balancedStringSplit(String s) {     int result = 0;     int count = 0;     for (char c : s.toCharArray()) {       if (c == 'L') {         count++;       } else {         count--;       }       if (count == 0) {         result++;       }     }     return result;   }  }   결과  Link   설명          ‘L’과 ‘R’ 문자로 이루어진 문자열 s를 각 문자의 갯수가 동일하게 부분 문자열로 분리할 수 있는 최대 갯수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 부분 문자열의 최대 갯수를 저장할 변수로, 0으로 초기화한다.       count는 ‘L’ 문자와 ‘R’ 문자 갯수 차이를 저장할 변수로, 0으로 초기화한다.           s의 문자를 순차적으로 c에 넣어 아래를 수행한다.            c가 ‘L’인 경우 count를 증가시키고, ‘R’인 경우 count를 감소시킨다.       count가 0인 문자 갯수가 동일한 위치인 경우, result를 증가시켜준다.           반복이 완료되면 부분 문자열의 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/split-a-string-in-balanced-strings/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Ways to Form a Target String Given a Dictionary",
        "excerpt":"문제  Link   코드  class Solution {    private static final int MOD = 1000000007;    public int numWays(String[] words, String target) {     int length = target.length();     long[] dp = new long[length + 1];     dp[0] = 1;     for (int i = 0; i &lt; words[0].length(); i++) {       int[] count = new int[26];       for (String word : words) {         count[word.charAt(i) - 'a']++;       }       for (int j = length - 1; j &gt;= 0; j--) {         dp[j + 1] += (dp[j] * count[target.charAt(j) - 'a']) % MOD;       }     }     return (int) (dp[length] % MOD);   }  }   결과  Link   설명     words를 이용하여 target 문자열을 구성할 수 있는 방법의 수를 계산하는 문제이다.            단, 방법의 수가 매우 클 수 있으므로, 모듈러 $10^9 + 7$을 적용한다.           문제 풀이에 필요한 변수를 정의한다.            length는 target 문자열의 길이를 저장한 변수이다.       dp는 방법의 수를 계산하기 위한 변수로, $length + 1$ 크기의 long 배열로 초기화하여 첫 값에 1을 넣어준다.           0부터 words[0]의 길이 미만까지 i를 증가시키며 아래를 반복한다.            count는 각 문자 갯수를 계산할 변수로, words 내 문자열들의 문자 갯수를 계산하여 넣어준다.       $length - 1$부터  0 이상까지 j를 감소시키며, dp[$j + 1$]에 아래 두 값을 곱한 값을 MOD로 나눈 나머지 값을 더해준다.                    dp[j]인 이전 위치까지 구성하기위한 방법의 수.           target의 j번째 문자에 해당하는 count 값인 현재 문자를 넣을 방법의 수.                           반복이 완료되어 계산된 방법을 다시 MOD로 나눈 나머지 값을 int형으로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-ways-to-form-a-target-string-given-a-dictionary/",
        "teaser": null
      },{
        "title": "Leetcode Java Queens That Can Attack the King",
        "excerpt":"문제  Link   코드  class Solution {    private static final int[][] DIRECTIONS = {     { -1, -1 },     { 0, -1 },     { 1, -1 },     { 1, 0 },     { 1, 1 },     { 0, 1 },     { -1, 1 },     { -1, 0 }   };    public List&lt;List&lt;Integer&gt;&gt; queensAttacktheKing(int[][] queens, int[] king) {     boolean[][] visited = new boolean[8][8];     for (int[] queen : queens) {       visited[queen[0]][queen[1]] = true;     }     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     for (int[] direction : DIRECTIONS) {       for (int x = king[0] + direction[0], y = king[1] + direction[1];           0 &lt;= x &amp;&amp; x &lt; 8 &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; 8; x += direction[0], y += direction[1]) {         if (visited[x][y]) {           result.add(Arrays.asList(x, y));           break;         }       }     }     return result;   }  }   결과  Link   설명          $8 \\times 8$ 크기의 체스판에서 queens 위치의 여왕들과 king 위치의 왕이 존재할 때, 왕을 직접 공격할 수 있는 여왕의 좌표를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            DIRECTIONS은 여왕이 움직일 수 있는 8방면 좌표를 저장한 전역 변수로, 현재 위치에서 각 방면으로 이동하기 위한 x와 y축 이동 값을 저장한다.       visited는 여왕과 만날 수 있는 위치를 저장할 변수로, $8 \\times 8$ 크기의 정수 배열로 초기화하여 queens의 각 위치에 true를 넣어 표시해준다.       result는 만날 수 있는 여왕 위치를 저장할 변수로, ArrayList로 초기화한다.           DIRECTIONS의 각 값을 direction에 순차적으로 넣어 아래를 수행한다.            x는 $king[0] + direction[0]$, y는 $king[1] + direction[1]$로 초기화하여 체스 판 위에서 움직일 수 있을 때 까지 x에 direction[0]을, y에 direction[1]을 더하면서 아래를 반복한다.                    visited[x][y]의 값이 true인 여왕과 만나는 경우, result에 해당 위치를 넣고 다음 위치의 여왕들은 해당 위치의 여왕에 막혀 공격이 불가능하므로 현재 반복을 중지한다.                           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/queens-that-can-attack-the-king/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Ways to Split Array",
        "excerpt":"문제  Link   코드  class Solution {    public int waysToSplitArray(int[] nums) {     int length = nums.length;     long left = 0;     long right = 0;     for (int num : nums) {       right += num;     }     int result = 0;     for (int i = 0; i &lt; length - 1; i++) {       left += nums[i];       right -= nums[i];       if (left &gt;= right) {         result++;       }     }     return result;   }  }   결과  Link   설명          nums 내 값들을 특정 위치를 기준으로 두 부분 집합으로 분리할 때, 좌측 부분 집합의 합이 우측 부분 집합의 합보다 크거나 같게 분리할 수 있는 방법의 갯수를 계산하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       left와 right는 좌측과 우측 부분 집합의 합을 저장할 변수로, 0과 num의 합계를 순차적으로 넣어준다.       result는 분리할 수 있는 방법의 갯수를 저장할 변수로, 0으로 초기화한다.           0부터 $length - 1$ 미만까지 i를 증가시키며 아래를 반복한다.            left에 nums[i] 값을 더해주고, right에 nums[i] 값을 빼준다.       left가 right 이상인 분리 가능한 경우, result를 증가시켜준다.           반복이 완료되어 계산된 방법의 갯수인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-ways-to-split-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Shifting Letters II",
        "excerpt":"문제  Link   코드  class Solution {    public String shiftingLetters(String s, int[][] shifts) {     int length = s.length();     int[] dp = new int[length + 1];     for (int[] shift : shifts) {       int end = shift[1] + 1;       int weight = shift[2] == 1 ? 1 : -1;       dp[shift[0]] += weight;       if (end &lt; length) {         dp[end] -= weight;       }     }     int curr = 0;     for (int i = 0; i &lt; length; i++) {       curr += dp[i];       dp[i] = curr;     }     StringBuilder sb = new StringBuilder(s);     for (int i = 0; i &lt; length; i++) {       sb.setCharAt(i, (char) ('a' + (s.charAt(i) - 'a' + (((dp[i] % 26) + 26) % 26)) % 26));     }     return sb.toString();   }  }   결과  Link   설명     s의 각 문자들을 아래의 조건을 만족하는 shifts를 수행한 결과를 반환하는 문제이다.            shifts[i] = [starti, endi, directioni]를 만족하며, starti번째 문자부터 endi번째 문자까지 directioni의 값에 따라 영문자를 변환하는 문제이다.       directioni가 1인 경우, [start, end] 범위의 각 문자들을 다음 문자들로 바꿔주고 ‘z’는 ‘a’로 변경한다.       directioni가 0인 경우, [start, end] 범위의 각 문자들을 이전 문자들로 바꿔주고 ‘a’는 ‘z’로 변경한다.           문제 풀이에 필요한 변수를 정의한다.            length는 s의 길이를 저장한 변수이다.       dp는 각 문자 위치 별 가감해야 하는 값들을 산정하기 위한 변수로, shifts의 값을 순차적으로 반복하여 dp의 [start, end] 범위 값들에 direction에 따라 1이면 1을 더하고 0은 1을 빼준다.                    먼저 start와 end에 가중치만 넣은 이후, 다시 반복을 수행하면서 가중치를 가감하면서 dp에 넣어준다.                       sb는 결과 문자열을 넣기 위한 변수로, s를 넣어 초기화한다.                0부터 length까지 i를 증가시키며, 각 i번째 위치 문자를 dp[i]번 값에 따라 차감하여 변환된 문자로 변환하여 넣어준다.       반복이 완료되어 변환된 sb를 문자열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/shifting-letters-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Number of Operations to Move All Balls to Each Box",
        "excerpt":"문제  Link   코드  class Solution {    public int[] minOperations(String boxes) {     char[] charArray = boxes.toCharArray();     int length = charArray.length;     int[] result = new int[length];     for (int i = 0, move = 0, count = 0; i &lt; length; i++, move += count) {       result[i] += move;       if (charArray[i] == '1') {         count++;       }     }     for (int i = length - 1, move = 0, count = 0; i &gt;= 0; i--, move += count) {       result[i] += move;       if (charArray[i] == '1') {         count++;       }     }     return result;   }  }   결과  Link   설명     각 위치에 존재하는 박스에 공이 존재하는지 여부가 담긴 boxes를 이용하여 해당 위치로 모든 공을 모으기위한 최소 이동 횟수를 구하는 문제이다.            boxes[i]의 값 중 ‘1’은 공이 존재, ‘0’은 빈 박스를 의미한다.       공은 비어있는 박스로만 이동이 가능하다.           문제 풀이에 필요한 변수를 정의한다.            charArray는 boxes를 문자 배열로 변환한 변수이다.       length는 charArray의 길이를 저장한 변수이다.       result는 각 위치 별 최소 이동 횟수를 저장하기 위한 변수로, boxes와 동일한 length 길이로 초기화한다.           i는 0부터 length 미만까지, 이동 횟수인 move와 공의 갯수인 count는 0으로 초기화하여 각 수행 별 i를 증가시키고 move에 count를 더해가며 아래를 반복한다.            result[i]에 이동 횟수인 move를 더해준 후, charArray[i]인 i번째 문자가 1인 공이 존재하면 count인 공의 갯수를 증가시켜준다.           i는 $length - 1$부터 0 이상까지, 이동 횟수인 move와 공의 갯수인 count는 0으로 초기화하여 각 수행 별 i를 감소시키고 move에 count를 더해가며 아래를 반복한다.            result[i]에 이동 횟수인 move를 더해준 후, charArray[i]인 i번째 문자가 1인 공이 존재하면 count인 공의 갯수를 증가시켜준다.           반복이 완료되면 좌측부터 우측으로, 우측부터 좌측으로 공의 이동 갯수를 계산한 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-number-of-operations-to-move-all-balls-to-each-box/",
        "teaser": null
      },{
        "title": "Leetcode Java String Matching in an Array",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; stringMatching(String[] words) {     String str = String.join(\" \", words);     List&lt;String&gt; result = new ArrayList&lt;&gt;();     for (String word : words) {       if (str.indexOf(word) != str.lastIndexOf(word)) {         result.add(word);       }     }     return result;   }  }   결과  Link   설명          words 내 임의 문장이 다른 문장의 부분 문자열인 경우를 중복되지 않게 모아 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            str은 words를 띄어쓰기 단위로 붙여 만든 변수이다.       result는 결과를 넣을 변수이다.           words의 각 문자열을 순차적으로 word에 넣어 아래를 수행한다.            str에 word의 처음 시작 위치와 마지막 위치가 다른 부분 문자열이 존재하는 경우, result애 word를 넣어준다.           반복이 완료되어 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/string-matching-in-an-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Prefix and Suffix Pairs I",
        "excerpt":"문제  Link   코드  class Solution {    public int countPrefixSuffixPairs(String[] words) {     int length = words.length;     int result = 0;     for (int i = 0; i &lt; length - 1; i++) {       for (int j = i + 1; j &lt; length; j++) {         if (words[j].startsWith(words[i]) &amp;&amp; words[j].endsWith(words[i])) {           result++;         }       }     }     return result;   }  }   결과  Link   설명          words 내 한 문자가 다른 문자의 접두사이면서 접미사인 조합의 갯수를 계산하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 words의 길이를 저장한 변수이다.       result는 조합의 갯수를 저장할 변수로, 0으로 초기화한다.           0부터 length - 1 미만까지 i를 증가시키면서, $i + 1$부터 length 미만까지 j를 증가시키면서 아래를 반복한다.            words[j]의 접두사와 접미사가 words[i]인 경우에 result를 증가시켜준다.           반복을 통해 계산된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-prefix-and-suffix-pairs-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Counting Words With a Given Prefix",
        "excerpt":"문제  Link   코드  class Solution {    public int prefixCount(String[] words, String pref) {     int result = 0;     for (String word : words) {       if (word.indexOf(pref) == 0) {         result++;       }     }     return result;   }  }   결과  Link   설명          words 중 pref로 시작하는 문자열의 갯수를 계산하는 문제이다.            result는 문자열의 갯수를 계산하기 위한 변수로, words의 각 문자열 중 pref가 시작 문자열 위치인 0을 만족하는 문자열의 갯수를 넣어준다.            반복이 완료되면 조건을 만족하는 문자열의 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/counting-words-with-a-given-prefix/",
        "teaser": null
      },{
        "title": "Leetcode Java Construct K Palindrome Strings",
        "excerpt":"문제  Link   코드  class Solution {    public boolean canConstruct(String s, int k) {     if (s.length() &gt; k) {       int odd = 0;       for (char c : s.toCharArray()) {         odd ^= 1 &lt;&lt; (c - 'a');       }       return Integer.bitCount(odd) &lt;= k;     } else {       return s.length() == k;     }   }  }   결과  Link   설명          문자열 s를 k개의 회문 문자열로 분리 가능한지 여부를 검증하는 문제이다.       s의 길이가 k 초과인 경우, 아래를 수행한다.            odd는 홀수 갯수를 저장할 변수로, s의 문자들을 순서대로 c에 넣고 odd에 각 문자의 영문자 순서만큼 1을 좌측으로 이동신 값을 자기 자신의 값과 XOR(‘^’) 비트연산을 수행한 결과로 넣어준다.       계산된 odd의 1 비트 갯수가 k 이하인 홀수번 존재하는 문자의 갯수가 k 이하인지 여부를 주어진 문제의 결과로 반환한다.                    k개 이하의 회문을 만들어야 하므로, 홀수번 반복되는 문자는 k개까지 문자열의 중앙에 넣을 수 있다.                           s의 길이가 k와 동일한 문자 하나 씩 분리가 가능한 경우만 true, k 초과인 분리해도 만들 수 없는 경우 false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/construct-k-palindrome-strings/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Length of String After Operations",
        "excerpt":"문제  Link   코드  class Solution {    public int minimumLength(String s) {     int[] counts = new int[26];     for (char c : s.toCharArray()) {       counts[c - 'a']++;     }     int result = 0;     for (int count : counts) {       if (count &gt; 0) {         if (count % 2 == 0) {           result += 2;         } else {           result++;         }       }     }     return result;   }  }   결과  Link   설명     아래의 규칙대로 수행하고 마지막 남은 문자열의 최소 길이를 반환하는 문제이다.            좌우에 동일한 문자가 존재하는 임의 문자를 선택하여 앞의 좌우 두 문자를 제거한다.           문제 풀이에 필요한 변수를 정의한다.            counts는 문자열 s의 각 문자 갯수를 계산해서 저장할 변수로, 영문자 갯수인 26 크기의 정수 배열로 초기화하고 s의 각 문자 갯수를 계산해준다.       result는 남은 문자열의 길이를 계산할 변수로, 0으로 초기화한다.           counts의 값들을 순차적으로 count에 넣어 아래를 수행한다.            count가 0 초과인 s에 존재하는 문자인 경우, 아래를 수행한다.                    count가 짝수이면 좌우에 값이 존재하므로 result를 2증가시키고, 홀수이면 result를 1증가시킨다.                           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-length-of-string-after-operations/",
        "teaser": null
      },{
        "title": "Leetcode Java Find the Prefix Common Array of Two Arrays",
        "excerpt":"문제  Link   코드  class Solution {    public int[] findThePrefixCommonArray(int[] A, int[] B) {     int length = A.length;     int[] counts = new int[length + 1];     int[] result = new int[length];     int common = 0;     for (int i = 0; i &lt; length; i++) {       if (++counts[A[i]] == 2) {         common++;       }       if (++counts[B[i]] == 2) {         common++;       }       result[i] = common;     }     return result;   }  }   결과  Link   설명          n개의 정수로 이루어진 [1, n] 범위의 정수가 한 번씩 들어있는 A와 B의 위치 별 이전 값까지의 공통 값이 발생한 갯수를 배열로 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 A의 길이를 저장한 변수이다.       counts는 각 숫자의 갯수를 계산해서 넣을 배열로, $length + 1$ 크기의 정수 배열로 초기화한다.       result는 공통 값이 발생한 갯수를 저장할 배열로, length 크기의 정수 배열로 초기화한다.       common은 공통 발생한 값을 계산하기 위한 변수로, 0으로 초기화한다.           0부터 length 미만까지 i를 증가시키며 아래를 반복한다.            counts의 A[i]번째 값과 B[i]번째 값을 증가시키고, 각 위치의 값이 2인 경우 해당 위치까지 A와 B에 공통으로 발생한 값이므로 common을 증가시켜준다.       result[i]에 common을 넣어 현재 위치까지 공통으로 값이 발생한 갯수를 넣어준다.           반복이 완료되면 완성된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-the-prefix-common-array-of-two-arrays/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimize XOR",
        "excerpt":"문제  Link   코드  class Solution {    public int minimizeXor(int num1, int num2) {     int bit1 = Integer.bitCount(num1);     int bit2 = Integer.bitCount(num2);     int result = num1;     for (int i = 0; i &lt; 32; i++) {       if (bit1 &gt; bit2 &amp;&amp; ((1 &lt;&lt; i) &amp; num1) &gt; 0) {         result ^= 1 &lt;&lt; i;         bit1--;       }       if (bit1 &lt; bit2 &amp;&amp; ((1 &lt;&lt; i) &amp; num1) == 0) {         result ^= 1 &lt;&lt; i;         bit1++;       }     }     return result;   }  }   결과  Link   설명     양의 정수 num1과 num2를 이용하여 아래의 규칙을 만족하는 양의 정수를 구하는 문제이다.            결과를 만족하는 양의 정수는 num2와 동일한 비트 수를 가지고 있다.       결과를 만족하는 양의 정수와 num1의 XOR(^) 비트 연산의 결과는 최솟값이다.           문제 풀이에 필요한 변수를 정의한다.            bit1과 bit2는 num1과 num2의 비트 값이 1인 갯수를 넣은 변수이다.       result에는 num1을 넣어준다.           int의 범위 내인 0부터 32 미만까지 i를 증가시키면서 아래를 반복한다.            bit1이 bit2보다 크면서 1을 i번 좌측으로 비트를 이동시킨 값과 num1의 AND(&amp;) 비트 연산의 결과가 0보다 큰 경우, result에 1을 i번 좌측으로 이동시킨 값과 자기 자신의 값을 XOR(^) 비트 연산 수행한 결과를 넣고 bit1을 감소시켜 비트 수를 조율한다.       bit1이 bit2보다 작으면서 1을 i번 좌측으로 비트를 이동시킨 값과 num1의 AND(&amp;) 비트 연산의 결과가 0인 경우, result에 1을 i번 좌측으로 이동시킨 값과 자기 자신의 값을 XOR(^) 비트 연산 수행한 결과를 넣고 bit1을 증가시켜 비트 수를 관율한다.           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimize-xor/",
        "teaser": null
      },{
        "title": "Leetcode Java Neighboring Bitwise XOR",
        "excerpt":"문제  Link   코드  class Solution {    public boolean doesValidArrayExist(int[] derived) {     int sum = 0;     for (int derive : derived) {       sum += derive;     }     return sum % 2 == 0;   }  }   결과  Link   설명     [0, $n - 1$] 범위 값을 가진 길이 n인 derived 정수 배열을 이용하여 아래를 만족하는 배열이 존재하는지 여부를 검증하는 문제이다.            i = $n - 1$인 경우, derived[i] = original[i] ^ original[0]를 만족한다.       위의 경우가 아닌 경우, derived[i] = original[i] ^ original[$i + 1$]를 만족한다.           derived의 합계가 짝수인지의 여부를 주어진 문제의 결과로 반환한다.            조건에 만족하기 위한 기본 논제를 정리한다.                    derived = [A[0], A[1], …, A[$n - 1$]] = [A[0] ^ A[1], A[1] ^ A[2], …, A[n-1] ^ A[0]]을 만족한다.           조건에 따른 derived의 값은 (A[0] ^ A[1]) ^ (A[1] ^ A[2]) ^  … ^ (A[$n - 1$] ^ A[0]) = 0을 만족한다.           위에 따라 SUM(derived) 의 결과가 짝수인지가 주어진 조건을 만족하는 경우이다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/neighboring-bitwise-xor/",
        "teaser": null
      },{
        "title": "Leetcode Java Map of Highest Peak",
        "excerpt":"문제  Link   코드  class Solution {    private static final int[] DIRECTIONS = { 0, 1, 0, -1, 0 };    public int[][] highestPeak(int[][] isWater) {     int row = isWater.length;     int col = isWater[0].length;     int[][] heights = new int[row][col];     Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();     for (int i = 0; i &lt; row; i++) {       for (int j = 0; j &lt; col; j++) {         if (isWater[i][j] == 1) {           heights[i][j] = 0;           queue.offer(new int[] { i, j });         } else {           heights[i][j] = -1;         }       }     }     while (!queue.isEmpty()) {       int[] curr = queue.poll();       for (int k = 0; k &lt; 4; k++) {         int x = curr[0] + DIRECTIONS[k];         int y = curr[1] + DIRECTIONS[k + 1];         if (0 &lt;= x &amp;&amp; x &lt; row &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; col &amp;&amp; heights[x][y] &lt; 0) {           heights[x][y] = heights[curr[0]][curr[1]] + 1;           queue.offer(new int[] { x, y });         }       }     }     return heights;   }  }   결과  Link   설명     물의 위치를 1로 표시한 $m \\times n$ 크기의 배열인 isWater를 이용하여 아래의 규칙을 만족하는 높이가 저장된 배열을 만들어 반환하는 문제이다.            물로 표시된 높이는 0으로 표시하고, 해당 상하좌우 셀의 값은 물보다 높으므로 1로 표시한다.       땅과 근접한 셀과의 높이 차이는 최대 1이어야한다.           문제 풀이에 필요한 변수를 정의한다.            DIRECTIONS는 인접한 두 값의 조합이 상하좌우를 모두 표시할 수 있는 값의 조합을 저장한 전역 변수이다.       row와 col은 isWater의 행과 열의 갯수를 저장한 변수이다.       heights는 규칙을 만족하는 높이를 계산하여 저장할 배열로, isWater과 동일한 $row \\times col$ 크기의 2차원 정수 배열로 정의한다.       queue는 물의 위치를 저장하여 해당 위치부터 순차적인 높이를 계산하기 위한 변수로, LinkedList로 초기화한다.           0 부터 row 미만까지 i를, 0 부터 col 미만까지 j를 순차적으로 증가시키며 아래를 반복한다.            isWater[i][j]의 값이 1인 물인 경우, heights[i][j]의 위치에 0을 넣어주고 queue에 해당 위치를 배열로 넣어준다.       isWater[i][j]의 값이 0인 땅인 경우, heights[i][j]의 위치에 -1을 넣어준다.           queue가 비어있지 않을 때 까지 아래를 반복하여 heights를 완성한다.            curr에 queue의 맨 앞 값을 꺼내 넣어준다.       0부터 4미만까지 k를 증가시키며 아래를 반복한다.                    x에 $curr[0] + DIRECTIONS[k]$ 값을, y에 $curr[1] + DIRECTIONS[k + 1]$ 값을 저장하여 다음 위치로 이동한다.           heights[x][y]의 값이 배열 범위 내이면서 값이 -1인 높이가 계산되지 않은 육지인 경우, 해당 위치에 이전 위치보다 1 큰 값을 넣고 queue에 [x, y] 좌표의 값을 배열로 넣어 물에서 현재 떨어진 위치 상하좌우 반복 이후 다음 위치 탐색 대상으로 저장한다.                           반복이 완료되어 완성된 높이가 저장된 heights를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/map-of-highest-peak/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Servers that Communicate",
        "excerpt":"문제  Link   코드  class Solution {    public int countServers(int[][] grid) {     int rowLength = grid.length;     int colLength = grid[0].length;     int[] rowCounts = new int[rowLength];     int[] colCounts = new int[colLength];     for (int i = 0; i &lt; rowLength; i++) {       for (int j = 0; j &lt; colLength; j++) {         if (grid[i][j] == 1) {           rowCounts[i]++;           colCounts[j]++;         }       }     }     int result = 0;     for (int i = 0; i &lt; rowLength; i++) {       for (int j = 0; j &lt; colLength; j++) {         if (grid[i][j] == 1 &amp;&amp; (rowCounts[i] &gt; 1 || colCounts[j] &gt; 1)) {           result++;         }       }     }     return result;   }  }   결과  Link   설명          컴퓨터의 위치가 저장된 grid를 이용하여 동일한 열과 행의 컴퓨터끼리 통신이 가능한 컴퓨터의 갯수를 계산하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            rowLength와 colLength는 grid의 행과 열의 길이를 저장한 변수이다.       rowCounts와 colCounts는 grid의 행과 열에 존재하는 컴퓨터 갯수를 계산하기 위한 변수로, 행과 열의 크기에 해당하는 정수 배열로 초기화하고 grid를 반복하여 행과 열에 존재하는 컴퓨터의 갯수를 계산한다.       result는 통신 가능한 컴퓨터의 수를 저장할 변수로, 0으로 초기화한다.           0부터 rowLength 미만까지 i를 증가시키고, 0부터 colLength 미만까지 j를 증가시키며 아래를 반복한다.            gird[i][j]의 값이 1인 컴퓨터가 존재하면서 rowCounts[i] 혹은 colCounts[j]가 1보다 큰 통신 가능한 컴퓨터가 존재하는 경우, result를 증가시켜 통신 가능한 컴퓨터의 수를 계산한다.           반복이 완료되어 계산된 통신 가능한 컴퓨터의 수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-servers-that-communicate/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Equal Frequency",
        "excerpt":"문제  Link   코드  class Solution {    public int maxEqualFreq(int[] nums) {     int[] counts = new int[100001];     int[] frequencies = new int[100001];     int length = nums.length;     int result = 0;     for (int i = 0; i &lt; length; i++) {       counts[nums[i]]++;       int frequency = counts[nums[i]];       frequencies[frequency]++;       int count = frequencies[frequency] * frequency;       if (count == i + 1 &amp;&amp; i != length - 1) {         result = Math.max(result, i + 2);       } else if (count == i) {         result = Math.max(result, i + 1);       }     }     return result;   }  }   결과  Link   설명          양의 정수가 들어있는 배열인 nums의 부분 배열 중 한 값을 제거하여 동일한 값이 정확히 같은 횟수로 반복되는 부분 배열의 최대 길이를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            counts와 frequencies는 문자 갯수와 빈도를 계산하기 위한 변수로, 각각 최대 크기인 $10^5$ 보다 1 큰 크기의 정수 배열로 초기화한다.       length는 nums의 길이를 저장한 변수이다.       result는 부분 배열의 길이를 저장한 변수로, 0으로 초기화한다.           0부터 length 미만까지 i를 증가시키며 아래를 반복한다.            counts[nums[i]]의 값인 nums[i]번째 문자 갯수를 증가시킨다.       frequency는 현재 발생 빈도 기준을 저장할 변수로, counts[nums[i]]의 값을 넣어준다.       frequencies[frequency]의 값을 증가시켜 현재까지 문자 발생 빈도의 갯수를 증가시켜준다.       count는 현재 발생 빈도만큼의 문자열이 동일하게 발생한 경우, 문자의 갯수를 저장한 변수이다.       count가 $i + 1$과 동일하면서 $length - 1$인 마지막 위치가 아닌 경우, result에 result와 $i + 2$인 현재까지 부분 문자열 길이보다 1 큰 값 중 큰 값을 넣어준다.                    nums의 값이 [1, 1, 3, 3, 5] 인 경우, 전체를 부분 배열로 하면 조건을 만족하는 1과 3이 존재하면서 제거할 5가 있으므로 count가 $i + 1$과 동일하다.           i는 0-index이므로 길이는 1을 더한 값이다.                       위의 경우가 아니면서 count가 i와 동일한 경우, result에 result와 $i + 1$ 중 큰 값을 넣어준다.                    nums의 값이 [1, 1, 3, 3, 3, 5] 인 경우, 조건을 만족하는 범위인 [1, 1, 3, 3, 3]인 부분 배열에서 3만 제거하면 되므로 count가 i와 동일하다.                           반복이 완료되면 부분 배열의 최대 길이가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-equal-frequency/",
        "teaser": null
      },{
        "title": "Leetcode Java Course Schedule IV",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Boolean&gt; checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {     boolean[][] connected = new boolean[numCourses][numCourses];     for (int[] prerequisite : prerequisites) {       connected[prerequisite[0]][prerequisite[1]] = true;     }     for (int k = 0; k &lt; numCourses; k++) {       for (int i = 0; i &lt; numCourses; i++) {         for (int j = 0; j &lt; numCourses; j++) {           connected[i][j] = connected[i][j] || (connected[i][k] &amp;&amp; connected[k][j]);         }       }     }     List&lt;Boolean&gt; result = new ArrayList&lt;&gt;();     for (int[] query : queries) {       result.add(connected[query[0]][query[1]]);     }     return result;   }  }   결과  Link   설명     $[0, numCourses - 1]$ 범위내 numCourses개 강의를 이용하여 prerequisites의 전제 조건을 만족하는 queries에 대한 결과를 각각 반환하는 문제이다.            prerequisites[i] = [ai, bi] 로, bi 강의를 수강하기 위해서 ai 강의를 사전에 수강해야 한다는 의미를 나타낸다.       queries[j] = [uj, vj] 로, uj 강의가 vj 강의의 사전 수강 강의인지 질의한다는 의미를 나타낸다.           문제 풀이에 필요한 변수를 정의한다.            connected는 연결된 강의 정보를 저장할 변수로, $numCourses \\times numCourses$ 크기의 부울 배열로 초기화하고 아래를 수행한다.                    prerequisites를 순차적으로 prerequisite에 넣어 connected[prerequisite[0]][prerequisite[1]] 위치에 true를 넣어 연결된 강의임을 체크해준다.           0부터 numCourses 미만까지 k, i, j순으로 각 값을 증가시키며 반복하여, connected[i][j]의 위치에 connected[i][j]가 true인 연결된 강의거나 connected[i][k]와 connected[k][j]가 true인 i -&gt; k -&gt; j 순으로 강의를 들어야하는 경우에는 true를 아니면 false를 넣어준다.                       result는 queries의 각 결과를 저장할 변수로, ArrayList로 초기화하여 queries를 순차적으로 query에 넣어 connected[query[0]][query[1]] 값을 넣어준다.           queries의 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/course-schedule-iv/",
        "teaser": null
      },{
        "title": "Leetcode Java Special Array I",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isArraySpecial(int[] nums) {     for (int i = 1; i &lt; nums.length; i++) {       if (((nums[i - 1] ^ nums[i]) &amp; 1) == 0) {         return false;       }     }     return true;   }  }   결과  Link   설명          nums 내 붙은 값이 홀수와 짝수가 번갈아 존재하는지 검증하는 문제이다.       1부터 nums의 길이 미만까지 i를 증가시키며 아래를 반복한다.            num[$i - 1$]의 값과 nums[i]의 값의 XOR(^) 비트 연산 수행한 값과 1의 AND(&amp;) 비트 연산 수행한 값이 0인 경우, false를 주어진 문제의 결과로 반환한다.                    num[$i - 1$]의 값과 nums[i]의 값의 XOR(^) 비트 연산 수행한 이후 1과 AND(&amp;) 비트 연산을 수행하여 비트 내 1의 자리 값을 가져온다.           위 결과가 이 0인 경우, 동일한 홀수 혹은 짝수가 아닌 경우이므로 false를 반환한다.                           반복이 완료되어 검증이 완료되면, true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/special-array-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Check if Array Is Sorted and Rotated",
        "excerpt":"문제  Link   코드  class Solution {    public boolean check(int[] nums) {     int count = 0;     int length = nums.length;     for (int i = 0; i &lt; length; i++) {       if (nums[(i + 1) % length] &lt; nums[i]) {         count++;       }       if (count &gt; 1) {         return false;       }     }     return true;   }  }   결과  Link   설명     nums 배열을 회전하였을 때, 증가하는 숫자들로 이루어진 배열로 정렬이 가능한지 검증하는 문제이다.            배열 A를 x 위치로 회전시켜 만들어진 배열 B가 완성될 때, A[i] == B[($i + x$) % A.length]를 만족한다.       % 연산 부호는 모듈러를 의미한다.           문제 풀이에 필요한 변수를 정의한다.            count는 주어진 조건인 A[i] == B[($i + x$) % A.length]를 만족하지 않고 더 작은 값이 되는 값의 갯수를 계산할 변수로, 0으로 초기화한다.       length는 nums의 길이를 저장한 변수이다.           0부터 length 미만까지 i를 증가시키면서 아래를 반복한다.            nums[($i + x$) % A.length]의 값이 nums[i]보다 작은 오히려 값이 작아지는 경우, count를 증가시킨다.       count가 둘 이상인 회전하더라도 조건을 만족하지 않는 경우, false를 주어진 문제의 결과로 반환한다.                    count가 1인 경우, 그 지점을 기준으로 회전시키면 정렬이 가능하다.                           반복이 완료되면 회전을 통해 증가하는 배열로 변환 가능하므로 true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/check-if-array-is-sorted-and-rotated/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Strictly Increasing or Strictly Decreasing Subarray",
        "excerpt":"문제  Link   코드  class Solution {    public int longestMonotonicSubarray(int[] nums) {     int result = 1;     int increase = 1;     int decrease = 1;     for (int i = 1; i &lt; nums.length; i++) {       if (nums[i - 1] &lt; nums[i]) {         increase++;         decrease = 1;       } else if (nums[i - 1] &gt; nums[i]) {         decrease++;         increase = 1;       } else {         increase = 1;         decrease = 1;       }       result = Math.max(result, Math.max(increase, decrease));     }     return result;   }  }   결과  Link   설명          nums의 연속된 값들을 이용하여 증가하는 값의 길이와 감소하는 값의 길이 중 가장 긴 길이를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 가장 긴 길이를 저장하기 위한 변수로, 첫 값을 포함한 최소 길이인 1로 초기화한다.       increase와 decrease는 증가하거나 감소하는 연속된 값의 갯수를 계산하기 위한 변수로, result와 동일한 이유로 둘 다 1로 초기화한다.           1부터 nums의 길이 미만까지 i를 증가시키며 아래를 반복한다.            nums[i - 1]의 값이 nums[i]의 값보다 작으면 값이 증가하고 있으므로, increase를 증가시키고 decrease를 1로 초기화한다.       nums[i - 1]의 값이 nums[i]의 값보다 크면 값이 감소하고 있으므로, decrease를 증가시키고 increase를 1로 초기화한다.       그 외의 경우 값이 동일하므로, increase와 decrease를 1로 초기화한다.       result에 result, increase, decrease 중 큰 값을 넣어 현재까지 가장 긴 길이를 저장한다.           반복이 완료되어 구해진 가장 긴 길이인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-strictly-increasing-or-strictly-decreasing-subarray/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Ascending Subarray Sum",
        "excerpt":"문제  Link   코드  class Solution {    public int maxAscendingSum(int[] nums) {     int result = nums[0];     int curr = nums[0];     for (int i = 1; i &lt; nums.length; i++) {       if (nums[i - 1] &lt; nums[i]) {         curr += nums[i];       } else {         curr = nums[i];       }       result = Math.max(result, curr);     }     return result;   }  }   결과  Link   설명          nums의 연속된 값들 중 증가되는 부분 배열의 합이 최대인 값을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 결과를 저장할 변수로, nums의 첫 값을 저장한다.       curr은 현재까지 부분 배열의 합을 저장할 변수로, result와 동일하게 nums의 첫 값을 저장한다.           1부터 nums의 길이 미만까지 i를 증가시키며 아래를 반복한다.            nums[$i - 1$]의 값이 nums[i]의 값보다 작은 값이 증가하는 경우, curr에 nums[i]의 값을 더해준다.       nums[$i - 1$]의 값이 nums[i]의 값보다 작지 않은 값이 증가하지 않는 경우, curr에 nums[i]의 값을 넣어준다.       result에 result와 curr 중 가장 큰 값을 넣어준다.           반복이 완료되면 증가되는 부분 배열의 합이 최대인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-ascending-subarray-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Check if One String Swap Can Make Strings Equal",
        "excerpt":"문제  Link   코드  class Solution {    public boolean areAlmostEqual(String s1, String s2) {     char[] s1CharArray = s1.toCharArray();     char[] s2CharArray = s2.toCharArray();     int i = -1;     int j = -1;     int count = 0;     for (int k = 0; k &lt; s1CharArray.length; k++) {       if (s1CharArray[k] != s2CharArray[k]) {         count++;         if (i == -1) {           i = k;         } else if (j == -1) {           j = k;         }       }     }     return count == 0 || (count == 2 &amp;&amp; s1CharArray[i] == s2CharArray[j] &amp;&amp; s1CharArray[j] == s2CharArray[i]);   }  }   결과  Link   설명          문자열 s1에서 문자들 간 스왑을 최대 한 번만 사용하여 s2를 만들 수 있는지 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            s1CharArray와 s2CharArray는 s1과 s2를 문자 배열로 변환한 변수이다.       i와 j는 문자 스왑을 위한 위치 변수로, 둘 다 -1로 초기화한다.       count는 s1과 s2의 다른 문자 갯수를 계산하기 위한 변수로, 0으로 초기화한다.           0부터 s1CharArray의 길이 미만까지 k를 증가시키며 아래를 반복한다.            s1CharArray[k] 문자와 s2CharArray[k] 문자가 다른 경우, 아래를 수행한다.                    count를 증가시켜 다른 갯수를 계산한다.           i가 -1이면 i에 k를, j가 -1이면 j에 k를 넣어 스왑할 위치를 저장한다.                           반복이 완료되면 아래의 두 경우 중 하나라도 만족하면 true를, 아니면 false를 주어진 문제의 결과로 반환한다.            count가 0인 스왑할 대상이 없는 경우.       count가 2이면서, s1CharArray[i] 문자와 s2CharArray[j] 문자가 같으면서 s1CharArray[j] 문자와 s2CharArray[i] 문자가 동일한 스왑하면 동일한 문자열이 되는 경우.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/check-if-one-string-swap-can-make-strings-equal/",
        "teaser": null
      },{
        "title": "Leetcode Java Tuple with Same Product",
        "excerpt":"문제  Link   코드  class Solution {    public int tupleSameProduct(int[] nums) {     int length = nums.length;     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();     int result = 0;     for (int i = 0; i &lt; length; i++) {       for (int j = i + 1; j &lt; length; j++) {         int key = nums[i] * nums[j];         int value = map.getOrDefault(key, 0);         result += 8 * value;         map.put(key, value + 1);       }     }     return result;   }  }   결과  Link   설명          nums의 값들을 이용하여 $a \\times b = c \\times d$를 만족하는 각 값이 모두 다른 임의 네 값인 a, b, c, d의 조합의 갯수를 계산하는 문제이다.            문제 풀이에 필요한 변수를 정의한다.             length는 nums의 길이를 저장한 변수이다.       map은 임의 두 값의 곱에 대한 갯수를 0-index로 계산하기 위한 변수로, key-value로 저장하기 위해 HashMap으로 초기화한다.              result는 조합의 갯수를 저장하기 위한 변수로, 0으로 초기화한다.      0부터 length 미만까지 i를 증가시키고, $i + 1$부터 length 미만까지 j를 증가시키며 아래를 반복한다.            key에 $nums[i] \\ times[j]$인 두 값의 곱을 넣어준다.       value에 map에서 key에 대한 값이 존재하면 꺼내 넣어주고, 없는 경우 0을 넣어준다.       result에 $8 \\times value$의 값인 조합의 수를 더해준다.       map의 key에 해당 하는 값을 $value + 1$로 넣어 갯수를 증가시켜준다.           반복이 완료되면 각 조합의 수가 저장된 result를 주어진 문제의 결과로 반환한다.   해설     두 값의 곱이 동일한 값이 2개가 존재해야 하나의 조합이므로 0-index로 시작하고, 2개는 $2 \\times 2 \\times 2 \\times 2 \\times 2 = 8$ 개의 조합의 갯수가 존재한다.            nums = [1, 3, 4, 12]의 경우, 아래의 총 8개 조합이 존재한다.       [1, 12, 3, 4], [1, 12, 4, 3], [12, 1, 3, 4], [12, 1, 4, 3], [3, 4, 1, 12], [3, 4, 12, 1], [4, 3, 1, 12], [4, 3, 12, 1]           두 값의 곱이 동일한 값이 3개가 존재하면 이미 2개의 조합에 대한 값을 result에 더했으므로, 위의 공식에 따라 다른 한 값과 나머지 두 개의 조합의 경우인 $8 \\time 2 = 16$ 개의 조합의 갯수가 존재한다.   위에 따라 두 값의 곱이 동일한 값을 0-index로 산출하고, 각 갯수에 따라 8개의 경우의 수를 곱한 값을 누계하면 모든 조합의 갯수가 완성된다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/tuple-with-same-product/",
        "teaser": null
      },{
        "title": "Leetcode Java Design a Number Container System",
        "excerpt":"문제  Link   코드  class NumberContainers {    private Map&lt;Integer, Integer&gt; indexMap;   private Map&lt;Integer, TreeSet&lt;Integer&gt;&gt; valueMap;    public NumberContainers() {     this.indexMap = new HashMap&lt;&gt;();     this.valueMap = new HashMap&lt;&gt;();   }    public void change(int index, int number) {     this.indexMap.put(index, number);     this.valueMap.computeIfAbsent(number, value -&gt; new TreeSet&lt;Integer&gt;()).add(index);   }    public int find(int number) {     if (this.valueMap.containsKey(number)) {       for (Integer value : this.valueMap.get(number)) {         if (this.indexMap.get(value) == number) {           return value;         }       }     }     return -1;   }  }  /**  * Your NumberContainers object will be instantiated and called as such:  * NumberContainers obj = new NumberContainers();  * obj.change(index,number);  * int param_2 = obj.find(number);  */   결과  Link   설명     아래의 기능을 제공하는 객체를 설계하는 문제이다.            생성자인 NumberContainers()는 객체를 초기화한다.       메서드인 change(int index, int number)는 특정 index에 number를 넣어준다. 단, 값이 존재하면 기존 값을 덮어쓴다.       메서드인 find(int number)는 number에 해당하는 index를 반환한다. 단, number에 해당하는 index가 존재하지 않으면 -1을 반환한다.           문제 풀이에 필요한 전역 변수를 정의한다.            indexMap은 index에 대한 number를 저장하기 위한 변수이다.       valueMap은 number에 해당하는 index를 저정하기 위한 변수이다.           생성자인 NumberContainers()를 정의한다.            전역 변수로 정의한 indexMap와 valueMap을 HashMap으로 초기화한다.           메서드인 change(int index, int number)를 정의한다.            indexMap의 index가 키인 값을 number로 넣어준다.       valueMap의 number에 해당하는 값이 없으면 새 TreeSet을, 있으면 기존 TreeSet을 가져와 index를 넣어준다.           메서드인 find(int number)를 정의한다.            valueMap에 number가 존재하는 경우, valueMap의 number에 해당하는 TreeSet을 가져와 순차적으로 작은 값부터 value에 넣어 아래를 반복한다.                    indexMap에서 value에 해당하는 값이 number와 동일한 경우, value를 주어진 문제의 결과로 반환한다.                       number에 해당하는 index가 존재하지 않으므로 -1을 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/design-a-number-container-system/",
        "teaser": null
      },{
        "title": "Leetcode Java Clear Digits",
        "excerpt":"문제  Link   코드  class Solution {    public String clearDigits(String s) {     StringBuilder sb = new StringBuilder();     for (char c : s.toCharArray()) {       if (Character.isDigit(c)) {         int length = sb.length();         if (length &gt; 0) {           sb.deleteCharAt(length - 1);         }       } else {         sb.append(c);       }     }     return sb.toString();   }  }   결과  Link   설명          문자열 s에서 숫자가 존재하는 경우, 해당 값과 좌측 값을 같이 제거 후 동일한 절차를 반복하여 더 이상 제거할 문자가 없는 문자열을 반환하는 문제이다.            sb는 결과 문자열을 저장할 변수로, 동적 문자열 생성을 위해 StringBuilder로 초기화한다.       s의 각 문자들을 순차적으로 c에 넣어 아래를 수행한다.            c가 숫자인 경우, sb에 문자가 추가된 경우 마지막 문자를 제거하여 반복 조건을 만족시킨다.       c가 문자인 경우, sb 다음 문자로 이어 넣어준다.           반복이 완료되면 완성된 sb를 문자열로 반환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/clear-digits/",
        "teaser": null
      },{
        "title": "Leetcode Java Max Sum of a Pair With Equal Sum of Digits",
        "excerpt":"문제  Link   코드  class Solution {    public int maximumSum(int[] nums) {     int[] max = new int[82];     int result = -1;     for (int num : nums) {       int sum = 0;       int temp = num;       while (temp != 0) {         sum += temp % 10;         temp /= 10;       }       if (max[sum] != 0) {         result = Math.max(result, num + max[sum]);       }       max[sum] = Math.max(max[sum], num);     }     return result;   }  }   결과  Link   설명     양의 정수로 구성된 nums 내 아래 규칙을 만족하는 최댓값 $nums[i] + nums[j]$를 구하는 문제이다.            서로 다른 임의 위치 i와 j를 고르되, nums[i] 값과 nums[j] 값의 값 각 자리 별 숫자의 합은 동일하다.           문제 풀이에 필요한 변수를 정의한다.            max는 최댓값을 저장할 변수로, 각 숫자별 합계가 최대가 될 수 있는 상한값인 82 크기의 정수 배열로 초기화한다.       result는 결과를 저장할 변수로, -1로 초기화한다.           nums의 각 값을 num에 넣어 순차적으로 아래를 수행한다.            sum은 합계를 저장할 변수로, 0으로 초기화하고 num을 temp에 넣어 각 자리 별 숫자의 합계를 더해준다.       max[sum]의 값이 0이 아닌 경우 이전에 계산한 값이 존재하므로, result에 result와 $num + max[sum]$ 중 합계가 큰 값을 넣어준다.       max[sum]에 max[sum] 값과 num 중 큰 값을 넣어 저장한다.           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/max-sum-of-a-pair-with-equal-sum-of-digits/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Operations to Exceed Threshold Value II",
        "excerpt":"문제  Link   코드  class Solution {    public int minOperations(int[] nums, int k) {     Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();     for (int num : nums) {       if (num &lt; k) {         queue.add(num);       }     }     int result = 0;     while (!queue.isEmpty()) {       int x = queue.poll();       result++;       if (queue.isEmpty()) {         break;       } else {         int y = queue.poll();         long value = (2L * x) + y;         if (value &lt; k) {           queue.add((int) value);         }       }     }     return result;   }  }   결과  Link   설명     nums의 모든 값이 k 이상이 되도록 하기 위한 아래 수행을 반복할 때, 최소 작업의 횟수를 구하는 문제이다.            nums의 가장 작은 값을 제거하고 x와 y에 넣은 후, 배열의 임의 위치에 $min(x, y) \\times 2 + max(x, y)$를 추가한다.           문제 풀이에 필요한 변수를 정의한다.            queue는 nums의 k 이하인 값을 저장할 변수로, 오름차순 값을 정렬하여 저장하기 위해 PriorityQueue로 초기화하고 nums를 반복하여 k 미만인 값을 넣어준다.       result는 최소 반복 횟수를 계산하기 위한 변수로, 0으로 초기화한다.           queue가 비어있지 않을 때 까지 아래를 반복한다.            x는 가장 작은 값을 저장할 변수로, queue의 첫 값을 넣어준다.       result인 꺼낸 횟수를 증가시켜준다.       queue가 비어있으면 반복을 중지시키고, 비어있지 않으면 아래를 수행한다.                    y에 queue의 x 이후 가장 작은 값을 넣어준다.           value는 조건인 $(2L \\times x) + y$를 수행한 결과를 넣어준다.           value가 k 미만인 경우, queue에 value를 넣어 다시 반복을 수행할 대상으로 추가한다.                           반복이 완료되면 최소 작업의 횟수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-operations-to-exceed-threshold-value-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Product of the Last K Numbers",
        "excerpt":"문제  Link   코드  class ProductOfNumbers {    private List&lt;Integer&gt; list;   private int product;    public ProductOfNumbers() {     this.list = new ArrayList&lt;&gt;();     this.product = 1;   }    public void add(int num) {     if (num != 0) {       this.product *= num;       this.list.add(product);     } else {       this.list.clear();       this.product = 1;     }   }    public int getProduct(int k) {     int size = this.list.size();     if (size &lt; k) {       return 0;     } else {       int num = this.list.get(size - 1);       if (size == k) {         return num;       } else {         return num / this.list.get(size - 1 - k);       }     }   }  }  /**  * Your ProductOfNumbers object will be instantiated and called as such:  * ProductOfNumbers obj = new ProductOfNumbers();  * obj.add(num);  * int param_2 = obj.getProduct(k);  */   결과  Link   설명     아래 기능을 수행하는 객체를 만드는 문제이다.            생성자인 ProductOfNumbers()는 객체를 초기화하는 역할을 수행한다.       메서드인 add(int num)는 객체에 num을 이어 넣어준다.       메서드인 getProduct(int k)는 마지막 k개 값을 곱한 결과를 반환한다.           수행에 필요한 전역 변수를 정의한다.            list는 add 메서드를 통해 입력된 숫자를 저장할 변수이다.       product는 입력된 숫자들의 곱을 저장할 변수이다.           생성자인 ProductOfNumbers()를 정의한다.            list를 ArrayList로, product를 1로 초기화한다.           메서드인 add(int num)를 정의한다.            num이 0이 아닌 경우, product에 num을 곱한 후 list에 product를 넣어 저장한다.       num이 0이어서 product의 이전 값의 곱이 0이 되는 경우, list를 초기화하고 product를 1로 초기화한다.           메서드인 getProduct(int k)를 정의한다.            size에 list의 길이를 넣어준다.       size가 k 미만인 경우, k개의 곱을 계산할 수 없으므로 0을 반환한다.       위의 경우가 아니라면, 아래를 수행한다.                    num에 list의 마지막 값을 넣어준다.           size가 k인 기존 값을 모두 곱하는 경우, num을 반환한다.           위의 경우가 아니라면 num에 list 내 $size - 1 - k$ 위치인 k개 이전까지 곱한 값을 가져와 나눈 값을 반환한다.                           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/product-of-the-last-k-numbers/",
        "teaser": null
      },{
        "title": "Leetcode Java Construct the Lexicographically Largest Valid Sequence",
        "excerpt":"문제  Link   코드  class Solution {    public int[] constructDistancedSequence(int n) {     int[] result = new int[(n * 2) - 1];     boolean[] visited = new boolean[n + 1];     this.backtrack(n, result, 0, visited);     return result;   }    private boolean backtrack(int n, int[] result, int index, boolean[] visited) {     if (index == result.length) {       return true;     } else if (result[index] != 0) {       return this.backtrack(n, result, index + 1, visited);     } else {       for (int i = n; i &gt;= 1; i--) {         if (!visited[i]) {           visited[i] = true;           result[index] = i;           if (i == 1) {             if (this.backtrack(n, result, index + 1, visited)) {               return true;             }           } else if (index + i &lt; result.length &amp;&amp; result[index + i] == 0) {             result[index + i] = i;             if (this.backtrack(n, result, index + 1, visited)) {               return true;             }             result[index + i] = 0;           }           result[index] = 0;           visited[i] = false;         }       }       return false;     }   }  }   결과  Link   설명     정수 n을 이용하여 아래의 규칙을 만족하는 사전적으로 가장 큰 배열을 반환하는 문제이다.            정수 1은 한 번만 발생한다.       2와 n 사이의 값들은 두 번씩 발생한다.       2와 n 사이의 임의 값 i에 대해서 동일한 값과의 거리는 정확히 i이다.           문제 풀이에 필요한 변수를 정의한다.            result는 결과를 넣을 변수로, 조건에 해당하는 값의 크기인 $(n \\times 2) - 1$ 크기의 정수 배열로 초기화한다.       visited는 숫자 사용 여부를 저장할 변수로, $n + 1$ 크기의 정수 배열로 초기화한다.                4번에서 정의한 backtrack(int n, int[] result, int index, boolean[] visited) 메서드에 n, result, 0, visited를 넣어 수행한다.       배열의 역순으로 탐색하며 조건에 만족하는 배열을 완성하기 위한 backtrack(int n, int[] result, int index, boolean[] visited) 메서드를 정의한다.            index가 result의 길이와 동일한 마지막 수행인 경우, true를 반환한다.       result[index]의 값이 0이 아닌 값이 설정된 경우, index를 증가시켜 재귀 수행한 결과를 반환한다.       위의 모든 경우가 아니라면 i를 n부터 1 이상일 때 까지 감소시키며 visited[i]가 false인 경우만 아래를 반복한다.                    visited[i]의 값을 true로 넣어주고, result[index]에 i를 넣어준다.           i가 1인 경우, index를 증가시켜 재귀 수행시킨 결과가 true인 경우 true를 반환한다.           i가 1이 아니면서 $index + i$가 result 길이보다 작고 result[$index + i$]의 값이 0인 값 설정이 안 된 경우, result[$index + i$]에 i를 넣고 index를 증가시켜 재귀 수행 시킨 결과가 true인 경우 true를 반환하고 result[$index + i$]에 다시 0을 넣어 초기화시켜준다.           result[index]에 0을 넣고, visited[i]에 false를 넣어 초기화시켜준다.                           수행이 완료되어 완성된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-the-punishment-number-of-an-integer/",
        "teaser": null
      },{
        "title": "Leetcode Java Airplane Seat Assignment Probability",
        "excerpt":"문제  Link   코드  class Solution {    public double nthPersonGetsNthSeat(int n) {     return n == 1 ? 1.0d : 0.5d;   }  }   결과  Link   설명          n번째 승객이 n석이 존재하는 비행기에 탑승할 때, 각 승객이 임의 좌석에 앉을 경우 자기 자신의 좌석에 앉을 확률을 구하는 문제이다.            첫 손님은 첫 자리에 앉을 수 있으므로 1을, 그 외는 0.5를 주어진 문제의 결과로 반환한다.             n이 2인 경우, $f(2) = \\frac{1}{2}$를 만족하는 것을 알 수 있다.       위를 이용하여 $f(m + 1) = \\frac{1}{m + 1} + \\frac{m + 1 - 2}{m + 1} \\times f(m) = \\frac{2}{2 \\times (m + 1)} + \\frac{m - 1}{m + 1} \\times \\frac{1}{2} = \\frac{m + 1}{2 \\times (m + 1)} = \\frac{1}{2}$를 만족하므로, n이 1이 아닌 결과는 모두 0.5가 된다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/airplane-seat-assignment-probability/",
        "teaser": null
      },{
        "title": "Leetcode Java Construct Smallest Number From DI String",
        "excerpt":"문제  Link   코드  class Solution {    public String smallestNumber(String pattern) {     StringBuilder sb = new StringBuilder();     int length = pattern.length();     int[] stack = new int[length + 1];     int index = 0;     for (int i = 0; i &lt;= length; i++) {       stack[index++] = i + 1;       if (i == length || pattern.charAt(i) == 'I') {         while (index &gt; 0) {           sb.append(stack[--index]);         }       }     }     return sb.toString();   }  }   결과  Link   설명     pattern의 값을 사전적으로 가장 작은 값인 num을 만들어 반환하는 문제이다.            num은 ‘1’에서 ‘9’까지로 구성된 숫자이다.       pattern[i] 값이 ‘I’면 증가하는 값을 의미하며, num[i] &lt; num[$i + 1$]를 만족한다.       pattern[i] 값이 ‘D’면 감소하는 값을 의미하며, num[i] &gt; num[$i + 1$]를 만족한다.           문제 풀이에 필요한 변수를 정의한다.            sb는 num을 만들기 위한 변수로, 동적 문자열 생성을 위한 StringBuilder로 초기화한다.       length는 pattern의 길이를 저장한 변수이다.       stack은 각 숫자를 위치 별 저장하기 위한 변수로, $length + 1$ 크기의 정수 배열로 초기화한다.       index는 stack의 위치를 저장할 변수로, 0으로 초기화한다.           0부터 length 이하까지 i를 증가시키며 아래를 반복한다.            stack[index]의 값에 $i + 1$을 넣어주고 index를 증가시킨다.       i가 마지막 위치인 length이거나 pattern의 i번째 문자가 ‘I’인 경우, index가 0보다 클 때까지 index를 감소시킨 후 sb에 stack[index] 값을 넣어 num 문자열을 만들어준다.           반복이 완료되면 완성된 문자열 sb를 문자열로 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/construct-smallest-number-from-di-string/",
        "teaser": null
      },{
        "title": "Leetcode Java The k-th Lexicographical String of All Happy Strings of Length n",
        "excerpt":"문제  Link   코드  class Solution {    public String getHappyString(int n, int k) {     int shift = 1 &lt;&lt; (n - 1);     if (k &gt; 3 * shift) {       return \"\";     } else {       int c = 'a' + ((k - 1) / shift);       StringBuilder sb = new StringBuilder(Character.toString(c));       while (shift &gt; 1) {         k = ((k - 1) % shift) + 1;         shift &gt;&gt;= 1;         if ((k - 1) / shift == 0) {           c = c == 'a' ? 'b' : 'a';         } else {           c = c == 'c' ? 'b' : 'c';         }         sb.append((char) c);       }       return sb.toString();     }   }  }   결과  Link   설명     아래 규칙을 만족하는 n 길이의 사전적인 순서가 k 번째 문자열을 생성하는 문제이다.            문자열은 ‘a’, ‘b’, ‘c’로 구성된다.       붙어있는 두 문자는 동일할 수 없다.                shift는 1의 비트를 $n - 1$번 좌측으로 이동시킨 값을 저장한 변수다.            k가 $3 \\times shift$ 값을 초과하는 조건을 만족하는 문자열 생성이 불가능한 경우, 빈 문자열을 주어진 문제의 결과로 반환한다.       k가 $3 \\times shift$ 값 이하인 조건을 만족하는 문자열 생성이 가능한 경우, 아래를 수행한다.            문자열 생성에 필요한 변수를 정의한다.                    c는 $’a’ + \\frac{k - 1}{shift}$인 처음 시작할 수 있는 작은 문자의 아스키 코드 10진수 값을 넣어준다.           sb는 결과 문자열 생성에 필요한 변수로, 동적 문자열 생성을 위한 StringBuilder로 초기화하고 c를 첫 문자로 넣어준다.                       shift가 1 초과일 때까지 아래를 반복한다.                    k에 $\\frac{k - 1}{shift}$의 나머지 값에 1을 더한 값을 넣어 다음 문자열의 순서를 저장한다.           shift의 비트를 우측으로 한 칸 이동시켜 수행 횟수를 차감한다.           $\\frac{k - 1}{shift}$의 값이 0인 경우, c에 c가 ‘a’면 ‘b’의 값을 그 외는 ‘a’의 값을 넣어 다음 문자를 저장한다.           $\\frac{k - 1}{shift}$의 값이 0이 아닌 경우, c에 c가 ‘c’면 ‘b’의 값을 그 외는 ‘c’의 값을 넣어 다음 문자를 저장한다.           sb에 c를 문자로 변환하여 넣어주고 다시 반복한다.                           반복이 완료되면 완성된 sb를 문자열로 반환하여 주어진 문제의 결과로 반환한다.   해설     길이가 n인 문자열은 $3 \\times 2^(n - 1)$개의 문자열을 만들 수 있으므로, 생성 가능한지 여부는 상한 값을 1의 비트를 $n - 1$번 좌측으로 이동시킨 값으로 설정 가능하다.   shift를 감소시키면서 $\\frac{k - 1}{shift}$의 값이 0인지 검증하는 이유는, 다음 문자의 순서에 따라 문자가 결정 가능하여 동일한 문자를 반복하여 넣지 않게 할 수 있다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Elements in a Contaminated Binary Tree",
        "excerpt":"문제  Link   코드  /**  * Definition for a binary tree node.  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode() {}  *     TreeNode(int val) { this.val = val; }  *     TreeNode(int val, TreeNode left, TreeNode right) {  *         this.val = val;  *         this.left = left;  *         this.right = right;  *     }  * }  */ class FindElements {    private BitSet bitSet;    public FindElements(TreeNode root) {     root.val = 0;     this.bitSet = new BitSet();     this.bfs(root);   }    public boolean find(int target) {     return this.bitSet.get(target);   }    private void bfs(TreeNode node) {     this.bitSet.set(node.val);     if (node.left != null) {       node.left.val = (2 * node.val) + 1;       this.bfs(node.left);     }     if (node.right != null) {       node.right.val = (2 * node.val) + 2;       this.bfs(node.right);     }   }  }  /**  * Your FindElements object will be instantiated and called as such:  * FindElements obj = new FindElements(root);  * boolean param_1 = obj.find(target);  */   결과  Link   설명     모든 값이 -1로 변환된 이진 트리의 구조가 입력되면 아래의 규칙을 만족하는 값을 가진 이진 트리로 복구하는 객체를 완성하는 문제이다.            root의 val 값은 0이다.       treeNode의 값이 x이고 left 노드가 null이 아닌 경우, left 노드의 val 값은 $2 \\times x + 1$ 값이 된다.       treeNode의 값이 x이고 right 노드가 null이 아닌 경우, right 노드의 val 값은 $2 \\times x + 2$ 값이 된다.       생성자인 FindElements(TreeNode root)는 오염된 객체를 초기화하고 복구한다.       메서드인 find(int target)는 복구된 이진 트리에서 target 값이 존재하는지 검증한다.                전역 변수인 bitSet은 비트 단위로 값을 저장하고 해당 값이 존재하는지 여부를 저장할 변수이다.       생성자인 FindElements(TreeNode root)를 완성한다.            root의 val 값을 0으로 넣어준다.       bitSet에 값 존재를 검증하기 효율적인 객체인 BitSet으로 초기화한다.       4번에서 정의한 bfs(TreeNode node) 메서드를 수행하여 이진 트리를 복구한다.           BFS 방식으로 이진 트리를 복구하기 위한 bfs(TreeNode node) 메서드를 정의한다.            bitSet에 node의 val 값을 넣어준다.       node의 left 노드가 존재하는 경우, 해당 노드의 val 값에 $(2 \\times x) + 1$을 넣어준 후 해당 노드로 재귀 호출을 수행한다.       node의 right 노드가 존재하는 경우, 해당 노드의 val 값에 $(2 \\times x) + 2$을 넣어준 후 해당 노드로 재귀 호출을 수행한다.           메서드인 find(int target)를 완성한다.            bitSet에서 target 값이 존재하는지 여부를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-elements-in-a-contaminated-binary-tree/",
        "teaser": null
      },{
        "title": "Leetcode Java Replace the Substring for Balanced String",
        "excerpt":"문제  Link   코드  class Solution {    public int balancedString(String s) {     int[] counts = new int[128];     for (char c : s.toCharArray()) {       counts[c]++;     }     int length = s.length();     int max = length / 4;     int result = length;     int i = 0;     for (int j = 0; j &lt; length; j++) {       counts[s.charAt(j)]--;       while (i &lt; length &amp;&amp; counts['Q'] &lt;= max &amp;&amp; counts['W'] &lt;= max &amp;&amp; counts['E'] &lt;= max &amp;&amp; counts['R'] &lt;= max) {         result = Math.min(result, j - i + 1);         counts[s.charAt(i++)]++;       }     }     return result;   }  }   결과  Link   설명          ‘Q’, ‘W’, ‘E’, ‘R’ 문자로 구성된 문자열 s가 균등한 문자의 배분이 되도록 하기 위한 최소 부분 문자열의 길이를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            counts는 각 문자의 갯수를 계산하기 위한 변수로, 128 크기의 정수 배열로 초기화하고 s의 각 문자 갯수를 넣어준다.       length는 s의 길이를 저장한 변수이다.       max는 각 문자의 상한 갯수를 저장할 변수로, $\\frac{length}{4}$로 초기화한다.       result는 결과를 저장할 변수로, 최대 부분 문자열의 길이인 length로 초기화한다.       i는 변환 문자의 시작 부분을 저장할 변수로, 0으로 초기화한다.           0부터 length 미만까지 j를 증가시키며 아래를 반복한다.            counts 내 s의 j번째 문자에 해당하는 갯수를 감소시킨다.       i가 length 미만이면서, counts 내 ‘Q’, ‘W’, ‘E’, ‘R’의 해당하는 갯수가 max 이하일 때 까지 아래를 반복한다.                    result에 result와 $j - i + 1$ 중 변환 갯수 중 작은 값을 저장한다.           counts의 s내 i번째 문자에 해당하는 값을 증가시켜 변환 갯수를 복구시켜주고, i도 증가시켜 다음 문자열로 이동시켜준다.                           반복이 완료되면 최소 부분 문자열의 길이가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/replace-the-substring-for-balanced-string/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Positive Integer Solution for a Given Equation",
        "excerpt":"문제  Link   코드  /*  * // This is the custom function interface.  * // You should not implement it, or speculate about its implementation  * interface CustomFunction {  *     // Returns f(x, y) for any given positive integers x and y.  *     // Note that f(x, y) is increasing with respect to both x and y.  *     // i.e. f(x, y) &lt; f(x + 1, y), f(x, y) &lt; f(x, y + 1)  *     public int f(int x, int y);  * };  */ class Solution {    public List&lt;List&lt;Integer&gt;&gt; findSolution(CustomFunction customfunction, int z) {     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     int x = 1;     int y = 1000;     while (x &lt;= 1000 &amp;&amp; y &gt; 0) {       int value = customfunction.f(x, y);       if (value &lt; z) {         x++;       } else if (value &gt; z) {         y--;       } else {         result.add(Arrays.asList(x++, y--));       }     }     return result;   }  }   결과  Link   설명     숨겨진 함수인 f(x, y)의 결과 값 z를 이용하여 양의 정수 쌍 x와 y을 유추하여 어떠한 순서로든 반환하는 문제이다.            정확한 공식은 숨어있지만, 값은 아래와 같이 단조롭게 증가한다.                    $f(x, y) &lt; f(x + 1, y)$           $f(x, y) &lt; f(x, y + 1)$                           문제 풀이에 필요한 변수를 정의한다.            result는 유추된 값들을 저장할 변수로, ArrayList로 초기화한다.       x와 y는 값의 하한값과 상한값을 저장할 변수로, 1과 1000으로 초기화한다.           x가 1000 이하이면서 y가 0 초과일 때 까지 아래를 반복한다.            value는 customfunction 내 f(x, y) 함수를 수행한 결과를 넣어준다.       value가 z 미만이면 x를 증가시키고, z 초과이면 y를 감소시켜준다.       value가 z와 동일한 경우, result에 x와 y를 쌍으로 넣어준 후 x를 증가시키고 y를 감소시켜준다.           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-positive-integer-solution-for-a-given-equation/",
        "teaser": null
      },{
        "title": "Leetcode Java Circular Permutation in Binary Representation",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; circularPermutation(int n, int start) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     for (int i = 0; i &lt; 1 &lt;&lt; n; i++) {       result.add(start ^ i ^ i &gt;&gt; 1);     }     return result;   }  }   결과  Link   설명          start부터 시작해서 다음부터 1 비트씩 다른 n 길이의 비트 길이의 숫자들을 반환하는 문제이다.            result는 결과를 넣을 변수로, ArrayList로 초기화한다.       0부터 1을 n만큼 비트를 이동시킨 값 미만까지 i를 증가시키며 아래를 반복한다.            result에 start와 i 두 개를 XOR(^) 비트 연산을 수행한 값을 좌측으로 한 번 비트를 이동시킨 값을 넣어준다.           반복을 통해 숫자들을 저장한 result를 주어진 문제의 결과로 반환한다.   참고     자세한 설명은 Gray Code를 읽어본다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/circular-permutation-in-binary-representation/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Sub-arrays With Odd Sum",
        "excerpt":"문제  Link   코드  class Solution {    public int numOfSubarrays(int[] arr) {     int result = 0;     int odd = 0;     for (int i = 0; i &lt; arr.length; i++) {       if (arr[i] % 2 == 1) {         odd = i - odd + 1;       }       result = (result + odd) % 1000000007;     }     return result;   }  }   결과  Link   설명     arr 내 홀수로 이루어진 값들로 만든 부분 배열의 합이 홀수인 값들의 갯수를 계산하는 문제이다.            값이 매우 클 수 있으므로, 모듈러 $10^9 + 7$을 적용한다.           문제 풀이에 필요한 변수를 정의한다.            result는 결과를 저장할 변수로, 0으로 초기화한다.       odd는 홀수인 하위 배열의 갯수를 저장할 변수로, 0으로 초기화한다.           0부터 arr 길이 미만까지 i를 증가시키며 아래를 반복한다.            arr[i]의 값이 홀수인 경우, odd에 $i - odd + 1$인 이전까지 홀수의 부분 배열의 갯수를 증가시켜 넣어 준다.       result에 $result + odd$에 모듈러 $10^9 + 7$을 적용한 값을 넣어준다.           반복이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-sub-arrays-with-odd-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Absolute Sum of Any Subarray",
        "excerpt":"문제  Link   코드  class Solution {    public int maxAbsoluteSum(int[] nums) {     int sum = 0;     int max = 0;     int min = 0;     for (int num : nums) {       sum += num;       max = Math.max(max, sum);       min = Math.min(min, sum);     }     return max - min;   }  }   결과  Link   설명          nums 내 부분 배열 중 값들의 합에 대한 절댓값이 가장 큰 값을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            sum은 합계를 저장할 변수로, 0으로 초기화한다.       max와 min은 최댓값과 최솟값을 저장할 변수로, 둘 다 0으로 초기화한다.           nums의 값들을 순차적으로 num에 넣어 아래를 수행한다.            sum에 num을 더해준다.       max와 min에 sum과 자기 자신 중 최댓값과 최솟값을 넣어준다.           반복이 완료되면 $max - min$을 통해 부분 배열의 합이 가장 큰 값과 가장 작은 값의 차잇값을 주어진 문제의 결과로 반환한다.   해설     배열의 시작부터 합이 가장 크고 작은 위치는 값의 차이에 대한 폭이 가장 크므로, 그 값을 먼저 찾는다.   위 두 지점 중 시작부터 가까운 지점까지의 부분 배열을 제외하고, 그 다음 값부터 다음 지점까지 부분 배열이 원하는 조건인 값들의 합에 대한 절댓값이 가장 큰 값이된다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-absolute-sum-of-any-subarray/",
        "teaser": null
      },{
        "title": "Spring Retry",
        "excerpt":"Spring Retry1     Spring Project를 구성하다보면 비즈니스 로직이 정상적으로 이루어지지 않는 경우에 대한 재시도 및 오류 처리에 대한 로직을 구현할 필요가 있다.   Spring Retry는 Spring Batch Project에서 파생되어, 현재는 분리되어 단독으로 발전해가는 프로젝트이다.   Dependency  &lt;dependency&gt;   &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;   &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;   &lt;version&gt;2.0.11&lt;/version&gt; &lt;/dependency&gt;  implementation 'org.springframework.retry:spring-retry:2.0.11'     일반적으로 “spring-retry”에 대한 maven dependency로 추가 혹은 gradle implementation하여 사용할 수 있다.   최신 Spring Boot 프로젝트에서는 버전을 명시하지 않으면, 해당 parents에 정의된 버전으로 사용할 수 있다.   @Retryable &amp; @Recover  @Service public interface SqlService {    @Retryable(retryFor = SQLException.class, maxAttempts = 3, backoff = @Backoff(delay = 100))   void execute(String sql);    @Recover   void recover(SQLException e, String sql);  }     @Retryable은 특정 비즈니스 로직 내 오류가 발생했을 때, 해당 메서드의 재시도를 수행할 수 있도록 정의하는 어노테이션이다.            retryFor는 특정 오류 상황이 발생하였을 때 재 시도 하도록 정의하는 속성이다.       maxAttempts는 retryFor 내 정의된 오류가 발생했을 때 최대 반복 횟수를 정의하는 속성이다.       backoff는 재 시도 수행 간 지연 시간을 정의하는 속성이다.           @Recover는 @Retryable 어노테이션을 정의한 메서드가 실패하였을 경우, 최종 오류에 대한 제어 및 복구를 위해 제공되는 어노테이션이다.   public interface FileService {    @Retryable(retryFor = IOException.class, maxAttemptsExpression = \"${retry.maxAttempts}\", backoff = @Backoff(delayExpression = \"${retry.maxDelay}\"))   void write(String path, String body);  }     maxAttempts와 backoff를 application.yml 혹은 application.properties 내 정의하여 코드를 수정하지 않아도 동적으로 변경 가능하도록 하는 maxAttemptsExpression 속성과 delayExpression 속성 또한 제공된다.   RetryTemplate  @Configuration public class RetryTemplateConfig {    @Bean   RetryTemplate retryTemplate(     @Value(\"${retry.maxAttempts}\") int maxAttempts,     @Value(\"${retry.maxDelay}\") long backoff   ) {     RetryTemplate retryTemplate = new RetryTemplate();     FixedBackOffPolicy fixedBackOffPolicy = new FixedBackOffPolicy();     fixedBackOffPolicy.setBackOffPeriod(backoff);     retryTemplate.setBackOffPolicy(fixedBackOffPolicy);     SimpleRetryPolicy retryPolicy = new SimpleRetryPolicy();     retryPolicy.setMaxAttempts(maxAttempts);     retryTemplate.setRetryPolicy(retryPolicy);     retryTemplate.registerListener(new CustomRetryListener());     return retryTemplate;   }  }     @Retryable 어노테이션 뿐 아니라, RetryTemplate을 통해서 비즈니스 수행을 원하는 정책에 따라 재시도할 수 있다.   RetryListener  public class CustomRetryListener implements RetryListener {    public &lt;T, E extends Throwable&gt; void close(RetryContext context, RetryCallback&lt;T, E&gt; callback, Throwable throwable) {     // Something to close.   }    public &lt;T, E extends Throwable&gt; void onError(RetryContext context, RetryCallback&lt;T, E&gt; callback, Throwable throwable) {     // Something on error.   }    public &lt;T, E extends Throwable&gt; boolean open(RetryContext context, RetryCallback&lt;T, E&gt; callback) {     // Something to open.     return true;   }  }     Retry 시도에 따라 각 상황 별 추가 로깅, 비즈니스 로직들을 추가할 수 있다.   @Retryable 어노테이션과 RetryTemplate 모두 해당 Listener를 주입하여 활용할 수 있다.   Conclusion     장애 상황에 따른 복구와 대처 방안은 항상 최악의 상황을 대비할 수 있는 서비스 안정성에 기여가 된다.   만일 API 서비스가 Cloud 혹은 On-Premise 환경 내 API 서비스만 존재한다고 가정하면 한 환경의 장애로 서비스가 단절될 수 있지만, 이렇게 Circuit Breaker 역할을 수행할 수 있는 기능들이 존재하면 RPO(Recovery Point Objective)와 RTO(Recovery Time Objective)를 현저히 줄일 수 있을 것이다.   안정적인 서비스는 사용자의 편의성과 신뢰도를 바탕으로, 더욱 발전하는 서비스가 될 기회를 맞이할 것이다.   Reference   ※ Sample Code는 여기에서 확인 가능합니다.                 Spring Retry Project &#8617;           ","categories": ["Spring"],
        "tags": ["Programming","Spring","Retry"],
        "url": "/spring/spring-retry/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Swaps to Make Strings Equal",
        "excerpt":"문제  Link   코드  class Solution {    public int minimumSwap(String s1, String s2) {     char[] s1CharArray = s1.toCharArray();     char[] s2CharArray = s2.toCharArray();     int x = 0;     int y = 0;     for (int i = s1.length() - 1; i &gt;= 0; i--) {       if (s1CharArray[i] == 'x' &amp;&amp; s2CharArray[i] == 'y') {         x++;       } else if (s1CharArray[i] == 'y' &amp;&amp; s2CharArray[i] == 'x') {         y++;       }     }     if (x % 2 != y % 2) {       return -1;     } else {       int result = (x / 2) + (y / 2);       if (x % 2 == 1) {         result += 2;       }       return result;     }   }  }   결과  Link   설명     s1과 s2 문자열의 문자를 스왑하여 동일한 문자열로 변환하기 위한 최소 횟수를 구하는 문제이다.            단, 변환이 불가능하면 -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            s1CharArray와 s2CharArray는 s1과 s2를 문자 배열로 변환한 변수이다.       x와 y는 s1에서 s2의 동일한 위치의 문자 중 x와 y가 다른 갯수를 저장할 변수로, 0으로 초기화하고 s1과 s2의 동일 자리의 문자가 다른 갯수를 계산해 넣어준다.                x와 y의 짝수 혹은 홀수로 동일하지 않은 동일한 문자열로 변환이 불가능한 경우, -1을 주어진 문제의 결과로 반환한다.       result에 $\\frac{x}{2} + \\frac{y}{2}$의 값을 넣어주고, x가 홀수인 문자 스왑을 추가해야 하는 경우에는 result에 2를 더 증가시킨 후 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-swaps-to-make-strings-equal/",
        "teaser": null
      },{
        "title": "Leetcode Java Apply Operations to an Array",
        "excerpt":"문제  Link   코드  class Solution {    public int[] applyOperations(int[] nums) {     int length = nums.length;     int index = 0;     for (int i = 0; i &lt; length; i++) {       if (i &lt; length - 1 &amp;&amp; nums[i] == nums[i + 1]) {         nums[i] *= 2;         nums[i + 1] = 0;       }       if (nums[i] != 0) {         if (i != index) {           int temp = nums[i];           nums[i] = nums[index];           nums[index] = temp;         }         index++;       }     }     return nums;   }  }   결과  Link   설명     nums 내 값들을 아래 규칙대로 수행하고 0이 아닌 값을 좌측으로 몰아 반환하는 문제이다.            nums[i] == nums[i + 1]의 경우, nums[i]의 값은 두 배로 증가시키고 nums[$i + 1$]의 값은 0으로 바꿔준다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       index는 0이 아닌 값이 존재하는 위치를 저장할 변수로, 0으로 초기화한다.           0부터 length 미만까지 i를 증가시키며 아래를 반복한다.            i의 값이 $length - 1$보다 작으면서 nums[i]의 값이 nums[$i + 1$]의 값과 동일하면, nums[i]의 값을 두 배로 증가시키고 nums[$i + 1$]의 위치에 0을 넣어준다.       nums[i]의 값이 0이 아닌 경우, 아래를 수행한다.                    i가 index와 다른 경우, nums[i]의 값과 nums[index]의 값을 바꾸어준다.           index를 증가시켜 다음 위치로 이동시켜준다.                           반복이 완료되어 수정된 배열 nums를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/apply-operations-to-an-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Merge Two 2D Arrays by Summing Values",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {     int nums1Length = nums1.length;     int nums2Length = nums2.length;     int i = 0;     int j = 0;     List&lt;int[]&gt; result = new ArrayList&lt;&gt;();     while (i &lt; nums1Length &amp;&amp; j &lt; nums2Length) {       if (nums1[i][0] == nums2[j][0]) {         result.add(new int[] { nums1[i][0], nums1[i++][1] + nums2[j++][1] });       } else if (nums1[i][0] &lt; nums2[j][0]) {         result.add(nums1[i++]);       } else {         result.add(nums2[j++]);       }     }     while (i &lt; nums1Length) {       result.add(nums1[i++]);     }     while (j &lt; nums2Length) {       result.add(nums2[j++]);     }     return result.toArray(new int[result.size()][]);   }  }   결과  Link   설명     아래의 규칙대로 구성된 nums1과 nums2 배열을 키 기준으로 값을 합쳐서 반환하는 문제이다.            nums1과 nums2는 첫번째 값이 키이고, 두 번째 값으로 구성되어 있다.       nums1과 nums2는 키 기준으로 오름차순 정렬되어 있다.           문제 풀이에 필요한 변수를 정의한다.            nums1Length와 nums2Length는 num1과 num2의 길이를 저장한 변수이다.       i와 j는 num1과 num2 내 위치를 계산할 변수로, 0으로 초기화한다.       result는 주어진 기준 내 키에 대한 값들의 합을 저장할 변수로, 합친 키의 갯수가 불분명하여 ArrayList로 초기화한다.           i가 nums1Length 미만이고, j가 nums2Length 미만일 때 까지 아래를 반복한다.            nums1[i][0]의 값과 nums2[j][0]의 값이 동일한 경우, result에 nums1[i][0]의 값과 $nums1[i][1] + nums2[j][1]$ 값을 배열로 넣어주고 i와 j를 증가시킨다.       nums1[i][0]의 값이 nums2[j][0]의 값보다 작은 경우, result에 nums1[i] 배열을 넣어주고 i를 증가시킨다.       nums1[i][0]의 값이 nums2[j][0]의 값보다 큰 경우, result에 nums2[j] 배열을 넣어주고 j를 증가시킨다.                i가 nums1Length 미만일 때 까지 result에 nums1[i] 배열을 넣어주면서 i를 증가시켜 남은 배열을 넣어준다.            j가 nums1Length 미만일 때 까지 result에 nums2[j] 배열을 넣어주면서 i를 증가시켜 남은 배열을 넣어준다.       반복이 완료되면 result를 해당 길이 크기의 정수 배열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/merge-two-2d-arrays-by-summing-values/",
        "teaser": null
      },{
        "title": "Leetcode Java Partition Array According to Given Pivot",
        "excerpt":"문제  Link   코드  class Solution {    public int[] pivotArray(int[] nums, int pivot) {     int length = nums.length;     int[] result = new int[length];     int i = 0;     int j = 0;     int k = 0;     for (int num : nums) {       if (num &lt;= pivot) {         k++;         if (num &lt; pivot) {           j++;         }       }     }     for (int num : nums) {       if (num &lt; pivot) {         result[i++] = num;       } else if (num &gt; pivot) {         result[k++] = num;       } else {         result[j++] = num;       }     }     return result;   }  }   결과  Link   설명     nums 내 값들을 pivot 기준으로 정렬하는 문제이다.            임의 i 위치에서 nums[i]의 값이 pivot 값 초과인 경우, nums의 우측으로 값을 이동한다.       임의 i 위치에서 nums[i]의 값이 pivot 값과 동일한 경우, pivot 값 미만인 값과 초과인 값 사이에 위치시킨다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       result는 조건에 만족한 값들을 정렬하여 저장할 변수로, length 길이의 정수 배열로 초기화한다.       i, j, k는 pivot 값 미만, 동일, 초과의 값들을 저장할 위치 변수로, 모두 0으로 초기화한다.           nums의 값들을 순차적으로 num에 넣어, 아래를 수행한다.            num이 pivot 미만이면 j만 증가시키고, pivot 이하이면 k도 증가시킨다.           다시 nums의 값들을 순차적으로 num에 넣어, 아래를 수행한다.            num이 pivot 값 미만인 경우, result[i] 위치에 num을 넣고 i를 증가시킨다.       num이 pivot 값 초과인 경우, result[k] 위치에 num을 넣고 k를 증가시킨다.       num이 pivot 값과 동일한 경우, result[j] 위치에 num을 넣고 j를 증가시킨다.           반복이 완료되면 정렬된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/partition-array-according-to-given-pivot/",
        "teaser": null
      },{
        "title": "Leetcode Java Check if Number is a Sum of Powers of Three",
        "excerpt":"문제  Link   코드  class Solution {    public boolean checkPowersOfThree(int n) {     while (n &gt; 0) {       if (n % 3 == 2) {         return false;       }       n /= 3;     }     return true;   }  }   결과  Link   설명          n을 3의 배수를 최대 한 번씩 사용한 합으로 구성된 숫자인지 검증하는 문제이다.       n이 0 초과일 때 까지 아래를 반복한다.            n을 3으로 나눈 나머지가 2인 3의 공약수가 아닌 3의 배수를 최대 한 번씩 사용하여 구성할 수 없는 숫자인 경우, false를 주어진 문제의 결과로 반환한다.       n을 3으로 나눈 값을 다시 넣어준다.           반복이 완료되면 주어진 조건을 충족하는 숫자이므로, true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/check-if-number-is-a-sum-of-powers-of-three/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Total Number of Colored Cells",
        "excerpt":"문제  Link   코드  class Solution {    public long coloredCells(int n) {     return 1 + (4L * (n * (n - 1) / 2));   }  }   결과  Link   설명          1분에 가운데 하나의 정사각형으로 시작하여, 시간의 흐름에 따라 마름모 모양으로 사각형이 상하좌우 및 대각선 방향으로 증식한다. n 분 이후 해당 사각형의 갯수를 계산하는 문제이다.            처음 하나부터 시작하여 네 방면으로 4의 배수만큼 증식하므로, $1 + 4 \\times \\frac{n \\times (n - 1)}{2}$의 값을 주어진 문제의 결과로 반환한다.             $n \\times (n - 1)$ 값이 매우 클 수 있으므로, 4를 long타입으로 적용하여 같이 계산해준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-total-number-of-colored-cells/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Total Number of Colored Cells",
        "excerpt":"문제  Link   코드  class Solution {    public int[] findMissingAndRepeatedValues(int[][] grid) {     int length = grid.length;     int[] result = new int[2];     int[] counts = new int[(length * length) + 1];     for (int[] row : grid) {       for (int value : row) {         if (counts[value] == 1) {           result[0] = value;         } else {           counts[value]++;         }       }     }     for (int i = 1; i &lt; counts.length; i++) {       if (counts[i] == 0) {         result[1] = i;         break;       }     }     if (result[1] == 0) {       result[1] = counts.length;     }     return result;   }  }   결과  Link   설명          2차원 정사각형 크기의 배열 grid 내 두 번 존재하는 값과 누락된 값을 찾아 배열로 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 grid의 길이를 저장한 변수이다.       result는 결과를 저장할 변수로, 두 값을 반환하기 위해 2 크기의 정수 배열로 초기화한다.       counts는 grid 내 값의 갯수를 계산하기 위한 변수로, 1-index 기준으로 값의 상한 값까지 들어가기 위해 $(length \\times length) + 1$ 크기의 정수 배열로 초기화하한다.                grid 내 첫 행부터 마지막 행까지 첫 열부터 마지막 열까지 순차적으로 값들을 탐색하면 중복된 값이 존재하는 경우, result[0]에 해당 값을 넣어주면서 counts 배열 내 값의 갯수를 계산한다.            1부터 counts 길이 미만까지 i를 증가시키며, count[i]의 값이 0인 값을 찾아 result[1]에 넣어주고 반복을 중지시킨다.            result[1]의 값이 0인 누락된 값이 존재하지 않는 경우, result[1]에 counts.length인 다음 가능한 값을 넣어준다.       모든 수행이 완료되어 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-missing-and-repeated-values/",
        "teaser": null
      },{
        "title": "Leetcode Java Closest Prime Numbers in Range",
        "excerpt":"문제  Link   코드  class Solution {    public int[] closestPrimes(int left, int right) {     List&lt;Integer&gt; primes = new ArrayList&lt;&gt;();     for (int i = left; i &lt;= right; i++) {       if (2 &lt; i &amp;&amp; i % 2 == 0) {         continue;       }       if (this.isPrime(i)) {         if (!primes.isEmpty() &amp;&amp; i &lt;= primes.get(primes.size() - 1) + 2) {           return new int[] { primes.get(primes.size() - 1), i };         }         primes.add(i);       }     }     if (primes.size() &lt; 2) {       return new int[] { -1, -1 };     }     int[] result = new int[2];     int min = Integer.MAX_VALUE;     for (int i = 1; i &lt; primes.size(); i++) {       int diff = primes.get(i) - primes.get(i - 1);       if (diff &lt; min) {         min = diff;         result[0] = primes.get(i - 1);         result[1] = primes.get(i);       }     }     return result;   }    private boolean isPrime(int number) {     if (number == 1) {       return false;     } else {       for (int i = 2; i &lt;= (int) Math.sqrt(number); i++) {         if (number % i == 0) {           return false;         }       }       return true;     }   }  }   결과  Link   설명     [left, right] 범위 내 값들 중 가장 인접한 두 소수값을 배열로 반환하는 문제이다.            단, 소수가 2개 미만이면 -1을 배열 값에 모두 넣어 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            primes는 소수값을 넣을 변수로, ArrayList로 초기화하여 left부터 right까지 범위 내 소수값들을 전부 넣어준다.                    단, primes의 크기가 2 미만으로 결과가 존재하지 않으면 -1로 채운 2 크기의 정수 배열을 주어진 문제의 결과로 반환한다.                       result는 결과를 저장할 변수로, 2 크기의 정수 배열로 초기화한다.       min은 인접한 소수값의 차이가 최소인 값을 저장할 변수로, 정수의 가장 큰 값으로 초기화한다.           1부터 primes의 크기 미만까지 i를 증가시키며 아래를 반복한다.            diff에 primes의 i번째 값과 $i - 1$번째 값의 차잇값을 저장한다.       diff가 min 미만인 최솟값인 경우, min에 diff, result에 위 두 값을 작은 순서대로 넣어준다.           반복이 완료되어 가장 인접한 두 소수값이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/closest-prime-numbers-in-range/",
        "teaser": null
      },{
        "title": "Leetcode Java Alternating Groups II",
        "excerpt":"문제  Link   코드  class Solution {    public int numberOfAlternatingGroups(int[] colors, int k) {     int length = colors.length;     int result = 0;     int i = 0;     for (int j = 0; j &lt; length + k - 1; j++) {       if (0 &lt; j &amp;&amp; colors[j % length] == colors[(j - 1) % length]) {         i = j;       }       if (k &lt;= j - i + 1) {         result++;       }     }     return result;   }  }   결과  Link   설명     아래 규칙대로 구성된 정수 배열인 colors에서 k개의 인접한 색깔이 번갈아 나타난 횟수를 계산하는 문제이다.            0은 빨간색 타일을, 1은 파란색 타일을 의미한다.       colors의 값들을 원형으로 이어주므로, 첫 값과 마지막 값은 인접한 상태이다.           문제 풀이에 필요한 변수를 정의한다.            length는 colors의 길이를 저장한 변수이다.       result는 결과 갯수를 계산하기 위한 변수로, 0으로 초기화한다.       i는 인접한 색깔이 번갈아 나타나기 시작한 위치 값을 저장할 변수로, 0으로 초기화한다.           0부터 $length + k - 1$ 미만까지 j를 증가시키며 아래를 반복한다.            j가 0 초과이면서 colors 내 j를 length로 나눈 값의 나머지 위치의 값과 $j - 1$을 length로 나눈 값의 나머지 위치의 값이 동일한 경우, i에 j를 넣어 시작 위치를 이동한다.       k가 $j - i + 1$보다 작거나 같은 조건에 부합하는 경우, result를 증가시켜 갯수를 계산해준다.           반복이 완료되면 조건에 부합한 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/alternating-groups-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Substrings Containing All Three Characters",
        "excerpt":"문제  Link   코드  class Solution {    public int numberOfSubstrings(String s) {     char[] charArray = s.toCharArray();     int length = charArray.length;     int[] lastIndex = new int[] { -1, -1, -1 };     int result = 0;     for (int i = 0; i &lt; length; i++) {       lastIndex[charArray[i] - 'a'] = i;       result += 1 + Math.min(lastIndex[0], Math.min(lastIndex[1], lastIndex[2]));     }     return result;   }  }   결과  Link   설명          문자열 s에서 a, b, c 문자가 최소 하나 이상 포함된 연속된 부분 문자열의 갯수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            charArray는 s를 문자 배열로 변환한 변수이다.       length는 charArray의 길이를 저장한 변수이다.       lastIndex는 a, b, c 각 위치 별 마지막 위치를 저장할 변수로, 3 크기의 정수 배열로 정의하고 모든 값을 -1로 초기화한다.       result는 결과인 부분 문자열의 갯수를 계산할 변수로, 0으로 초기화한다.           0부터 length 미만까지 i를 증가시키며 아래를 반복한다.            lastIndex의 charArray[i] 문자에 해당하는 영문자 순서 위치에 i를 넣어준다.       restul에 lastIndex의 a, b, c 문자에 해당하는 위치 중 가장 작은 값에 1을 더한 값을 더해준다.           반복이 완료되면 부분 문자열의 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-substrings-containing-all-three-characters/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Count of Positive Integer and Negative Integer",
        "excerpt":"문제  Link   코드  class Solution {    public int maximumCount(int[] nums) {     return Math.max(this.binarySearch(nums, 0), nums.length - this.binarySearch(nums, 1));   }    private int binarySearch(int[] nums, int target) {     int left = 0;     int right = nums.length;     while (left &lt; right) {       int mid = left + (right - left) / 2;       if (nums[mid] &lt; target) {         left = mid + 1;       } else {         right = mid;       }     }     return right;   }  }   결과  Link   설명          오름차순 정렬된 정수 배열인 nums 내 양의 정수와 음의 정수 갯수 중 가장 많은 정수의 갯수를 반환하는 문제이다.       이진 탐색을 수행할 binarySearch(int[] nums, int target) 메서드를 정의한다.            left와 right는 nums의 위치 탐색을 위한 시작과 종료 위치를 저장할 변수로, 0과 nums의 길이로 초기화한다.       left가 right 미만일 때 까지 아래를 수행한다.                    mid에 $left + \\frac{right - left}{2}$인 중앙값을 넣어준다.           nums[mid]의 값이 target 미만이면 left에 $mid + 1$을, 아니면 right에 mid를 넣어 범위를 좁혀준다.                           아래의 두 값 중 큰 값인 가장 많은 정수의 갯수를 주어진 문제의 결과로 반환한다.            2번의 binarySearch(int[] nums, int target) 메서드를 nums와 0을 넣어 수행한 음의 정수 갯수.       nums의 길이에서 2번의 binarySearch(int[] nums, int target) 메서드를 nums와 1을 넣어 수행한 0 이하의 정수 갯수를 뺀 양의 정수 갯수.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-count-of-positive-integer-and-negative-integer/",
        "teaser": null
      },{
        "title": "Leetcode Java Zero Array Transformation II",
        "excerpt":"문제  Link   코드  class Solution {    public int minZeroArray(int[] nums, int[][] queries) {     int length = nums.length;     int sum = 0;     int result = 0;     int[] counts = new int[length + 1];     for (int i = 0; i &lt; length; i++) {       while (sum + counts[i] &lt; nums[i]) {         if (result == queries.length) {           return -1;         } else {           int l = queries[result][0];           int r = queries[result][1];           int val = queries[result][2];           result++;           if (i &lt;= r) {             counts[Math.max(l, i)] += val;             counts[r + 1] -= val;           }         }       }       sum += counts[i];     }     return result;   }  }   결과  Link   설명     정수 배열로 이루어진 nums를 이용하여 아래 규칙대로 적용하여 모든 값이 0이 되기 위한 queries의 위치를 찾는 문제이다.            queries[i] = [li, ri, vali]로,  [li, ri] 범위 내 값들을 vali만큼 감소시킨다는 의미이다.       각 감소되는 위치 별 값은 0 미만으로 내려가지 않는다.       해당 위치가 존재하지 않는 경우, -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       sum은 위치 별 감소될 값을 합쳐 저장할 변수로, 0으로 초기화한다.       result는 nums의 모든 값을 0으로 되기까지 적용한 queries의 위치를 계산할 변수로, 0으로 초기화한다.       counts는 각 위치 별 차감되는 갯수를 누계하기 위한 변수로, $length - 1$크기의 정수 배열로 초기화한다.           0부터 length 미만까지 i를 증가시키면서 아래를 반복한다.            $sum + counts[i]$의값이 nums[i] 미만인 차감 가능할 때 까지 아래를 반복한다.                    result가 queries의 길이와 동일한 모든 쿼리 수행이 완료된 경우, 모든 위치의 값이 0으로 될 수 없으므로 -1을 주어진 문제의 결과로 반환한다.           위의 경우가 아니라면 l, r, val에 queries[result]의 값들을 순차적으로 넣고 result를 증가시킨 후, i가 r보다 작다면 counts 내 l과 i 중 큰 값에 해당하는 위치에 val을 더해주고, counts[$r + 1$]의 값을 val만큼 감소시켜준다.                       sum에 counts[i]의 값을 더해 감소되는 값을 증가시켜준다.           반복이 완료되면 적용된 queries의 갯수인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/zero-array-transformation-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java House Robber IV",
        "excerpt":"문제  Link   코드  class Solution {    public int minCapability(int[] nums, int k) {     int left = Integer.MAX_VALUE;     int right = 0;     for (int num : nums) {       left = Math.min(left, num);       right = Math.max(right, num);     }     int length = nums.length;     while (left &lt; right) {       int mid = left + (right - left) / 2;       int count = 0;       int i = 0;       while (i &lt; length) {         if (nums[i++] &lt;= mid) {           count++;           i++;         }       }       if (count &gt;= k) {         right = mid;       } else {         left = mid + 1;       }     }     return left;   }  }   결과  Link   설명          nums는 각 집에 보유한 달러를 저장한 배열로 인접하지 않은 k개 집을 털 때, 최대 털수 있는 달러의 경우 중 가장 최소로 털 수 있는 달러를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            left와 right는 탐색에 필요한 위치 변수로, nums의 최솟값과 최댓값을 넣어준다.       length는 nums의 길이를 저장한 변수이다.           left가 right 미만일 때 까지 아래를 반복한다.            mid에 $left + \\frac{right - left}{2}$인 중앙값을 넣어준다.       count는 턴 집의 갯수를 저장할 변수로, 0으로 초기화한다.       i는 nums의 위치 변수로, 0으로 초기화한다.       i가 length 미만까지 아래를 반복한다.                    nums[i]의 값이 mid 이하인 경우, count와 i를 증가시키고 i를 다시 증가시켜준다.           count가 k 이상인 조건에 충저한 경우, right에 mid를 넣고 그렇지 않으면 left에 $mid + 1$을 넣어 범위를 좁혀준다.                           반복이 완료되면 최소 달러인 left를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/house-robber-iv/",
        "teaser": null
      },{
        "title": "Leetcode Java House Robber IV",
        "excerpt":"문제  Link   코드  class Solution {    public boolean divideArray(int[] nums) {     int[] counts = new int[501];     for (int num : nums) {       counts[num]++;     }     for (int count : counts) {       if (count % 2 != 0) {         return false;       }     }     return true;   }  }   결과  Link   설명          짝수로 구성된 nums의 동일 숫자들을 짝으로 매칭시킬 수 있는지 검증하는 문제이다.            counts는 nums 내 값들의 갯수를 저장할 변수로, nums의 값들을 반복하여 갯수를 넣어준다.            counts의 각 값들을 순차적으로 반복하여 홀수개 존재하는 경우, 짝으로 매칭되는 값이 존재하므로 false를 주어진 문제의 결과로 반환한다.            반복이 완료되면 모든 값들이 짝으로 매칭될 수 있으므로, true를 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/divide-array-into-equal-pairs/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Nice Subarray",
        "excerpt":"문제  Link   코드  class Solution {    public int longestNiceSubarray(int[] nums) {     int result = 0;     int i = 0;     int and = 0;     for (int j = 0; j &lt; nums.length; j++) {       while ((and &amp; nums[j]) &gt; 0) {         and ^= nums[i++];       }       and |= nums[j];       result = Math.max(result, j - i + 1);     }     return result;   }  }   결과  Link   설명          nums 내 인근 값의 AND 비트 연산의 결과가 0이 되는 최대 부분 배열의 길이를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 최대 부분 배열의 길이를 저장할 변수로, 0으로 초기화한다.       i는 부분 배열의 시작 위치를 저장할 변수로, 0으로 초기화한다.       and는 인접한 두 값의 and 비트 연산의 결과를 계산할 변수로, 0으로 초기화한다.           0부터 nums의 길이 미만까지 j를 증가시키면서 아래를 반복한다.            and와 nums[j]의 AND 비트 연산의 결과가 0보다 클 때까지, and에 and와 nums[i]의 값을 XOR 비트 연산의 결과를 넣어주고 i를 증가시킨다.       and에 nums[j]인 현재 위치 값을 OR 비트 연산을 수행하여 넣어 마지막 값으로 저장한다.       result에 result와 $j - i + 1$인 현재까지 부분 배열의 길이 중 큰 값을 넣어준다.           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-nice-subarray/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Operations to Make Binary Array Elements Equal to One I",
        "excerpt":"문제  Link   코드  class Solution {    public int minOperations(int[] nums) {     int length = nums.length;     int count = 0;     for (int i = 0; i &lt;= length - 3; i++) {       if (nums[i] == 0) {         nums[i] ^= 1;         nums[i + 1] ^= 1;         nums[i + 2] ^= 1;         count++;       }     }     return nums[length - 1] == 0 || nums[length - 2] == 0 ? -1 : count;   }  }   결과  Link   설명     0과 1로 이루어진 이진 정수 배열 nums의 연속된 세 정수의 값을 플립(0에서 1 혹은 1에서 0)하여 모든 값을 1로 만들기 위한 최소 연산의 수를 구하는 문제이다.            단, 모든 값을 1로 만들 수 없다면 -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       count는 최소 연산 횟수를 구하기 위한 변수로, 0으로 초기화한다.           0부터  $length - 3$ 이하까지 i를 증가시키며 아래를 반복한다.            nums[i]의 값이 0인 경우, 해당 위치 값을 포함한 연속된 세 값을 각자 1과 XOR 비트 연산을 수행한 값을 넣어주고 count를 증가시켜준다.           반복이 완료되면, 마지막 두 값이 0이면 -1을, 아니면 count를 주어진 문제의 결과로 반환한다.   해설     각 자리 값을 1과 XOR 비트 연산을 수행하면 1은 0으로, 0은 1로 플립하게 된다.   처음부터 연속된 자리의 플립을 수행하는 중, 마지막 두 자리의 값이 0이 아니면 1이 아닌 값이 남게 되므로 절대 모든 값을 1로 만들 수 없다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-operations-to-make-binary-array-elements-equal-to-one-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Count the Number of Complete Components",
        "excerpt":"문제  Link   코드  class Solution {    public int countCompleteComponents(int n, int[][] edges) {     List&lt;Integer&gt;[] graph = new ArrayList[n];     for (int i = 0; i &lt; n; i++) {       graph[i] = new ArrayList&lt;&gt;();     }     for (int[] edge : edges) {       graph[edge[0]].add(edge[1]);       graph[edge[1]].add(edge[0]);     }     boolean[] visited = new boolean[n];     int result = 0;     for (int i = 0; i &lt; n; i++) {       if (!visited[i]) {         Set&lt;Integer&gt; set = new HashSet&lt;&gt;();         int count = this.dfs(graph, visited, set, i);         if (set.size() == 1 &amp;&amp; set.contains(count - 1)) {           result++;         }       }     }     return result;   }    private int dfs(List&lt;Integer&gt;[] graph, boolean[] visited, Set&lt;Integer&gt; set, int index) {     visited[index] = true;     set.add(graph[index].size());     int count = 1;     for (int neighbor : graph[index]) {       if (!visited[neighbor]) {         count += this.dfs(graph, visited, set, neighbor);       }     }     return count;   }  }   결과  Link   설명          n 개의 컴포넌트와 연결선 정보인 edges를 이용하여 컴포넌트의 각 요소끼리 모두 연결된 완전한 컴포넌트 그룹의 수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            graph는 각 연결 요소의 정보들을 각각 저장할 배열로, 각 위치 값을 ArrayList로 초기화하고 edges를 반복하여 각 컴포넌트 숫자 위치에 상대 컴포넌트 숫자를 저장해준다.       visited는 컴포넌트의 방문 여부를 저장하기 위한 변수로, n 크기의 부울 배열로 초기화한다.       result는 완벽한 컴포넌트 그룹의 수를 저장할 변수로, 0으로 초기화한다.           DFS 방식으로 컴포넌트를 탐색할 dfs(List[] graph, boolean[] visited, Set set, int index) 메서드를 정의한다.            visited[index]의 값을 true로 바꾸어 방문한 위치인 것을 표시한다.       count는 컴포넌트의 수를 계산할 변수로, 현재 컴포넌트를 포함하여 1로 초기화한다.       graph[index]에 해당하는 인접한 컴포넌트 값을 neighbor에 순차적으로 넣어 아래를 반복하여 index에 해당 값을 넣어 재귀 호출하여 count를 증가시켜준다.       계산된 count를 반환한다.           0부터 n 미만까지 i를 증가시키며 아래를 반복한다.            visited[i]의 값이 false인 방문하지 않은 경우, 아래를 수행한다.                    set은 각 컴포넌트와 연결된 컴포넌트 갯수를 저장할 변수로, 중복을 배제하기 위해 set으로 초기화한다.           count에는 3번에서 정의한 dfs(List[] graph, boolean[] visited, Set set, int index)를 수행한 결과를 저장한다.           set의 값이 하나인 각 컴포넌트에서 연결되지 않은 특정 컴포넌트가 포함되어 있지 않으면서, 컴포넌트 갯수인 $count - 1$이 존재하면 조건에 충족하므로 result를 증가시켜준다.                           반복이 완료되면 완전한 컴포넌트 그룹의 갯수가 계산된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-the-number-of-complete-components/",
        "teaser": null
      },{
        "title": "Leetcode Java Check if Grid can be Cut into Sections",
        "excerpt":"문제  Link   코드  class Solution {    public boolean checkValidCuts(int n, int[][] rectangles) {     return this.checkValidCuts(rectangles, 0) || this.checkValidCuts(rectangles, 1);   }    private boolean checkValidCuts(int[][] rectangles, int i) {     int result = 0;     Arrays.sort(rectangles, (a, b) -&gt; Integer.compare(a[i], b[i]));     int prev = rectangles[0][i + 2];     for (int[] rectangle : rectangles) {       if (prev &lt;= rectangle[i]) {         result++;       }       prev = Math.max(prev, rectangle[i + 2]);     }     return result &gt; 1;   }  }   결과  Link   설명     $n \\times n$ 크기의 정사각형 내 아래의 조건을 만족하는 직사각형 위치가 저장된 rectangles를 이용하여 가로 혹은 세로로 두 번 절단 가능한지 검증하는 문제이다.            rectangles[i] = [startx, starty, endx, endy]로 직사각형의 x축은 startx부터 시작하여 endx까지, y축은 starty부터 endy까지로 의미한다.           rectangles의 가로와 세로 기준으로 정렬하여 두 번 절단 가능한지 검증하기 위한 checkValidCuts(int[][] rectangles, int i) 메서드를 정의한다.            result는 절단 갯수를 저장하기 위한 변수로, 0으로 초기화한다.       rectangles를 i 기준의 위치 값 기준으로 오름차순 정렬해준다.       prev는 이전 직사각형의 종료 위치를 저장할 변수로, rectangles[0][$i + 2$]인 첫 직사각형의 종료 위치를 저장한다.       rectangles 정렬된 순서대로 rectangle에 넣어 아래를 수행한다.                    prev의 값이 rectangle[i] 값인 시작 위치보다 작거나 같은 절단 가능한 경우, result를 증가시켜준다.           prev에 prev와 rectangle[i + 2] 값인 종료 위치 중 큰 값을 넣어준다.                       result가 1 초과인 두 번 절단 가능한 위치가 존재하는지 여부를 반환한다.           2번에서 정의한 checkValidCuts(int[][] rectangles, int i) 메서드를 0과 1인 x의 시작 위치와 y의 시작 위치를 이용하여 수행한 결과 중 하나라도 참인지 여부를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/check-if-grid-can-be-cut-into-sections/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Index of a Valid Split",
        "excerpt":"문제  Link   코드  class Solution {    public int minimumIndex(List&lt;Integer&gt; nums) {     int size = nums.size();     int max = Integer.MIN_VALUE;     int count = 0;     for (int num : nums) {       if (count == 0) {         max = num;       }       if (max == num) {         count++;       } else {         count--;       }     }     count = 0;     for (int num : nums) {       if (num == max) {         count++;       }     }     if (count &lt;= (size - count) + 1) {       return -1;     }     count = 0;     for (int i = 0; i &lt; size; i++) {       if (nums.get(i) == max) {         count++;       } else {         count--;       }       if (count == 1) {         return i;       }     }     return -1;   }  }   결과  Link   설명     nums의 값들을 아래 조건을 만족하는 두 집단으로 분리할 수 있는 위치를 반환하는 문제이다.            0 &lt;= i &lt; $n - 1$을 만족하는 한 위치를 결정할 때, 두 집단은 절반 이상의 동일한 값을 가진다.           문제 풀이에 필요한 변수를 정의한다.            size는 nums의 크기를 저장한 변수이다.       max는 최빈값의 갯수를 계산하기 위한 변수로, 정수의 최솟값을 넣어준다.       count는 Boyer–Moore majority vote algorithm을 사용하여 계산하기 위한 변수로, 0으로 초기화한다.           nums의 값들을 순차적으로 반복하여 아래를 반복한다.            count가 0인 경우, max에 num을 넣어준다.       max와 num이 동일하면 count를 증가시키고, 그렇지 않으면 count를 감소시켜준다.                count를 0으로 초기화 한 후 nums 내 max에 해당하는 값의 갯수를 넣고 $(size - count) + 1$의 값이 count 이상인 발생 빈도가 과반 미만인 경우, -1을 주어진 문제의 결과로 반환한다.       count를 다시 0으로 초기화 후, 0부터 size 미만까지 i를 증가시키며 아래를 반복한다.            nums의 i번째 값이 max이면 count를 증가시키고, 그렇지 않으면 count를 감소시켜준다.       count가 1이 되는 과반 이상의 지점으로 분리 가능한 위치를 탐색한 경우, i를 주어진 문제의 결과로 반환한다.           모든 수행이 완료되면 분리할 수 있는 위치를 탐색하지 못하였으므로, -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-index-of-a-valid-split/",
        "teaser": null
      },{
        "title": "Leetcode Java Put Marbles in Bags",
        "excerpt":"문제  Link   코드  class Solution {    public long putMarbles(int[] weights, int k) {     int length = weights.length;     int[] sum = new int[length - 1];     for (int i = 0; i &lt; sum.length; i++) {       sum[i] = weights[i] + weights[i + 1];     }     Arrays.sort(sum);     long result = 0;     for (int i = 0; i &lt; k - 1; i++) {       result += sum[length - 2 - i] - sum[i];     }     return result;   }  }   결과  Link   설명     k개의 가방과 각 대리석의 갯수가 담긴 weights를 이용하여 아래의 조건에 따른 최댓값과 최솟값의 차이를 구하는 문제이다.            가방은 비어있지 않는다.       i번째 대리석과 j번째 대리석이 동일한 가방안에 있다면, 그 사이 대리석들도 가방 안에 있으며 무게는 $weights[i] + weights[j]$가 된다.       구슬을 가방 별로 나눈 후 점수는 각 가방 무게의 합이다.           문제 풀이에 필요한 변수를 정의한다.            length는 weights의 길이를 저장한 변수이다.       sum은 합계를 저장할 변수로, $length - 1$ 크기의 정수 배열로 초기화하고 인접한 두 값의 합을 순차적으로 저장하고 오름차순 정렬한다.       result는 결과를 저장할 변수로, 0으로 초기화한다.           0부터 $k - 1$인 가방의 갯수만큼 i를 증가시키며 아래를 반복한다.            result에 sum의 $length - 2 - i$번째 값에서 i번째 값을 뺀 가방에 들어갈 대리석의 숫자를 더해준다.           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/put-marbles-in-bags/",
        "teaser": null
      },{
        "title": "Leetcode Java Check If It Is a Good Array",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isGoodArray(int[] nums) {     int result = nums[0];     for (int num : nums) {       while (num &gt; 0) {         int temp = result % num;         result = num;         num = temp;       }       if (result == 1) {         return true;       }     }     return false;   }  }   결과  Link   설명     nums 내 아래의 규칙을 만족하는 부분 배열이 존재하는지 검증하는 문제이다.            부분 배열 내 각 값을 임의 정수와 곱한 값을 합한 값이 1이 된다.                result에 nums의 첫 값을 먼저 넣어준다.       nums의 값을 순차적으로 num에 넣어 아래를 반복한다.            num이 0보다 클 때까지, temp에 result와 num을 나눈 나머지 값을 임시 보관 후 result에 num을 num에 temp를 넣어준다.       위 반복이 완료된 후 result가 1인 조건을 만족하는 부분 집합이 되는 경우, true를 주어진 문제의 결과로 반환한다.           반복이 완료되면 조건을 만족하는 부분 배열이 존재하지 않으므로, false를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/check-if-it-is-a-good-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Value of an Ordered Triplet I",
        "excerpt":"문제  Link   코드  class Solution {    public long maximumTripletValue(int[] nums) {     long result = 0;     int diff = 0;     int max = 0;     for (int num : nums) {       result = Math.max(result, 1L * diff * num);       diff = Math.max(diff, max - num);       max = Math.max(max, num);     }     return result;   }  }   결과  Link   설명     양의 정수로 구성된 nums의 임의 i &lt; j &lt; k 를 만족하는 세 위치 i, j, k를 이용하여 $(nums[i] - nums[j]) \\times nums[k]$의 값이 최대인 값을 구하는 문제이다.            단, 결과가 음의 정수이면 0을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            result는 최댓값을 저장하기 위한 변수로, long 타입의 0으로 초기화한다.       diff는 $nums[i] - nums[j]$의 값이 최대인 값을 구하기 위한 변수로, 0으로 초기화한다.       max는 마지막 곱하기 위한 nums[k]의 값을 구하기 위한 변수로, 0으로 초기화한다.           nums의 값들을 순차적으로 num에 넣고 아래를 수행한다.            result에 result와 $diff \\times num$을 long 타입으로 변환한 값 중 큰 값을 넣어준다.       diff에 diff와 $max - num$ 중 차잇값이 큰 값을 넣어준다.       max에는 max와 num 중 큰 값을 넣어 곱할 값을 넣어준다.           반복이 완료되어 조건을 만족하는 최댓값이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-value-of-an-ordered-triplet-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Value of an Ordered Triplet II",
        "excerpt":"문제  Link   코드  class Solution {    public long maximumTripletValue(int[] nums) {     long result = 0;     long diff = 0;     long max = 0;     for (int num : nums) {       result = Math.max(result, diff * num);       diff = Math.max(diff, max - num);       max = Math.max(max, num);     }     return result;   }  }   결과  Link   설명     양의 정수로 구성된 nums의 임의 i &lt; j &lt; k 를 만족하는 세 위치 i, j, k를 이용하여 $(nums[i] - nums[j]) \\times nums[k]$의 값이 최대인 값을 구하는 문제이다.            이전 문제 Maximum Value of an Ordered Triplet I와 유사한 문제로, 배열의 길이가 더 늘어난 문제이다.       단, 결과가 음의 정수이면 0을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            result는 최댓값을 저장하기 위한 변수로, long 타입의 0으로 초기화한다.       diff는 $nums[i] - nums[j]$의 값이 최대인 값을 구하기 위한 변수로, num과 곱한 값이 매우 클 수 있으므로 long 타입의 0으로 초기화한다.       max는 마지막 곱하기 위한 nums[k]의 값을 구하기 위한 변수로, diff를 저장 할 수 있는 long 타입의 0으로 초기화한다.           nums의 값들을 순차적으로 num에 넣고 아래를 수행한다.            result에 result와 $diff \\times num$을 long 타입으로 변환한 값 중 큰 값을 넣어준다.       diff에 diff와 $max - num$ 중 차잇값이 큰 값을 넣어준다.       max에는 max와 num 중 큰 값을 넣어 곱할 값을 넣어준다.           반복이 완료되어 조건을 만족하는 최댓값이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-value-of-an-ordered-triplet-ii/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Average Selling Price",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT Prices.product_id     , ROUND(COALESCE(SUM(Prices.price * UnitsSold.units), 0)::NUMERIC / COALESCE(SUM(UnitsSold.units), 1), 2) AS average_price FROM Prices LEFT OUTER JOIN UnitsSold ON Prices.product_id = UnitsSold.product_id AND  Prices.start_date &lt;= UnitsSold.purchase_date AND UnitsSold.purchase_date &lt;= Prices.end_date GROUP BY Prices.product_id   결과  Link   설명          일자별 가격을 저장한 Prices를 이용하여 판매 기록인 UnitsSold의 품목 별 평균 판매가를 구하는 문제이다.       Prices에 UnitsSold 테이블을 LEFT OUTER JOIN 을 수행한다.            이 때 두 테이블의 product_id는 동일해야 하며, UnitsSold 테이블의 purchase_date는 Prices 테이블의 start_date 부터 end_date 이하여야 한다.           Prices 테이블의 product_id 기준으로 GROUP BY 수행하면서, 아래의 두 값을 나눈 후 소수점 2자리 반올림 처리한 평균 판매가를 구해준다.            Prices 테이블의 price의 값과 UnitsSold 테이블의 units 갯수를 곱한 값이 NULL이면 0, 아니면 곱한 값에 소수점을 포함한 NUMERIC으로 변환한 값.       UnitsSold 테이블의 units 갯수의 합이 null이면 1로, 아니면 해당 값.          ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/average-selling-price/",
        "teaser": null
      },{
        "title": "Leetcode Java Cells with Odd Values in a Matrix",
        "excerpt":"문제  Link   코드  class Solution {    public int oddCells(int m, int n, int[][] indices) {     int count = 0;     int[] rows = new int[m];     int[] cols = new int[n];     for (int[] indice : indices) {       rows[indice[0]]++;       cols[indice[1]]++;     }     for (int row : rows) {       for (int col : cols) {         if ((row + col) % 2 != 0) {           count++;         }       }     }     return count;   }  }   결과  Link   설명     0으로 채워진 $m \\times n$ 크기의 정수 배열을 이용하여 아래 규칙을 만족하는 indices를 수행한 결과 중 홀수 값의 갯수를 반환하는 문제이다.            indices[i] = [ri, ci]이다.       ri는 i번째 행의 값을 모두 증가시킨다.       ci는 i번째 열의 값을 모두 증가시킨다.           문제 풀이에 필요한 변수를 정의한다.            count는 홀수 값의 갯수를 저장할 변수로, 0으로 초기화한다.       rows와 cols는 각 행과 열의 증가되는 값을 저장할 변수로, m과 n 크기의 정수 배열로 초기화 후 indices를 순차적으로 수행하여 각 증가되는 값을 넣어준다.           rows의 값들을 순차적으로 row에, cols의 값들을 순차적으로 col에 넣어 아래를 수행한다.            $row + col$인 해당 위치의 값이 홀수인 경우, count를 증가시켜준다.           반복이 완료되면 홀수의 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/cells-with-odd-values-in-a-matrix/",
        "teaser": null
      },{
        "title": "Leetcode Java Reconstruct a 2-Row Binary Matrix",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; reconstructMatrix(int upper, int lower, int[] colsum) {     int sum = 0;     for (int num : colsum) {       sum += num;     }     if (sum != upper + lower) {       return new ArrayList&lt;&gt;();     } else {       int length = colsum.length;       int[][] result = new int[2][length];       for (int i = 0; i &lt; length; i++) {         if (colsum[i] == 2 || (colsum[i] == 1 &amp;&amp; lower &lt; upper)) {           result[0][i] = 1;         }         if (colsum[i] == 2 || (colsum[i] == 1 &amp;&amp; result[0][i] == 0)) {           result[1][i] = 1;         }         upper -= result[0][i];         lower -= result[1][i];       }       return upper == 0 &amp;&amp; lower == 0 ? new ArrayList(Arrays.asList(result[0], result[1])) : new ArrayList&lt;&gt;();     }   }  }   결과  Link   설명     [0, 2] 범위의 값으로 구성된 colsum를 합이 upper인 List와 합이 lower인 List로 순차적으로 List로 감싸 반환하는 문제이다.            단, 구성이 불가능하면 빈 List를 주어진 문제의 결과로 반환한다.                colsum의 각 값의 합이 $upper + lower$와 동일하지 않는 조건을 만족할 수 없는 경우, 새 ArrayList를 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            length는 colsum의 길이를 저장한 변수이다.       result는 결과를 만들 변수로, $2 \\times length$ 크기의 2차원 정수 배열로 초기화한다.           0부터 length까지 i를 증가시키며 아래를 반복한다.            colsum[i]의 값이 2이거나 colsum[i]의 값이 1이면서 upper가 lower보다 클 경우, result[0][i]의 위치에 1을 넣어준다.       colsum[i]의 값이 2이거나 colsum[i]의 값이 1이면서 result[0][i]의 값이 1인 upper에 넣지 않은 경우, result[1][i]의 위치에 1을 넣어준다.       upper에 result[0][i]의 값을, lower에 result[1][i]의 값을 빼준다.           upper와 lower의 값이 0인지 여부에 따라 아래를 수행한다.            0인 두 List로 나눌 수 있는 경우, result[0]과 result[1]을 ArrayList로 변환 후 새 ArrayList에 넣어 주어진 문제의 결과로 반환한다.       0이 아닌 두 List로 나눌 수 없는 경우, 새 ArrayList를 주어진 문제의 결과로 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reconstruct-a-2-row-binary-matrix/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Number of Operations to Make Elements in Array Distinct",
        "excerpt":"문제  Link   코드  class Solution {    public int minimumOperations(int[] nums) {     boolean[] seen = new boolean[101];     for (int i = nums.length - 1; i &gt;= 0; i--) {       if (seen[nums[i]]) {         return (i + 3) / 3;       } else {         seen[nums[i]] = true;       }     }     return 0;   }  }   결과  Link   설명          남은 배열 내 값이 고유한 값이 되도록 배열 시작의 세 값들을 계속 제거할 때, 제거 횟수를 구하는 문제이다.            seen은 동일한 값 발생 여부를 확인하기 위한 배열로, 최대 가능한 값보다 1 큰 101 크기의 부울 배열로 초기화한다.       nums의 길이보다 1 낮은 값부터 0 이상까지 i를 증가시키며 아래를 반복한다.            seen[nums[i]]의 값이 true이면, 남은 값들을 제거하는 최소 횟수인 $\\frac{i + 3}{3}$의 몫을 주어진 문제의 결과로 반환한다.       seen[nums[i]]의 값이 false이면, 본 값을 체크하기 위해서 seen의 해당 위치에 true를 넣어준다.           반복이 완료되면 0을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-number-of-operations-to-make-elements-in-array-distinct/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Operations to Make Array Values Equal to K",
        "excerpt":"문제  Link   코드  class Solution {    public int minOperations(int[] nums, int k) {     boolean[] seen = new boolean[101];     for (int num : nums) {       seen[num] = true;     }     int count = 0;     for (int i = 1; i &lt; 101; i++) {       if (seen[i]) {         if (i &lt; k) {           return -1;         } else if (i &gt; k) {           count++;         }       }     }     return count;   }  }   결과  Link   설명     nums의 각 값을 아래의 규칙을 수행하며 모든 값을 k로 만들 수 있는 최소 횟수를 반환하는 문제이다.            배열에서 h보다 큰 모든 값이 같은 유효한 값인 h를 선택하여, nums[i] &gt; h를 만족하면 nums[i]의 위치에 h를 넣어준다.       모든 값을 k로 만들 수 없는 경우, -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            seen은 nums 내 값을 기록하기 위한 변수로, 값의 범위보다 1 큰 101 크기의 부울 배열로 초기화하고 nums 내 값들의 위치에 true를 넣어준다.       count는 조건을 만족하는 최소 횟수를 저장할 변수로, 0으로 초기화한다.           1부터 101 미만까지 i를 증가시키며 아래를 반복한다.            seen[i]가 true인 경우, 아래를 수행한다.                    i가 k보다 작으면 k로 값을 변경할 수 없으므로, -1을 주어진 문제의 결과로 반환한다.           i가 k보다 크면 k로 값을 변경할 수 있으므로, count를 증가시킨다.                           반복이 완료되면 계산된 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-operations-to-make-array-values-equal-to-k/",
        "teaser": null
      },{
        "title": "Leetcode Java Count the Number of Powerful Integers",
        "excerpt":"문제  Link   코드  class Solution {    public long numberOfPowerfulInt(long start, long finish, int limit, String s) {     return this.numberOfPowerfulInt(finish, limit, s) - this.numberOfPowerfulInt(start - 1, limit, s);   }    private long numberOfPowerfulInt(long num, int limit, String s) {     String str = Long.toString(num);     int length = str.length() - s.length();     if (length &lt; 0) {       return 0;     } else {       long[][] dp = new long[length + 1][2];       dp[length][0] = 1;       dp[length][1] = str.substring(length).compareTo(s) &gt;= 0 ? 1 : 0;       for (int i = length - 1; i &gt;= 0; i--) {         int curr = str.charAt(i) - '0';         dp[i][0] = (limit + 1) * dp[i + 1][0];         if (curr &lt;= limit) {           dp[i][1] = (curr * dp[i + 1][0]) + dp[i + 1][1];         } else {           dp[i][1] = dp[i][0];         }       }       return dp[0][1];     }   }  }   결과  Link   설명          각 자리가 limit보다 낮은 [start, finish] 범위 내 값들 중 s로 끝나는 숫자들의 갯수를 계산하는 문제이다.       특정 값 내 조건을 만족하는 숫자의 갯수를 계산하기 위한 numberOfPowerfulInt(long num, int limit, String s) 메서드를 정의한다.            메서드 수행에 필요한 변수를 정의한다.                    str은 num을 문자열로 변환한 변수이다.           length는 str과 s의 길이 차이를 저장한 변수이다.                       length가 0보다 작아 s로 끝날 수 없는 경우, 0을 반환한다.       length가 0보다 큰 경우, 아래를 계속 수행한다.       dp는 갯수를 계산하기 위한 변수로, $(length + 1) \\times 2$ 크기의 2차원 long 배열로 초기화 후 마지막 위치에 아래 값을 넣어준다.                    dp[length][0] 값에는 1을 넣어준다.           dp[length][1] 값에는 str의 length만큼 자른 숫자가 s보다 큰 경우 1을, 아니면 0을 넣어준다.                       $length -1$부터 0 이상까지 i를 감소시키며 아래를 반복한다.                    curr에 str의 i번째 문자를 숫자로 변환하여 넣어준다.           dp[i][0]에 $(limit + 1) \\times dp[i + 1][0]$인 이전까지 값들의 갯수를 앞자리 limit 이하의 갯수만큼 곱한 값을 넣어준다.           curr이 limit보다 작은 경우, dp[i][1]의 위치에 $(curr \\times dp[i + 1][0]) + dp[i + 1][1]$인 앞자리 이전까지 값의 갯수를 curr 이하의 갯수만큼 곱한 값에 이전까지 계산된 값을 더한 값을 넣어준다.           curr이 limit보다 큰 경우, dp[i][1]의 위치에 기본 갯수인 dp[i][0]의 값을 넣어준다.                       반복이 완료되면 계산된 갯수인 dp[0][1]의 값을 반환한다.           2번에서 정의한 numberOfPowerfulInt(long num, int limit, String s) 메서드를 num에 finish를 넣어 수행한 값에 start를 넣어 수행한 값을 뺀 [start, finish] 범위 내 조건에 만족하는 갯수를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-the-number-of-powerful-integers/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Symmetric Integers",
        "excerpt":"문제  Link   코드  class Solution {    public int countSymmetricIntegers(int low, int high) {     int result = 0;     for (int i = low; i &lt;= high; i++) {       String s = Integer.toString(i);       int length = s.length();       if (length % 2 != 0) {         continue;       }       int diff = 0;       for (int j = 0; j &lt; length / 2; j++) {         diff += s.charAt(j) - s.charAt(length - j - 1);       }       if (diff == 0) {         result++;       }     }     return result;   }  }   결과  Link   설명          [low, high] 범위 내 짝수 값들 중 앞 숫자 합과 뒤 숫자 합이 동일한 숫자 갯수를 계산하는 문제이다.            result는 결과를 저장할 변수로, 0으로 초기화한다.       low부터 high 이하까지 i를 증가시키며 아래를 반복한다.            계산에 필요한 변수를 정의한다.                    s는 i를 문자열로 변환한 변수이다.           length는 s의 길이를 저장한 변수로, 홀수인 경우 다음 반복을 수행한다.           diff는 앞 숫자 합과 뒤 숫자 합의 차이를 저장할 변수로, 0으로 초기화한다.                       0부터 $\\frac{length}{2}$ 미만까지 j를 증가시키며 아래를 반복한다.                    diff에 s의 j번째 숫자에 $length - j - 1$번째 숫자를 뺀 값을 더해준다.                       diff가 0인 앞 숫자 합과 뒤 숫자 합이 동일한 조건을 만족하는 경우, result를 증가시켜준다.           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-symmetric-integers/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Closed Islands",
        "excerpt":"문제  Link   코드  class Solution {    public int closedIsland(int[][] grid) {     int row = grid.length;     int col = grid[0].length;     int result = 0;     for (int i = 0; i &lt; row; i++) {       for (int j = 0; j &lt; col; j++) {         if (grid[i][j] == 0 &amp;&amp; this.dfs(grid, row, col, i, j)) {           result++;         }       }     }     return result;   }    private boolean dfs(int[][] grid, int row, int col, int i, int j) {     if (i &lt; 0 || row &lt;= i || j &lt; 0 || col &lt;= j) {       return false;     } else if (grid[i][j] == 1) {       return true;     } else {       grid[i][j] = 1;       boolean left = this.dfs(grid, row, col, i, j - 1);       boolean top = this.dfs(grid, row, col, i - 1, j);       boolean right = this.dfs(grid, row, col, i, j + 1);       boolean bottom = this.dfs(grid, row, col, i + 1, j);       return left &amp;&amp; right &amp;&amp; top &amp;&amp; bottom;     }   }  }   결과  Link   설명          0은 땅, 1은 물을 나타내는 값들로 이루어진 grid를 이용하여 물 사이에 존재하는 섬의 갯수를 계산하는 문제이다.       물 사이에 존재하는 섬을 검증하기 위한 dfs(int[][] grid, int row, int col, int i, int j) 메서드를 정의한다.            i가 [0, $row - 1$], j가 [0, $col - 1$] 범위를 벗어나는 경우, false를 반환한다.       grid[i][j]의 값이 1인 물인 경계에 도달하는 경우, true를 반환한다.       그 외의 경우 아래를 수행한다.                    gird[i][j]의 값을 1로 바꾸어 방문한 위치임을 저장한다.           주어진 조건 순서대로 left, top, right, bottom 위치 별 재귀 호출을 수행한 결과가 모두 true인 물 사이에 존재하는 섬인지 검증한 결과를 반환한다.                           문제 풀이에 필요한 변수를 정의한다.            row와 col은 grid의 행과 열의 갯수를 저장한 변수이다.       result는 섬의 갯수를 저장하기 위한 변수로, 0으로 초기화한다.           0부터 row 미만까지 i를, 0부터 col 미만까지 j를 증가시키며 아래를 반복한다.            grid[i][j]가 육지이면서 2번에서 정의한 dfs(int[][] grid, int row, int col, int i, int j) 메서드를 수행한 결과가 true인 조건을 만족하는 경우, result를 증가시켜준다.           반복이 완료되면 물 사이에 존재하는 섬의 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-closed-islands/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Good Numbers",
        "excerpt":"문제  Link   코드  class Solution {    private static final int MOD = 1000000007;    public int countGoodNumbers(long n) {     return (int) (this.pow(5, (n + 1) / 2) * this.pow(4, n / 2) % MOD);   }    public long pow(long x, long y) {     if (y == 0) {       return 1;     } else {       long temp = this.pow(x, y / 2);       if (y % 2 == 0) {         return (temp * temp) % MOD;       } else {         return (x * temp * temp) % MOD;       }     }   }  }   결과  Link   설명     n 길이의 숫자들 중 아래의 규칙을 만족하는 좋은 숫자의 갯수를 세는 문제이다.            좋은 숫자는 짝수 위치의 값은 짝수이고, 홀수 위치의 값은 소수인 값이다.       n 길이의 숫자 앞 자리에 0이 포함하여 조건을 만족할 수 있다.       조건을 만족하는 숫자의 갯수가 매우 많을 수 있으므로, 모듈러 $10^9 + 7$를 적용하여 반환한다.           조건을 만족하는 제곱을 계산하기 위한 pow(long x, long y) 메서드를 정의한다.            y가 0인 승수가 0이면, 1을 반환한다.       y가 0이 아닌 경우, 아래를 수행한다.                    temp에 x와 $\\frac{y}{2}$로 재귀 호출 수행한 결과를 넣어준다.           y가 짝수인 경우, $\\frac{temp \\times temp}{MOD}$를 반환한다.           y가 홀수인 경우, $\\frac{x \\times temp \\times temp}{MOD}$를 반환한다.                           주어진 조건의 결과로 2번의 pow(long x, long y) 메서드에 5와 $\\frac{n + 1}{2}$를 수행한 결과와 4와 $frac{n}{2}$를 수행한 결과의 곱을 주어진 문제의 결과로 반환한다.   해설     짝수 자리는 짝수인 0, 2, 4, 6, 8 값의 갯수인 5개가, 홀수 자리는 소수인 2, 3, 5, 7 값의 갯수인 4개가 존재한다.   좋은 숫자의 총 갯수는 아래의 두 경우의 수에 대한 곱이 되며, 각 계산에 모듈러 $10^9 + 7$을 적용해야 한다.            짝수의 5개에 짝수 인덱스 갯수의 제곱.       소수의 4개에 소수 인덱스 갯수의 제곱.           제곱 계산은 승수가 짝수인 경우와 홀수인 경우에 대해서 아래와 같이 계산이 가능하다.            y가 짝수인 경우, $x^y = x^\\frac{y}{2} \\times x^\\frac{y}{2}$로 표현 가능하다. 예를 들어, $x^4 = x^2 \\times x^2$와 같다.       y가 홀수인 경우, $x^y = x \\times x^\\frac{y}{2} \\times x^\\frac{y}{2}$로 표현 가능하다. 예를 들어, $x^5 = x \\times x^2 \\times x^2$와 같다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-good-numbers/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Good Triplets",
        "excerpt":"문제  Link   코드  class Solution {    public int countGoodTriplets(int[] arr, int a, int b, int c) {     int length = arr.length;     int result = 0;     for (int i = 0; i &lt; length - 2; i++) {       for (int j = i + 1; j &lt; length - 1; j++) {         if (Math.abs(arr[i] - arr[j]) &lt;= a) {           for (int k = j + 1; k &lt; length; k++) {             if (Math.abs(arr[j] - arr[k]) &lt;= b &amp;&amp; Math.abs(arr[i] - arr[k]) &lt;= c) {               result++;             }           }         }       }     }     return result;   }  }   결과  Link   설명     정수가 들어있는 arr을 이용하여 아래 조건을 만족하는 값들의 조합 수를 반환하는 문제이다.            0 &lt;= i &lt; j &lt; k &lt; arr.length 를 만족할 때, 아래 세 조건을 만족한다.                                                                                    $                   arr[i] - arr[j]                   &lt;= a$                                                                                                                                   $                   arr[j] - arr[k]                   &lt;= b$                                                                                                                                   $                   arr[i] - arr[k]                   &lt;= c$                                                                                   문제 풀이에 필요한 변수를 정의한다.            length는 arr의 길이를 저장한 변수이다.       result는 조합 수를 저장하기 위한 변수로, 0으로 초기화한다.           0부터 $length - 2$까지 i를 증가시키며, $i + 1$부터 $length - 1$까지 j를 증가시키며 아래를 반복한다.                                                            첫 조건인 $               arr[i] - arr[j]               &lt;= a$ 조건을 만족하는 경우, 아래의 수행을 계속 진행한다.                                                                                                                     $j + 1$부터 length 미만까지 k를 증가시키며 $                   arr[j] - arr[k]                   &lt;= b$ 조건과 $                   arr[i] - arr[k]                   &lt;= c$ 조건을 만족하는 경우, result를 증가시켜준다.                                                                                   반복이 완료되어 계산된 조합의 수인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-good-triplets/",
        "teaser": null
      },{
        "title": "Leetcode Java Count the Number of Good Subarrays",
        "excerpt":"문제  Link   코드  class Solution {    public long countGood(int[] nums, int k) {     long result = 0L;     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();     for (int i = 0, j = 0; j &lt; nums.length; j++) {       int num = map.getOrDefault(nums[j], 0);       k -= num;       map.put(nums[j], num + 1);       while (k &lt;= 0) {         map.put(nums[i], map.get(nums[i]) - 1);         k += map.get(nums[i++]);       }       result += i;     }     return result;   }  }   결과  Link   설명     정수 배열인 nums을 이용하여 아래 규칙을 만족하는 부분 배열의 수를 반환하는 문제이다.            연속된 값들로 이루어진 부분 배열은 i &lt; j, arr[i] == arr[j]를 만족하는 위치 값 (i, j)가 최소 k쌍 이상이다.           문제 풀이에 필요한 변수를 정의한다.            result는 부분 배열의 수를 계산할 변수로, 0으로 초기화한다.       map은 nums[i] 기준의 조건을 만족하는 갯수를 계산하기 위한 변수로, HashMap으로 초기화한다.           i는 0으로 초기화하고, 0부터 nums의 길이 미만까지 j를 증가시키며 아래를 반복한다.            num에 map에서 nums[j]의 값이 존재하면 해당 값을, 아니면 0을 넣어준다.       k에 num인 조건에 해당하는 쌍의 갯수를 빼준 후, map에 nums[j]의 위치에 쌍의 갯수인 num을 1 증가시켜 넣어준다.       k가 0 이하일 때 까지 아래를 반복하여 기존 쌍의 갯수를 차감하고 k를 원상복구시켜준다.                    map의 nums[i]에 해당하는 위치에 해당 위치의 값에서 1을 빼준다.           k에 map에서 nums[i]에 해당하는 값을 가져와 더해준 후, i를 증가시켜준다.                       result에 i를 더해 부분 배열의 수를 더해준다.           반복이 완료되면 계산된 부분 배열의 수인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-the-number-of-good-subarrays/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Equal and Divisible Pairs in an Array",
        "excerpt":"문제  Link   코드  class Solution {    public int countPairs(int[] nums, int k) {     int length = nums.length;     int result = 0;     for (int i = 0; i &lt; length - 1; i++) {       for (int j = i + 1; j &lt; length; j++) {         if (nums[i] == nums[j] &amp;&amp; i * j % k == 0) {           result++;         }       }     }     return result;   }  }   결과  Link   설명     정수 배열 nums를 이용하여 아래 조건을 만족하는 쌍의 갯수를 계산하는 문제이다.            0 &lt;= i &lt; j &lt; n를 만족하는 i와 j를 선택할 때, nums[i] == nums[j]와 $i \\times j$의 값이  k의 배수를 만족한다.           문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       result는 조건을 만족하는 쌍의 갯수를 계산할 변수로, 0으로 초기화한다.           0부터 $length - 1$까지 i를 증가시키고, $i + 1$부터 length 미만까지 j를 증가시키며 아래를 반복한다.            nums[i] == nums[j]를 만족하면서 $i \\times j$의 값이 k의 배수인 경우, result를 증가시킨다.           반복이 완료되면 조건을 만족하는 쌍의 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-equal-and-divisible-pairs-in-an-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Shift 2D Grid",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;Integer&gt;&gt; shiftGrid(int[][] grid, int k) {     int rows = grid.length;     int cols = grid[0].length;     int[][] arr = new int[rows][cols];     for (int i = 0; i &lt; rows; i++) {       for (int j = 0; j &lt; cols; j++) {         arr[(i + ((j + k) / cols)) % rows][(j + k) % cols] = grid[i][j];       }     }     List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();     for (int[] row : arr) {       List&lt;Integer&gt; list = new ArrayList&lt;&gt;();       for (int col : row) {         list.add(col);       }       result.add(list);     }     return result;   }  }   결과  Link   설명     2차원 정수 배열 grid를 이용하여 k번 아래의 규칙대로 수행한 결과를 반환하는 문제이다.            grid[i][j] 값을 grid[i][$j + 1$] 위치로 이동한다.       grid[i][$n - 1$]인 오른쪽 마지막 위치의 값은 grid[$i + 1$][0] 위치로 이동한다.       grid[$m - 1$][$n - 1$] 마지막 모서리 값은 처음 위치인 grid[0][0] 위치로 이동한다.           문제 풀이에 필요한 변수를 정의한다.            rows와 cols는 grid의 행과 열의 갯수를 저장한 변수이다.       arr은 조건에 해당하는 값을 저장할 배열로, $rows \\times cols$ 크기의 2차원 배열로 초기화 후 아래를 수행하여 값을 채워준다.                    arr의 $i + \\frac{j + k}{cols}$ 값을 rows로 나눈 나머지 값의 행, $j + k$를 cols로 나눈 나머지 값의 열에 해당하는 위치에 grid[i][j]의 값을 넣어준다.                                결과를 저장할 result를 ArrayList로 초기화 후, arr을 반복하여 순차적으로 값을 채워준다.       각 수행을 통해서 변경된 위치로 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/shift-2d-grid/",
        "teaser": null
      },{
        "title": "Leetcode Java Greatest Sum Divisible by Three",
        "excerpt":"문제  Link   코드  class Solution {    public int maxSumDivThree(int[] nums) {     int[] dp = new int[3];     for (int num : nums) {       for (int i : Arrays.copyOf(dp, dp.length)) {         int sum = i + num;         int remainder = sum % 3;         dp[remainder] = Math.max(dp[remainder], sum);       }     }     return dp[0];   }  }   결과  Link   설명          nums 값들 중 합이 3의 배수가 되도록 하는 최댓값을 계산하는 문제이다.            dp는 합계를 3으로 나눈 나머지 값에 해당 하는 위치에 저장할 변수로, 3 크기의 정수 배열로 초기화한다.       nums의 각 값을 순차적으로 num에 넣어 아래를 반복한다.            현재 dp의 값을 그대로 복제하여 순차적으로 i에 넣어 아래를 반복한다.                    sum은 $i + num$의 값을, remainder는 sum을 3으로 나눈 나머지 값을 저장한 변수이다.           dp[remainder]의 위치에 해당 값과 sum 중 가장 큰 값을 넣어준다.                           반복이 완료되면 3의 배수 자리의 최댓값이 저장된 dp[0] 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/greatest-sum-divisible-by-three/",
        "teaser": null
      },{
        "title": "Leetcode Java Search Suggestions System",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) {     Arrays.sort(products);     StringBuilder sb = new StringBuilder();     List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();     for (char c : searchWord.toCharArray()) {       sb.append(c);       String prefix = sb.toString();       int index = Arrays.binarySearch(products, prefix);       if (index &lt; 0) {         index = -index - 1;       }       List&lt;String&gt; list = new ArrayList&lt;&gt;();       for (int j = index; list.size() &lt; 3 &amp;&amp; j &lt; products.length &amp;&amp; products[j].startsWith(prefix); j++) {         list.add(products[j]);       }       result.add(list);     }     return result;   }  }   결과  Link   설명          searchWord의 각 문자를 입력할때마다 제품 목록인 products 내 사전적으로 유사한 상위 3개 제품을 반환하는 문제이다.            products의 문자열들을 오름차순 정렬한다.       문제 풀이에 필요한 변수를 정의한다.            sb는 searchWord를 한 문자씩 입력할 때 현재까지 입력된 문자열을 동적으로 저장할 변수로, StringBuilder로 초기화한다.       result는 결과 문자열들을 저장할 변수로, ArrayList로 초기화한다.           searchWord의 각 문자들을 순차적으로 c에 넣고 아래를 반복한다.            sb에 c를 이어주고, prefix에 sb의 현재까지 입력된 문자들을 문자열로 변환해서 넣어준다.       index는 products에서 prefix에 해당하는 문자열의 이진 탐색 위치를 넣어준다.       index가 0 이하인 음수인 경우, 양수로 변경 후 1울 빼준다.       list는 현재 검색할 상위 3개 제품을 넣을 변수로, ArrayList로 초기화한다.       index부터 list의 길이가 3 미만이면서 j가 제품 갯수 미만이고 products[j]의 문자가 prefix로 시작할 때 까지 j를 증가시키며 list에 products[j] 문자열을 넣어준다.       result에 현재 문자열까지 유사한 제품 목록이 저장된 list를 넣어준다.           반복이 완료되면 각 문자열 목록들이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/search-suggestions-system/",
        "teaser": null
      },{
        "title": "Leetcode Java Count the Hidden Sequences",
        "excerpt":"문제  Link   코드  class Solution {    public int numberOfArrays(int[] differences, int lower, int upper) {     long sum = 0;     long max = 0;     long min = 0;     for (int difference : differences) {       sum += difference;       max = Math.max(max, sum);       min = Math.min(min, sum);     }     return (int) Math.max(0, (upper - lower) - (max - min) + 1);   }  }   결과  Link   설명     아래의 규칙을 만족하는 정수 배열인 differences를 이용하여 [lower, upper] 범위 내 만족하는 조합의 수를 구하는 문제이다.            hidden은 숨겨진 조합으로, 인접한 두 값의 차이가 differences 배열이 된다.       즉, $differences[i] = hidden[i + 1] - hidden[i]$를 만족한다.           문제 풀이에 필요한 변수를 정의한다.            sum은 differences 내 값들의 합계를 구하기 위한 변수로, 합계가 매우 클 수 있으므로 long 타입의 0으로 초기화한다.       max와 min은 누계된 값들 중 최댓값과 최솟값을 저장하기 위한 변수로, sum과 동일하게 long 타입의 0으로 초기화한다.           differences의 값들을 순차적으로 difference에 넣어 아래를 수행한다.            sum에 difference의 값을 누계한다.       max 와 min에 자기 자신과 sum 중 최댓값과 최솟값을 넣어준다.           반복이 완료되면 0과 $(upper - lower) - (max - min) + 1$인 [lower, upper] 범위 내 만족하는 조합의 수를 주어진 문제의 결과로 반환한다.   해설     누계된 값들을 이용한 max와 min의 차잇값은 범위 내 최대 폭을 나타내므로, [lower, upper] 범위에서는 아래와 같은 계산식이 성립한다.            $upper - lower &lt; max - min$의 경우, [lower, upper] 범위 내 hidden 배열은 존재하지 않는다.       $upper - lower = max - min$의 경우, [lower, upper] 범위 내 hidden 배열이 한 개만 존재한다.       위의 공식을 반복하여 $upper - lower = max - min + n$의 경우, [lower, upper] 범위 내 hidden 배열이 $n + 1$ 개가 존재한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-the-hidden-sequences/",
        "teaser": null
      },{
        "title": "Leetcode Java N-Queens",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) {     char[][] board = new char[n][n];     for (char[] row : board) {       Arrays.fill(row, '.');     }     List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();     this.dfs(n, board, result, 0, new boolean[n], new boolean[2 * n - 1], new boolean[2 * n - 1]);     return result;   }    private void dfs(int n, char[][] board, List&lt;List&lt;String&gt;&gt; result, int i, boolean[] cols, boolean[] diagonals1, boolean[] diagonals2) {     if (i == n) {       List&lt;String&gt; list = new ArrayList&lt;&gt;();       for (char[] row : board) {         list.add(new String(row));       }       result.add(list);     } else {       for (int j = 0; j &lt; cols.length; j++) {         if (!cols[j] &amp;&amp; !diagonals1[i + j] &amp;&amp; !diagonals2[j - i + n - 1]) {           board[i][j] = 'Q';           cols[j] = diagonals1[i + j] = diagonals2[j - i + n - 1] = true;           this.dfs(n, board, result, i + 1, cols, diagonals1, diagonals2);           cols[j] = diagonals1[i + j] = diagonals2[j - i + n - 1] = false;           board[i][j] = '.';         }       }     }   }  }   결과  Link   설명     $n \\times n$ 크기의 체스판 내 n개의 퀸을 배치하였을 때, 서로 공격할 수 없는 위치의 배치들을 반환하는 문제이다.            문자 ‘Q’는 퀸을, 문자 ‘.’은 빈 공간을 의미한다.           문제 풀이에 필요한 변수를 정의한다.            board는 체스판을 구성할 변수로, $n \\times n$ 크기의 문자 배열로 초기화 후 모든 위치에 ‘.’ 문자를 넣어준다.       result는 결과를 저장할 변수로, ArrayList로 초기화한다.           DFS 방식으로 퀸이 서로 공격하지 못하는 체스판을 구성할 dfs(int n, char[][] board, List&lt;List&gt; result, int i, boolean[] cols, boolean[] diagonals1, boolean[] diagonals2) 메서드를 정의한다.            i가 n인 마지막 위치인 경우, board의 각 행을 문자열로 변환하여 넣은 ArrayList를 모두 넣어준다.       i가 n인 마지막 위치가 아닌 경우, 0부터 cols의 길이 미만까지 j를 증가시키며 아래를 반복한다.                    cols[j], diagonals1[$i + j$], diagonals2[$j - i + n - 1$] 값이 모두 true이면 다음 반복을 수행한다.           board[i][j]의 위치에 ‘Q’를 넣어 퀸을 위치시킨다.           cols[j], diagonals1[$i + j$], diagonals2[$j - i + n - 1$] 값에 모두 true를 넣어, 공격 가능한 위치를 체크해준다.           i 위치에 $i + 1$을 넣어 재귀 호출을 수행해준다.           cols[j], diagonals1[$i + j$], diagonals2[$j - i + n - 1$] 값에 모두 false를 넣어, 해당 위치를 초기화시켜준다.           board[i][j]의 위치에 ‘.’를 넣어 퀸도 제거해준다.                                3번의 dfs(int n, char[][] board, List&lt;List&gt; result, int i, boolean[] cols, boolean[] diagonals1, boolean[] diagonals2) 메서드를 i에 0, cols는 n 크기의 부울 배열, diagonals1과 diagonals2는 $2 * n - 1$ 크기의 부울 배열을 넣어 수행해준다.       반복이 완료되면 각 위치가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/n-queens/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Largest Group",
        "excerpt":"문제  Link   코드  class Solution {    public int countLargestGroup(int n) {     int[] counts = new int[37];     int result = 0;     int max = 0;     for (int i = 1; i &lt;= n; i++) {       int sum = 0;       for (int x = i; x &gt; 0; x /= 10) {         sum += x % 10;       }       counts[sum]++;       if (max == counts[sum]) {         result++;       } else if (max &lt; counts[sum]) {         max = counts[sum];         result = 1;       }     }     return result;   }  }   결과  Link   설명          [1, n] 범위 내 값들 중 각 자리 숫자의 합이 동일한 숫자들끼리 그룹을 만들 때, 가장 많은 숫자가 모인 그룹의 갯수를 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            counts는 합계가 동일한 숫자의 갯수를 계산할 변수로, 합이 최대인 9999의 합인 $9 \\times 4 = 36$ 보다 1 큰 37 크기의 정수 배열로 초기화한다.       result는 가장 많은 숫자가 모인 그룹의 갯수를 계산할 변수로, 0으로 초기화한다.       max는 가장 많은 숫자가 모인 그룹의 크기를 저장할 변수로, 0으로 초기화한다.           1부터 n 이하까지 i를 증가시키며 아래를 반복한다.            sum은 각 숫자의 합계를 더할 변수로, 현재 숫자 i의 각 숫자 합을 더한 값을 넣어준다.       counts[sum]의 갯수를 증가시켜준다.       max와 counts[sum]의 값이 동일한 경우, result를 증가시켜 갯수를 더해준다.       max보다 counts[sum]의 값이 큰 경우, max에 counts[sum]을 넣어 새로운 최댓값으로 설정하고 result를 1로 초기화한다.           반복이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-largest-group/",
        "teaser": null
      },{
        "title": "Leetcode Java Count of Interesting Subarrays",
        "excerpt":"문제  Link   코드  class Solution {    public long countInterestingSubarrays(List&lt;Integer&gt; nums, int modulo, int k) {     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();     map.put(0, 1);     long result = 0;     int sum = 0;     for (int num : nums) {       sum = (sum + (num % modulo == k ? 1 : 0)) % modulo;       result += map.getOrDefault((sum - k + modulo) % modulo, 0);       map.put(sum, map.getOrDefault(sum, 0) + 1);     }     return result;   }  }   결과  Link   설명     nums 내 아래 규칙을 만족하는 연속된 부분 배열의 갯수를 계산하는 문제이다.            부분 배열인 [l, r] 범위 내 nums[i] % modulo = k를 만족하는 값의 갯수인 cnt도 cnt % modulo = k를 만족한다.           문제 풀이에 필요한 변수를 정의한다.            map은 갯수를 계산하기 위한 변수로, HashMap으로 초기화 후 키가 0인 위치에 값을 1로 넣어준다.       result는 부분 배열의 갯수를 계산할 변수로, 0으로 초기화한다.       sum은 부분 합계를 저장할 변수로, 0으로 초기화한다.           nums의 값들을 순차적으로 num에 넣어 아래를 수행한다.            sum에 num % modulo의 결과가 k인 조건을 만족하면 1을, 아니면 0을 sum에 더한 값을 modulo로 나눈 나머지 값을 넣어준다.       result에 map에서 $sum - k + modulo$의 값을 modulo로 나눈 값에 해당하는 키의 값을 가져와 더해준다.       map에서 sum이 키의 값을 1 증가시켜준다.           반복이 완료되면 부분 배열의 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   해설     $sum - k + modulo$에서 modulo는 $sum - k$가 음수인 경우를 방지하기 위한 값이므로, 아래부터는 $sum - k$에 대해서 이야기한다.   map에서 $sum - k$의 값을 modulo로 나눈 나머지 값에 해당하는 키의 값이 조건을 만족하는 부분 배열의 갯수인 이유는 아래와 같다.            부분 배열 [i, j]이 cnt % modulo = k를 만족할 때, nums[i] % modulo = k를 만족하는 숫자의 갯수를 계산할 sum() 함수를 사용해 l = sum(0, $i - 1$), r = sum(0, j)로 $r - l$ = sum(i, j)을 만족한다.       위를 기반으로 ($r - l$) % modulo = k를 만족할 때, modulo를 각 값에 적용하면 (r % modulo) - (l % modulo) = k를 만족한다.       k % modulo = k를 만족하므로, (r % modulo) - (l % modulo) = k % modulo가 성립한다.       (l % modulo) - (k % modulo)를 좌우 변에 더해주면, (r % modulo) - (k % modulo) = l % modulo가 되고, 이는 (r - k) % modulo = l % modulo가 된다.       즉, $sum - k$는 두 조건을 만족하는 키를 뜻하고 이에 대한 값은 조건을 만족하는 부분 배열의 갯수가 된다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-of-interesting-subarrays/",
        "teaser": null
      },{
        "title": "Docker Entrypoint로 실행된 Shell Script에서 Application으로 SIGTERM을 전송하는 방법",
        "excerpt":"개요     Dockerfile을 만들다 보면, ENTRYPOINT1에 단순 application을 실행하는 로직 외 다양한 로직을 실행하기 위해서 Shell Script를 실행하는 경우가 있다.   이 경우, Docker를 종료하려고 SIGTERM을 전송하면 Shell Script로 전송되기 때문에 Application에서는 정상적으로 SIGTERM을 전달받지 못해서 Graceful Shutdown이 수행되지 않고 SIGKILL에 의해서 서비스는 강제 종료된다.   위의 상황들을 해결하기 위한 기본적인 방법인 Shell Script로 전달된 SIGTERM을 Application으로 전달하는 방법을 설명한다.   run.sh  #!/bin/sh  # Send SIGTERM to the application. term_handler() {   if [ $pid -ne 0 ]; then     kill -SIGTERM \"$pid\"     wait \"$pid\"   fi   exit 143 # 128(External) + 15(SIGTERM) }  # Setup the trap for the SIGTERM. trap 'kill ${!}; term_handler' SIGTERM  # Start application. java org.springframework.boot.loader.launch.JarLauncher &amp; pid=\"$!\"  # Wait the signal. while true; do   # Check if process is still running.   kill -0 \"$pid\" 2&gt;/dev/null   if [ $? -ne 0 ]; then     echo \"Process $pid is not running. Terminating the container.\"     term_handler   fi   # Signal confirmation interval.   sleep 5 done     Apline Linux에서도 정상 동작 가능하도록 bash가 아닌 sh로 실행 가능하게 shebang2을 “/bin/sh”로 정의한다.   term_handler 함수는 pid가 존재하면 pid로 SIGTERM을 전송 후 완료되기 까지 pid 프로세스를 기다리는 작업을 수행하고 마지막으로 143 코드로 스크립트 실행을 종료한다.            143의 의미는 외부 요청 수행을 의미하는 128에, SIGTERM을 의미하는 15를 더한 값으로 차별화 시킨 값이다.           tarp 명령어를 통해 SIGTERM을 받았을 때, term_handler 함수를 수행한다.   java 명령어로 어플리케이션을 수행하면서, pid 변수에 실행된 pid를 저장한다.   5초마다 수행 프로세스가 진행 중인지를 검증하고, 프로세스 종료된 경우 스크립트 실행을 종료하여 현재 실행 중인 컨테이너 또한 종료한다.   Dockerfile  ... omitted ...  # Copy run.sh and change mode to 755 COPY ./run.sh / RUN chmod 755 /run.sh  ... omitted ...  # Run application ENTRYPOINT [ \"/bin/sh\", \"/run.sh\" ]     위에서 정의한 run.sh 파일을 컨테이너 내부로 이동시킨 후, 실행에 문제 없게 755 권한을 부여한다.   ENTRYPOINT로 컨테이너 실행 시, run.sh 쉘 스크립트를 실행하도록 정의한다.   부가 설명     Docker Compose를 이용하여 종료하게 되는 경우엔 컨테이너 Graceful Shutdown을 위한 stop_grace_period3 옵션과 Spring Boot의 Graceful Shutdown4 설정을 유연하게 조절하여야 한다.   정리     Docker Container는 컨테이너 실행에 수행되는 CMD 혹은 ENTRYPOINT 설정으로 실행된 프로세스의 상태와 직접적인 관계가 있지만, Shell Script 등을 활용한 간접적인 Application 실행의 경우 Signal을 주요 Application에 중계해야 정상적인 상태를 동기화 할 수 있다.   Reference  ※ Sample Code는 여기에서 확인 가능합니다.                 Docker-Docs-Dockerfile-ENTRYPOINT &#8617;                  Shebang &#8617;                  Docker-Compose-stop_grace_period &#8617;                  Spring-Boot-Graceful-Shutdown &#8617;           ","categories": ["Java"],
        "tags": ["Programming","Docker","ENTRYPOINT","Shell Script","SIGTERM","Graceful Shutdown"],
        "url": "/java/sending-docker-sigterm-from-shell-to-application/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Subarrays of Length Three With a Condition",
        "excerpt":"문제  Link   코드  class Solution {    public int countSubarrays(int[] nums) {     int result = 0;     for (int i = 0; i &lt; nums.length - 2; i++) {       if (2 * (nums[i] + nums[i + 2]) == nums[i + 1]) {         result++;       }     }     return result;   }  }   결과  Link   설명          nums 내 연속된 세 숫자의 가운데 값이 나머지 두 값의 두 배가 되는 부분 배열의 갯수를 계산하는 문제이다.            nums의 연속된 세 숫자를 반복하여 $2 \\times (nums[i] + nums[i + 2]) = nums[i + 1]$이 성립하는 부분 배열의 갯수를 계산하여 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-subarrays-of-length-three-with-a-condition/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Subarrays With Score Less Than K",
        "excerpt":"문제  Link   코드  class Solution {    public long countSubarrays(int[] nums, long k) {     long sum = 0;     long result = 0;     for (int i = 0, j = 0; j &lt; nums.length; j++) {       sum += nums[j];       while (sum * (j - i + 1) &gt;= k) {         sum -= nums[i++];       }       result += j - i + 1;     }     return result;   }  }   결과  Link   설명     nums 내 아래 규칙을 만족하는 k 점수 미만의 부분 배열 갯수를 반환하는 문제이다.            부분 배열 [1, 2, 3, 4, 5]의 값은 $(1 + 2 + 3 + 4 + 5) \\times 5$ 점수를 획득한다.           문제 풀이에 필요한 변수를 정의한다.            sum은 합계를 저장할 변수로, 0으로 초기화한다.       result는 k 점수 이하의 부분 배열 갯수를 계산할 변수로, 0으로 초기화한다.           i는 0으로, j는 0부터 nums의 길이 미만까지 증가시키며 아래를 반복한다.            sum에 nums[j]의 값을 더해준다.       $sum \\times (j - i + 1)$의 값이 k 이상인 조건에 부합하는 값일 때 까지, sum에 nums[i]의 값을 빼주고 i를 증가시켜준다.       result에 $j - i + 1$인 가능한 부분 배열의 갯수를 더해준다.           반복이 완료되면 k 점수 미만의 부분 배열의 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-subarrays-with-score-less-than-k/",
        "teaser": null
      },{
        "title": "Leetcode Java N-Queens II",
        "excerpt":"문제  Link   코드  class Solution {    private int count;    public int totalNQueens(int n) {     this.count = 0;     int diagonalLength = 2 * n;     this.backtracking(n, 0, new boolean[n], new boolean[diagonalLength], new boolean[diagonalLength]);     return this.count;   }    private void backtracking(int n, int i, boolean[] values, boolean[] diagonal1, boolean[] diagonal2) {     if (i == n) {       this.count++;     } else {       for (int j = 0; j &lt; n; j++) {         int index1 = j - i + n;         int index2 = j + i;         if (!values[j] &amp;&amp; !diagonal1[index1] &amp;&amp; !diagonal2[index2]) {           values[j] = diagonal1[index1] = diagonal2[index2] = true;           this.backtracking(n, i + 1, values, diagonal1, diagonal2);           values[j] = diagonal1[index1] = diagonal2[index2] = false;         }       }     }   }  }   결과  Link   설명          이전 문제 N-Queens와 유사한 문제로, n개의 퀸이 $n \\times n$ 크기의 2차원 배열 위에 서로 공격할 수 없는 위치에 존재할 수 있는 경우의 수를 구하는 문제이다.            전역 변수인 count는 경우의 수를 계산하기 위한 변수로 0으로 초기화 후, 대각선으로 진행하기 위한 최대 길이인 diagonalLength를 $2 \\times n$으로 초기화한다.       백트래킹 방식으로 경우의 수를 계산할 backtracking(int n, int i, boolean[] values, boolean[] diagonal1, boolean[] diagonal2) 메서드를 정의한다.            i가 n인 마지막 행의 경우, count를 증가시킨다.       i가 n이 아닌 경우, 0부터 n 미만까지 j를 증가시키며 아래를 반복한다.                    각 대각선의 이동 위치인 index1에 $j - i + n$을, index2에 $j + i$를 넣어준다.           values[j], diagonal1[index1], diagonal2[index2]의 값이 모두 false인 방문하지 않은 위치의 경우, 해당 값에 true를 넣어 방문한 이력을 넣고 $i + 1$을 넣어 재귀 호출을 수행한 후 다시 앞의 위치에 true를 넣어 복구해준다.                           반복이 완료되면 경우의 수가 계산된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/n-queens-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Numbers with Even Number of Digits",
        "excerpt":"문제  Link   코드  class Solution {    public int findNumbers(int[] nums) {     int count = 0;     for (int num : nums) {       if ((9 &lt; num &amp;&amp; num &lt; 100) || (999 &lt; num &amp;&amp; num &lt; 10000) || num == 100000) {         count++;       }     }     return count;   }  }   결과  Link   설명          nums 내 짝수 자리의 숫자 갯수를 계산하는 문제이다.            nums 내 아래 범위 내 짝수 자릿수인 숫자의 갯수를 계산하여 주어진 문제의 결과로 반환한다.             [10, 99] 사이의 두 자리 숫자.       [1000, 9999] 사이의 네 자리 숫자.       100000인 여섯 자리 숫자.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-numbers-with-even-number-of-digits/",
        "teaser": null
      },{
        "title": "Leetcode Java Valid Number",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isNumber(String s) {     char[] charArray = s.toCharArray();     boolean seenNumber = false;     boolean seenExponent = false;     boolean seenDot = false;     for (int i = 0; i &lt; charArray.length; i++) {       switch (charArray[i]) {         case '.':           if (seenDot || seenExponent) {             return false;           } else {             seenDot = true;             break;           }         case 'e': case 'E':           if (seenExponent || !seenNumber) {             return false;           } else {             seenExponent = true;             seenNumber = false;             break;           }         case '+': case '-':           if (i != 0 &amp;&amp; (charArray[i - 1] != 'e' &amp;&amp; charArray[i - 1] != 'E')) {             return false;           } else {             seenNumber = false;             break;           }         default:           if (charArray[i] - '0' &lt; 0 || charArray[i] - '0' &gt; 9) {             return false;           } else {             seenNumber = true;           }       }     }     return seenNumber;   }  }   결과  Link   설명     문자열 s가 숫자로 표시 가능한지 검증하는 문제이다.            숫자는 정수 혹은 실수로 표현된다.       ’+’, ‘-‘ 부호가 포함될 수 있다.       지수 표현인 ‘e’, ‘E’ 문자가 포함될 수 있다.           문제 풀이에 필요한 변수를 정의한다.            charArray는 문자열 s를 문자 배열로 변환한 변수이다.       seenNumber는 숫자를 마주친 경우를 저장할 변수로, false로 초기화한다.       seenExponent는 지수를 마주친 경우를 저장할 변수로, false로 초기화한다.       seenDot는 실수의 소수점 표시를 마주친 경우 저장할 변수로, false로 초기화한다.           0부터 charArray의 길이 미만까지 i를 증가시키며 아래를 반복한다.            charArray[i]의 값에 따라서 아래를 수행한다.                    ’.’ 문자인 경우, seenDot 혹은 seenExponent의 값이 true이면 false를 반환하고 아니면 seenDot을 true로 바꾸고 다음 반복을 수행한다.           ‘e’ 혹은 ‘E’ 문자인 경우, seenExponent의 값이 true이거나 seenNumber의 값이 false이면 false를 반환하고 아니면 seenExponent 값에 true를 seenNumber의 값에 false를 넣어준다.           ’+’ 혹은 ‘-‘ 문자인 경우, i가 0이 아니면서 이전 문자가 ‘e’ 혹은 ‘E’가 아니면 false를 반환하고 아니면 seenNumber를 false로 바꿔준다.           그 외로 charArray[i]의 값이 [0, 9] 사이의 숫자가 아니면 false를 반환하고 아니면 seenNumber를 true로 바꿔준다.                           반복이 완료되면 seenNumber의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/valid-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Scramble String",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isScramble(String s1, String s2) {     int length = s1.length();     boolean[][][] dp = new boolean[length][length][length + 1];     for (int k = 1; k &lt;= length; k++) {       for (int i = 0; i + k &lt;= length; i++) {         for (int j = 0; j + k &lt;= length; j++) {           if (k == 1) {             dp[i][j][k] = s1.charAt(i) == s2.charAt(j);           } else {             for (int l = 1; l &lt; k &amp;&amp; !dp[i][j][k]; l++) {               dp[i][j][k] = (dp[i][j][l] &amp;&amp; dp[i + l][j + l][k - l]) || (dp[i][j + k - l][l] &amp;&amp; dp[i + l][j][k - l]);             }           }         }       }     }     return dp[0][0][length];   }  }   결과  Link   설명     문자열 s1을 아래 알고리즘에 따라 s2로 변환이 가능한지 검증하는 문제이다.            문자열의 길이가 1인 경우 알고리즘을 수행할 수 없으며, 1 초과인 경우만 알고리즘을 수행할 수 있다.       문자열을 임의 부분 문자열로 분할 후 두 문자열의 순서를 교체하거나 그대로 유지할 수 있다.       위 두 단계를 재귀적으로 수행한다.           문제 풀이에 필요한 변수를 정의한다.            length는 s1의 길이를 저장한 변수이다.       dp는 각 경우를 반복하여 검증하기 위한 배열로, $length \\times length \\times (length + 1)$ 크기의 3차원  정수 배열로 초기화한다.           1부터 length 이하까지 k를 증가시키고, 0부터 $i + k$가 length 이하까지 i를 증가시키고, 0부터 $j + k$가 length 이하까지 j를 증가시키며 아래를 반복한다.            k가 1인 경우 알고리즘을 수행할 수 없는 경우, dp[i][j][k]의 값에 s1의 i번째 문자와 s2의 j번째 문자가 동일한지 검증한다.       k가 1 초과인 알고리즘을 수행하는 경우, l이 1부터 k 미만이면서 dp[i][j][k]의 값이 false일 때 까지 아래를 반복한다.                    dp[i][j][k]의 위치에 dp[i][j][l]의 값과 dp[$i + l$][$j + l$][$k - l$]의 값이 모두 true이거나, dp[i][$j + k - l$][l]의 값과 dp[i + l][j][k - l]의 값이 모두 true인 둘 중 하나라도 만족하는 부분적으로 변환 가능하면 true를, 둘 다 만족하지 않아 변환할 수 없으면 false를 넣어준다.                           반복이 완료되면 dp[0][0][length]의 값인 변환 가능한지 여부를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/scramble-string/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Game Play Analysis IV",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT ROUND(COUNT(Activity2.player_id)::numeric / COUNT(Activity1.player_id), 2) AS fraction FROM ( \tSELECT player_id, MIN(event_date) AS first_login \tFROM Activity \tGROUP BY player_id ) Activity1 LEFT JOIN Activity Activity2 ON Activity1.player_id = Activity2.player_id AND Activity1.first_login = Activity2.event_date - 1   결과  Link   설명          게임 활동 이력이 담긴 Activity 테이블을 이용하여 첫 로그인 이후 이틀 연속 접속한 사용자의 비율을 소수점 두 자리까지 반올림하여 계산하는 문제이다.            사용자 별 처음 로그인한 시간을 frist_login으로 담아 Activity1을 정의한다.            Activity 테이블을 Activity2로 정의하여 Activity1과 player_id와 first_login과 event_date의 전날이 동일한 계정을 기준으로 LEFT OUTER JOIN을 수행하여 연속 접속한 정보를 넣어준다.            Activity2의 player_id인 이틀 연속 접속한 사용자의 수를 실수형으로 변환하여 Activity1의 player_id인 전체 사용자 수로 나누어 소수점 두 자리까지 반올림하여 비율을 계산한다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/game-play-analysis-iv/",
        "teaser": null
      },{
        "title": "Leetcode Java Next Permutation",
        "excerpt":"문제  Link   코드  class Solution {    public void nextPermutation(int[] nums) {     int length = nums.length;     if (1 &lt; length) {       int i = length - 2;       while (0 &lt;= i &amp;&amp; nums[i + 1] &lt;= nums[i]) {         i--;       }       if (0 &lt;= i) {         int j = length - 1;         while (nums[j] &lt;= nums[i]) {           j--;         }         this.swap(nums, i, j);       }       this.reverse(nums, i + 1, length - 1);     }   }    private void swap(int[] nums, int i, int j) {     int temp = nums[i];     nums[i] = nums[j];     nums[j] = temp;   }    private void reverse(int[] nums, int i, int j) {     while (i &lt; j) {       this.swap(nums, i++, j--);     }   }  }   결과  Link   설명     nums의 사전적으로 다음에 올 수 있는 순열로 변환하는 문제이다.            단, 현재 배열이 사전적으로 다음에 올 수 있는 순열이 없으면 사전적으로 가장 작은 순열로 변환한다.           length는 nums의 길이를 저장한 변수로, 1 초과인 경우만 변환 가능하므로 다음을 수행한다.            i는 시작 지점을 탐색할 위치를 저장할 변수로, $length - 2$로 초기화하고 i가 처음 위치일 때까지 사전적으로 작은 위치를 탐색하여 넣어준다.       i가 0보다 큰 경우, 아래를 반복한다.                    j인 마지막 지점을 탐색할 위치를 저장할 변수로, $length - 1$로 넣어 nums[j]의 값이 nums[i]의 값보다 작거나 같을 때 까지 j를 감소시켜준 후 nums 내 i번째 값과 j번째 값을 바꿔준다.                       nums의 $i + 1$번째 값과 $length - 1$번째 값을 역순으로 치환하여 순서를 다시 정렬해준다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/next-permutation/",
        "teaser": null
      },{
        "title": "Leetcode Java Finding 3-Digit Even Numbers",
        "excerpt":"문제  Link   코드  class Solution {    public int[] findEvenNumbers(int[] digits) {     int[] counts = new int[10];     for (int digit : digits) {       counts[digit]++;     }     List&lt;Integer&gt; list = new ArrayList&lt;&gt;();     for (int i = 1; i &lt; 10; i++) {       if (0 &lt; counts[i]) {         counts[i]--;         for (int j = 0; j &lt; 10; j++) {           if (0 &lt; counts[j]) {             counts[j]--;             for (int k = 0; k &lt; 10; k += 2) {               if (0 &lt; counts[k]) {                 list.add(i * 100 + j * 10 + k);               }             }             counts[j]++;           }         }         counts[i]++;       }     }     return list.stream().mapToInt(i -&gt; i).toArray();   }  }   결과  Link   설명          [0, 9] 사이 값들로 이루어진 digits 내 숫자들을 이용하여 중복되지 않은 짝수인 세 자리 숫자를 모두 만드는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            counts는 digits 내 값들의 갯수를 계산할 변수로, 10 크기의 정수 배열로 초기화하고 digits 내 각 값들의 갯수를 넣어준다.       list는 만들 수 있는 세 자리 숫자들을 넣을 변수로, ArrayList로 초기화한다.           1부터 10 미만까지 i를 증가시키며 아래를 반복한다.            counts[i] 값이 0보다 큰 경우, counts[i]를 감소시키고 0부터 10 미만까지 j를 증가시키며 아래를 반복한다.                    counts[j]의 값이 0보다 큰 경우, counts[j]를 감소시키고 0부터 10 미만까지 k를 2씩 증가시키며 counts[k]의 값이 0보다 크면 list에 $i \\times 100 + j \\times 10 + k$의 값을 넣어준다.           counts[j]의 값을 다시 증가시켜 값을 복원해준다.                       counts[i]의 값을 다시 증가시켜 값을 복원해준다.           완성된 list를 정수 배열로 변환하여 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/finding-3-digit-even-numbers/",
        "teaser": null
      },{
        "title": "Leetcode Java Total Characters in String After Transformations I",
        "excerpt":"문제  Link   코드  class Solution {    private static final int MOD = 1000000007;    public int lengthAfterTransformations(String s, int t) {     int[] dp = new int[t + 26];     for (int i = 0; i &lt; 26; i++) {       dp[i] = 1;     }     for (int i = 26; i &lt; t + 26; i++) {       dp[i] = (dp[i - 25] + dp[i - 26]) % MOD;     }     int result = 0;     for (char c : s.toCharArray()) {       result = (result + dp[c - 'a' + t]) % MOD;     }     return result;   }  }   결과  Link   설명     영소문자로 이루어진 s를 이용하여 아래 규칙을 t번 수행한 결과에 대한 문자열 길이를 반환하는 문제이다.            ‘a’는 ‘b’로 ‘b’는 ‘c’와 같이 각 영소문자는 각 수행에서 다음 영소문자로 변환하고, ‘z’ 문자는 ‘ab’ 문자열로 변환한다.       길이가 매우 길 수 있으므로 모듈러 $10^9 + 7$을 적용한다.           문제 풀이에 필요한 변수를 정의한다.            dp는 각 수행 별 영소문자의 갯수를 계산할 변수로, 영소문자 갯수인 26과 반복 횟수인 t를 더한 크기로 초기화 후 아래를 수행하여 값을 넣어준다.                    dp 내 모든 위치 값에 1을 넣어 초기값을 넣어준다.           26부터 $t + 26$ 미만까지 i를 증가시키며 dp[i]의 값에 $dp[i - 25] + dp[i - 26]$의 값인 현재 반복을 수행한 결과에 모듈러 $10^9 + 7$을 적용한 값을 넣어준다.                       result는 문자열의 길이를 저장할 변수로, 0으로 초기화한다.           s의 각 문자를 순서대로 c에 넣어 아래를 수행한다.            result에 result와 dp 내 c의 영문자 순서에 t를 더한 위치 값을 더한 후 모듈러 $10^9 + 7$을 적용한 값을 넣어준다.           반복이 완료되어 계산된 문자열의 길이인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/total-characters-in-string-after-transformations-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Type of Triangle",
        "excerpt":"문제  Link   코드  class Solution {    public String triangleType(int[] nums) {     if (nums[0] + nums[1] &lt;= nums[2] || nums[0] + nums[2] &lt;= nums[1] || nums[1] + nums[2] &lt;= nums[0]) {       return \"none\";     } else if (nums[0] == nums[1] &amp;&amp; nums[1] == nums[2]) {       return \"equilateral\";     } else if (nums[0] == nums[1] || nums[1] == nums[2] || nums[0] == nums[2]) {       return \"isosceles\";     } else {       return \"scalene\";     }   }  }   결과  Link   설명     nums의 세 숫자를 이용하여 삼각형을 만들려고 할 때, 만들 수 있는 삼각형 종류를 반환하는 문제이다.            모든 변의 값이 동일한 삼각형은 정삼각형이라고 하며, “equilateral”를 반환한다.       두 변의 값이 동일한 삼각형은 이등변 삼각형이라고 하며, “isosceles”를 반환한다.       모든 변의 값이 다른 삼각형은 부등변 삼각형이라고 하며, “scalene”를 반환한다.       삼각형을 만들 수 없으면 “none”을 반환한다.           아래의 각 상태에 따른 값을 반환한다.            nums내 한 값이 나머지 두 값을 더한 값보다 작아 삼각형을 이룰 수 없는 경우, “none”을 반환한다.       nums의 모든 값이 동일한 정삼각형을 만들 수 있는 경우, “equilateral”을 반환한다.       nums의 임의 두 값이 동일한 이등변 삼각형을 만들 수 있는 경우, “isosceles”를 반환한다.       그 외인 부등변 삼각형을 만들 수 있는 경우, “scalene”을 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/type-of-triangle/",
        "teaser": null
      },{
        "title": "Leetcode Java Zero Array Transformation I",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isZeroArray(int[] nums, int[][] queries) {     int length = nums.length;     int[] counts = new int[length];     for (int[] query : queries) {       counts[query[0]]++;       if (query[1] + 1 &lt; length) {         counts[query[1] + 1]--;       }     }     int curr = 0;     for (int i = 0; i &lt; length; i++) {       curr += counts[i];       if (curr &lt; nums[i]) {         return false;       }     }     return true;   }  }   결과  Link   설명          nums 내 값을 queries의 구간에 대해서 1씩 줄일 때, 모든 값을 0으로 변환 가능한지 검증하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이을 저장한 변수이다.       counts는 각 값을 계산하기 위한 변수로, length 길이의 정수 배열로 정의하고 queries의 각 값을 순차적으로 query에 넣어 아래를 반복한다.                    counts 내 query[0] 번째 값을 증가시키고, $query[1] + 1$ 값이 length 미만인 counts 내 해당 값에 대한 값을 감소시킬 수 있으면 감소시킨다.                       curr은 nums 내 음수로 전환되는 값의 갯수를 계산할 변수로, 0으로 초기화한다.           0부터 length까지 i를 증가시키며 아래를 반복한다.            curr에 counts[i]를 증가시킨 후 curr이 nums[i]보다 작은 0 미만으로 내려가는 경우, false를 주어진 문제의 결과로 반환한다.           반복이 완료되면 true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/zero-array-transformation-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Build Array from Permutation",
        "excerpt":"문제  Link   코드  class Solution {    public int[] buildArray(int[] nums) {     int length = nums.length;     int[] result = new int[length];     for (int i = 0; i &lt; length; i++) {       result[i] = nums[nums[i]];     }     return result;   }  }   결과  Link   설명          nums 내 값들을 nums 내 값에 해당하는 위치 값을 넣어 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       result는 결과 값을 넣을 배열로, length 길이의 정수 배열로 초기화한다.           0부터 length까지 i를 증가시키며, result[i]의 위치에 nums[nums[i]]의 값을 순차적으로 넣어 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/build-array-from-permutation/",
        "teaser": null
      },{
        "title": "Leetcode Java Zero Array Transformation III",
        "excerpt":"문제  Link   코드  class Solution {    public int maxRemoval(int[] nums, int[][] queries) {     int length = nums.length;     int queryCount = queries.length;     Arrays.sort(queries, (a, b) -&gt; a[0] - b[0]);     Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();     int[] end = new int[length + 1];     int j = 0;     int curr = 0;     for (int i = 0; i &lt; length; i++) {       curr -= end[i];       while (j &lt; queryCount &amp;&amp; queries[j][0] &lt;= i) {         queue.offer(-queries[j++][1]);       }       while (curr &lt; nums[i]) {         if (queue.isEmpty() || -queue.peek() &lt; i) {           return -1;         }         end[-queue.poll() + 1]++;         curr++;       }     }     return queue.size();   }  }   결과  Link   설명     nums 내 각 값들을 아래 규칙대로 값을 제거할 때, 모든 값을 0으로 변환 가능한 쿼리를 남기고 제거할 쿼리의 갯수를 계산하는 문제이다.            queries[i] = [li, ri]로, nums의 [li, ri] 범위 내 값들 중 선택하여 최대 1씩 감소시킬 수 있다.       만일 모든 값을 0으로 변환할 수 없는 경우, -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의하고 값을 정렬한다.            length와 queryCount는 nums와 queries의 길이를 각각 저장한 변수이다.       queries의 각 값을 시작 위치부터 오름차순 정렬해준다.       queue는 사용할 쿼리의 종료 위치를 저장할 변수로, 종료 위치를 오름차순 정렬된 값을 저장하기 위해 PriorityQueue로 초기화한다.       end는 위치 별 사용할 쿼리의 갯수를 계산할 변수로, $length + 1$ 크기의 정수 배열로 초기화한다.       j는 queries를 탐색할 위치 변수로, 0으로 초기화한다.       curr은 현재 사용할 쿼리의 갯수를 계산할 변수로, 0으로 초기화한다.           0부터 length 미만까지 i를 증가시키며 아래를 반복한다.            curr에 end[i]의 현재 위치에 사용 쿼리 갯수를 빼준다.       j가 queryCount 미만이면서 queries[j][0]의 값이 i 이하인 이전 위치의 값까지, queue에 queries[j][1]의 값을 음수로 넣고 j를 증가시켜준다.       curr이 nums[i]의 값보다 작을 때 까지 아래를 반복한다.                    queue가 비어있거나 queue의 맨 앞의 값을 양수로 변환한 값이 i 미만인 현재 위치의 값을 0으로 변경할 수 없는 경우, -1을 주어진 문제의 결과로 반환한다.           end의 queue의 맨 앞의 값을 양수로 변환한 값에 1 증가시킨 위치의 값과 curr의 값을 증가시켜준다.                           반복이 완료되면 모든 값을 0으로 변환하고 남은 쿼리의 갯수인 queue의 크기를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/zero-array-transformation-iii/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Unequal Adjacent Groups Subsequence I",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; getLongestSubsequence(String[] words, int[] groups) {     List&lt;String&gt; result = new ArrayList&lt;&gt;();     result.add(words[0]);     for (int i = 1; i &lt; words.length; i++) {       if (groups[i - 1] != groups[i]) {         result.add(words[i]);       }     }     return result;   }  }   결과  Link   설명     0과 1로 구성된 groups를 이용하여 그룹이 동일하지 않도록 동일한 위치의 words의 문자들을 구성하여 반환하는 문제이다.            답이 여러 개여도 임의 하나만 반환하면 된다.                result는 결과를 저장하기 위한 배열로, ArrayList로 초기화하여 words의 첫 문자를 넣어준다.            1부터 words의 길이 미만까지 i를 증가시키며, groups의 $i - 1$번째 값과 i번째 값이 다른 다른 그룹이면 result에 words[i]를 넣어준다.       반복이 완료되어 그룹이 다른 문자들을 넣은 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-unequal-adjacent-groups-subsequence-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Words Containing Character",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; findWordsContaining(String[] words, char x) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     for (int i = 0; i &lt; words.length; i++) {       if (words[i].indexOf(x) != -1) {         result.add(i);       }     }     return result;   }  }   결과  Link   설명          words 내 x 문자가 포함된 문자의 위치를 모두 반환하는 문제이다.            result는 결과를 저장할 변수로, ArrayList로 초기화한다.            0부터 words의 길이 미만까지 i를 증가시키며, words[i]의 문자열에 x 문자가 -1이 아닌 포함되면 result에 위치 값인 i를 넣어준다.            반복이 완료되면 위치 값이 저장된 result를 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-words-containing-character/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Palindrome by Concatenating Two Letter Words",
        "excerpt":"문제  Link   코드  class Solution {    public int longestPalindrome(String[] words) {     int[][] counts = new int[26][26];     int result = 0;     for (String word : words) {       int c1 = word.charAt(0) - 'a';       int c2 = word.charAt(1) - 'a';       if (counts[c2][c1] == 0) {         counts[c1][c2]++;       } else {         result += 4;         counts[c2][c1]--;       }     }     for (int i = 0; i &lt; 26; i++) {       if (counts[i][i] &gt; 0) {         result += 2;         break;       }     }     return result;   }  }   결과  Link   설명          words 내 문자열을 이용해서 회문(앞 뒤가 동일한 문자열)을 만들 수 있는 최대 문자열의 길이를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            counts는 각 문자의 조합 갯수를 계산하기 위한 변수로, $26 \\times 26$ 크기의 정수 배열로 초기화한다.       length는 words의 길이를 저장한 변수이다.           words의 각 문자열을 word에 순차적으로 넣고 아래를 반복한다.            c1과 c2는 word의 첫 번째 문자와 두 번째 문자의 영문자 순번을 넣어준다.       counts[c2][c1]의 값이 0인 현재 문자열을 반대로 반전시킨 결과가 없는 경우, counts[c1][c2]의 값을 증가시켜준다.       counts[c2][c1]의 값이 0보다 큰 현재 문자열을 반대로 반전시킨 결과가 있는 경우, 아래를 수행한다.                    result 현재 문자와 이전 문자를 합친 문자열 길이인 4를 더해준다.           counts[c2][c1]인 반전시킨 문자열의 갯수를 감소시켜준다.                                마지막으로 0부터 26 미만까지 i를 증가시키며 동일 문자로 구성된 문자가 존재하는지 확인하여 존재하는 경우, result에 2를 더해준다.       반복이 완료되면 만들 수 있는 회문의 최대 길이가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-palindrome-by-concatenating-two-letter-words/",
        "teaser": null
      },{
        "title": "Leetcode Java Largest Color Value in a Directed Graph",
        "excerpt":"문제  Link   코드  class Solution {    public int largestPathValue(String colors, int[][] edges) {     char[] charArray = colors.toCharArray();     int length = charArray.length;     List&lt;Integer&gt;[] graph = new List[length];     for (int i = 0; i &lt; length; i++) {       graph[i] = new ArrayList&lt;&gt;();     }     int[] indegree = new int[length];     for (int[] edge : edges) {       indegree[edge[1]]++;       graph[edge[0]].add(edge[1]);     }     int[][] counts = new int[length][26];     Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();     for (int i = 0; i &lt; length; i++) {       if (indegree[i] == 0) {         queue.offer(i);       }     }     int visited = 0;     int result = 0;     while (!queue.isEmpty()) {       visited++;       int curr = queue.poll();       int color = charArray[curr] - 'a';       result = Math.max(result, ++counts[curr][color]);       for (int value : graph[curr]) {         for (int i = 0; i &lt; 26; i++) {           counts[value][i] = Math.max(counts[value][i], counts[curr][i]);         }         if (--indegree[value] == 0) {           queue.offer(value);         }       }     }     return visited == length ? result : -1;   }  }   결과  Link   설명     각 노드의 색상을 ‘a’ 부터 ‘z’까지로 정의한 colors와 노드 간 연결 정보가 저장된 edges를 이용하여 순환되지 않는 직렬로 연결된 선 중 가장 많은 색상의 수를 구하는 문제이다.            선이 순환되는 경우, -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            charArray는 colors를 문자 배열로 변환한 변수이다.       length는 charArray의 길이를 저장한 변수이다.       graph는 노드 간 연결 정보를 저장할 변수로, length 크기의 List 배열로 초기화한다.       indegree는 간선 정보를 저장할 변수로, length 길이의 정수 배열로 초기화한다.                    edges를 순차적으로 edge에 넣어 indegree 내 연결된 edge[1] 번째 값을 증가시키고, graph의 edge[0] 노드 값의 위치에 edge[1] 노드 값을 넣어준다.                       counts는 색상의 갯수를 계산할 변수로, $length \\times 26$ 크기의 2차원 정수 배열로 초기화한다.       queue는 노드를 순차적으로 넣어 탐색하기 위한 변수로, LinkedList로 초기화 후 indegree 값 존재하는 위치 값을 넣어준다.       visited는 탐색한 위치 값을 저장하기 위한 변수로, 0으로 초기화한다.       result는 연결선 중 가장 많은 색상의 수를 저장하기 위한 변수로, 0으로 초기화한다.           queue가 비어있지 않을 때까지 아래를 반복한다.            visited를 증가시켜 탐색한 위치를 기록한다.       curr은 현재 노드 값을, color는 charArray 내 curr번째 문자의 영문자 순서를 저장한다.       counts[curr][color]의 값을 증가시킨 후 result에 result와 해당 값 중 큰 값을 넣어준다.       graph[curr]의 값을 순차적으로 value에 넣고 아래를 반복한다.                    0부터 26 미만까지 i를 증가시키며 counts[value][i]의 위치에 기존 값과 counts[curr][i]의 값인 현재 노드까지 포함된 갯수 중 큰 값을 반복하여 저장한다.           indegree[value]의 값을 감소시킨 후 값이 0인 연결된 간선 정보가 없는 경우, queue에 value를 넣어 앞의 노드 계산을 수행하도록 한다.                           반복이 완료되면 visited의 값이 length인 마지막까지 탐색한 경우, result를 아니면 -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/largest-color-value-in-a-directed-graph/",
        "teaser": null
      },{
        "title": "Leetcode Java Divisible and Non-divisible Sums Difference",
        "excerpt":"문제  Link   코드  class Solution {    public int differenceOfSums(int n, int m) {     int result = 0;     for (int i = 1; i &lt;= n; i++) {       if (i % m == 0) {         result -= i;       } else {         result += i;       }     }     return result;   }  }   결과  Link   설명          [1, n] 범위의 숫자들 중 m로 나눈 나머지가 0이 아닌 값의 합에 0인 값의 합을 뺀 결과를 구하는 문제이다.            result는 결과를 저장할 변수로, 0으로 초기화한다.       1부터 n 이하까지 i를 증가시키며 아래를 반복한다.            i를 m으로 나눈 나머지가 0인 m의 배수인 경우, result에 i를 빼준다.       i를 m으로 나눈 나머지가 0이 아닌 경우, result에 i를 더해준다.           반복이 완료되면 합계가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/divisible-and-non-divisible-sums-difference/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximize the Number of Target Nodes After Connecting Trees I",
        "excerpt":"문제  Link   코드  class Solution {    public int[] maxTargetNodes(int[][] edges1, int[][] edges2, int k) {     List&lt;List&lt;Integer&gt;&gt; list = this.parseList(edges2);     int max = 0;     for (int i = 0; i &lt; list.size(); i++) {       max = Math.max(max, this.dfs(list, k - 1, i, -1));     }     list = this.parseList(edges1);     int length = list.size();     int[] result = new int[length];     for (int i = 0; i &lt; length; i++) {       result[i] = this.dfs(list, k, i, -1) + max;     }     return result;   }    private List&lt;List&lt;Integer&gt;&gt; parseList(int[][] edges) {     int length = edges.length + 1;     List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(length);     for (int i = 0; i &lt; length; i++) {       list.add(new ArrayList&lt;&gt;());     }     for (int[] edge : edges) {       list.get(edge[0]).add(edge[1]);       list.get(edge[1]).add(edge[0]);     }     return list;   }    private int dfs(List&lt;List&lt;Integer&gt;&gt; list, int k, int i, int target) {     if (k &lt; 0) {       return 0;     } else {       int count = 1;       for (int value : list.get(i)) {         if (value != target) {           count += this.dfs(list, k - 1, value, i);         }       }       return count;     }   }  }   결과  Link   설명          노드간 연결 선 정보가 있는 edges1, edges2를 이용하여 edges1에서 edges2의 임의 노드에 연결하여 k번 이하 이동을 통해 연결할 수 있는 최대 노드의 갯수를 반환하는 문제이다.       각 edges 배열을 이용하여 노드 연결 정보를 List로 변환할 parseList(int[][] edges) 메서드를 정의한다.            length는 list의 길이를 저장할 변수로, [0, $n - 1$] 범위의 값이 존재하므로 edges의 길이보다 1 큰 값을 넣어준다.       list는 각 노드의 연결 정보를 저장할 변수로, [0, $n - 1$] 위치에 ArrayList를 넣어 초기화 후 edges를 순차적으로 edge에 넣고 각 노드 위치에 반대편 노드 위치를 넣어주 후 반환한다.           DFS 방식으로 연결된 노드의 갯수를 계산할 dfs(List&lt;List&lt;Integer&gt;&gt; list, int k, int i, int target) 메서드를 정의한다.            k가 0 미만인 이동 위치가 없으면, 0을 반환한다.       k가 0 이상인 경우, 아래를 반복한다.                    count는 연결된 노드 갯수를 계산하기 위한 변수로, 현재 연결된 노드를 포함하여 1로 초기화한다.           list의 i번째 값들을 순차적으로 value에 넣고 k에 $k - 1$인 이동 횟수를 차감 후 i와 target 위치에 value와 i를 순차적으로 넣어 재귀 호출한 값을 count에 더해준다.           반복을 통해 계산된 count를 반환한다.                           문제 풀이에 필요한 변수를 정의한다.            list는 연결된 노드 정보를 저장할 변수로, 우선 edges2로 parseList(int[][] edges) 메서드를 수행한 결과를 넣어준다.       max는 edges2에서 k 이동거리 내 노드가 최대인 갯수를 저장할 변수로, list를 반복하여 k에 $k - 1$인 이동 횟수를 차감 후 target 위치에 -1을 넣어 dfs(List&lt;List&lt;Integer&gt;&gt; list, int k, int i, int target) 메서드를 수행한 값 중 최댓값을 저장한다.       length는 edges1의 길이를 저장한 변수이다.       result는 결과를 저장할 변수로, length 길이의 정수 배열로 초기화한다.                list에 다시 edges1으로 parseList(int[][] edges) 메서드를 수행한 결과를 넣어준다.       0부터 length 미만까지 i를 증가시키며, result[i]의 위치에 아래 두 값의 합을 넣어준다.            target을 -1로 넣고 dfs(List&lt;List&lt;Integer&gt;&gt; list, int k, int i, int target) 메서드를 수행한 결과인 edges1 내 i번째 노드에서 연결 가능한 노드의 갯수.       edges2에서 최대 연결 가능한 노드 갯수인 max의 값.           반복이 완료되면 각 노드 별 최대 연결 가능한 노드의 수가 저장된 count를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximize-the-number-of-target-nodes-after-connecting-trees-i/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Friend Requests II: Who Has the Most Friends",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below WITH ids AS (   SELECT requester_id AS id FROM RequestAccepted   UNION ALL   SELECT accepter_id AS id FROM RequestAccepted ) SELECT id, COUNT(*) AS num FROM ids GROUP BY id ORDER BY num DESC LIMIT 1   결과  Link   설명          친구 요청에 대한 데이터가 담긴 RequestAccepted를 이용하여 친구가 가장 많은 친구의 아이디와 보유한 친구의 수를 반환하는 문제이다.       요청한 아이디인 requester_id와 수학한 아이디인 accepter_id의 값을 한 컬럼으로 모은 서브 쿼리이다.            친구를 요청한 계정과 수락한 계정은 서로 친구 관계이므로, 친구 수를 하나의 컬럼으로 모은다.           2번에서 정의한 ids의 id를 기준으로 갯수가 가장 많은 하나의 행만 가져온다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/friend-requests-ii-who-has-the-most-friends/",
        "teaser": null
      },{
        "title": "Leetcode Java Find the Lexicographically Largest String From the Box I",
        "excerpt":"문제  Link   코드  class Solution {    public String answerString(String word, int numFriends) {     if (numFriends == 1) {       return word;     } else {       int length = word.length();       int size = length - numFriends + 1;       String result = \"\";       String curr;       for (int i = 0; i &lt; length; i++) {         curr = word.substring(i, Math.min(size + i, length));         if (result.compareTo(curr) &lt; 0) {           result = curr;         }       }       return result;     }   }  }   결과  Link   설명          word를 재귀적으로 중복된 위치의 문제를 배제하고 numFriends 개의 비어있지 않은 문자열로 분할할 때, 분할된 문자열 중 사전적으로 가장 큰 문자열을 찾는 문제이다.            numFriends가 1인 하나의 문자열로 분할하는 경우, 가능한 유일한 문자열인 word를 주어진 문제의 결과로 반환한다.       문제 풀이에 필요한 변수를 정의한다.            length는 word의 길이를 저장한 변수이다.       size는 분할할 문자열의 가능한 길이를 저장할 변수로, $length - numFriends + 1$로 초기화한다.       result는 결과를 저장할 변수이고, curr은 현재 문자열을 저장할 변수이다.           0부터 length 미만까지 i를 증가시키며 아래를 반복한다.            curr에 word의 i번째 위치부터 $size + 1$과 length 중 작은 값 위치 미만까지 문자열을 잘라 넣어준다.       curr이 result보다 사전적으로 큰 문자열인 경우, result에 curr을 넣어준다.           반복이 완료되면 조건을 만족하는 사전적으로 가장 큰 문자열이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-the-lexicographically-largest-string-from-the-box-i/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Employee Bonus",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT Employee.name, Bonus.bonus FROM Employee LEFT OUTER JOIN Bonus ON Employee.empId = Bonus.empId WHERE Bonus.bonus &lt; 1000 OR Bonus.bonus IS NULL   결과  Link   설명          직원이 받은 보너스가 1000 미만인 직원의 이름과 보너스 금액을 반환하는 문제이다.            보너스를 못받은 직원도 있으므로, Employee에 Bonus를 LEFT OUTER JOIN 후 bonus가 1000 미만이거나 null인 받지 못한 직원들만 조회한다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/employee-bonus/",
        "teaser": null
      },{
        "title": "Leetcode Java Lexicographically Minimum String After Removing Stars",
        "excerpt":"문제  Link   코드  class Solution {    public String clearStars(String s) {     char[] charArray = s.toCharArray();     int length = charArray.length;     List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();     for (int i = 0; i &lt; 26; i++) {       lists.add(new ArrayList&lt;&gt;());     }     boolean[] removed = new boolean[length];     for (int i = 0; i &lt; length; i++) {       if (charArray[i] == '*') {         removed[i] = true;         for (int j = 0; j &lt; 26; j++) {           List&lt;Integer&gt; list = lists.get(j);           if (!list.isEmpty()) {             int last = list.size() - 1;             removed[list.get(last)] = true;             list.remove(last);             break;           }         }       } else {         lists.get(charArray[i] - 'a').add(i);       }     }     StringBuilder sb = new StringBuilder();     for (int i = 0; i &lt; length; i++) {       if (!removed[i]) {         sb.append(charArray[i]);       }     }     return sb.toString();   }  }   결과  Link   설명     문자열 s에서 아래의 절차를 반복 수행한 후 사전적 순서가 가장 작은 문자열을 만드는 문제이다.            현재 문자열에서 ‘*‘문자가 존재하는 경우, 해당 문자와 ‘*’ 문자가 아닌 좌측에 존재하는 가장 작은 문자 중 하나를 반복하여 제거한다.           문제 풀이에 필요한 변수를 정의한다.            charArray는 문자열 s를 문자 배열로 저장한 변수이다.       length는 charArray의 길이를 저장한 변수이다.       lists는 각 문자들의 위치를 순차적으로 저장할 변수로, ArrayList로 초기화 후 영문자 갯수인 26개의 ArrayList를 다시 넣어준다.       removed는 제거된 문자인지 기록하기 위한 변수로, length 길이의 부울 배열로 초기화한다.           0부터 length 미만까지 i를 증가시킨다.            charArray의 i번째 문자가 ‘/*‘인 경우, 아래를 수행한다.                    removed[i]의 값을 true로 변경하여 제거된 문자임을 체크해준다.           0부터 26 미만까지 j를 증가시키며, list에 lists의 i번째 ArrayList를 넣어준 후 removed 내 list의 마지막 값에 해당하는 위치의 값을 true로 바꾼 후 list의 last번째 값을 제거하고 반복을 중지한다.                       charArray의 i번째 문자가 ‘/*‘가 아닌 경우, lists의 charArray의 i번째 문자 위치의 ArrayList에 i인 위치를 넣어준다.                sb는 사전적 순서가 가장 작은 문자열을 만들기 위한 변수로, 0부터 length 미만까지 i를 증가시키며 제거된 문자가 아닌 경우만 sb에 순차적으로 넣어준다.       4번을 통해 제거된 문자를 제외하고 사전적 순서가 작은 문자들을 순차적으로 넣은 sb를 문자열로 변환하여  주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/lexicographically-minimum-string-after-removing-stars/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Biggest Single Number",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT MAX(num) AS num FROM (   SELECT num   FROM MyNumbers   GROUP BY num   HAVING COUNT(num) = 1 ) AS UniqueNumbers   결과  Link   설명          MyNumbers 내 중복되지 않은 값 중 가장 큰 값을 찾는 문제이다.            중복된 값을 제거하기 위해 num 기준으로 GROUP BY를 수행하고 발생 빈도가 1인 경우만 취합한 UniqueNumbers 서브 쿼리를 선언한다.            UniqueNumbers 내 가장 큰 num 값을 검색한다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/biggest-single-number/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Managers with at Least 5 Direct Reports",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT name FROM Employee WHERE id IN (   SELECT managerId FROM Employee   GROUP BY managerId   HAVING COUNT(*) &gt;= 5 )   결과  Link   설명          Employee 테이블에서 담당하고 있는 직원이 5명 이상인 매니저의 이름을 반환하는 문제이다.            Employee 테이블 내 매니저의 아이디가 5개 이상인 매니저 아이디만 서브 쿼리로 간추린다.            Employee 테이블에서 2번에서 간추린 아이디의 이름을 검색한다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/managers-with-at-least-5-direct-reports/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Difference Between Even and Odd Frequency I",
        "excerpt":"문제  Link   코드  class Solution {    public int maxDifference(String s) {     int[] counts = new int[26];     for (char c : s.toCharArray()) {       counts[c - 'a']++;     }     int odd = Integer.MIN_VALUE;     int even = Integer.MAX_VALUE;     for (int count : counts) {       if (count != 0) {         if (count % 2 == 1) {           odd = Math.max(odd, count);         } else {           even = Math.min(even, count);         }       }     }     return odd - even;   }  }   결과  Link   설명          문자열 s에서 홀수번 발생한 문자와 짝수번 발생한 문자의 차이가 가장 큰 값을 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            counts는 문자열 s 내 문자의 갯수를 계산하기 위한 변수로, 정수 배열로 초기화 후 s의 각 문자를 순차적으로 반복하여 갯수를 넣어준다.       odd와 even은 홀수번, 짝수번 발생한 문자의 갯수를 계산하기 위한 변수로, 정수의 가장 작은 값과 큰 값으로 초기화한다.           counts를 순차적으로 count에 넣어 아래를 반복한다.            count가 0이 아닌 경우만 아래를 수행한다.                    count가 홀수인 경우, odd에 odd와 count 중 큰 값을 넣어준다.           count가 짝수인 경우, even에 even과 count 중 작은 값을 넣어준다.                           3번을 통해 가장 큰 홀수 값인 odd와 가장 작은 짝수 값인 even의 차잇값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-difference-between-even-and-odd-frequency-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Difference Between Adjacent Elements in a Circular Array",
        "excerpt":"문제  Link   코드  class Solution {    public int maxAdjacentDistance(int[] nums) {     int length = nums.length;     int result = this.getAbsoluteDifference(nums[0], nums[length - 1]);     for (int i = 0; i &lt; length - 1; i++) {       result = Math.max(result, this.getAbsoluteDifference(nums[i], nums[i + 1]));     }     return result;   }    private int getAbsoluteDifference(int num1, int num2) {     if (num1 &gt; num2) {       return num1 - num2;     } else {       return num2 - num1;     }   }  }   결과  Link   설명          원형으로 순환하는 값들이 저장된 nums를 이용하여 인접한 두 값의 차이에 대한 절댓값이 최대인 값을 찾는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       result는 인접한 두 값의 차이에 대한 절댓값이 최대인 값을 저장할 변수로, 첫 값과 마지막 값의 차이에 대한 절댓값으로 넣어준다.           0부터 $length - 1$까지 i를 증가시키며 아래를 반복한다.            result에 result의 값과 nums[i]의 값과 nums[$i + 1$]의 값의 차이에 대한 절댓값 중 큰 값을 저장한다.           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-difference-between-adjacent-elements-in-a-circular-array/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Triangle Judgement",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT x, y, z, CASE WHEN x + y &gt; z AND x + z &gt; y AND y + z &gt; x THEN 'Yes' ELSE 'No' END AS triangle FROM Triangle   결과  Link   설명          삼각형 세 변의 길이인 x, y, z가 저장된 Triangle 테이블을 이용하여 삼각형을 만들 수 있는지 여부를 같이 조회하는 문제이다.            x, y, z 기본 세 값과 triangle 컬럼 값에 삼각 부등식을 만족하여 삼각형을 만들 수 있으면 ‘Yes’를, 아니면 ‘No’를 넣어준다.      ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/triangle-judgement/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Difference by Remapping a Digit",
        "excerpt":"문제  Link   코드  class Solution {    public int minMaxDifference(int num) {     String str = String.valueOf(num);     char[] max = str.toCharArray();     char[] min = str.toCharArray();     char replace = ' ';     for (char c : max) {       if (c != '9') {         replace = c;         break;       }     }     for (int i = 0; i &lt; max.length; i++) {       if (max[i] == replace) {         max[i] = '9';       }     }     replace = min[0];     for (int i = 0; i &lt; min.length; i++) {       if (min[i] == replace) {         min[i] = '0';       }     }     return Integer.parseInt(String.valueOf(max)) - Integer.parseInt(String.valueOf(min));   }  }   결과  Link   설명          num의 숫자들 중 하나의 숫자를 선택하여 [0, 9] 범위 내 숫자로 바꾸었을 때 최댓값과 최솟값을 구한 후, 두 값의 차잇값을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            str은 num을 문자열로 변환한 변수이다.       max와 min은 최댓값과 최솟값으 문자를 변환하여 저장할 변수로, str의 문자 배열로 초기화한다.       replace는 변환할 문자열을 저장할 변수로, 임의 문자열인 ‘ ‘로 초기화하고 max의 문자를 순차적으로 c에 넣은 후 순차적으로 c가 9가 아니면 replace에 c를 넣어준다.                0부터 max의 길이 미만까지 i를 증가시키며, max[i]의 값이 replace와 같은 문자열을 모두 ‘9’로 바꿔 최댓값 문자 배열로 변환한다.            replace를 min[0]의 첫 값으로 초기화 후 0부터 min의 길이 미만까지 i를 증가시키며 아래를 min[i]의 값이 replace와 동일한 경우, min[i]에 ‘0’을 넣어 최솟값 문자여롤 변환한다.       max와 min을 정수형으로 변환 후 두 값의 차이를 주어진 문제의 결과로 반환한다.   해설     임의 값 num의 첫 번째 값과 동일한 값을 9로 바꿔주는 경우, 한 숫자만 바꿀 때 가장 큰 값이된다.            예를 들어, 121212 -&gt; 929292           임의 값 num의 첫 번째 값과 동일한 값을 0으로 바꿔주는 경우, 한 숫자만 바꿀 때 가장 작은 값이된다.            예를 들어, 121212 -&gt; 20202           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-difference-by-remapping-a-digit/",
        "teaser": null
      },{
        "title": "Leetcode Java Max Difference You Can Get From Changing an Integer",
        "excerpt":"문제  Link   코드  class Solution {    public int maxDiff(int num) {     String str = Integer.toString(num);     char[] charArray = str.toCharArray();     String max = str;     String min = str;     for (char c : charArray) {       if (c != '9') {         max = str.replace(c, '9');         break;       }     }     if (str.charAt(0) != '1') {       return Integer.parseInt(max) - Integer.parseInt(str.replace(charArray[0], '1'));     }     for (int i = 1; i &lt; str.length(); i++) {       if (charArray[i] != '0' &amp;&amp; charArray[i] != '1') {         min = str.replace(charArray[i], '0');         break;       }     }     return Integer.parseInt(max) - Integer.parseInt(min);   }  }   결과  Link   설명     num을 이용하여 아래 연산을 서로 다른 두 숫자를 선택하여 수행한 최대 차잇값을 반환한다.            num의 숫자들 중 하나의 숫자를 선택하여 [0, 9] 범위 내 숫자로 바꾼다.       바꾼 숫자의 앞은 0이 되면 안된다.           문제 풀이에 필요한 변수를 정의한다.            str은 num을 문자열로 변환한 변수이다.       charArray는 str의 문자 배열을 저장한 변수이다.       max와 min은 수행한 결과의 차이가 최대가 되기 위한 최댓값과 최솟값을 저장할 변수로, 아래의 값으로 초기화한다.                    max는 str의 앞에서 부터 ‘9’가 아닌 값을 선택하여 해당 값을 모두 ‘9’로 바꾼 문자열로 초기화한다.           min은 str로 초기화한다.                                str의 첫 문자가 1이 아닌 경우, max와 str의 첫 문자를 1로 변환한 두 문자열을 숫자로 치환하여 차잇값을 주어진 문제의 결과로 반환한다.            1부터 str의 길이 미만까지 i를 증가시키며 charArray[i] 문자가 ‘0’과 ‘1’이 아닌 경우, min에 str 내 해당 문자와 동일한 문자를 ‘0’으로 변환하여 넣어준다.       위의 수행이 완료되어 저장된 max와 min을 숫자로 변환하여 두 값의 차잇값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/max-difference-you-can-get-from-changing-an-integer/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Difference Between Increasing Elements",
        "excerpt":"문제  Link   코드  class Solution {    public int maximumDifference(int[] nums) {     int result = -1;     int min = nums[0];     for (int i = 1; i &lt; nums.length; i++) {       result = Math.max(result, nums[i] - min);       min = Math.min(min, nums[i]);     }     return result == 0 ? -1 : result;   }  }   결과  Link   설명     nums를 이용하여 $0 &lt;= i &lt; j &lt; n$를 만족하는 i와 j로 $nums[i] - nums[j]$ 결과가 최대인 값을 반환하는 문제이다.            조건을 만족하는 i와 j가 없는 경우, -1을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의한다.            result는 결과값을 저장할 변수로, 불가능한 -1로 초기화한다.       min은 최솟값을 저장할 변수로, nums[0] 값으로 초기화한다.           1부터 num의 길이 미만까지 i를 증가시키며 아래를 반복한다.            result에 result 와 $nums[i] - min$인 두 값의 최대 차잇값을 넣어준다.       min에 이전까지 최솟값인 min과 num[i] 중 가장 작은 값을 넣어준다.           result가 0인 차잇값이 없으면 -1을, 아니면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-difference-between-increasing-elements/",
        "teaser": null
      },{
        "title": "Leetcode Java Divide Array Into Arrays With Max Difference",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] divideArray(int[] nums, int k) {     Arrays.sort(nums);     int length = nums.length;     int[][] result = new int[length / 3][3];     for (int i = 2; i &lt; length; i += 3) {       if (nums[i] - nums[i - 2] &gt; k) {         return new int[0][];       } else {         result[i / 3] = new int[] { nums[i - 2], nums[i - 1], nums[i] };       }     }     return result;   }  }   결과  Link   설명     3의 배수의 갯수의 정수가 존재하는 nums를 이용하여 부분 배열 내 값들의 차이는 k 이하를 만족하는 3개의 정수로 구성된 부분 배열들로 분리하는 문제이다.            단, 모든 값들을 부분 배열로 분리할 수 없으면 빈 배열을 주어진 문제의 결과로 반환한다.           문제 풀이에 필요한 변수를 정의 혹은 초기화한다.            nums를 오름차순으로 정렬한다.       length는 nums의 길이를 저장한 변수이다.       result는 결과를 저장할 변수로, 가능한 부분 배열의 갯수인 $\\frac{length}{3}$과 부분 배열의 길이인 3의 2차원 정수 배열로 초기화한다.           2부터 length 미만까지 i를 3씩 증가시키며 아래를 반복한다.            $nums[i] - nums[i - 2]$의 값이 k 초과인 조건을 만족하지 않는 경우, 빈 배열을 주어진 문제의 결과로 반환한다.       위의 경우가 아니라면 result[$\\frac{i}{3}$]의 위치에 nums[$i - 2$], nums[$i - 1$], num[i]의 값을 넣어준다.           반복이 완료되어 조건을 만족하는 배열로 구성된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/divide-array-into-arrays-with-max-difference/",
        "teaser": null
      },{
        "title": "Leetcode Java Divide Array Into Arrays With Max Difference",
        "excerpt":"문제  Link   코드  class Solution {    public int partitionArray(int[] nums, int k) {     Arrays.sort(nums);     int result = 1;     for (int i = 1, j = 0; i &lt; nums.length; i++) {       if (nums[i] - nums[j] &gt; k) {         result++;         j = i;       }     }     return result;   }  }   결과  Link   설명          정수 배열인 nums를 최댓값과 최솟값의 차이가 최대 k가 되도록 나눌 수 있는 최소 부분 배열의 갯수를 구하는 문제이다.            nums의 값을 오름차순 정렬하고, 결과를 저장할 변수인 result를 1로 초기화한다.       1부터 nums의 길이 미만까지 i를 증가시키고, j는 0으로 초기화 하여 아래를 반복한다.            $nums[i] - nums[j]$의 값이 k 초과인 경우, result를 증가시키고 시작 위치를 저장할 j에 현재 위치인 i를 넣어준다.           반복이 완료되면 최소 부분 배열의 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/partition-array-such-that-maximum-difference-is-k/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Manhattan Distance After K Changes",
        "excerpt":"문제  Link   코드  class Solution {    public int maxDistance(String s, int k) {     char[] charArray = s.toCharArray();     int[] position = new int[2];     int result = 0;     for (int i = 0; i &lt; charArray.length; i++) {       switch (charArray[i]) {         case 'N': position[1]++; break;         case 'S': position[1]--; break;         case 'E': position[0]++; break;         default: position[0]--; break;       }       int distance = Math.abs(position[0]) + Math.abs(position[1]);       result = Math.max(result, distance + Math.min(2 * k, i + 1 - distance));     }     return result;   }  }   결과  Link   설명     아래 규칙대로 이동하는 문자들이 저장된 s를 이용하여 순차적으로 이동할 때, 최대 k개의 문자를 변환하여 최대 이동 거리를 반환하는 문제이다.            ‘N’은 북쪽으로 1 이동한다.       ‘S’는 남쪽으로 1 이동한다.       ‘E’은 동쪽으로 1 이동한다.       ‘W’은 서쪽으로 1 이동한다.           문제 풀이에 필요한 변수를 정의한다.            charArray는 s를 문자 배열로 변환한 변수이다.       position은 이동 위치를 저장할 변수로, 2 크기의 정수 배열로 초기화한다.       result는 최대 이동 거리를 저장할 변수로, 0으로 초기화한다.           0부터 charArray의 길이 미만까지 i를 증가시키며 아래를 반복한다.            charArray[i] 문자에 따라 아래를 수행한다.                    ‘N’ 문자인 경우, position[1]의 값인 y축 값을 증가시켜준다.           ‘S’ 문자인 경우, position[1]의 값인 y축 값을 감소시켜준다.           ‘E’ 문자인 경우, position[0]의 값인 x축 값을 증가시켜준다.           그 외인 ‘S’ 문자인 경우, position[0]의 값인 x축 값을 감소시켜준다.                       distance는 x축과 y축의 값인 position[0]과 position[1]의 값의 절댓값의 합을 더해준다.       result에 result와 distance에 이동 횟수를 변경하여 이동 가능한 최대 거리인 $2 \\times k$와 가능한 최대 거리를 도달하기 위한 남은 거리인 $i + 1 - distance$ 중 작은 값을 넣어준다.           반복이 완료되면 최대 이동 거리가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-manhattan-distance-after-k-changes/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Manhattan Distance After K Changes",
        "excerpt":"문제  Link   코드  class Solution {    public int minimumDeletions(String word, int k) {     int result = 100000;     int[] counts = new int[26];     for (char c : word.toCharArray()) {       counts[c - 'a']++;     }     for (int i = 0; i &lt; 26; i++) {       if (counts[i] == 0) {         continue;       }       int count = 0;       for (int j = 0; j &lt; 26; j++) {         if (i == j || counts[j] == 0) {           continue;         }         count += counts[j] &lt; counts[i] ? counts[j] : Math.max(0, counts[j] - (counts[i] + k));       }       result = Math.min(result, count);     }     return result;   }  }   결과  Link   설명          word 내 문자의 각 갯수가 모두 k개 이내의 차이가 되도록 하기 위해 삭제해야 할 문자의 최소 갯수를 게산하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 삭제할 문자의 갯수르 계산하기위한 변수로, 문자열의 최대 길이인 $10^5$로 초기화한다.       counts는 word의 각 문자 갯수를 계산하여 저장할 변수로, word의 각 문자 별 위치에 해당 갯수를 넣어준다.           0부터 26 미만까지 i를 증가시키며 아래를 반복한다.            counts[i]의 값이 0인 존재하지 않는 경우는 무시한다.       count는 현재 삭제할 문자의 갯수를 저장할 변수로, 0으로 초기화한다.       0부터 26 미만까지 j를 증가시키며 아래를 반복한다.                    i와 j가 동일한 검증이 필요 없거나, counts[j]의 값이 0인 존재하지 않는 문자의 경우는 무시한다.           count에 counts[j]의 값이 counts[i]의 값보다 작으면 j번째 문자를 삭제하는 경우인 counts[j]를 넣고, 아니면 0과  k개 이내의 차이가 되기 위한 $counts[j] - (counts[i] + k)$의 값 중 큰 값을 넣어준다.                       위 반복이 완료되면 result에 아래 두 경우 중 가장 작은 값을 넣어준다.                    이전까지 삭제해야할 최소 갯수가 저장된 result의 값.           j번째 문자 기준으로 각 문자가 k개 이내의 차이가 되도록 하기 위한 최소 갯수가 저장된 count의 값.                           반복이 완료되면 조건을 맍족한 최소 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-deletions-to-make-string-k-special/",
        "teaser": null
      },{
        "title": "Leetcode Java Find All K-Distant Indices in an Array",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; findKDistantIndices(int[] nums, int key, int k) {     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();     int curr = 0;     int length = nums.length;     for (int i = 0; i &lt; length; i++) {       if (nums[i] == key) {         int j = Math.max(curr, i - k);         curr = Math.min(i + k, length - 1) + 1;         while (j &lt; curr) {           result.add(j++);         }       }     }     return result;   }  }   결과  Link   설명          nums 내 key와 동일한 값을 포함한 좌우 k개의 중복되지 않은 위치 값을 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            result는 위치 값을 저장할 변수로, ArrayList로 초기화한다.       curr은 현재까지 탐색한 마지막 위치를 저장할 변수로, 0으로 초기화한다.       length는 nums의 길이를 저장한 변수이다.           0부터 length 미만까지 i를 증가시키며 아래를 반복한다.            nums[i]의 값이 key와 동일한 경우, 아래를 수행한다.                    j는 위치 값을 넣기 위한 시작 위치를 저장할 변수로, curr과 현재 위치에서 k 이전 위치인 $i - k$ 중 큰 값을 넣어준다.           curr은 현재 위치에서 k 이후 위치인 $i + k$와 마지막 위치인 $length - 1$ 중 작은 값에 1을 더해서 넣어준다.           j가 curr 미만까지 result에 curr의 값을 넣고 j를 증가시켜준다.                           반복이 완료되면 저장된 restul를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-all-k-distant-indices-in-an-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Binary Subsequence Less Than or Equal to K",
        "excerpt":"문제  Link   코드  class Solution {    public int longestSubsequence(String s, int k) {     char[] charArray = s.toCharArray();     int result = 0;     int cost = 1;     for (int i = s.length() - 1; i &gt;= 0; i--) {       if (charArray[i] == '0' || cost &lt;= k) {         k -= cost * (charArray[i] - '0');         result++;       }       if (cost &lt;= k) {         cost *= 2;       }     }     return result;   }  }   결과  Link   설명          k 이하의 이진수를 구성하는 문자열 s의 가장 긴 부분 배열의 길이를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            charArray 는 문자열 s를 문자 배열로 변환한 변수이다.       result는 부분 배열의 길이를 저장할 변수로, 0으로 초기화한다.       cost는 이진수 값을 계산하기위한 변수로, 1로 초기화한다.           s의 마지막 위치에서 처음 위치까지 역순으로 i를 증가시키면서 아래를 반복한다.            charArray[i] 문자가 0이거나 cost가 k 이하인 경우, k에 cost와 charArray[i]의 영문자 순서 값을 곱한 값을 빼주고 result를 증가시킨다.       cost가 k 이하인 더 증가시킬 수 있는 경우, cost에 2를 곱해준다.           반복이 완료되어 계산된 최대 길이인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-binary-subsequence-less-than-or-equal-to-k/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Subsequence of Length K With the Largest Sum",
        "excerpt":"문제  Link   코드  class Solution {    public int[] maxSubsequence(int[] nums, int k) {     int length = nums.length;     int[] sorted = Arrays.copyOf(nums, length);     Arrays.sort(sorted);     int limit = sorted[length - k];     int count = 0;     for (int i = length - k; i &lt; length; i++) {       if (sorted[i] == limit) {         count++;       }     }     int[] result = new int[k];     int i = 0;     for (int num : nums) {       if (num &gt; limit) {         result[i++] = num;       } else if (num == limit &amp;&amp; count &gt; 0) {         result[i++] = num;         count--;       }       if (i == k) {         break;       }     }     return result;   }  }   결과  Link   설명          정수 배열 nums에서 순차적인 k개 숫자들의 합이 최대인 부분 수열을 만드는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       sorted는 nums의 값들을 오름차순 정렬한 배열로 저장할 변수로, nums를 깊은 복제를 수행 후 오름차순 정렬해준다.       limit은 sorted 내 제거할 숫자의 한계 값을 저장할 변수로, sorted[$length - k$]의 포함될 첫 숫자의 값으로 초기화한다.       count는 limit과 동일한 숫자의 갯수를 계산할 변수로, sorted 내 $length - k$부터 마지막 위치까지 값들 중 limit과 동일한 값의 갯수를 넣어준다.       result는 k개 숫자의 합이 최대인 부분 수열을 저장할 변수로, k 크기의 정수 배열로 초기화한다.       i는 result내 위치 변수로, 0으로 초기화한다.           nums의 각 값을 순차적으로 num에 넣어 아래를 수행한다.            num이 limit보다 큰 부분 수열에 포함되는 숫자의 경우, result[i]에 num을 넣어주고 i를 증가시켜준다.       num이 limit과 동일하면서 count가 0 초과인 포함될 숫자의 경우, result[i]에 num을 넣어주고 i를 증가 count를 감소시켜준다.       위의 수행 이후 i가 k와 동일한 부분 수열이 완성된 경우, 반복을 중지한다.           3번의 반복을 통해 완성된 부분 수열인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-subsequence-of-length-k-with-the-largest-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Subsequences That Satisfy the Given Sum Condition",
        "excerpt":"문제  Link   코드  class Solution {    private static final int MOD = 1000000007;    public int numSubseq(int[] nums, int target) {     Arrays.sort(nums);     int result = 0;     int length = nums.length;     int[] pows = new int[length];     pows[0] = 1;     for (int i = 1; i &lt; length; i++) {       pows[i] = (2 * pows[i - 1]) % MOD;     }     int left = 0;     int right = length - 1;     while (left &lt;= right) {       if (nums[left] + nums[right] &gt; target) {         right--;       } else {         result = (result + pows[right - left++]) % MOD;       }     }     return result;   }  }   결과  Link   설명     정수 배열 nums를 이용하여 부분 수열의 값이 최댓값과 최솟값의 차잇값이 target 이하인 부분 수열의 갯수를 계산하는 문제이다.            단, 값이 매우 클 수 있으므로, 모듈러 $10^9 + 7$을 적용한다.           문제 풀이에 필요한 변수를 정의 및 정렬한다.            nums를 오름차순으로 정렬한다.       result는 부분 수열의 갯수를 계산할 변수로, 0으로 초기화한다.       length는 nums의 길이를 저장한 변수이다.       pows는 2의 거듭제곱값을 저장할 변수로, length 길이의 정수 배열로 초기화하고 첫 값을 1로 넣어주고 각 위치에 해당 위치에 해당하는 2의 거듭제곱 값을 모듈러를 적용한 값으로 넣어준다.       left와 right는 nums의 위치 변수로, 0과 $length - 1$로 초기화한다.           left가 right 이하까지 아래를 반복한다.            $nums[left] + nums[right]$의 값이 target보다 큰 경우, right를 감소시켜 범위를 좁혀준다.       위의 경우가 아니라면 조건에 만족하므로, result에 $result + pows[right - left]$ 값에 모듈러를 적용한 값으로 넣어준다.           반복이 완료되면 계산된 부분 수열의 갯수인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-subsequences-that-satisfy-the-given-sum-condition/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Winner on a Tic Tac Toe Game",
        "excerpt":"문제  Link   코드  class Solution {    public String tictactoe(int[][] moves) {     int length = 3;     int[] rows = new int[length];     int[] cols = new int[length];     int diagonal1 = 0;     int diagonal2 = 0;     int player = 1;     for (int[] move : moves) {       rows[move[0]] += player;       cols[move[1]] += player;       diagonal1 = move[0] == move[1] ? diagonal1 + player : diagonal1;       diagonal2 = move[0] + move[1] == length - 1 ? diagonal2 + player : diagonal2;       if (Math.abs(rows[move[0]]) == length           || Math.abs(cols[move[1]]) == length           || Math.abs(diagonal1) == length           || Math.abs(diagonal2) == length) {         return player == 1 ? \"A\" : \"B\";       }       player *= -1;     }     return moves.length &lt; 9 ? \"Pending\" : \"Draw\";   }  }   결과  Link   설명     A와 B가 $3 \\times 3$ 크기의 바둑판에서 가로, 세로, 대각선이 한 줄을 완성하는 게임을 할 때, 누가 이겼는지 플레이어를 반환하는 문제이다.            A 먼저 시작하고, B는 그 다음으로 순서를 번걸아가면서 둔다.       마지막까지 수행한 결과, 이긴 사람이 없는 경우 “Draw”를 반환한다.       아직 마지막까지 수행하지 않은 경우, “Pending”을 반환한다.           문제 풀이에 필요한 변수를 정의한다.            length는 바둑판 길이인 3을 저장한 변수이다.       rows와 cols는 행과 열의 값을 저장하기 위한 변수로, 각각 length 크기의 정수 배열로 초기화한다.       diagonal1, diagonal2는 왼쪽 아래에서 오른쪽 위로, 왼쪽 위에서 오른쪽 아래로 연결된 대각선 내 돌의 갯수를 저장하기 위한 변수로, 둘 다 0으로 초기화한다.       player는 각 플레이어를 구분하기 위한 값으로, A를 뜻하는 1로 초기화한다.           moves의 처음 값부터 각 값을 move에 순차적으로 넣어 아래를 수행한다.            rows 내 move[0]인 x축, move[1]인 y축에 각각 플레이어의 값인 player를 더해준다.       diagonal1에 move[0]과 move[1]이 동일한 왼쪽 아래에서 오른쪽 위로 향하는 대각선의 위치 값이면 $diagonal1 + player$인 player의 돌이 계속 이어지는지를, 아니면 diagonal1 값 그대로 유지한다.       diagonal2에 $move[0] + move[1]$의 값이 $length - 1$과 동일한 왼쪽 위에서 오른쪽 아래로 향하는 대각선의 위치 값이면 $diagonal2 + player$를, 아니면 diagonal2 값 그대로 유지한다.       아래의 각 값이 length와 동일한 하나라도 선이 완성된 경우 player가 1이면 “A”를, -1인 그 외의 경우 “B”를 주어진 문제의 결과로 반환한다.                    rows[move[0]]의 절댓값인 move[0] 행이 player 돌로 채워진 경우.           cols[move[1]]의 절댓값인 move[1] 열이 player 돌로 채워진 경우.           diagonal1의 절댓값인 왼쪽 아래에서 오른쪽 위로 향하는 대각선이 player 돌로 채워진 경우.           diagonal2의 절댓값인 왼쪽 위에서 오른쪽 아래로 향하는 대각선이 player 돌로 채워진 경우.                       수행을 완료하고 player에 -1을 곱하여 플레이어를 전환한다.           반복이 완료되면 moves의 길이가 9 미만인 진행 중이면 “Pending”을, 9인 수행이 완료되었으면 “Draw”를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-winner-on-a-tic-tac-toe-game/",
        "teaser": null
      },{
        "title": "Leetcode Java Find the K-th Character in String Game I",
        "excerpt":"문제  Link   코드  class Solution {    public char kthCharacter(int k) {     StringBuilder sb = new StringBuilder(\"a\");     while (sb.length() &lt;= k) {       int length = sb.length();       for (int i = 0; i &lt; length; i++) {         sb.append((char) ('a' + ((sb.charAt(i) - 'a') + 1) % 26));       }     }     return sb.charAt(k - 1);   }  }   결과  Link   설명     아래 규칙대로 문자열을 만들 때, k번째 문자를 반환하는 문제이다.            “a” 문자부터 시작해서 현재 문자열 내 모든 영문자들의 다음 순서의 영문자로 변환하여 이어주되, ‘z’ 문자의 다음 문자는 ‘a’로 순회한다.       예를 들어, “c”에서 연산을 수행하면 “cd”가 되고 “zb”에서 연산을 수행하면 “zbac”가 된다.                sb는 동적 문자열 생성을 위한 변수로, StringBuilder로 첫 값인 “a” 문자를 넣어 초기화한다.       sb의 길이가 k 이하일 때 까지 아래를 반복한다.            length에 현재 sb의 길이를 넣어준다.       0부터 length 미만까지 i를 증가시키며, sb에 sb의 i번째 문자의 다음 영소문자를 이어준다.           반복이 완료되면 sb 내 $k - 1$번째 값인 k번째 문자를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-the-k-th-character-in-string-game-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Find the K-th Character in String Game II",
        "excerpt":"문제  Link   코드  class Solution {    public char kthCharacter(long k, int[] operations) {     int c = 0;     k--;     for (int i = 0; k != 0; i++, k &gt;&gt;= 1) {       c += ((int) (k &amp; 1) &amp; operations[i]);     }     return (char) ((c % 26) + 'a');   }  }   결과  Link   설명     0과 1로 구성된 operations를 이용하여 아래대로 문자열을 만들 때, k번째 문자를 반환하는 문제이다.            operations[i] 값이 0이면, 현재 단어의 사본을 복사해서 뒤에 이어준다.       operations[i] 값이 1이면, 현재 단어의 각 문자들을 모두 다음 문자들로 변경 후 기존 문자열 뒤에 이어준다.       “a” 문자부터 시작해서 현재 문자열 내 모든 영문자들의 다음 순서의 영문자로 변환하여 이어주되, ‘z’ 문자의 다음 문자는 ‘a’로 순회한다.       예를 들어, “c”에서 연산을 수행하면 “cd”가 되고 “zb”에서 연산을 수행하면 “zbac”가 된다.                c는 k번째 문자에 해당하는 영문자 순서를 저장할 변수로, 0으로 초기화한다.       k를 감소시킨 후, 0부터 k가 0이 아닐 때 까지 i를 증가시키고, k의 비트를 우측으로 하나씩 이동시키며 아래를 반복한다.            c에 k와 1의 AND(&amp;) 비트 연산을 수행한 후 operations[i]를 다시 AND(&amp;) 비트 연산을 수행한다.           반복이 완료되면 c를 26으로 나눈 나머지 값에 ‘a’문자를 추가 후 문자로 변환하여 주어진 문제의 결과로 반환한다.   해설     k를 1 감소시켜 0-index 기반으로 변환해준 후 만들어지는 문자열 s의 k번째 문자를 찾을 수 있도록 한다.   operations[i] 값에 따라 아래의 경우를 고려한다.            operations[i]의 값이 0인 경우, 동일한 문자열이 반복해서 이어진다.       operations[i]의 값이 1인 경우, 이어지는 문자열은 이전 문자들보다 하나 씩 큰 문자들로 이어진다.           위를 통해서 k의 i번째 비트가 1인 경우, operations[i]를 적용한 후 합계가 더해진 c를 영소문자 갯수인 26으로 나눈 나머지 값을 영소문자로 변환하여 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-the-k-th-character-in-string-game-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Lucky Integer in an Array",
        "excerpt":"문제  Link   코드  class Solution {    public int findLucky(int[] arr) {     int[] counts = new int[501];     for (int num : arr) {       counts[num]++;     }     for (int i = arr.length; i &gt; 0; i--) {       if (i == counts[i]) {         return i;       }     }     return -1;   }  }   결과  Link   설명     arr 내 숫자와 갯수가 일치하는 값 중 가장 큰 값을 반환하는 문제이다.            단, 조건에 해당하는 숫자가 없으면 -1을 주어진 문제의 결과로 반환한다.                counts는 arr 내 값의 갯수를 계산하기 위한 변수로, 값의 상한인 500보다 1 큰 정수 배열로 초기화 후 arr 내 숫자에 해당하는 위치에 갯수를 넣어준다.            arr의 길이부터 0 초과일 때 까지 i를 감소시키며, i 와 counts[i]의 값이 동일한 경우 해당 값을 반환한다.       반복이 완료되면 조건에 해당하는 숫자가 없으므로, -1을 주어진 문제의 결과로 반환한다.   해설     arr 내 값의 상한과 arr의 길이 제한이 500 이하이므로, arr 길이를 초과하는 숫자에 해당하는 갯수는 존재할 수 없다.   발생 가능한 arr의 길이부터 내림차순으로 조건을 확인하여, 먼저 조건을 만족하는 숫자가 가장 큰 값이다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-lucky-integer-in-an-array/",
        "teaser": null
      },{
        "title": "Leetcode Java Finding Pairs With a Certain Sum",
        "excerpt":"문제  Link   코드  class FindSumPairs {    private int[] nums1;   private int[] nums2;   private Map&lt;Integer, Integer&gt; map;    public FindSumPairs(int[] nums1, int[] nums2) {     this.nums1 = nums1;     this.nums2 = nums2;     this.map = new HashMap&lt;&gt;();     for (int num : nums2) {       this.increase(num, 1);     }   }    public void add(int index, int val) {     this.increase(this.nums2[index], -1);     this.nums2[index] += val;     this.increase(this.nums2[index], 1);   }    public int count(int tot) {     int result = 0;     for (int num : nums1) {       result += this.map.getOrDefault(tot - num, 0);     }     return result;   }    private void increase(int key, int value) {     this.map.put(key, this.map.getOrDefault(key, 0) + value);   }  }  /**  * Your FindSumPairs object will be instantiated and called as such:  * FindSumPairs obj = new FindSumPairs(nums1, nums2);  * obj.add(index,val);  * int param_2 = obj.count(tot);  */   결과  Link   설명     아래의 기능을 수행하는 FindSumPairs 객체를 완성하는 문제이다.            생성자인 FindSumPairs(int[] nums1, int[] nums2)는 nums1과 nums2를 이용하여 객체를 초기화한다.       메서드인 add(int index, int val)는 nums2[index]의 위치에 val 값을 더해준다.       메서드인 count(int tot)는 $nums1[i] + nums2[j] == tot$를 만족하는 조합의 갯수를 반환한다.           기능 수행에 필요한 전역 변수를 정의한다.            nums1과 nums2는 생성자를 통해 주어지는 정수 배열을 저장할 변수이다.       map은 합계의 갯수를 저장할 변수이다.           생성자인 FindSumPairs(int[] nums1, int[] nums2)를 완성한다.            nums1과 nums2에 주어진 배열을 넣어 초기화한다.       map은 HashMap으로 초기화 후, nums2의 각 값을 순차적으로 num에 넣어 map의 num에 해당하는 위치의 값을 1 증가시킨다.           메서드인 add(int index, int val)를 완성한다.            이전 값인 map 내 nums2[index]에 해당하는 값을 1 감소시킨다.       nums2[index] 값에 val을 더해준다.       변경된 값인 map 내 nums2[index]에 해당하는 값을 1 증가시킨다.           메서드인 count(int tot)를 완성한다.            result는 갯수를 계산하기 위한 변수로, 0으로 초기화한다.       nums1을 순차적으로 num에 넣어 result에 $tot - num$에 해당하는 위치 값을 더해준다.       계산된 조건을 만족하는 값의 갯수인 result를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/finding-pairs-with-a-certain-sum/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Number of Events That Can Be Attended II",
        "excerpt":"문제  Link   코드  class Solution {    public int maxValue(int[][] events, int k) {     if (k == 1) {       return Arrays.stream(events).max(Comparator.comparingInt(e -&gt; e[2])).orElseThrow()[2];     } else {       Arrays.sort(events, Comparator.comparingInt(e -&gt; e[0]));       int length = events.length;       int[][] dp = new int[length + 1][k + 1];       for (int i = length - 1; i &gt;= 0; i--) {         int next = this.binarySearch(events, events[i][1], i + 1, length);         for (int j = 1; j &lt;= k; j++) {           dp[i][j] = Math.max(dp[i + 1][j], dp[next][j - 1] + events[i][2]);         }       }       return dp[0][k];     }   }    private int binarySearch(int[][] events, int target, int start, int end) {     while (start &lt; end) {       int mid = ((end - start) / 2) + start;       if (target &gt;= events[mid][0]) {         start = mid + 1;       } else {         end = mid;       }     }     return start;   }  }   결과  Link   설명     아래 구성으로 된 events를 이용하여 겹치지 않은 이벤트에 참석하여 얻을 수 있는 최대 값을 반환하는 문제이다.            events[i] = [startDayi, endDayi, valuei]로 구성되어 있으며, 각 값은 아래의 의미를 가진다.                    startDayi는 i번째 이벤트 시작 날자를 의미한다.           endDayi는 i번째 이벤트 종료 날자를 의미한다.           valuei는 i번째 이벤트 참석을 통해 얻을 수 있는 값을 의미한다.                                k가 1인 하나의 이벤트만 참석하는 경우, 모든 이벤트 중 가장 큰 value 값을 주어진 문제의 결과로 반환한다.            events를 시작 날자인 첫 값 기준으로 오름차순 정렬한다.       문제 풀이에 필요한 변수를 정의한다.            length는 events의 길이를 저장한 변수이다.       dp는 최대 값을 구하기 위한 배열로, $(length + 1) \\times (k + 1)$ 크기의 2차원 배열로 초기화한다.           $length - 1$부터 0 이상까지 i를 감소시키며 아래를 반복한다.            next에 $i + 1$번째 이벤트에서 마지막 이벤트까지 i번째 events의 종료 날자 이후에 시작하는 이벤트의 위치를 찾아 넣어준다.       1부터 k이하까지 j를 증가시키며 dp[i][j]의 위치에 dp[$i + 1$][k] 값인 다음 이벤트까지의 값과 $dp[next][j - 1] + events[i][2]$의 값인 해당 이벤트를 포함한 값의 합 중 큰 값을 넣어준다.           반복이 완료되면 조건을 만족하는 최대 값이 저장된 dp[0][k]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-number-of-events-that-can-be-attended-ii/",
        "teaser": null
      },{
        "title": "Leetcode Java Reschedule Meetings for Maximum Free Time I",
        "excerpt":"문제  Link   코드  class Solution {    public int maxFreeTime(int eventTime, int k, int[] startTime, int[] endTime) {     int length = startTime.length;     int[] gaps = new int[length + 1];     gaps[0] = startTime[0];     gaps[length] = eventTime - endTime[length - 1];     for (int i = 1; i &lt; length; i++) {       gaps[i] = startTime[i] - endTime[i - 1];     }     int window = 0;     for (int i = 0; i &lt;= k; i++) {       window += gaps[i];     }     int result = window;     for (int i = k + 1; i &lt;= length; i++) {       window += gaps[i] - gaps[i - (k + 1)];       result = Math.max(result, window);     }     return result;   }  }   결과  Link   설명     [0, eventTime] 범위 내 i개의 스케줄 시작과 종료 시간이 저장된 startTime과 endTime을 이용해서 최대 k개의 스케줄 조정을 통해 얻을 수 있는 최대 여유 시간을 구하는 문제이다.            최대 여유 시간은 스케줄 사이의 유휴 시간을 의미하며, 각각의 스케줄은 겹치지 않아야 한다.       각 스케줄은 eventTime 외 시간으로 변경할 수 없다.           문제 풀이에 필요한 변수를 정의한다.            length는 스케줄 갯수인 startTime의 길이를 저장한 변수이다.       gaps는 스케줄 사이의 여유 시간을 저장할 배열로, $length + 1$ 크기의 정수 배열로 초기화 후 아래를 통해 값을 넣어준다.                    gaps[0]에 startTime[0]의 값을, gaps[length]에 $eventTime - endTime[length - 1]$ 값을 넣어준다.           1부터 length 미만까지 i를 증가시키며, gaps[i]에 $startTime[i] - endTime[i - 1]$의 값인 스케줄의 차잇값을 넣어준다.                       window는 Sliding Window 방식으로 결과 값 탐색하기 위한 변수로, 0으로 초기화 후 0부터 k 이하까지 i를 증가시키며, window에 gaps[i] 값을 더해준다.       result는 결과 값을 저장할 변수로, 위에서 초기화한 window 값을 넣어준다.           $k + 1$부터 length 이하까지 i를 증가시키며 아래를 반복한다.            window에 아래 두 값의 차잇값을 더해준다.                    gaps[i] 값인 i번째 위치 이전까지 여유 시간.           gaps[$i - (k + 1)$] 값인 window 값을 구성할 때 옮긴 스케줄 이전의 여유 시간.                       result에 해당 값과 window 중 큰 값인 가장 큰 여유 시간을 넣어준다.           반복이 완료되어 저장된 가장 큰 여유 시간이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/reschedule-meetings-for-maximum-free-time-i/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Matching of Players With Trainers",
        "excerpt":"문제  Link   코드  class Solution {    public int matchPlayersAndTrainers(int[] players, int[] trainers) {     Arrays.sort(players);     Arrays.sort(trainers);     int i = 0;     int j = 0;     int result = 0;     while (j &lt; trainers.length &amp;&amp; i &lt; players.length) {       if (players[i] &gt; trainers[j]) {         while (j &lt; trainers.length &amp;&amp; trainers[j] &lt; players[i]) {           j++;         }       } else {         result++;         i++;         j++;       }     }     return result;   }  }   결과  Link   설명          players의 각 플레이어는 자신의 능력보다 크거나 같은 trainers 내 트레이너를 선택할 수 있으며, 가장 많이 매칭할 수 있는 조합의 수를 반환하는 문제이다.            players와 trainers를 오름차순으로 정렬해준다.       문제 풀이에 필요한 변수를 정의한다.            i와 j는 players와 trainers를 탐색할 위치 변수로, 0으로 초기화한다.       result는 가장 많이 매칭할 수 있는 조합의 수를 계산할 변수로, 0으로 초기화한다.           j가 trainers 이하면서 i가 players 이하일 때 까지 아래를 반복한다.            players[i] 값이 trainers[j] 값보다 큰 경우, j가 trainers 길이 미만이면서 trainers[j] 값이 players[i] 값보다 작을 때 까지 j를 증가시켜준다.       players[i] 값이 trainers[j] 값보다 작거나 같은 매칭이 가능한 경우, result와 i, j의 값 모두 증가시켜준다.           반복이 완료되면 매칭된 쌍의 수인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-matching-of-players-with-trainers/",
        "teaser": null
      },{
        "title": "Leetcode Java Valid Word",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isValid(String word) {     if (word.length() &lt; 3) {       return false;     } else {       int vowels = 0;       int consonants = 0;       for (char c : word.toCharArray()) {         if (Character.isLetter(c)) {           if (\"aeiouAEIOU\".indexOf(c) != -1) {             vowels++;           } else {             consonants++;           }         } else if (!Character.isDigit(c)) {           return false;         }       }       return 0 &lt; vowels &amp;&amp; 0 &lt; consonants;     }   }  }   결과  Link   설명     word의 문자열의 아래 조건을 모두 만족하는지 검증하는 문제이다.            최소 3자리 이상의 문자열로, 숫자와 영대소문자로만 구성되어있다.       영문자 모음 ‘a’, ‘e’, ‘i’, ‘o’, ‘u’ 문자의 대소문자를 최소 하나 이상 포함한다.       영문자 자음 ‘a’, ‘e’, ‘i’, ‘o’, ‘u’ 문자를 제외한 문자의 대소문자를 최소 하나 이상 포함한다.                word가 3자리 미만의 문자열인 경우, false를 주어진 문제의 결과로 반환한다.            vowels와 consonants는 모음과 자음 문자의 갯수를 저장할 변수로, 0으로 초기화한다.       word의 문자들을 순차적으로 c에 넣고 아래를 수행한다.            c가 영문자이면 모음인 경우 vowels를, 자음인 경우 consonants를 증가시킨다.       c가 영문자가 아니면 숫자가 아닌 경우, false를 주어진 문제의 결과로 반환한다.           마지막으로 vowels와 consonants 모두 0보다 큰지 확인하여 해당 결과를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/valid-word/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Erasure Value",
        "excerpt":"문제  Link   코드  class Solution {    public int maximumUniqueSubarray(int[] nums) {     int length = nums.length;     int sum = 0;     int result = 0;     int[] index = new int[10001];     for (int left = 0, right = 0; right &lt; length; right++) {       while (left &lt; index[nums[right]]) {         sum -= nums[left++];       }       sum += nums[right];       result = Math.max(sum, result);       index[nums[right]] = right + 1;     }     return result;   }  }   결과  Link   설명          nums 내 고유한 값으로 이루어진 연속된 순서의 단 하나의 부분 배열을 제거하고 합한 값이 최대인 값을 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 nums의 길이를 저장한 변수이다.       sum은 합계를 저장할 변수로, 0으로 초기화한다.       result는 최대 합계를 저장할 변수로, 0으로 초기화한다.       index는 값을 저장할 변수로, 값의 상한선보다 1 큰 $10^4 + 1$ 크기의 정수 배열로 초기화한다.           left를 0으로, right가 0부터 length 미만까지 right를 증가시키며 아래를 반복한다.            left가 index[nums[right]]의 값보다 작을 때 까지, sum에서 nums[left]의 값을 빼고 left를 증가시키는 것을 반복하여 합계에서 부분 범위 내 값들을 빼준다.       sum에 nums[right]를 추가하여 right번째 값을 포함시켜준다.       result에 지금까지 합계인 sum과 이전 최대 값인 result 중 큰 값을 넣어준다.       index[nums[right]]의 위치에 $right + 1$을 넣어 위치 값을 저장한다.           반복이 완료되면 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-erasure-value/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Burgers with No Waste of Ingredients",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;Integer&gt; numOfBurgers(int tomatoSlices, int cheeseSlices) {     int doubleJumbo = tomatoSlices - (2 * cheeseSlices);     int jumbo = doubleJumbo / 2;     int small = cheeseSlices - jumbo;     if (0 &lt;= jumbo &amp;&amp; doubleJumbo % 2 == 0 &amp;&amp; 0 &lt;= small) {       return Arrays.asList(jumbo, small);     } else {       return new ArrayList&lt;&gt;();     }   }  }   결과  Link   설명     아래 조합의 햄버거를 남은 재료 없이 만들기 위한 조합을 [점보 버거 수, 스몰 버거 수]로 반환하는 문제이다.            점보 버거는 4개의 썰은 토마토와 1개의 썰은 치즈가 필요하다.       점보 버거는 2개의 썰은 토마토와 1개의 썰은 치즈가 필요하다.       남은 재료가 존재하는 경우, 빈 ArrayList를 반환한다.           문제 풀이에 필요한 변수를 정의한다.            doubleJumbo는 만들 수 있는 점보 버거 수의 두배를 저장한 변수로, $tomatoSlices - (2 \\times cheeseSlices)$로 초기화한다.       jumbo는 만들 수 있는 점보 버거 수를 저장한 변수로, $\\frac{doubleJumbo}{2}$로 초기화한다.       small은 만들 수 있는 스몰 버거 수를 저장한 변수로, $cheeseSlices - jumbo$로 초기화한다.           아래 조건을 모두 부합하면 jumbo와 small을 순서대로 ArrayList로 넣어 주어진 문제의 결과로 반환한다.            jumbo가 0보다 크거나 같은 음수가 아닌 경우.       doubleJumbo가 짝수인 jumbo를 만들면서 남는 재료가 없는 경우.       small이 0보다 크거나 같은 음수가 아닌 경우.           해설     tomatoSlices는 점보 버거에 4개, 스몰 버거에 2개 사용되므로 $tomatoSlices = (4 \\times jumbo) + (2 \\times small)$로 표기한다.   cheeseSlices는 점보 버거에 1개, 스몰 버거에 1개 사용되므로 $cheeseSlices = jumbo + small$로 표기한다.   위 값을 기반으로 $doubleJumbo = 2 \\times jumbo = tomatoSlices - (2 \\times cheeseSlices)$가 성립한다.   위를 기반으로 $jumbo = \\frac{doubleJumbo}{2}$가 되며, $small = cheeseSlices - jumbo$가 성립한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-burgers-with-no-waste-of-ingredients/",
        "teaser": null
      },{
        "title": "Leetcode Java Longest Subarray With Maximum Bitwise AND",
        "excerpt":"문제  Link   코드  class Solution {    public int longestSubarray(int[] nums) {     int result = 1;     int max = Integer.MIN_VALUE;     for (int num : nums) {       max = Math.max(max, num);     }     int temp = 0;     for (int num : nums) {       if (num == max) {         temp++;       } else {         result = Math.max(result, temp);         temp = 0;       }     }     return Math.max(result, temp);   }  }   결과  Link   설명     nums 내 아래의 조건을 만족하는 최대 길이를 구하는 문제이다.            모든 부분 배열의 AND 비트 연산 값의 최댓값으로 이루어진 값으로 이루어진 값들의 연속된 최대 길이를 구하는 문제이다.           문제 풀이에 필요한 변수를 정의한다.            result는 최대 길이를 저장할 변수로, 최소 길이인 1으로 초기화한다.       max는 최댓값을 구하기 위한 변수로, 정수의 최솟값으로 초기화 후 nums의 각 값을 반복하여 최댓값을 넣어준다.       temp는 최대 길이를 저장하기 위한 임시 변수로, 0으로 초기화한다.           nums의 각 값을 num에 순차적으로 넣어 아래를 반복한다.            num이 max와 동일한 경우, temp를 증가시킨다.       위의 경우가 아니라면, result에 result와 temp 중 큰 값인 최대 길이를 저장 후 temp를 0으로 초기화한다.           이전까지 저장된 최대 길이인 result와 마지막으로 계산된 최대 길이인 temp 중 큰 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/longest-subarray-with-maximum-bitwise-and/",
        "teaser": null
      },{
        "title": "Leetcode PostgreSQL Students and Examinations",
        "excerpt":"문제  Link   코드  -- Write your PostgreSQL query statement below SELECT Students.student_id   , Students.student_name   , Subjects.subject_name   , COUNT(Examinations.student_id) AS attended_exams FROM Students CROSS JOIN Subjects LEFT OUTER JOIN Examinations ON Students.student_id = Examinations.student_id AND Subjects.subject_name = Examinations.subject_name GROUP BY Students.student_id, Students.student_name, Subjects.subject_name ORDER BY Students.student_id, Subjects.subject_name   결과  Link   설명     아래 테이블들을 이용하여 학생의 각 과목 별 시험을 본 횟수를 구하는 문제이다.            Students 테이블은 학생 정보(student_id, student_name)가 저장된다.       Subjects 테이블은 과목 정보(subject_name)가 저장된다.       Examinations 테이블은 학생 별 시험을 치룬 정보(student_id, subject_name)가 저장된다.                Students 테이블 과 Subjects 테이블을 CROSS JOIN하여 학생과 전과목 정보를 1:1로 이어준다.            Examinations을 Students 테이블의 student_id와 Subjects 테이블의 subject_name를 각 필드 기준으로 OUTER 조인을 함으로 학생 별 시험본 과목을 연결해준다.            COUNT 함수와 GROUP BY 구문을 통해 이용하여 3번의 OUTER 조인을 통해 학생 별 시험을 본 과목의 갯수를 계산해준다.       ORDER BY 구문으로 Students 테이블의 student_id, Subjects 테이블의 subject_name 기준의 오름차순으로 정렬해준다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","PostgreSQL"],
        "url": "/leetcode/students-and-examinations/",
        "teaser": null
      },{
        "title": "Leetcode Java Subtract the Product and Sum of Digits of an Integer",
        "excerpt":"문제  Link   코드  class Solution {    public int subtractProductAndSum(int n) {     int substract = 1;     int sum = 0;     while (n &gt; 0) {       int remainder = n % 10;       n /= 10;       substract *= remainder;       sum += remainder;     }     return substract - sum;   }  }   결과  Link   설명          n의 각 자리의 숫자들을 곱한 값에 합한 값을 뺀 값을 반환하는 문제이다.            substract는 곱한 값을 sum은 더한 값을 저장할 변수로, 1과 0으로 초기화한다.       n이 0 초과일 때까지 아래를 반복한다.            remainder에 n을 10으로 나눈 나머지 값을 저장한다.       n을 10으로 나눈 몫을 넣어준다.       substract에 방금 자릿수인 remainder 값을 자기 자신과 곱한 값을 넣어준다.       sum에 동일하게 방금 자릿수인 remainder 값을 더해준다.           반복이 완료되면 $substract - sum$의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/subtract-the-product-and-sum-of-digits-of-an-integer/",
        "teaser": null
      },{
        "title": "Leetcode Java Fruits Into Baskets II",
        "excerpt":"문제  Link   코드  class Solution {    public int numOfUnplacedFruits(int[] fruits, int[] baskets) {     int length = fruits.length;     int result = length;     for (int i = 0; i &lt; length; i++) {       for (int j = 0; j &lt; length; j++) {         if (fruits[i] &lt;= baskets[j]) {           baskets[j] = 0;           result--;           break;         }       }     }     return result;   }  }   결과  Link   설명     각 자릿수에 해당하는 유형의 과일들의 갯수가 저장된 fruits와 과일을 담을 수 있는 갯수 별 바구니들인 baskets를 이용하여 아래를 수행한 후 담지 못한 과일의 갯수를 계산하는 문제이다.            fruits[i]는 baskets에서 해당 과일을 담을 수 있는 동일한 크기 혹은 더 큰 크기의 바구니를 좌측부터 찾아 조건을 만족하는 빈 바구니가 존재하면 해당 바구니에 해당 과일을 담는다.       한 유형의 과일을 담은 바구니에 다른 유형의 과일을 추가로 담을 수 없다.           문제 풀이에 필요한 변수를 정의한다.            length는 fruits의 길이을 저장한 변수이다.       result는 담을 수 없는 과일의 갯수를 저장한 변수로, 가능한 최대 갯수인 length로 초기화한다.           0부터 length 미만까지 i를 증가시키며 아래를 반복한다.            다시 0부터 length 미만까지 j를 증가시키며 아래를 반복한다.                    fruits[i]의 값이 baskets[j] 이하인 조건에 만족하는 바구니인 경우, baskets[j]의 값을 0으로 바꿔 사용한 바구니임을 체크하고 result를 감소신 후 다음 반복을 수행한다.                           반복이 완료되면 담을 수 없는 과일의 갯수가 남은 result를 주어진 무제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/fruits-into-baskets-ii/",
        "teaser": null
      },{
        "title": "Spring gRPC",
        "excerpt":"Spring gRPC1     Spring gRPC는 gRPC2 프로젝트를 간소화하여 구성하기위한 프로젝트이다.   gRPC란 고성능 오픈 소스 Remote Procedure Call(이하 RPC) Framework로, Client를 Server와 효율적으로 연결할 수 있다.   Protocol buffer3는 언어와 플랫폼에 중립적인 구조화된 데이터를 직렬화하기 위한 데이터 형식으로, JSON과 비슷하지만 더 빠르고 다양한 언어에서 쉽게 읽고 쓸 수 있다. 현재는 Protocol buffer v3인 proto3로 더 다양한 확장성을 제공한다.   Spring gRPC Sample     간단한 Server-Client로 구성된 프로젝트를 기반으로 설명을 진행한다.   hello.proto  syntax = \"proto3\";  option java_multiple_files = true; option java_package = \"com.gracefulsoul.grpc.lib.proto\"; option java_outer_classname = \"HelloProto\";  service Hello {   rpc SayHello(Request) returns (Reply) {}   rpc StreamHello(Request) returns (stream Reply) {} }  message Request {   string name = 1; }  message Reply {   string message = 1; }     syntax는 Protocol buffer의 사용 버전을 명시하며, proto2 혹은 proto3를 반드시 명시한다.   option은 세부 설정을 위한 기능으로, 아래 세 가지를 정의하였다.            ‘java_package는’ Java 혹은 Kotlin 코드를 생성할 때, 패키지 이름을 정의한다.       ‘java_multiple_files’은 Java 코드를 생성할 때, .proto 파일을 단일 .java 파일로 생성할지 각 Java Class, Enum 등에 대해서 각각 생성할지 결정하는 설정으로 기본값은 false인 단일 .java 파일로 생성한다.       ‘java_outer_classname’는 Java 코드를 생성할 때, .proto 파일을 .java 파일로 생성할 때 이름을 결정하기 위한 설정으로 기본값은 .proto 파일의 이름을 카멜 표현식으로 변환한 값이다.           service는 message 타입을 RPC과 함께 사용하기 위해 서비스 인터페이스를 정의하면 Protocol buffer 컴파일러가 선택한 언어로 서비스 인터페이스 코드와 Client와 Server 간의 통신을 추상화하여 복잡한 부분을 숨기고, 사용자가 편리하게 서비스를 이용할 수 있도록 돕기위한 코드인 stubs을 생성한다.            rpc 키워드를 통해서 각 RPC를 정의하고, 반환되는 값에 stream 유무의 차이는 단일 응답인지 Streaming 응답인지를 구분하기 위한 키워드이다.           message는 Client와 Server 간의 주고 받을 내용을 정의하는 데이터 구조로, 필드(field)와 값(value)으로 구성된 구조화된 데이터 형식을 사용한다.            위의 Request message를 예로 들면, string 타입의 name 필드 1개의 키-값 쌍을 가진다.           Request.java  // Generated by the protocol buffer compiler.  DO NOT EDIT! // NO CHECKED-IN PROTOBUF GENCODE // source: hello.proto // Protobuf Java Version: 4.30.2  package com.gracefulsoul.grpc.lib.proto;  /**  * Protobuf type {@code Request}  */ public final class Request extends     com.google.protobuf.GeneratedMessage implements     // @@protoc_insertion_point(message_implements:Request)     RequestOrBuilder { private static final long serialVersionUID = 0L;   static {     com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(       com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,       /* major= */ 4,       /* minor= */ 30,       /* patch= */ 2,       /* suffix= */ \"\",       Request.class.getName());   }   // Use Request.newBuilder() to construct.   private Request(com.google.protobuf.GeneratedMessage.Builder&lt;?&gt; builder) {     super(builder);   }   private Request() {     name_ = \"\";   }   // 이하 생략 }     위의 ‘hello.proto’를 빌드하여 생성된 파일 중 Request message에 대한 파일로, 위에서 간단히 세 줄로 설정한 데이터 구조를 Java에 맞추어 객체 생성에 도움이 될 Builder를 포함하여 기본 객체 비교에 대한 Object의 메서드들과 데이터 송수신에 효율적인 구조를 정의한 GeneratedMessage의 각 메서드들을 상속받아 자동으로 구현한 객체이다.   HelloGrpc.java  package com.gracefulsoul.grpc.lib.proto;  import static io.grpc.MethodDescriptor.generateFullMethodName;  /**  */ @io.grpc.stub.annotations.GrpcGenerated public final class HelloGrpc {    // 중략    /**    * A stub to allow clients to do asynchronous rpc calls to service Hello.    */   public static final class HelloStub       extends io.grpc.stub.AbstractAsyncStub&lt;HelloStub&gt; {     private HelloStub(         io.grpc.Channel channel, io.grpc.CallOptions callOptions) {       super(channel, callOptions);     }      @java.lang.Override     protected HelloStub build(         io.grpc.Channel channel, io.grpc.CallOptions callOptions) {       return new HelloStub(channel, callOptions);     }      /**      */     public void sayHello(com.gracefulsoul.grpc.lib.proto.Request request,         io.grpc.stub.StreamObserver&lt;com.gracefulsoul.grpc.lib.proto.Reply&gt; responseObserver) {       io.grpc.stub.ClientCalls.asyncUnaryCall(           getChannel().newCall(getSayHelloMethod(), getCallOptions()), request, responseObserver);     }      /**      */     public void streamHello(com.gracefulsoul.grpc.lib.proto.Request request,         io.grpc.stub.StreamObserver&lt;com.gracefulsoul.grpc.lib.proto.Reply&gt; responseObserver) {       io.grpc.stub.ClientCalls.asyncServerStreamingCall(           getChannel().newCall(getStreamHelloMethod(), getCallOptions()), request, responseObserver);     }   }    /**    * A stub to allow clients to do limited synchronous rpc calls to service Hello.    */   public static final class HelloBlockingStub       extends io.grpc.stub.AbstractBlockingStub&lt;HelloBlockingStub&gt; {     private HelloBlockingStub(         io.grpc.Channel channel, io.grpc.CallOptions callOptions) {       super(channel, callOptions);     }      @java.lang.Override     protected HelloBlockingStub build(         io.grpc.Channel channel, io.grpc.CallOptions callOptions) {       return new HelloBlockingStub(channel, callOptions);     }      /**      */     public com.gracefulsoul.grpc.lib.proto.Reply sayHello(com.gracefulsoul.grpc.lib.proto.Request request) {       return io.grpc.stub.ClientCalls.blockingUnaryCall(           getChannel(), getSayHelloMethod(), getCallOptions(), request);     }      /**      */     public java.util.Iterator&lt;com.gracefulsoul.grpc.lib.proto.Reply&gt; streamHello(         com.gracefulsoul.grpc.lib.proto.Request request) {       return io.grpc.stub.ClientCalls.blockingServerStreamingCall(           getChannel(), getStreamHelloMethod(), getCallOptions(), request);     }   }    // 이하 생략  }     ‘HelloGrpc.java’는 ‘hello.proto’에서 정의한 Hello service의 각 rpc를 수행하기 위한 객체로, Asynchronous 방식의 연동을 제공하는 HelloStub과 Synchronous 방식의 연동을 제공하는 HelloBlockingStub 등을 포함하여 다양한 기능 수행에 필요한 Stub 객체들을 컴파일을 통해 자동으로 만들어준다.   GrpcServerService.java (Server)  package com.gracefulsoul.grpc.server.service;  import org.springframework.stereotype.Service; import com.gracefulsoul.grpc.lib.proto.HelloGrpc; import com.gracefulsoul.grpc.lib.proto.Reply; import com.gracefulsoul.grpc.lib.proto.Request;  import io.grpc.stub.StreamObserver;  @Service public class GrpcServerService extends HelloGrpc.HelloImplBase {  \t@Override \tpublic void sayHello(Request request, StreamObserver&lt;Reply&gt; responseObserver) { \t\tif (request.getName().startsWith(\"error\")) { \t\t\tthrow new IllegalArgumentException(\"Bad name: \" + request.getName()); \t\t} \t\tif (request.getName().startsWith(\"internal\")) { \t\t\tthrow new RuntimeException(); \t\t} \t\tReply reply = Reply.newBuilder().setMessage(\"Hello \" + request.getName()).build(); \t\tresponseObserver.onNext(reply); \t\tresponseObserver.onCompleted(); \t}  \t@Override \tpublic void streamHello(Request request, StreamObserver&lt;Reply&gt; responseObserver) { \t\tint count = 0; \t\twhile (count &lt; 10) { \t\t\tReply reply = Reply.newBuilder().setMessage(\"Hello \" + request.getName()).build(); \t\t\tresponseObserver.onNext(reply); \t\t\tcount++; \t\t\ttry { \t\t\t\tThread.sleep(1000L); \t\t\t} catch (InterruptedException e) { \t\t\t\tThread.currentThread().interrupt(); \t\t\t\tresponseObserver.onError(e); \t\t\t\treturn; \t\t\t} \t\t} \t\tresponseObserver.onCompleted(); \t}  }     서버에서 각 호출에 대해서 응답을 제공하기 위한 RPC를 Hello service를 구현한 가장 기본 객체인 HelloImplBase를 상속받아 구현하였다.   주요 차이점은 아래와 같다.            sayHello(Request request, StreamObserver&lt;Reply&gt; responseObserver) 메서드는 request로 전달받은 요청을 responseObserver를 이용하여 reply를 한 번에 전달하고 전송을 종료한다.       streamHello(Request request, StreamObserver&lt;Reply&gt; responseObserver) 메서드는 request로 전달받은 요청을 responseObserver를 이용하여 원하는만큼 분할하여 여러 번 전송하고 전송을 종료한다.           GrpcClientApplication.java (Client)  package com.gracefulsoul.grpc.client;  import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.springframework.boot.CommandLineRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.Bean; import org.springframework.grpc.client.GrpcChannelFactory;  import com.gracefulsoul.grpc.lib.proto.HelloGrpc; import com.gracefulsoul.grpc.lib.proto.Request;  @SpringBootApplication public class GrpcClientApplication {  \tprivate static final Log LOG = LogFactory.getLog(GrpcClientApplication.class);  \tpublic static void main(String[] args) { \t\tSpringApplication.run(GrpcClientApplication.class, args); \t}  \t@Bean \tHelloGrpc.HelloBlockingStub stub(GrpcChannelFactory channels) { \t\treturn HelloGrpc.newBlockingStub(channels.createChannel(\"local\")); \t}  \t@Bean \tCommandLineRunner runner(HelloGrpc.HelloBlockingStub stub) { \t\treturn args -&gt; LOG.info(stub.sayHello(Request.newBuilder().setName(\"GracefulSoul\").build())); \t}  }     stub(GrpcChannelFactory channels) 메서드를 통해서 Synchronous 방식의 HelloBlockingStub을 테스트를 위해 ‘local’로 채널을 생성한 객체를 만들어준다.   runner(HelloGrpc.HelloBlockingStub stub) 메서드로 서버측의 sayHello RPC에 ‘GracefulSoul’을 전달해준다.   결과는 아래와 같다.     message: \"Hello GracefulSoul\"           Conclusion     현재 서비스의 아키텍쳐가 다양해짐에 따라 구성되는 서비스의 언어 또한 필요에 따라 다양한 언어들로 구성을 하여 서로의 장점을 이용한 최적의 서비스를 제공하고있다.   기존엔 REST API를 설계 후 Request와 Response에 대한 상세 문서로 연관 서비스 개발자들과 공유하고 관리하는 시간 또한 생산성의 저하의 주 요인이었다면, gRPC를 통해 자동화하고 정형화된 코드 기반으로 개발자들은 비즈니스 로직에 집중할 수 있다.   실 운영에서 사용해보면 단순한 REST API보다는 러닝 커브와 디버깅에 대한 다양한 이슈를 접하겠지만, 익숙해지면 더 나은 개발 환경을 여러분에게 제공하게 될 것이다.   Reference   ※ Sample Code는 여기에서 확인 가능합니다.                 Spring gRPC Start &#8617;                  gRPC Home &#8617;                  Protocol Buffers Home &#8617;           ","categories": ["Spring"],
        "tags": ["Programming","Spring","gRPC"],
        "url": "/spring/spring-grpc/",
        "teaser": null
      },{
        "title": "Leetcode Java Find the Smallest Divisor Given a Threshold",
        "excerpt":"문제  Link   코드  class Solution {    public int smallestDivisor(int[] nums, int threshold) {     int left = 1;     int right = (int) 1e6;     while (left &lt; right) {       int mid = (left + right) / 2;       int sum = 0;       for (int num : nums) {         sum += (num + mid - 1) / mid;       }       if (sum &gt; threshold) {         left = mid + 1;       } else {         right = mid;       }     }     return left;   }  }   결과  Link   설명     아래 수행을 통해서 모든 배열의 값을 threshold보다 작거나 같도록 할 수 있는 가장 작은 약수를 구하는 문제이다.            양의 정수 약수를 선택하여 모든 배열의 값을 이 숫자로 나눈 후 다음 나눗셈 연산에 합산한다.       각 나눗셈의 결과는 해당 값보다 크거나 가까운 숫자로 반올림된다.                left와 right는 값을 탐색하기 위한 값의 범위로, 값의 하한값인 1과 상한값인 $10^6$으로 각각 초기화한다.       left가 right보다 작을 때 까지 아래를 반복한다.            mid에 $\\frac{left + right}{2}$인 중앙값을 넣어준다.       sum은 합계를 저장할 변수로 0으로 초기화한다.                nums의 모든 값을 순차적으로 num에 넣으며 sum에 $\\frac{num + mid - 1}{mid}$ 값을 더해준다.            sum이 threshold보다 크면 left에 $mid + 1$을, 아니면 right에 mid를 넣어 범위를 축소시킨다.       반복이 완료되면 가능한 가장 작은 약수인 left를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-the-smallest-divisor-given-a-threshold/",
        "teaser": null
      },{
        "title": "Leetcode Java Ways to Express an Integer as Sum of Powers",
        "excerpt":"문제  Link   코드  class Solution {    public int numberOfWays(int n, int x) {     int[] dp = new int[n + 1];     dp[0] = 1;     int power;     for (int i = 1; (power = (int) Math.pow(i, x)) &lt;= n; i++) {       for (int sum = n; power &lt;= sum; sum--) {         dp[sum] = (dp[sum] + dp[sum - power]) % 1000000007;       }     }     return dp[n];   }  }   결과  Link   설명     n을 고유한 양의 정수의 x 제곱의 합으로 표현될 수 있는 방법의 수를 반환하는 문제이다.            값이 매우 클 수 있으므로, 모듈러 $10^9 + 7$을 적용하여 계산한다.       예를 들어, n = 160이고 x = 3이면 n을 표현하는 방법 중 하나는 $2^3 + 3^3 + 5^3$이다.           문제 풀이에 필요한 변수를 정의한다.            dp는 결과 계산에 사용할 배열로, $n + 1$ 크기의 정수 배열로 초기화하고 첫 값에 1을 넣어준다.       power는 각 숫자별 제곱 값을 저장할 변수이다.           1부터 $i^x$의 값을 정수로 변환한 power가 n 이하일 때 까지 i를 증가시키며 아래를 반복한다.            n부터 power가 sum 이하일 때 까지 sum을 감소시키며, dp[sum]의 위치에 아래 두 값의 합을 모듈러 $10^9 + 7$을 적용하여 넣어준다.                    sum이 되기 위한 경우의 수가 저장된 dp[sum]의 값           sum에서 power를 뺀 값을 만들 수 있는 경우의 수인 dp[$sum - power$]의 값                           반복이 완료되면 표현될 수 있는 방법의 갯수가 계산된 dp[n]의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/ways-to-express-an-integer-as-sum-of-powers/",
        "teaser": null
      },{
        "title": "Leetcode Java Power of Three",
        "excerpt":"문제  Link   코드  class Solution {    public boolean isPowerOfThree(int n) {     if (n &lt;= 0) {       return false;     } else {       while (n % 3 == 0) {         n /= 3;       }       return n == 1;     }   }  }   결과  Link   설명          주어진 정수가 n이 $3^x$인 3의 제곱수인지를 검증하는 문제이다.            n이 0 이하인 3의 제곱수로 표현 불가능한 값인 경우, false를 주어진 문제의 결과로 반환한다.            n을 나머지 값이 0이 아닐 때 까지 3으로 계속 나눈 나머지 값이 1인 3으로만 구성되는지 여부를 주어진 문제의 결과로 반환한다.       소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/power-of-three/",
        "teaser": null
      },{
        "title": "Leetcode Java Iterator for Combination",
        "excerpt":"문제  Link   코드  class CombinationIterator {    private List&lt;String&gt; list;   private int index;    public CombinationIterator(String characters, int combinationLength) {     this.list = new ArrayList&lt;&gt;();     this.index = 0;     this.dfs(characters.toCharArray(), combinationLength, 0, new StringBuilder());   }    public String next() {     return this.list.get(this.index++);   }    public boolean hasNext() {     return this.index &lt; this.list.size();   }    private void dfs(char[] characters, int combinationLength, int start, StringBuilder sb) {     if (combinationLength == 0) {       this.list.add(sb.toString());     } else {       for (int i = start; i &lt;= characters.length - combinationLength; i++) {         sb.append(characters[i]);         this.dfs(characters, combinationLength - 1, i + 1, sb);         sb.deleteCharAt(sb.length() - 1);       }     }   }  }  /**  * Your CombinationIterator object will be instantiated and called as such:  * CombinationIterator obj = new CombinationIterator(characters, combinationLength);  * String param_1 = obj.next();  * boolean param_2 = obj.hasNext();  */   결과  Link   설명     아래 기능을 수행하는 CombinationIterator 객체를 설계하는 문제이다.            생성자인 CombinationIterator(string characters, int combinationLength)는 정렬된 서로 다른 영소문자로 구성된 characters와 조합 문자열의 길이인 combinationLength로 객체를 초기화한다.       메서드인 next()는 combinationLength 길이의 사전적 다음 순서의 문자열 조합을 반환한다.       메서드인 hasNext()는 다음 조합 문자가 존재하는지 여부를 반환한다.           객체의 조합 문자열 구성에 필요한 전역 변수를 정의한다.            list는 조합 문자열을 구성하여 저장할 변수이다.       index는 조합 문자열이 저장된 위치 변수이다.           조합 문자열 생성에 필요한 dfs(char[] characters, int combinationLength, int start, StringBuilder sb) 메서드를 정의한다.            combinationLength가 0인 경우, list에 sb를 문자열로 변환하여 넣어준다.       combinationLength가 0이 아닌 경우, start부터 characters의 길이에서 combinationLength 값을 뺀 값 이하까지 i를 증가시키며 아래를 반복한다.                    sb에 characters의 i번째 문자를 넣어준다.           combinationLength를 1 감소시키고, start를 1 증가시켜 재귀 호출을 수행한다.           sb에서 마지막 문자를 제거해준다.                           생성자인 CombinationIterator(string characters, int combinationLength)를 구성한다.            전역 변수인 list를 ArrayList로, index를 0으로 초기화한다.       3번에서 정의한 dfs(char[] characters, int combinationLength, int start, StringBuilder sb) 메서드를 characters를 문자 배열로, start를 0으로, sb에 새 StringBuilder로 초기화하여 수행하여 combinationLength 길이의 조합 문자열을 list에 모두 넣어 객체를 초기화한다.           메서드인 next()를 구성한다.            list의 index번째 문자열인 바로 다음 조합 문자열을 반환 후 index를 증가시켜준다.           메서드인 hasNext()를 구성한다.            index가 list의 길이 미만인 마지막 위치가 아닌지 여부를 반환한다.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/iterator-for-combination/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum 69 Number",
        "excerpt":"문제  Link   코드  class Solution {    public int maximum69Number(int num) {     int position = -1;     for (int i = 0, temp = num, remainder = temp % 10; temp &gt; 1; i++, temp /= 10, remainder = temp % 10) {       if (remainder == 6) {         position = i;       }     }     if (-1 &lt; position) {       num += (int) (3 * Math.pow(10, position));     }     return num;   }  }   결과  Link   설명          6과 9로 이루어진 num을 최대 한 자리만 바꿔서 최대가 되는 값으로 변경하는 문제이다.            position은 위치를 바꿀 자릿수를 저장할 변수로, -1로 초기화한다.       i에 0, temp에 num, remainder에 temp의 1의 자릿수를 넣고 temp가 1보다 클 때까지 i를 증가시키고, remainder에 temp의 1의 자릿수를 넣어주며 아래를 반복한다.            remainder가 6인 경우, position에 현재 자릿수인 i를 넣어준다.                position이 -1보다 큰 변경 가능한 위치가 존재하는 경우, num에 $10^position$ 값을 더해준다.       수행이 완료되어 최대 한 자리만 바꾸어 가능한 최대 값으로 변환된 num을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-69-number/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Zero-Filled Subarrays",
        "excerpt":"문제  Link   코드  class Solution {    public long zeroFilledSubarray(int[] nums) {     long count = 0;     long result = 0;     for (int i = 0; i &lt; nums.length; i++) {       if (nums[i] == 0) {         result += ++count;       } else {         count = 0;       }     }     return result;   }  }   결과  Link   설명          nums 내 연속된 0으로 구성된 부분 배열의 갯수를 계산하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            count는 연속된 0으로 구성할 수 있는 부분 배열의 갯수를 계산하기 위한 변수로, 0으로 초기화한다.       result는 총 부분 배열의 갯수를 계산하기 위한 변수로, 0으로 초기화한다.           0부터 nums의 길이 미만까지 i를 증가시키며 아래를 반복한다.            nums[i]의 값이 0인 경우, count를 증가시킨 후 result에 값을 더해준다.       nums[i]의 값이 0이 아닌 경우, count를 0으로 초기화시켜준다.           반복이 완료되면 총 부분 배열의 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-zero-filled-subarrays/",
        "teaser": null
      },{
        "title": "Leetcode Java Element Appearing More Than 25% In Sorted Array",
        "excerpt":"문제  Link   코드  class Solution {    public int findSpecialInteger(int[] arr) {     int length = arr.length;     int quarter = length / 4;     for (int i = 0; i &lt; length - quarter; i++) {       if (arr[i] == arr[i + quarter]) {         return arr[i];       }     }     return -1;   }  }   결과  Link   설명          오름차순으로 정렬된 arr 내 숫자들 중 $\\frac{1}{4}$ 이상 존재하는 숫자를 찾아 반환하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            length는 arr 길이를 저장한 변수이다.       quarter는 arr 길이의 $\\frac{1}{4}$ 값을 저장한 변수이다.           0부터 $length - quarter$ 미만까지 i를 증가시키며 아래를 반복한다.            arr[i] 값과 arr[$i + quarter$] 값이 동일한 arr 길이의 $\\frac{1}{4}$ 구간 이상의 값이 동일한 경우, arr[i] 값을 주어진 문제의 결과로 반환한다.           arr 길이의 $\\frac{1}{4}$ 이상 존재하는 값이 없는 경우, -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/element-appearing-more-than-25-in-sorted-array/",
        "teaser": null
      },{
        "title": "Copilot을 사용하여 개발하는 방법",
        "excerpt":"Ai Assistant     AI 기술을 기반으로 사용자의 업무나 일과를 지원하거나 수행하는 지능형 소프트웨어 도구를 의미한다.   아래의 다양한 종류의 AI Assistant가 존재한다. 1            Gemini       GitHub Copilot       Amazon Q       Windsurf       Cursor           이 글에서는 GitHub Copilot의 설정하고, 이를 이용해 개발하는 방법에 대해서 설명한다.   Project       위의 그림과 같이 프로젝트 최상단 폴더에서 .github 폴더 내 아래의 세 분류가 존재한다.            copilot-instructions.md       /instructions       /prompts           현재까지 Inline Chat을 통한 질의에는 해당 설정이 적용되지 않으므로, 해당 기능을 활용하여 질의하는 경우에는 프로젝트 구성을 변경하거나 적용하는 행위를 제외한 간단한 질의에만 사용해야한다.                   해당 이슈는 Inline chat ignores copilot-instructions.md file로 등록되어, 이후 개선될 수 있을 것으로 보인다.           copilot-instructions.md2  # Project Overview  This project is a web application that allows users to manage their tasks and to-do lists. It is built using React and Node.js, and uses MongoDB for data storage.  ## Folder Structure  - `/src`: Contains the source code for the frontend. - `/server`: Contains the source code for the Node.js backend. - `/docs`: Contains documentation for the project, including API specifications and user guides.  ## Libraries and Frameworks  - React and Tailwind CSS for the frontend. - Node.js and Express for the backend. - MongoDB for data storage.  ## Coding Standards  - Use semicolons at the end of each statement. - Use single quotes for strings. - Use function based components in React. - Use arrow functions for callbacks.  ## UI guidelines  - A toggle is provided to switch between light and dark mode. - Application should have a modern and clean design     위와 같이 프로젝트에 대한 전반적인 설명을 markdown을 활용한 자연어 기반으로 작성한다.   이 설정은 현재 오픈된 프로젝트의 모든 GitHub Chat에 적용되는 전역 규칙을 정의하여 따르게 한다.   /instructions     전역 설정 외 부분적으로 여러 설정을 사용하는 경우, 해당 폴더에 “*.instructions.md” 파일에 저장하여 사용한다.   일부 파일 적용 혹은 제외  --- applyTo: '**/*.ts' ---  # VS Code Copilot Development Instructions for TypeScript  You MUST check compilation output before running ANY script or declaring work complete!  1. **ALWAYS** check the \"VS Code - Build\" task output for compilation errors 3. **NEVER** run tests if there are compilation errors 3. **NEVER** use `npm run compile` to compile TypeScript files, always check task output 4. **FIX** all compilation errors before moving forward     위 코드는 VSCode Github 내 typescript.instructions.md의 일부를 발췌한 내용이다.   여기서 applyTo는 glob 구문을 사용하여, “*/.ts”로 프로젝트 내 모든 ts 확장자를 가진 폴더에 적용한다는 것을 나타낸다.   역으로, test 폴더 내 ts 파일들을 제외하고 적용하고 싶다면 applyTo: '**/*.ts, !test/**/*.ts'와 같이 설정이 가능하다.   IDE 설정에 적용     대표적으로 VSCode를 예를 들면, 아래의 각 설정에 따라 각 instructions 파일을 읽어와 사용할 수 있다.3            github.copilot.chat.codeGeneration.useInstructionFiles : 코드 생성에 instructions 파일을 적용할지 여부를 결정한다. (실험)       chat.instructionsFilesLocations : 특정 폴더 별 채팅에서 instructions 파일을 사용할지 여부를 결정한다. 예를 들어, 아래와 같이 설정한다.         \"chat.instructionsFilesLocations\": { \"src/frontend/instructions\": true, \"src/backend/instructions\": false }                       github.copilot.chat.codeGeneration.instructions : 코드 생성에 사용될 instructions 파일을 설정한다. (실험)       github.copilot.chat.testGeneration.instructions : 테스트 생성에 사용할 instructions 파일을 설정한다. (실험)       github.copilot.chat.reviewSelection.instructions : 선택 영역 리뷰에 사용할 instructions 파일을 설정한다. (프리뷰)       github.copilot.chat.commitMessageGeneration.instructions : 커밋 메시지 생성에 사용할 instructions 파일을 설정한다. (실험)       github.copilot.chat.pullRequestDescriptionGeneration.instructions : pull request 설명 생성에 사용할 instructions 파일을 설정한다. (실험)           /prompts4     자주 사용하는 작업에 필요한 프롬프트를 markdown 저장하여 빠르게 실행하기 위한 기능으로, 해당 폴더 내 “*.prompt.md” 파일로 저장하고 설정된 이름을 “/” 이후 넣어 실행시킨다.   대표적으로, plan인 계획 생성과 implement인 코드 구현을 주로 사용한다.            /plan 명령을 통해 기본 코드 구현 계획 문서를 생성한다.       /implement 명령을 통해 계획 문서를 참고하여 코드를 구현한다.           plan.prompt.md  --- mode: agent description: 'Plan the solution for a problem.' tools: ['codebase', 'fetch', 'findTestFiles', 'githubRepo', 'search', 'searchResults', 'usages', 'vscodeAPI'] --- Your goal is to write a Detailed Plan to fix the bug or add new features. To do this, you first need to:  * Read the issue description and comments to understand the context of bugs or features. * Read the relevant instruction file to understand the code base. * If it's a bug, identify the **root cause of the bug and explain it to the user.  The plan must be in Markdown format and save the file name in the 'plan/' directory as \"**_plan.md\".     계획 문서를 만들기 위한 프롬프트 내용으로, 아래의 세부 설정을 적용하였다.            mode를 통해 Copilot 모드를 agent로 실행할 것을 정의한다.       tools를 통해 무엇을 활용하여 내용을 작성할지를 결정한다. 기본적으로 IDE에 내장된 Built-In Tool과 Extension에서 제공되는 Tool 등을 사용할 수 있다.           자연어를 기반으로 Markdown 문법으로 설계에 있어 반드시 포함해야 하는 항목을 정의하였고, 이를 다시 Markdown 형태의 문서로 작성되도록 하였다.   계획 문서는 최종 implement를 수행하기 전 단계에서 내용을 확인하고 상세화 시켜 보완된 내용으로 발전시킨다.   implement.prompt.md  --- mode: agent description: 'Implement the solution for a problem.' tools: ['codebase', 'usages', 'vscodeAPI', 'problems', 'changes', 'testFailure', 'openSimpleBrowser', 'fetch', 'findTestFiles', 'searchResults', 'githubRepo', 'todos', 'runTests', 'editFiles', 'runNotebooks', 'search', 'runCommands', 'runTasks'] --- Please write a high quality, general purpose solution. Implement a solution that works correctly for all valid inputs, not just the test cases.  Do not hard-code values or create solutions that only work for specific test inputs. Instead, implement the actual logic that solves the problem generally.  The end solution should be solid, maintainable, and scalable.     코드 구현을 위한 프롬프트 내용으로, 아래의 세부 설정을 적용하였다.            mode를 통해 Copilot 모드를 agent로 실행할 것을 정의한다.       tools를 통해 무엇을 활용하여 내용을 작성할지를 결정한다. 기본적으로 IDE에 내장된 Built-In Tool과 Extension에서 제공되는 Tool 등을 사용할 수 있다.           자연어를 기반으로 Markdown 문법으로 구현에 중요시 여기는 내용을 위주를 작성하여 코드 생성에 참고하도록 하였다.   정리     AI Assistant의 발전을 통해 코드 작성과 소프트웨어 개발에 필요한 시간은 점점 줄어들고 있으며, 이를 위한 다양한 도구와 기술들이 빠르게 개발 및 적용되고 있다.   과거 코딩하는 시간이 부족했던 개발자는 AI Assistant의 도입으로 점차 설계에 더 집중하고 더 나은 방향성으로 코드가 구현되기 위해 위와 같은 기술들을 적극 교육 및 업무에 적용해야한다.   참고     AI Assistant와 Chat을 진행하면서 주제가 변경되면 “새 술을 새 부대에 담아라.” 라는 말이 있듯이 새 Chat을 다시 생성하여 작성해야 Hallucination을 줄일 수 있다. 이는 물론 사람과 대화에 있어서도 주제를 넘나들며 이야기하면 경청에 방해가 되며, 주제를 혼동할 수 있음을 염두해야한다.   AI Assistant는 전지전능하지 않으며 아직까지는 “개떡같이 말해도 찰떡같이 알아듣는다”라는 속담을 만족시킬 수 없으므로, 질문에 있어서 상세화 및 구체화 시키고 어려운 설명에는 예시를 참고하여 질의하면 더욱 좋은 품질의 응답을 받을 수 있다.   Reference                 Gartner_Review &#8617;                  copilot_instructions &#8617;                  vscode-setting &#8617;                  copilot_prompts &#8617;           ","categories": ["CS"],
        "tags": ["Programming","CS","AI Assistant","Copilot"],
        "url": "/cs/copilot-programming/",
        "teaser": null
      },{
        "title": "Leetcode Java Remove Covered Intervals",
        "excerpt":"문제  Link   코드  class Solution {    public int removeCoveredIntervals(int[][] intervals) {     Arrays.sort(intervals, (i, j) -&gt; (i[0] == j[0] ? j[1] - i[1] : i[0] - j[0]));     int result = 0;     int curr = 0;     for (int[] interval : intervals) {       if (curr &lt; interval[1]) {         curr = interval[1];         result++;       }     }     return result;   }  }   결과  Link   설명     아래의 값이 저장된 intervals를 이용하여 다른 값에 포함된 범위 값들을 제거하고 남은 값의 갯수를 계산하는 문제이다.            intervals[i] = [li, ri] 로, li 부터 ri 까지 범위를 나타낸다.                intervals의 값을 시작 값이 동일하면 종료 값이 큰 순서로, 아니면 시작 값이 작은 순서로 정렬한다.       문제 풀이에 필요한 변수를 정의한다.            result는 남은 범위 값을 저장할 변수로, 0으로 초기화한다.       curr은 종료 값을 저장할 변수로, 0으로 초기화한다.           intervals의 각 값을 순차적으로 interval에 넣어 아래를 수행한다.            현재 우측 범위가 저장된 curr의 값보다 interval[1]의 값이 큰 미포함 범위 값인 경우, curr에 interval[1]의 값을 넣고 result를 증가시켜준다.           반복이 완료되면 남은 값의 갯수가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/remove-covered-intervals/",
        "teaser": null
      },{
        "title": "Leetcode Java Maximum Area of Longest Diagonal Rectangle",
        "excerpt":"문제  Link   코드  class Solution {    public int areaOfMaxDiagonal(int[][] dimensions) {     int result = 0;     int max = 0;     for (int[] dimension : dimensions) {       int diagonal = (dimension[0] * dimension[0]) + (dimension[1] * dimension[1]);       int area = dimension[0] * dimension[1];       if (max &lt; diagonal || (diagonal == max &amp;&amp; result &lt; area)) {         max = diagonal;         result = area;       }     }     return result;   }  }   결과  Link   설명     dimensions는 사각형의 두 변의 값들로 저장된 2차원 배열로, 가장 긴 길이의 대각선 길이를 가진 사각형의 면적을 반환한다.            대각선의 길이가 동일한 경우, 가장 큰 면적을 반환하는 문제이다.           문제 풀이에 필요한 변수를 정의한다.            result는 결과로 반환할 가장 큰 너비를 저장할 변수로, 0으로 초기화한다.       max는 제곱근을 수행하지 않은 가장 큰 대각선의 길이를 저장할 변수로, 0으로 초기화한다.                    제곱근을 수행하지 않은 값이 더 큰 경우, 대각선의 길이도 더 길어 제곱근을 수행하지 않은 값으로 비교한다.                           dimensions의 각 값을 순차적으로 dimension에 넣어 아래를 수행한다.            검증에 필요한 두 변수를 정의한다.                    diagonal은 dimension의 제곱근을 수행하지 않은 대각선의 길이를 저장한 변수로, $dimension[0]^2 + dimension[1]^2$의 값으로 초기화한다.           area는 dimension의 면적을 저장할 변수로, $dimension[0] \\times dimension[1]$의 값으로 초기화한다.                       아래의 두 경우 중 하나라도 만족하면 max에 diagonal의 값을 넣어주고, result에 area를 넣어준다.                    현재 대각선의 길이인 diagonal의 값이 기존 가장 긴 대각선의 길이인 max의 값보다 더 큰 경우.           현재 대각선의 길이인 diagonal의 값과 기존 가장 긴 대각선의 길이인 max의 값이 동일하면서 area의 값이 result보다 더 큰 면적인 경우.                           반복이 완료되면 조건에 만족하는 면적이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/maximum-area-of-longest-diagonal-rectangle/",
        "teaser": null
      },{
        "title": "Leetcode Java Sort Matrix by Diagonals",
        "excerpt":"문제  Link   코드  class Solution {    public int[][] sortMatrix(int[][] grid) {     int length = grid.length;     for (int i = 0; i &lt; length; i++) {       this.sortDiagonal(grid, i, 0, false);     }     for (int j = 1; j &lt; length; j++) {       this.sortDiagonal(grid, 0, j, true);     }     return grid;   }    private void sortDiagonal(int[][] grid, int row, int col, boolean isAscending) {     int length = grid.length - (isAscending ? col : row);     Integer[] diagonal = new Integer[length];     for (int i = row, j = col, k = 0; k &lt; length; i++, j++, k++) {       diagonal[k] = grid[i][j];     }     if (isAscending) {       Arrays.sort(diagonal);     } else {       Arrays.sort(diagonal, Collections.reverseOrder());     }     for (int num : diagonal) {       grid[row++][col++] = num;     }   }  }   결과  Link   설명     grid 내 좌측 상단에서 우측 하단 대각선 방향으로 두 구역을 분리했을 때 각 경우에 따라 대각선 내 값을 정렬하는 문제이다.            중앙 대각선 라인을 포함한 좌측 하단 구역은, 좌측 상단에서 우측 하단 대각선 방향으로 값을 내림차순 정렬한다.       중앙 대각선 우측 상단 구역은, 좌측 상단에서 우측 하단 대각선 방향으로 값을 오름차순 정렬한다.                length는 grid의 길이를 저장한 변수이다.       대각선 라인의 값을 정렬하기 위한 sortDiagonal(int[][] grid, int row, int col, boolean isAscending) 메서드를 정의한다.            정렬에 필요한 변수를 정의한다.                    length는 대각선 숫자 갯수를 저장할 변수로, grid의 길이에 isAscending이면 col을 아니면 row를 빼준다.           diagonal은 대각선의 숫자들을 정혈하기 위한 변수로, 값의 정렬을 위해 length 길이의 Integer 배열로 초기화한다.                       i에 row를 j에 col을 넣고 k는 0부터 length까지 i, j, k를 증가시키며, diagonal[k] 위치에 grid[i][j] 값을 넣어준다.       diagonal을 isAscending 의 값이 true이면 오름차순, 아니면 내림차순 정렬한다.       diagonal의 각 값을 순차적으로 num에 넣어 grid[row][col] 위치부터 대각선 방향으로 num을 넣어준다.                0부터 length까지 i를 증가시키며 sortDiagonal(int[][] grid, int row, int col, boolean isAscending) 메서드를 row에 i, col에 0, isAscending에 false를 넣어 대각선 좌측 하단 값들을 정렬해준다.            0부터 length까지 j를 증가시키며 sortDiagonal(int[][] grid, int row, int col, boolean isAscending) 메서드를 row에 0, col에 j, isAscending에 true를 넣어 대각선 우측 상단 값들을 정렬해준다.       반복이 완료되어 정렬된 grid를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/sort-matrix-by-diagonals/",
        "teaser": null
      },{
        "title": "K8s(Kubernetes)",
        "excerpt":"개요     쿠버네티스(Kubernetes, 줄여서 K8s)1는 컨테이너화된 애플리케이션의 배포와 확장, 관리를 자동화하는 오픈 소스 컨테이너 오케스트레이션 플랫폼이다.   주요 기능  서비스 디스커버리와 로드 밸런싱     쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다.   컨테이너 트래픽이 많은 경우 쿠버네티스는 로드 밸런싱을 수행하고 네트워크 트래픽을 분산하여 배포를 안정적으로 수행할 수 있다.   스토리지 오케스트레이션     쿠버네티스를 사용하면 로컬 스토리지, 퍼블릭 클라우드 제공업체 등 원하는 스토리지 시스템을 자동으로 마운트할 수 있다.   자동화된 롤아웃과 롤백     쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 설명할 수 있으며, 실제 상태를 원하는 상태로 제어된 속도로 변경할 수 있다.   예를 들어, 쿠버네티스를 자동화하여 배포할 새 컨테이너를 생성하고 기존 컨테이너를 제거한 후 모든 리소스를 새 컨테이너에 적용할 수 있다.   롤링 업데이트, Canary, Blue-Green 등의 배포 전략을 사용할 수 있다.   자동화된 bin packing     쿠버네티스는 컨테이너화된 작업을 실행하는 데 사용할 수 있는 노드 클러스터를 제공하고, 각 컨테이너에 필요한 CPU와 메모리의 양을 쿠버네티스에게 알려준다.   쿠버네티스는 컨테이너를 노드에 장착하여 리소스를 최대한 활용할 수 있다.   자가 복구     쿠버네티스는 실패한 컨테이너를 다시 시작하고 컨테이너를 교체하며, ‘사용자 정의 상태 검사’에 응답하지 않는 컨테이너를 죽이고 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.   보안 정보와 구성 관리     쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 보안 정보를 저장하고 관리할 수 있다.   컨테이너 이미지를 재구성하거나 스택 구성의 보안 정보을 노출하지 않고도 보안 정보 및 애플리케이션 구성을 배포하고 업데이트할 수 있다.   NameSpace, RBAC, NetworkPolicy 등을 활용한 보안 격리가 가능하다.   배치 실행     서비스 외에도, 쿠버네티스는 배치 및 CI 워크로드를 관리할 수 있으며, 필요한 경우 실패한 컨테이너를 교체할 수 있다.   확장     간단한 명령어, UI, 또는 CPU 사용량에 따라 수평 오토 스케일링(HPA)으로 부하에 따라 자동으로 애플리케이션을 확장하거나 축소할 수 있다.   업스트림 소스 코드를 변경하지 않고 쿠버네티스 클러스터 기능을 추가할 수 있다.   필요 항목                  도구       설명                       kubectl       Kubernetes CLI                 Docker       컨테이너 빌드용              Windows 환경에서는 Docker Desktop을 설치 후 설정의 Kubernetes에서 “Enable Kubernetes” 설정하면 모든 준비는 완료된다.   이미지 빌드     해당 이미지는 이전 포스트인 Custom JRE로 경령화된 Dockering II에서 만든 이미지로 대체하므로, Custom JRE로 경령화된 Dockering I과 함께 참고 바란다.   K8s 리소스 파일 작성     기본 구성은 아래와 같다.            apiVersion : K8s API 버전       kind : 생성할 리소스의 종류       metadata : 애플리케이션의 이름, 레이블(Label)과 같은 메타데이터       spec : 배포의 실제 구성           리소스의 종류는 아래와 같다.            Pod : 하나 이상의 컨테이너를 묶어 실행하는 가장 기본적인 단위이다.       Deployment : 파드를 생성하고 관리하며, 애플리케이션의 배포와 업데이트를 자동화한다.       Service : 파드들을 묶어 안정적인 네트워크 엔드포인트를 제공하고, 파드에 접근하는 방식을 정의한다.       StatefulSet : 순서가 중요한 데이터베이스와 같이 상태를 가지는 애플리케이션을 위한 워크로드 컨트롤러이다.       DaemonSet : 각 노드에 하나의 파드 복제본을 배포하도록 한다.       Custom Resource Definition (CRD) : 사용자가 직접 새로운 리소스를 정의할 수 있도록 하는 기능이다.           여기선 간단히 구성할 예정이므로, 프로젝트 위치에서 “k8s” 폴더를 생성 후 아래 두 파일만 작성한다.   deployment.yaml  apiVersion: apps/v1 kind: Deployment metadata:   name: hello-deployment spec:   replicas: 1   selector:     matchLabels:       app: hello-k8s   template:     metadata:       labels:         app: hello-k8s     spec:       containers:       - name: hello-k8s         image: hello-docker:latest         imagePullPolicy: IfNotPresent         ports:         - containerPort: 8080     deployment.yaml은 K8s에서 애플리케이션의 배포를 정의하는 파일로, 애플리케이션 배포에 필요한 구성 정보를 포함한 세부 설정을 작성하여 이 파일을 기반으로 클러스터에 자동으로 배포, 관리, 업데이트한다.   service.yaml  apiVersion: v1 kind: Service metadata:   name: hello-service spec:   type: NodePort   selector:     app: hello-k8s   ports:   - port: 8080     targetPort: 8080     nodePort: 30080     service.yaml 파일은 K8s에서 파드(Pod) 그룹에 대한 고정적인 네트워크 서비스(IP 주소 및 포트)를 정의하는 파일이다.   파드의 동적인 IP 주소 대신 안정적인 단일 엔드포인트를 제공하여 클라이언트가 애플리케이션을 안정적으로 호출할 수 있도록 하고, 파드 그룹의 IP 주소와 포트 번호를 직접 노출하는 대신 추상화된 네트워크 서비스로 제공하는 역할을 한다.   K8s에 배포  C:\\Development\\Workspace\\hello-docker&gt;kubectl apply -f k8s/deployment.yaml deployment.apps/hello-deployment created  C:\\Development\\Workspace\\hello-docker&gt;kubectl apply -f k8s/service.yaml service/hello-service created   서비스 점검  애플리케이션 확인  C:\\Development\\Workspace\\hello-docker&gt;kubectl get svc NAME            TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE hello-service   NodePort    10.110.61.174   &lt;none&gt;        8080:30080/TCP   35s kubernetes      ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP          67m  C:\\Development\\Workspace\\hello-docker&gt;curl http://localhost:30080/api/GracefulSoul Hello GracefulSoul     클러스터에 구성된 서비스를 조회하고, 서비스를 호출하여 정상적으로 애플리케이션이 구동되었는지 확인한다.   리소스 확인  C:\\Development\\Workspace\\hello-docker&gt;kubectl get all NAME                                    READY   STATUS    RESTARTS   AGE pod/hello-deployment-69cf9f9d77-lp5f7   1/1     Running   0          2m9s  NAME                    TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE service/hello-service   NodePort    10.110.61.174   &lt;none&gt;        8080:30080/TCP   101s service/kubernetes      ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP          68m  NAME                               READY   UP-TO-DATE   AVAILABLE   AGE deployment.apps/hello-deployment   1/1     1            1           2m9s  NAME                                          DESIRED   CURRENT   READY   AGE replicaset.apps/hello-deployment-69cf9f9d77   1         1         1       2m9s     현재 K8s 의 모든 정보를 조회한다.   로그 확인  C:\\Development\\Workspace\\hello-docker&gt;kubectl logs -l app=hello-k8s 2025-09-02T11:19:40.563Z  INFO 7 --- [hello-docker] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8080 (http) 2025-09-02T11:19:40.577Z  INFO 7 --- [hello-docker] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat] 2025-09-02T11:19:40.578Z  INFO 7 --- [hello-docker] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.31] 2025-09-02T11:19:40.604Z  INFO 7 --- [hello-docker] [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext 2025-09-02T11:19:40.605Z  INFO 7 --- [hello-docker] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 616 ms 2025-09-02T11:19:40.841Z  INFO 7 --- [hello-docker] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8080 (http) with context path '/' 2025-09-02T11:19:40.852Z  INFO 7 --- [hello-docker] [           main] gracefulsoul.HelloDockerApplication      : Started HelloDockerApplication in 1.151 seconds (process running for 1.421) 2025-09-02T11:21:17.817Z  INFO 7 --- [hello-docker] [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet' 2025-09-02T11:21:17.818Z  INFO 7 --- [hello-docker] [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet' 2025-09-02T11:21:17.818Z  INFO 7 --- [hello-docker] [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 0 ms     hello-k8s 애플리케이션의 로그를 확인한다.   배포 삭제  C:\\Development\\Workspace\\hello-docker&gt;kubectl delete -f k8s/ deployment.apps \"hello-deployment\" deleted service \"hello-service\" deleted     불필요한 애플리케이션인 경우, 확인 후 “k8s” 폴더에서 정의한 파일들을 참조하여 관련 앱을 제거한다.   정리     Spotify는 과거 Helios라는 오픈 소스 자체 컨테이너 오케스트레이션 시스템을 사용하였으나, 쿠버네티스의 활성화된 커뮤니티와 기술력을 기반으로 모든 서비스를 전환하고 CPU 최적화 등 다양한 이점을 얻었다고 알려져있다.   이렇게 기술의 변화에 따라서 서비스 운영 환경에 더 적합한 서비스를 학습하고, 더 안정적인 서비스를 고객에게 적용하는 것은 산업의 발전을 넘어 기술과 사회에 더 좋은 이점으로 나타날 것이다.   Reference  ※ Sample Code는 여기에서 확인 가능합니다.                 K8s-Home &#8617;           ","categories": ["Java"],
        "tags": ["Programming","Container","Kubernetes","K8s"],
        "url": "/java/k8s/",
        "teaser": null
      },{
        "title": "Leetcode Java Minimum Operations to Make the Integer Zero",
        "excerpt":"문제  Link   코드  class Solution {    public int makeTheIntegerZero(int num1, int num2) {     for (int i = 1; i &lt;= 60; i++) {       long num = num1 - ((long) num2 * i);       if (num &lt; i) {         return -1;       }       if (Long.bitCount(num) &lt;= i) {         return i;       }     }     return -1;   }  }   결과  Link   설명     num1과 num2가 주어지면 [0, 60] 범위의 i를 이용해서 $2^i + num2$의 값을 num1에서 뺄 때 0을 만들기 위한 최소 횟수를 계산하는 문제이다.            단, 0을 만들 수 없다면 -1을 주어진 문제의 결과로 반환한다.           1부터 60 이하까지 i를 증가시키며 아래를 반복한다.            num은 i에 대해서 조건을 수행한 결과를 저장한 변수로, $num1 - (num2 \\times i)$의 값으로 초기화한다.                    $2^i + num2$의 값을 i가 1부터 현재 위치까지 누계하는 경우, $num1 - (2^1 + 2^2 + … + 2^i) + (num2 \\times i)$이 된다.           $num1 - (2^1 + 2^2 + … + 2^i) + (num2 \\times i) = 0$이 만족해야 조건을 충족하므로, $(2^1 + 2^2 + … + 2^i) = num1 - (num2 \\times i)$를 만족한다.           위를 통해서 현재 위치인 i에서 num을 $num1 - (num2 \\times i)$의 값으로 설정한다.                       num이 i보다 작은 0을 만들 수 없는 경우, -1을 주어진 문제의 결과로 반환한다.       num의 비트 중 1의 갯수가 i보다 작은 i번의 수행을 통해 0을 만들 수 있는 경우, i를 주어진 문제의 결과로 반환한다.           반복이 완료되면 주어진 조건을 통해 0을 만들 수 없으므로, -1을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/minimum-operations-to-make-the-integer-zero/",
        "teaser": null
      },{
        "title": "Leetcode Java Convert Integer to the Sum of Two No-Zero Integers",
        "excerpt":"문제  Link   코드  class Solution {    public int[] getNoZeroIntegers(int n) {     int[] result = new int[] { 0, n };     while (result[0]++ &lt; result[1]--) {       if (this.isNoZeroInteger(result[0]) &amp;&amp; this.isNoZeroInteger(result[1])) {         break;       }     }     return result;   }    private boolean isNoZeroInteger(int num) {     while (num &gt;= 1) {       if (num % 10 == 0) {         return false;       }       num /= 10;     }     return true;   }  }   결과  Link   설명          0이 포함되지 않은 두 숫자의 합이 n이 되는 두 숫자를 구하는 문제이다.            result는 합이 n이 되는 두 숫자를 저장하기 위한 변수로, 0과 n로 구성된 정수 배열로 초기화한다.       result[0]의 값이 result[1]의 값보다 작을 때까지 result[0]의 값을 증가시키고, result[1]의 값을 감소시키며 아래를 반복한다.            result[0]의 값과 result[1]의 값에 0이 포함되는지 여부를 검증하여 둘 다 만족하는 경우, 반복을 종료한다.           계산된 두 숫자가 저장된 배열인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/convert-integer-to-the-sum-of-two-no-zero-integers/",
        "teaser": null
      },{
        "title": "Leetcode Java Find Resultant Array After Removing Anagrams",
        "excerpt":"문제  Link   코드  class Solution {    public List&lt;String&gt; removeAnagrams(String[] words) {     String prev = \"\";     List&lt;String&gt; result = new ArrayList&lt;&gt;();     for (String word : words) {       char[] charArray = word.toCharArray();       Arrays.sort(charArray);       String curr = String.valueOf(charArray);       if (!curr.equals(prev)) {         result.add(word);         prev = curr;       }     }     return result;   }  }   결과  Link   설명     주어진 문자열 배열인 words에서 아래 조건을 만족하지 않을 때 까지 반복 후 남은 문자열을 반환하는 문제이다.            인접한 두 문자열이 아나그램을 만족하는 경우, 뒷 문자열을 삭제한다.           문제 풀이에 필요한 변수를 정의한다.            prev는 이전에 발생한 문자열을 저장할 변수이다.       result는 결과를 저장할 변수로, ArrayList로 초기화한다.           words의 각 문자를 word에 넣어 아래를 수행한다.            word를 오름차순으로 문자들을 정렬하고 prev와 동일하지 않은 아나그램을 만족하지 않는 경우, result에 word를 넣고 prev에 curr을 저장한다.           반복이 완료되면 결과가 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/find-resultant-array-after-removing-anagrams/",
        "teaser": null
      },{
        "title": "Gradle Multi Project에 대한 설명",
        "excerpt":"Gradle1     Gradle은 Groovy를 사용한 빌드 자동화 시스템으로, 주로 Java, C/C++, 파이썬 등의 언어를 지원한다.   Gradle Multi Project     Gradle Multi Project Builds는 Monorepo 형태로 Root Project에서 Project 구조를 정의하고, Sub Project들을 파생하는 구조이다.      my-project/ ├── settings.gradle          ├── build.gradle         ├── app/                     │   └── build.gradle     ├── core/                    │   └── build.gradle     └── util/                      └── build.gradle             이 구조에서 특정 Sub Project에서 공통으로 사용하는 소스를 Sub Project로 관리하고 의존성을 주입하는 관계로 적용이 가능하다.      . ├── api │   ├── src │   │   └──... │   └── build.gradle ├── services │   └── person-service │       ├── src │       │   └──... │       └── build.gradle ├── shared │   ├── src │   │   └──... │   └── build.gradle └── settings.gradle           위와 같은 구성을 통해 공통된 소스들을 각 Project에 Copy/Paste 혹은 다중 관리에 대한 유지보수성을 저하시키는 요소를 제거할 수 있다.   물론 Maven에서도 동일한 구성의 Multi Modules가 존재하지만, 오늘은 Gradle의 Multi Project 구성에 대해서 이전 포스트인 Spring gRPC 코드를 사용하여 설명을 진행한다.   Example Project  spring-grpc/ ├── grpc-server │   ├── src │   │   └──... │   └── build.gradle ├── grpc-client │   └── src │   │   └──... │   └── build.gradle ├── grpc-libs │   ├── proto │   │   └──... │   └── build.gradle ├── build.gradle └── settings.gradle   spring-grpc  plugins {   id 'java'   id 'org.springframework.boot' version '3.4.5'   id 'io.spring.dependency-management' version '1.1.7'   id 'com.google.protobuf' version '0.9.2' }  ext {   set('springGrpcVersion', \"0.10.0\")   set('springBootVersion', \"3.4.5\") }  allprojects {     group = 'com.gracefulsoul'     version = '0.0.1-SNAPSHOT'      repositories {         mavenCentral()         google()         maven { url 'https://repo.spring.io/milestone' }     } }  subprojects {     apply plugin: \"java\"     apply plugin: 'io.spring.dependency-management'      java {         toolchain {             languageVersion = JavaLanguageVersion.of(21)         }     }    dependencyManagement {     imports {       mavenBom \"org.springframework.grpc:spring-grpc-dependencies:${springGrpcVersion}\"       mavenBom \"org.springframework.boot:spring-boot-dependencies:${springBootVersion}\"     }   } }     여기서 주목해야 하는 항목은 allprojects, subprojects이다.            allprojects는 모든 프로젝트에 공통으로 적용하기 위한 설정이다.       subprojects는 최상위 프로젝트를 제외한 하위 프로젝트에 공통으로 적용하기 위한 설정이다.           위 설정들은 각 프로젝트 내 build.gradle에 중복으로 설정되지 않도록 일괄 적용하기 위해 사용한다.   grpc-libs  plugins {   id 'java-library'   id 'com.google.protobuf' version '0.9.2' }  jar {     enabled = true }  repositories {     mavenCentral()     google() }  dependencies {   implementation 'io.grpc:grpc-services:1.60.0' }  protobuf {   protoc {     artifact = 'com.google.protobuf:protoc:3.25.3'   }   plugins {     grpc {       artifact = 'io.grpc:protoc-gen-grpc-java:1.64.0'     }   }   generateProtoTasks {     all()*.plugins {       grpc {         option 'jakarta_omit'         option '@generated=omit'       }     }   } }     위 프로젝트는 라이브러리 형태로 각 프로젝트에 의존성 주입을 위한 프로젝트로, ‘java-library’ 플러그인을 사용한다.   이전 글에서 설명한 내용대로 protobuf를 사용하여 java 코드를 자동 생성할 것이므로, protobuf 관련 설정만 추가한다.   grpc-server  plugins {   id 'java'   id 'org.springframework.boot'   id 'io.spring.dependency-management' }  dependencies {   implementation project(\":grpc-libs\")   implementation 'io.grpc:grpc-services'   implementation 'org.springframework.boot:spring-boot-starter'   implementation 'org.springframework.grpc:spring-grpc-spring-boot-starter'    testImplementation 'org.springframework.boot:spring-boot-starter-test'   testImplementation 'org.springframework.grpc:spring-grpc-test'   testRuntimeOnly 'org.junit.platform:junit-platform-launcher' }  tasks.named('test') {   useJUnitPlatform() }     grpc-server에서는 implementation project(\":grpc-libs\")를 통해서 앞의 grpc-libs 프로젝트를 의존성 주입하여 사용하는 것을 명시한다.   grpc-client  plugins {   id 'java'   id 'org.springframework.boot'   id 'io.spring.dependency-management' }  dependencies {   implementation project(\":grpc-libs\")   implementation 'org.springframework.boot:spring-boot-starter'   implementation 'org.springframework.grpc:spring-grpc-client-spring-boot-starter'    testImplementation 'org.springframework.boot:spring-boot-starter-test'   testImplementation 'org.springframework.grpc:spring-grpc-test'   testRuntimeOnly 'org.junit.platform:junit-platform-launcher' }  tasks.named('test') {   useJUnitPlatform() }     grpc-client 또한 implementation project(\":grpc-libs\")를 통해서 앞의 grpc-libs 프로젝트를 의존성 주입하여 사용하는 것을 명시한다.   Conclusion       위와 같이 공통으로 사용하는 DTO와 Utility 등의 사이드 이펙트가 없는 순수 함수, 등의 다양한 목적의 공통 코드를 모듈화하여 공유한다.   쉽고 간편한 개발을 통해 만들어진 프로젝트는 깊은 고민과 설계를 통해 만들어진 프로젝트를 결코 따라잡지 못하므로, 코드를 먼저 작성하기보다는 더 나은 방안을 설계하고 고민하는 습관을 가졌으면 한다.   Reference   ※ Sample Code는 여기에서 확인 가능합니다.                 Gradle Home &#8617;           ","categories": ["Build"],
        "tags": ["Programming","Build","Gradle","Multi Project","Monorepo"],
        "url": "/build/gradle-module/",
        "teaser": null
      },{
        "title": "Leetcode Java The Two Sneaky Numbers of Digitville",
        "excerpt":"문제  Link   코드  class Solution {    public int[] getSneakyNumbers(int[] nums) {     int n = nums.length - 2;     int max = 0;     int[] counts = new int[n];     for (int num : nums) {       if (max &lt; ++counts[num]) {         max = counts[num];       }     }     int index = 0;     int[] result = new int[2];     for (int i = 0; i &lt; counts.length; i++) {       if (counts[i] == max) {         result[index++] = i;       }     }     return result;   }  }   결과  Link   설명          가장 많이 발생한 두 숫자를 찾는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            n은 값의 최대 범위를 저장하기 위한 변수로, 가능한 최댓값인 $nums.length - 2$으로 초기화한다.       max는 가장 많이 발생한 값의 갯수를 저장할 변수로, 0으로 초기화한다.       counts는 가장 많이 발생한 값의 갯수를 계산하기 위한 배열로, n 길이의 정수 배열로 초기화한다.                    nums의 값들을 반복하여 max에 가장 많이 발생한 갯수와 counts 배열에 숫자별 갯수를 계산한다.                       index는 결과 값을 저장할 위치 변수로, 0으로 초기화한다.       result는 결과 값을 저장할 배열로, 2 크기의 정수 배열로 초기화한다.                counts[i]의 값이 max와 동일한 경우, result에 순차적으로 해당 값을 넣어준다.       반복이 완료되어 가장 많이 발생한 두 값이 저장된 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/the-two-sneaky-numbers-of-digitville/",
        "teaser": null
      },{
        "title": "Leetcode Java Number of Substrings With Only 1s",
        "excerpt":"문제  Link   코드  class Solution {    public int numSub(String s) {     int result = 0;     int count = 0;     int mod = 1000000007;     for (char c : s.toCharArray()) {       if (c == '1') {         count++;         result = (result + count) % mod;       } else {         count = 0;       }     }     return result;   }  }   결과  Link   설명     문자열 s의 ‘1’ 문자가 반복된 갯수들의 합을 구하는 문제이다.            단, 답이 매우 클 수 있으므로 모듈러 $10^9 + 7$을 이용해 계산한다.           문제 풀이에 필요한 변수를 정의한다.            result는 문자열 s의 ‘1’ 문자가 반복된 갯수들의 합을 저장할 변수로, 0으로 초기화한다.       count는 ‘1’ 문자가 반복된 갯수를 계산할 변수로, 0으로 초기화한다.       mod는 모듈러 $10^9 + 7$를 적용하기 위한 변수이다.           s의 문자들을 순차적으로 c에 넣고 아래를 수행한다.            c가 ‘1’ 문자인 경우, 아래를 수행한다.                    count를 증가시켜 반복된 ‘1’의 갯수를 증가시켜준다.           result에 모듈러 $10^9 + 7$를 적용한 result와 count의 합계를 넣어준다.                       그 외인 c가 ‘0’ 문자인 경우, count를 0으로 초기화시켜준다.           반복이 완료되면 계산된 result의 값을 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/number-of-substrings-with-only-1s/",
        "teaser": null
      },{
        "title": "Leetcode Java Check If All 1's Are at Least Length K Places Away",
        "excerpt":"문제  Link   코드  class Solution {    public boolean kLengthApart(int[] nums, int k) {     for (int i = -1, j = 0; j &lt; nums.length; j++)       if (nums[j] == 1) {         if (i != -1 &amp;&amp; j - i - 1 &lt; k) {           return false;         }         i = j;       }     return true;   }  }   결과  Link   설명          정수 배열 nums 내 ‘1’ 사이의 ‘0’의 갯수가 최소 k개가 되는지 검증하는 문제이다.       1의 시작 지점을 저장할 i는 -1로 정의하고, 이후 탐색을 진행할 j는 0에서 nums의 길이 미만까지 j를 증가시키며 아래를 반복한다.            nums[j]의 값이 1인 경우, 아래를 수행한다.                    i가 -1이 아닌 초기 지점이 아니면서 $j - i - 1$의 값인 0의 갯수가 k개 미만인 조건을 만족하지 않는 경우, false를 주어진 문제의 결과로 반환한다.           i에 j를 넣어 현재 위치를 저장해준다.                           반복이 완료되면 nums가 조건을 만족하는 숫자로 구성되었으므로, true를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/check-if-all-1s-are-at-least-length-k-places-away/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Odd Numbers in an Interval Range",
        "excerpt":"문제  Link   코드  class Solution {    public int countOdds(int low, int high) {     return (high + 1) / 2 - low / 2;   }  }   결과  Link   설명          [low, high] 범위 내 홀수의 갯수를 구하는 문제이다.            두 경우의 차분을 주어진 문제의 결과로 반환한다.             high 이하의 홀수 갯수인 $\\frac{high + 1}{2}$개.       low 미만의 홀수 갯수인 $\\frac{low}{2}$개.           소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-odd-numbers-in-an-interval-range/",
        "teaser": null
      },{
        "title": "Leetcode Java Count Square Sum Triples",
        "excerpt":"문제  Link   코드  class Solution {    public int countTriples(int n) {     int result = 0;     for (int i = 3; i &lt; n - 1; i++) {       for (int j = i + 1; j &lt; n; j++) {         int volume = (i * i) + (j * j);         int sqrt = (int) Math.sqrt(volume);         if (sqrt * sqrt == volume &amp;&amp; sqrt &lt;= n) {           result += 2;         }       }     }     return result;   }  }   결과  Link   설명          n 이하의 임의 세 값을 이용해서 만들 수 있는 직삼각형의 갯수를 계산하는 문제이다.            result는 만들 수 있는 직삼각형의 갯수를 저장할 변수로, 0으로 초기화한다.       i는 3부터 $n - 1$ 미만까지 1씩 증가시키고, j는 $i + 1$부터 n 미만까지 1씩 증가시키며 아래를 반복한다.            사각형의 부피인 volume을 $(i \\times i) + (j \\times j)$ 값으로 초기화한다.       대각선의 길이인 sqrt에 volume 제곱근 값을 정수형으로 넣어준다.       $sqrt \\times sqrt$의 값이 volume이면서 sqrt의 값이 n 이하인 조건을 만족하는 직사각형을 만들 수 있는 경우, x축과 y축이 긴 경우의 두 경우를 result에 더해준다.           조건을 만족하는 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/count-square-sum-triples/",
        "teaser": null
      },{
        "title": "Leetcode Java Apple Redistribution into Boxes",
        "excerpt":"문제  Link   코드  class Solution {    public int minimumBoxes(int[] apple, int[] capacity) {     int sum = 0;     for (int count : apple) {       sum += count;     }     int result = 0;     Arrays.sort(capacity);     for (int i = capacity.length - 1; 0 &lt;= i &amp;&amp; 0 &lt; sum; i--) {       result++;       sum -= capacity[i];     }     return result;   }  }   결과  Link   설명          각 사과 갯수가 저장된 apple로 각 사과를 담을 수 있는 크기가 저장된 박스가 저장된 capacity에 넣을 최소 박스의 갯수를 구하는 문제이다.       문제 풀이에 필요한 변수를 정의한다.            sum은 apple에 저장된 모든 사과의 갯수를 저장할 변수로, apple 내 모든 값을 더해 넣어준다.       result는 필요한 박스의 최소 갯수를 저장할 변수로, 0으로 초기화한다.           capacity를 오름차순 정렬 후, i를 capacity 마지막 위치부터 0 이하까지 i를 감소시키고 sum이 0 초과일 때 까지 아래를 반복한다.            result인 사용한 박수 갯수를 증가시킨다.       sum에 capacity[i]의 값인 박스에 넣은 사과의 갯수를 차감시켜준다.           반복이 완료되면 사용된 박스의 갯수인 result를 주어진 문제의 결과로 반환한다.   소스  Sample Code는 여기에서 확인 가능합니다.  ","categories": ["Leetcode"],
        "tags": ["Programming","Leetcode","Java"],
        "url": "/leetcode/apple-redistribution-into-boxes/",
        "teaser": null
      },{
        "title": "K3s(Lightweight Kubernetes)",
        "excerpt":"개요     k3s는 Rancher Labs(SUSE)가 만든 경량 Kubernetes로, k8s(Kubernetes)의 핵심 기능을 유지하며 리소스 사용량을 크게 줄이고 설치와 운영을 단순화한 것이 특징이다.   Edge 컴퓨팅과 Internet of Things(IoT), CI 등 다양한 리소스가 제한된 환경에 최적화 되어 있다.   비교  K8s의 주요 단점     비교적 높은 리소스(CPU, Memory) 사용량.   복잡한 설치 방법들과 다양한 설정 파일 관리.   K3s의 주요 장점     CLI 및 설정 파일등을 포함하여 K8s와 완전히 호환.   기본 애드온(Traefik, CoreDNS, Metric Server 등) 내장을 통해 간단한 설치.   K3s airgap     K3s 에어갭(airgap)이란 인터넷 연결이 차단된, 즉 외부 네트워크와 완전히 분리된 환경에서 K3s를 설치하고 실행하는 것을 의미한다.   인터넷이 연결되지 않은 보안이 매우 중요한 환경이나, 공용 인터넷에 의존할 수 없는 환경에서 K3s를 배포하기 위해 사용되는 설치 방식이며, 필요한 컨테이너 이미지와 K3s 바이너리를 미리 다운로드하여 에어갭 환경에 전송한 뒤 설치를 진행한다.   특징  보안 강화     외부 위협으로부터 시스템을 물리적으로 격리하여 사이버 공격 가능성을 최소화한다.   안정적인 환경     인터넷 연결이 불안정하거나 불가능한 환경에서도 K3s를 안정적으로 운영할 수 있도록 한다.   제어된 환경     모든 소프트웨어와 이미지를 직접 관리하므로, 보안 정책이나 규제 준수가 필요한 환경에서 유용하다.   설치  파일 준비  # Install script curl -sfL https://get.k3s.io &gt; install.sh chmod +x ./install.sh  # Download curl -LO https://github.com/k3s-io/k3s/releases/download/${K3S_VERSION}/k3s-airgap-images-amd64.tar  # Place image sudo mkdir -p /var/lib/rancher/k3s/agent/images/ sudo mv k3s-airgap-images-amd64.tar.zst /var/lib/rancher/k3s/agent/images/   서버 설치  # INSTALL_K3S_SKIP_DOWNLOAD: 오프라인 설치 여부 # server: Kubernetes control plane 역할로 클러스터를 관리한다. # --cluster-init: 내장 etcd 클러스터 초기화 # --embedded-registry: Spegel 활성화(옵션, 권장) # --kube-proxy-arg=proxy-mode=ipvs: kube-proxy를 IPVS 모드로 실행(성능 향상) # --kube-proxy-arg=ipvs-strict-arp=true: IPVS 모드에서 ARP 충돌 방지를 위해 strict ARP를 활성화 INSTALL_K3S_SKIP_DOWNLOAD=true \\ INSTALL_K3S_EXEC=\"server \\   --cluster-init \\   --embedded-registry \\   --kube-proxy-arg=proxy-mode=ipvs \\   --kube-proxy-arg=ipvs-strict-arp=true\" \\ ./install.sh  # Check cluster token cat /var/lib/rancher/k3s/server/node-token   워커 추가(선택)  # K3S_TOKEN: 클러스터 초기화한 서버의 토큰 # --server: 조인 대상 클러스터의 control plane 주소 export K3S_TOKEN=\"{token}\" INSTALL_K3S_SKIP_DOWNLOAD=true \\ INSTALL_K3S_EXEC=\"server \\   --server https://{real-ip}:6443 \\   --embedded-registry \\   --kube-proxy-arg=proxy-mode=ipvs \\   --kube-proxy-arg=ipvs-strict-arp=true\" \\ ./install.sh     워커는 INSTALL_K3S_EXEC 명령어의 시작 키워드에 따라 아래의 두 종류로 조인이 가능하다.            server 키워드로 실행하는 경우, Control Plane 멤버로 클러스터에 조인하여 HA(High Availability)를 제공하기 위해 사용한다.       agent 키워드로 실행하는 경우, Worker로 클러스터에 조인하여 수평적 확장을 제공하기 위해서 사용한다.           확인  # k3s kubectl get nodes NAME        STATUS   ROLES                  AGE   VERSION k3s-server  Ready    control-plane,master   1m    v1.35.0+k3s1  # k3s kubectl get pods -A NAMESPACE     NAME                                      READY   STATUS         RESTARTS        AGE kube-system   coredns-64fd4b4794-mc6qz                  1/1     Running        0               1m7s kube-system   local-path-provisioner-774c6665dc-fnbmh   1/1     Running        0               1m7s kube-system   metrics-server-79dc797866-p9bkg           1/1     Running        0               1m7s kube-system   traefik-32bw1e5674-2bqc8                  1/1     Running        0               1m7s   회고     가용 리소스를 확인하지 않고 무조건 Kubernetes를 적용하는 것은 오히려 비용과 관리가 커지는 부작용을 창출할 수 있다.   Docker 컨테이너 기반 서비스를 Kubernetes 적용안을 고려하는 경우, K3s를 경유하는 방법은 러닝 커브를 일시적으로 낮춰주면서 운영 감각을 점층적으로 늘릴 수 있는 좋은 방법이 될 수 있다.   Reference  ","categories": ["Java"],
        "tags": ["Programming","Container","Kubernetes","K3s"],
        "url": "/java/k3s/",
        "teaser": null
      }]
